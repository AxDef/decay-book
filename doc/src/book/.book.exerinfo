
# Information about all exercises in the file book.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.book.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'chapter_exercise': 1,
  'chapter_no': 2,
  'chapter_title': 'Algorithms and implementations',
  'chapter_type': 'Chapter',
  'closing_remarks': 'In Section ref{decay:computing:error} we show how easy it is to\ncompute a mesh function by array arithmetics (or array computing).\nUsing this technique, one could simply implement `mesh_function(f,t)`\nas `return f(t)`. However, `f(t)` will not work if there are\nif tests involving `t` inside `f` as is the case in b). Typically,\n`if t < 3` must have `t < 3` as a boolean expression, but if `t` is\narray, `t < 3`, is an *array of boolean values*, which is not legal\nas a boolean expression in an if test.\nComputing one element\nat a time as suggested in a) is a way of out of this problem.\n\nWe also remark that the function in b) is the solution of $u^{\\prime}=-au$,\n$u(0)=1$, for $t\\in [0,4]$, where $a=1$ for $t\\in [0,3]$ and $a=3$ for\n$t\\in [3,4]$.',
  'file': ['mesh_function'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:meshfunc',
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': 'The function may look like\n\n!bc pycod\ndef mesh_function(f, t):\n    u = np.zeros(len(t))  # or t.size\n    for i in range(len(t)):\n        u[i] = f(t[i])\n    return u\n\n!ec',
             'text': 'Write a function `mesh_function(f, t)` that returns an array with\nmesh point values $f(t_0),\\ldots,f(t_{N_t})$, where `f` is a Python\nfunction implementing a mathematical function `f(t)` and $t_0,\\ldots,t_{N_t}$\nare mesh points stored in the array `t`. Use a loop over the mesh\npoints and compute one mesh function value at the time.'},
            {'aftertext': '\n\n',
             'answer': '',
             'file': None,
             'hints': [],
             'solution': "An appropriate function is\n\n!bc pycod\ndef demo():\n    def f(t):\n        if t <= 3:\n            return np.exp(-t)\n        else:\n            return np.exp(-3*t)\n\n    # Compute mesh and mesh function\n    t = np.linspace(0, 4, 41)\n    u = mesh_function(f, t)\n\n    # Plot\n    import matplotlib.pyplot as plt\n    plt.plot(t, u)\n    plt.xlabel('t')\n    plt.ylabel('mesh function')\n    plt.savefig('tmp.png'); plt.savefig('tmp.pdf')\n    plt.show()\n\n!ec",
             'text': 'Use `mesh_function` to compute the mesh function corresponding to\n\n!bt\n\\[\nf(t) = \\left\\lbrace\n\\begin{array}{ll}\ne^{-t},& 0\\leq t\\leq 3,\\\\ \ne^{-3t}, & 3 < t\\leq 4\n\\end{array}\\right.\n\\]\n\n!et\nChoose a mesh $t_n=n\\Delta t$ with $\\Delta t=0.1$.\nPlot the mesh function.'}],
  'text': '',
  'title': 'Define a mesh function and visualize it',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 2,
  'chapter_no': 2,
  'chapter_title': 'Algorithms and implementations',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['differentiate'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:dudt',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': ['The three differentiation formulas are\nexact for quadratic polynomials. Use this property to verify the program.'],
             'solution': 'The functions can be written as\n\n!bc pycod\nimport numpy as np\n\ndef differentiate(u, dt):\n    dudt = np.zeros(len(u))\n    for i in range(1, len(dudt)-1, 1):\n        dudt[i] = (u[i+1] - u[i-1])/(2*dt)\n    i = 0\n    dudt[i] = (u[i+1] - u[i])/dt\n    i = len(dudt)-1\n    dudt[i] = (u[i] - u[i-1])/dt\n    return dudt\n\ndef test_differentiate():\n    """Test differentiate with a linear u."""\n    # Expect exact results\n    t = np.linspace(0, 4, 9)\n    u = 2*t + 7\n    dudt = differentiate(u, dt=t[1]-t[0])\n    diff = abs(dudt - 2).max()\n    tol = 1E-15\n    assert diff < tol\n\n!ec',
             'text': 'Write a function\n`differentiate(u, dt)` that returns the discrete derivative $d^n$ of the\nmesh function $u^n$. The parameter `dt` reflects the\nmesh spacing $\\Delta t$. Write a corresponding test function\n`test_differentiate()` for verifying the implementation.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': 'Appropriate functions are\n\n!bc pycod\ndef differentiate_vec(u, dt):\n    dudt = np.zeros(len(u))\n    dudt[1:-1] = (u[2:] - u[0:-2])/(2*dt)\n    dudt[0] = (u[1] - u[0])/dt\n    dudt[-1] = (u[-1] - u[-2])/dt\n    return dudt\n\ndef test_differentiate_vec():\n    """Test differentiate_vec by comparing with differentiate."""\n    t = np.linspace(0, 4, 9)\n    u = 2*np.sin(t) + 7\n    dudt_expected = differentiate(u, dt=t[1]-t[0])\n    dudt_computed = differentiate_vec(u, dt=t[1]-t[0])\n    diff = abs(dudt_expected - dudt_computed).max()\n    tol = 1E-15\n    assert diff < tol\n\n!ec',
             'text': 'A standard implementation of the formula (ref{decay:exer:dudt:D2t}) is to\nhave a loop over $i$. For large $N_t$, such loop may run slowly in\nPython. A technique for speeding up the computations, called vectorization\nor array computing,\nreplaces the loop by array operations. To see how this can be done in\nthe present mathematical problem, we\ndefine two arrays\n\n!bt\n\\begin{align*}\nu^+ &= (u^2,u^3,\\ldots,u^{N_t}),\nu^- &= (u^0,u^1,\\ldots,u^{N_t-2})\\tp\n\\end{align*}\n\n!et\nThe formula (ref{decay:exer:dudt:D2t}) can now be expressed as\n\n!bt\n\\[ (d^1,d^2,\\ldots,d^{N_t-1}) = \\frac{1}{2\\Delta t}(u^+ - u^-)\\tp\\]\n\n!et\nThe corresponding Python code reads\n\n!bc pycod\nd[1:-1] = (u[2:] - u[0:-2])/(2*dt)\n# or\nd[1:N_t] = (u[2:N_t+1] - u[0:N_t-1])/(2*dt)\n\n!ec\nRecall that an array slice `u[1:-1]` contains the elements in `u` starting\nwith index 1 and going all indices up to, but not including, the last one\n(`-1`).\n\nUse the ideas above to implement a vectorized version of the\n`differentiate` function without loops. Make a corresponding\ntest function that compares the result with that of\n`differentiate`.'}],
  'text': 'idx{array arithmetics} idx{array computing} idx{vectorization}\n\nGiven a mesh function $u^n$ as an array `u` with $u^n$ values at mesh\npoints $t_n=n\\Delta t$, the discrete derivative can be based on\ncentered differences:\n\n!bt\n\\begin{equation}\nd^n = [D_{2t}u]^n =\n\\frac{u^{n+1}-u^{n-1}}{2\\Delta t},\\quad n=1,\\ldots,N_t-1\\tp\nlabel{decay:exer:dudt:D2t}\n\\end{equation}\n\n!et\nAt the end points we use forward and backward differences:\n\n!bt\n\\[ d^0 = [D_t^+u]^n = \\frac{u^{1}-u^{0}}{\\Delta t},\\]\n\n!et\nand\n\n!bt\n\\[ d^{N_t} = [D_t^-u]^n = \\frac{u^{N_t}-u^{N_t-1}}{\\Delta t}\\tp\\]\n\n!et',
  'title': 'Differentiate a function',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 3,
  'chapter_no': 2,
  'chapter_title': 'Algorithms and implementations',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['pyproblems'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:intdiv',
  'no': 3,
  'solution': "We add some more investigations of the types and values involved\nin the computations:\n\n!bc pyshell\n>>> dt = 3\n>>> T = 8\n>>> Nt = T/dt\n>>> Nt\n2\n>>> type(Nt)\n<type 'int'>\n>>> from numpy import linspace\n>>> theta = 1; a = 1\n>>> (1 - (1-theta)*a*dt)/(1 + theta*dt*a)\n0\n>>> (1 - (1-theta)*a*dt)\n1\n>>> (1 + theta*dt*a)\n2\n\n!ec\nFrom this we realize that the unexpected results are caused by\ninteger division: `int` object divided by `int` object.\nFor example,\n`Nt` is an integer, not a real as we want, because 8/3 according integer\ndivision is 2, not the 2.66666 approximation to $\\frac{8}{3}$.",
  'solution_file': None,
  'subex': [],
  'text': 'Explain what happens in the following computations, where\nsome are mathematically unexpected:\n\n!bc ipy\n>>> dt = 3\n>>> T = 8\n>>> Nt = T/dt\n>>> Nt\n2\n>>> theta = 1; a = 1\n>>> (1 - (1-theta)*a*dt)/(1 + theta*dt*a)\n0\n\n!ec',
  'title': 'Experiment with divisions',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 4,
  'chapter_no': 2,
  'chapter_title': 'Algorithms and implementations',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['decay_v1_err'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:decay1err',
  'no': 4,
  'solution': 'A code for investigating this problem may look as follows.\n\n!bc pypro\ndef solver(I, a, T, dt, theta):\n    """Solve u\'=-a*u, u(0)=I, for t in (0,T] with steps of dt."""\n    Nt = int(T/dt)            # no of time intervals\n    T = Nt*dt                 # adjust T to fit time step dt\n    u = zeros(Nt+1)           # array of u[n] values\n    t = linspace(0, T, Nt+1)  # time mesh\n\n    u[0] = I                  # assign initial condition\n    for n in range(0, Nt):    # n=0,1,...,Nt-1\n        factor1 = (1 - (1-theta)*a*dt)\n        factor2 = (1 + theta*dt*a)\n        factor3 = factor1/factor2\n        print factor1, type(factor1), factor2, type(factor2),\n        print factor3, type(factor3)\n        u[n+1] = (1 - (1-theta)*a*dt)/(1 + theta*dt*a)*u[n]\n    return u, t\n\nfrom numpy import *\nu, t = solver(I=1, a=1, T=7, dt=2, theta=1)\n\n# Write out a table of t and u values:\nfor i in range(len(t)):\n    print \'t=%6.3f u=%g\' % (t[i], u[i])\n    # or print \'t={t:6.3f} u={u:g}\'.format(t=t[i], u=u[i])\n\n!ec\nRunning this code shows\n\n!bc sys\nTerminal> python decay_v1_err.py\n1 <type \'int\'> 3 <type \'int\'> 0 <type \'int\'>\n1 <type \'int\'> 3 <type \'int\'> 0 <type \'int\'>\n1 <type \'int\'> 3 <type \'int\'> 0 <type \'int\'>\nt= 0.000 u=1\nt= 2.000 u=0\nt= 4.000 u=0\nt= 6.000 u=0\n\n!ec\nWe realize that we have integer divided by integer in the numerical\nformula, i.e., the result of 1/3 is 0 because of integer division.\nThis fraction is multiplied by `u[n]`, but the result remains zero.',
  'solution_file': None,
  'subex': [],
  'text': 'Consider the `solver` function in the "`decay_v1.py`":\n"http://tinyurl.com/ofkw6kc/alg/decay_v1.py" file\nand the following call:\n\n!bc pycod\nu, t = solver(I=1, a=1, T=7, dt=2, theta=1)\n\n!ec\nThe output becomes\n\n!bc dat\nt= 0.000 u=1\nt= 2.000 u=0\nt= 4.000 u=0\nt= 6.000 u=0\n\n!ec\nPrint out the result of all intermediate computations and use\n`type(v)` to see the object type of the result stored in some variable `v`.\nExamine the intermediate calculations and explain\nwhy `u` is wrong and why we compute up to $t=6$ only even though we\nspecified $T=7$.',
  'title': 'Experiment with wrong computations',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 5,
  'chapter_no': 2,
  'chapter_title': 'Algorithms and implementations',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['decay_plot_error'],
  'heading': '=====',
  'hints': ['Modify the "`decay_plot_mpl.py`": "http://tinyurl.com/ofkw6kc/alg/decay_plot_mpl.py" code.'],
  'keywords': None,
  'label': 'decay:exer:plot:error',
  'no': 5,
  'solution': 'Looking at the `decay_plot_mpl.py` file, we realize that we only\nneed to change the `explore` method such that the error and not\nthe solutions are plotted. We also need to run a loop over\n$\\Delta t$ values and get all the corresponding curves in the same\nplot. Quite some editing is necessary. Also the `main` function needs\nsome edits.\n\nThe `solver` and `exact_solution` functions are not altered.\nThe `explore` and `main` functions as well as the call to `main` are\nedited to:\n\n!bc pycod\ndef explore(I, a, T, dt_values, theta=0.5):\n    """\n    Run cases with the solver, compute error measure,\n    and plot the error.\n    """\n    figure() # create new plot\n    for dt in dt_values:\n        print \'dt\', dt\n        u, t = solver(I, a, T, dt, theta)    # Numerical solution\n        u_e = u_exact(t, I, a)\n        e = u_e - u\n        plot(t, e)\n        hold(\'on\')\n    legend([\'dt=%g\' % dt for dt in dt_values])\n    xlabel(\'t\')\n    ylabel(\'u\')\n    title(\'theta=%g\' % theta)\n    theta2name = {0: \'FE\', 1: \'BE\', 0.5: \'CN\'}\n    savefig(\'%s_%g.png\' % (theta2name[theta], dt))\n    savefig(\'%s_%g.pdf\' % (theta2name[theta], dt))\n\ndef main(I, a, T, dt_values, theta_values=(0, 0.5, 1)):\n    for theta in theta_values:\n        explore(I, a, T, dt_values, theta)\n\ndt = 0.1\ndt_values = [dt, dt/4, dt/8]\nmain(I=1, a=2, T=5, dt_values=dt_values)\nshow()\n\n!ec\n\nFIGURE: [fig-alg/decay_plot_error, width=800 frac=1]',
  'solution_file': None,
  'subex': [],
  'text': "Solve the problem $u'=-au$, $u(0)=I$, using the Forward Euler, Backward\nEuler, and Crank-Nicolson schemes. For each scheme, plot the error mesh\nfunction $e^n = \\uex(t_n)-u^n$ for $\\Delta t$, $\\frac{1}{4}\\Delta t$, and\n$\\frac{1}{8}\\Delta t$, where $\\uex$ is the exact solution of the ODE and\n$u^n$ is the numerical solution at mesh point $t_n$.",
  'title': 'Plot the error function',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 6,
  'chapter_no': 2,
  'chapter_title': 'Algorithms and implementations',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['decay_memsave_v2'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:inexact:output',
  'no': 6,
  'solution': 'The new formatting is obtained by replacing the format `%.16E` for\n`t` by `%.3f` and the format for `u` must be `%.5f`.\n\nWith only 5 decimals in the file, the `test_solver_minmem` function compares\ntruncated elements `u`, accurate only to $10^{-5}$ with the\nexact discrete solution and applies a far too small `tol` value.\n`tol` must be `1E-4`.',
  'solution_file': None,
  'subex': [],
  'text': 'The "`decay_memsave.py`":\n"http://tinyurl.com/ofkw6kc/alg/decay_memsave.py" program\nwrites the time values and solution values to a file which looks\nlike\n!bc\n0.0000000000000000E+00  1.0000000000000000E+00\n2.0000000000000001E-01  8.3333333333333337E-01\n4.0000000000000002E-01  6.9444444444444453E-01\n6.0000000000000009E-01  5.7870370370370383E-01\n8.0000000000000004E-01  4.8225308641975323E-01\n1.0000000000000000E+00  4.0187757201646102E-01\n1.2000000000000000E+00  3.3489797668038418E-01\n1.3999999999999999E+00  2.7908164723365347E-01\n\n!ec \nModify the file output such that it looks like\n!bc dat\n0.000  1.00000\n0.200  0.83333\n0.400  0.69444\n0.600  0.57870\n0.800  0.48225\n1.000  0.40188\n1.200  0.33490\n1.400  0.27908\n\n!ec\nIf you have just modified the formatting of numbers in the file,\nrunning the modified program\n!bc sys\nTerminal> python decay_memsave_v2.py --T 10 --theta 1 \\ \n          --dt 0.2 --makeplot\n\n!ec\nleads to printing of the message `Bug in the implementation!` in the\nterminal window. Why?',
  'title': 'Change formatting of numbers and debug',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 1,
  'chapter_no': 3,
  'chapter_title': 'Analysis',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['decay_plot_fd_error'],
  'heading': '=====',
  'hints': ['To save manual calculations and learn more about symbolic computing,\nmake functions for the three difference operators and use `sympy`\nto perform the symbolic differences, differentiation, and Taylor series\nexpansion. To plot a symbolic expression `E` against `p`, convert the\nexpression to a Python function first: `E = sympy.lamdify([p], E)`.'],
  'keywords': None,
  'label': 'decay:analysis:exer:fd:exp:plot',
  'no': 7,
  'solution': "Here is Python code for the exercise:\n\n!bc pypro\nimport sympy as sym\n\n# Define finite difference operators as functions\n\ndef D_f(u, dt, t):\n    return (u(t + dt) - u(t))/dt\n\ndef D_b(u, dt, t):\n    return (u(t) - u(t - dt))/dt\n\ndef D_c(u, dt, t):\n    return (u(t + dt) - u(t - dt))/(2*dt)\n\n\ndef make_plot():\n    def u(t):\n        return sym.exp(-a*t)\n\n    a, t, dt, p = sym.symbols('a t dt p')\n    dudt = sym.diff(u(t), t)\n\n    from numpy import logspace, exp\n    from matplotlib.pyplot import (\n        semilogx, legend, show, loglog, savefig)\n\n    # Map operator function name to logical names\n    operator2name = dict(\n        D_f='forward', D_b='backward', D_c='central')\n    legends = []\n    for operator in D_f, D_b, D_c:\n        E = operator(u, dt, t)/dudt\n        # Expand, set p=a*dt, simplify\n        E = sym.expand(E)\n        E = E.subs(a*dt, p)\n        E = sym.simplify(E)\n        print '%s E:' % operator2name[operator.__name__], E\n        print 'Taylor series:', E.series(p, 0, 3)\n        latex_expr = sym.latex(E)\n\n        E = sym.lambdify([p], E, modules='numpy')\n        p_values = logspace(-6, -0.5, 101)\n        y = E(p_values)\n        semilogx(p_values, y)\n        legends.append(operator2name[operator.__name__] +\n                       ': $' + latex_expr + '$')\n    legend(legends, loc='lower left')\n    savefig('tmp.png'); savefig('tmp.pdf')\n    show()\n\nmake_plot()\n\n!ec\nThe output of the Taylor polynomials reads\n\n!bc\nforward E: (exp(p) - 1)*exp(-p)/p\nTaylor series: 1 - p/2 + p**2/6 + O(p**3)\nbackward E: (exp(p) - 1)/p\nTaylor series: 1 + p/2 + p**2/6 + O(p**3)\ncentral E: sinh(p)/p\nTaylor series: 1 + p**2/6 + O(p**3)\n\n!ec \n\nFIGURE: [fig-analysis/decay_plot_fd_error, width=700 frac=0.9] Plot for Exercise ref{decay:analysis:exer:fd:exp:plot}.",
  'solution_file': None,
  'subex': [],
  'text': "The purpose of this exercise is to visualize the accuracy of finite difference\napproximations of the derivative of a given function.\nFor any finite difference approximation, take the Forward Euler difference\nas an example, and any specific function, take  $u=e^{-at}$,\nwe may introduce an error fraction\n\n!bt\n\\begin{align*}\nE = \\frac{[D_t^+ u]^n}{u'(t_n)} &= \\frac{\\exp{(-a(t_n+\\Delta t))} - \\exp{(-at_n)}}{-a\\exp{(-at_n)\\Delta t}}\\\\ \n&= \\frac{1}{a\\Delta t}\\left(1 -\\exp{(-a\\Delta t)}\\right),\n\\end{align*}\n\n!et\nand view $E$ as a function of $\\Delta t$. We expect that\n$\\lim_{\\Delta t\\rightarrow 0}E=1$, while $E$ may deviate significantly from\nunity for large $\\Delta t$. How the error depends on $\\Delta t$ is best\nvisualized in a graph where we use a logarithmic scale for $\\Delta t$,\nso we can cover many orders of magnitude of that quantity. Here is\na code segment creating an array of 100 intervals, on the logarithmic\nscale, ranging from $10^{-6}$ to $10^{-0.5}$ and then plotting $E$ versus\n$p=a\\Delta t$ with logarithmic scale on the $p$ axis:\n\n!bc pycod\nfrom numpy import logspace, exp\nfrom matplotlib.pyplot import semilogx\np = logspace(-6, -0.5, 101)\ny = (1-exp(-p))/p\nsemilogx(p, y)\n\n!ec\nIllustrate such errors for the finite difference operators $[D_t^+u]^n$\n(forward), $[D_t^-u]^n$ (backward), and $[D_t u]^n$ (centered) in\nthe same plot.\n\nPerform a Taylor series expansions of the error fractions and find\nthe leading order $r$ in the expressions of type\n$1 + Cp^r + \\Oof{p^{r+1}}$, where $C$ is some constant.",
  'title': 'Visualize the accuracy of finite differences',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 2,
  'chapter_no': 3,
  'chapter_title': 'Analysis',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['exponential_growth'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:analysis:exer:growth',
  'no': 8,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '#Does not work: @@@CODE exer-analysis/exponential_growth.do.txt envir=None fromto: The schemes are@=== Analysis\n\nThe schemes are exactly the same as in the case $a>0$.\nA program solving the problem numerically is shown below.\n\n!bc pycod\nfrom numpy import *\n\n# Exercise a\n\ndef solver(I, a, T, dt, theta):\n    """Solve u\'=-a*u, u(0)=I, for t in (0,T] with steps of dt."""\n    dt = float(dt)            # avoid integer division\n    Nt = int(round(T/dt))     # no of time intervals\n    T = Nt*dt                 # adjust T to fit time step dt\n    u = zeros(Nt+1)           # array of u[n] values\n    t = linspace(0, T, Nt+1)  # time mesh\n\n    u[0] = I                  # assign initial condition\n    for n in range(0, Nt):    # n=0,1,...,Nt-1\n        u[n+1] = (1 - (1-theta)*a*dt)/(1 + theta*dt*a)*u[n]\n    return u, t\n\ndef u_exact(t, I, a):\n    return I*exp(-a*t)\n\ndef numerical_and_exact(theta, I, a, T, dt):\n    """Compare the numerical and exact solution in a plot."""\n    u, t = solver(I=I, a=a, T=T, dt=dt, theta=theta)\n\n    t_e = linspace(0, T, 1001)        # fine mesh for u_e\n    u_e = u_exact(t_e, I, a)\n    return u, t, u_e, t_e\n\ndef demo(dt):\n    from matplotlib.pyplot import (\n        plot, xlabel, ylabel, legend, title, savefig, show)\n    for theta in [0, 0.5, 1]:\n        u, t, u_e, t_e = numerical_and_exact(\n            I=1, a=-1, T=2.5, dt=dt, theta=theta)\n        xlabel(\'t\')\n        ylabel(\'u\')\n        plot(t,   u)\n\n    plot(t_e, u_e, \'k-\')  # black line\n    legend([\'FE\', \'CN\', \'BE\', \'exact\'], loc=\'upper left\')\n    title(\'Timestep: %g\' % dt)\n    savefig(\'tmp_%g.png\' % dt); savefig(\'tmp_%g.pdf\' % dt)\n    show()\n\n!ec\n\nWe can try different $\\Delta t$ values: 3, 0.5, 0.1, and 0.01.\n\nFIGURE: [fig-analysis/exponential_growth_demo, width=800 frac=1]',
             'text': 'Set $a=-1$ and run experiments with $\\theta=0, 0.5, 1$ for\nvarious values of $\\Delta t$ to uncover numerical artifacts.\nRecall that the exact solution is a\nmonotone, growing function when $a < 0$. Oscillations or significantly\nwrong growth are signs of wrong qualitative behavior.\n\nFrom the experiments, select four values of $\\Delta t$ that\ndemonstrate the kind of numerical solutions that are characteristic\nfor this model.'},
            {'answer': '',
             'file': None,
             'hints': ['Modify the "`decay_ampf_plot.py`": "http://tinyurl.com/ofkw6kc/analysis/decay_ampf_plot.py" code\n(in the `src/analysis` directory).'],
             'solution': "#@@@CODE exer-analysis/exponential_growth.do.txt envir=None fromto: === Analysis@\n\nThe amplification factor is the same as when $a>0$, but here we introduce\n$p=-a\\Delta t>0$ since $a < 0$:\n\n!bt\n\\begin{equation}\nA(p) = \\frac{1+(1-\\theta)p}{1-\\theta p}.\n\\end{equation}\n\n!et\nA major problem is that the denominator can be zero when $a < 0$. This\nhappens for $p=1/\\theta$. The exact amplification factor is $\\Aex = e^{p}$.\n\nHere is code for computing and plotting the factors:\n\n!bc pycod\n# Exercise b\n\ndef plot_amplification_factors(names):\n    # Substitute -p by p since a is negative for a growth model\n\n    def A_exact(p):\n        return exp(p)\n\n    def A(p, theta):\n        return (1+(1-theta)*p)/(1-theta*p)\n\n    def amplification_factor(names):\n        # Use SciTools since it adds markers to colored lines\n        from scitools.std import (\n            plot, title, xlabel, ylabel, hold, savefig,\n            axis, legend, grid, show, figure)\n        figure()\n        curves = {}\n        p = linspace(0, 3, 99)\n        curves['exact'] = A_exact(p)\n        plot(p, curves['exact'])\n        hold('on')\n        name2theta = dict(FE=0, BE=1, CN=0.5)\n        for name in names:\n            curves[name] = A(p, name2theta[name])\n            plot(p, curves[name])\n            axis([p[0], p[-1], -20, 20])\n            #semilogy(p, curves[name])\n        plot([p[0], p[-1]], [0, 0], '--')  # A=0 line\n        title('Amplification factors')\n        grid('on')\n        legend(['exact'] + names, loc='lower left', fancybox=True)\n        xlabel(r'$p=-a\\cdot dt$')\n        ylabel('Amplification factor')\n        savefig('A_growth.png'); savefig('A_growth.pdf')\n        #show()\n\n    amplification_factor(names)\n\n!ec\n\nFIGURE: [fig-analysis/A_growth, width=700 frac=0.9]",
             'text': 'Write up the amplification factor and plot it for $\\theta=0,0.5,1$\ntogether with the exact one for $a\\Delta t < 0$. Use the plot to\nexplain the observations made in the experiments.'}],
  'text': "This exercise asks you to solve the ODE $u'=-au$ with $a < 0$ such that\nthe ODE models exponential growth instead of exponential decay.  A\ncentral theme is to investigate numerical artifacts and non-physical\nsolution behavior.",
  'title': 'Explore the $\\theta$-rule for exponential growth',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 1,
  'chapter_no': 4,
  'chapter_title': 'Generalizations',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['test_precision'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:precision',
  'no': 9,
  'solution': 'We modify the `decay_vc.py` program to\n\n!bc pypro\nfrom numpy import *\nfrom matplotlib.pyplot import *\n\ndef solver(I, a, b, T, dt, theta):\n    """\n    Solve u\'=-a(t)*u + b(t), u(0)=I,\n    for t in (0,T] with steps of dt.\n    a and b are Python functions of t.\n    """\n    dt = float(dt)            # avoid integer division\n    Nt = int(round(T/dt))     # no of time intervals\n    T = Nt*dt                 # adjust T to fit time step dt\n    u = zeros(Nt+1)           # array of u[n] values\n    t = linspace(0, T, Nt+1)  # time mesh\n\n    u[0] = I                  # assign initial condition\n    for n in range(0, Nt):    # n=0,1,...,Nt-1\n        u[n+1] = ((1 - dt*(1-theta)*a(t[n]))*u[n] + \\\n                  dt*(theta*b(t[n+1]) + (1-theta)*b(t[n])))/\\\n                  (1 + dt*theta*a(t[n+1]))\n    return u, t\n\ndef test_linear_solution():\n    """\n    Test problem where u=c*t+I is the exact solution, to be\n    reproduced (to machine precision) by any relevant method.\n    """\n    def u_exact(t):\n        return c*t + I\n\n    def a(t):\n        return t**0.5  # can be arbitrary\n\n    def b(t):\n        return c + a(t)*u_exact(t)\n\n    theta = 0.4; I = 0.1; dt = 0.1\n    T = 4\n    Nt = int(T/dt)  # no of steps\n\n    c_values = [1E-5, 0.1, 1, 10, 100, 1000, 10000,\n                1E+7, 1E+10, 1E+20]\n    for c in c_values:\n        u, t = solver(I=I, a=a, b=b, T=Nt*dt, dt=dt, theta=theta)\n        u_e = u_exact(t)\n        difference = abs(u_e - u).max()  # max deviation\n        print \'c=%6g, difference=%g\' % (c, difference)\n\ntest_linear_solution()\n\n!ec\nRunning this program gives the output\n\n!bc\nc= 1e-05, difference=2.77556e-17\nc=   0.1, difference=1.11022e-16\nc=     1, difference=8.88178e-16\nc=    10, difference=7.10543e-15\nc=   100, difference=1.13687e-13\nc=  1000, difference=9.09495e-13\nc= 10000, difference=1.09139e-11\nc= 1e+07, difference=7.45058e-09\nc= 1e+10, difference=1.14441e-05\nc= 1e+20, difference=131072\n\n!ec \nThe tolerance must in each case be chosen less than the size of\n`difference`. It is an essential point to avoid parameters in\nODEs that are very large. Scaling the problem is then a good\nidea (see Section ref{decay:app:scaling}).',
  'solution_file': None,
  'subex': [],
  'text': 'It is claimed in Section ref{decay:MMS} that most numerical methods will\nreproduce a linear exact solution to machine precision. Test this\nassertion using the test function `test_linear_solution` in the\n"`decay_vc.py`": "http://tinyurl.com/ofkw6kc/genz/decay_vc.py" program.\nVary the parameter `c` from very small, via `c=1` to many larger values,\nand print out the maximum difference between the numerical solution\nand the exact solution. What is the relevant value of the tolerance\nin the float comparison in each case?',
  'title': 'Experiment with precision in tests and the size of $u$',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 2,
  'chapter_no': 4,
  'chapter_title': 'Generalizations',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['decay_backward2step'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:bw2',
  'no': 10,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Implement the 2-step backward method (ref{decay:fd2:bw:2step}) for the\nmodel $u^{\\prime}(t) = -a(t)u(t) + b(t)$, $u(0)=I$.  Allow the first step to\nbe computed by either the Backward Euler scheme or the Crank-Nicolson\nscheme. Verify the implementation by choosing $a(t)$ and $b(t)$ such\nthat the exact solution is linear in $t$ (see Section\nref{decay:MMS}). Show mathematically that a linear solution is indeed a\nsolution of the discrete equations.\n\nCompute convergence rates (see Section ref{decay:convergence:rate}) in\na test case using $a=\\hbox{const}$ and $b=0$, where we easily have an exact\nsolution, and determine if the choice of a first-order scheme\n(Backward Euler) for the first step has any impact on the overall\naccuracy of this scheme. The expected error goes like $\\Oof{\\Delta t^2}$.',
  'title': 'Implement the 2-step backward scheme',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 3,
  'chapter_no': 4,
  'chapter_title': 'Generalizations',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['decay_AdamsBashforth2'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:AB2',
  'no': 11,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Implement the 2nd-order Adams-Bashforth method (ref{decay:fd2:AB2})\nfor the decay problem $u^{\\prime}=-a(t)u + b(t)$, $u(0)=I$, $t\\in (0, T]$.\nUse the Forward Euler method for the first step such that the overall\nscheme is explicit. Verify the implementation using an exact\nsolution that is linear in time.\nAnalyze the scheme by searching for solutions $u^n=A^n$ when $a=\\hbox{const}$\nand $b=0$. Compare this second-order scheme to the Crank-Nicolson scheme.',
  'title': 'Implement the 2nd-order Adams-Bashforth scheme',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 4,
  'chapter_no': 4,
  'chapter_title': 'Generalizations',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['decay_AdamsBashforth3'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:AB3',
  'no': 12,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Implement the 3rd-order Adams-Bashforth method (ref{decay:fd2:AB3})\nfor the decay problem $u^{\\prime}=-a(t)u + b(t)$, $u(0)=I$, $t\\in (0, T]$.\nSince the scheme is explicit, allow it to be started by two steps with\nthe Forward Euler method.  Investigate experimentally the case where\n$b=0$ and $a$ is a constant: Can we have oscillatory solutions for\nlarge $\\Delta t$?',
  'title': 'Implement the 3rd-order Adams-Bashforth scheme',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 5,
  'chapter_no': 4,
  'chapter_title': 'Generalizations',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['decay_RK2_Taylor2'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:RK2:Taylor:analysis',
  'no': 13,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Show that the schemes (ref{decay:fd2:RK2:s2}) and\n(ref{decay:fd2:Taylor2}) are identical in the case $f(u,t)=-a$, where\n$a>0$ is a constant. Assume that the numerical solution reads\n$u^n=A^n$ for some unknown amplification factor $A$ to be determined.\nFind $A$ and derive stability criteria. Can the scheme produce\noscillatory solutions of $u^{\\prime}=-au$? Plot the numerical and exact\namplification factor.',
  'title': 'Analyze explicit 2nd-order methods',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 6,
  'chapter_no': 4,
  'chapter_title': 'Generalizations',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['decay_leapfrog'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:leapfrog1',
  'no': 14,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Implement the Leapfrog scheme for the model equation.\nPlot the solution in the case $a=1$, $b=0$, $I=1$,\n$\\Delta t = 0.01$, $t\\in [0,4]$. Compare with the exact\nsolution $\\uex(t)=e^{-t}$.'},
            {'answer': '',
             'file': None,
             'hints': ["It can be wise to automate the calculations such that it is easy to\nredo the calculations for other types of solutions. Here is\na possible `sympy` function that takes a symbolic expression `u`\n(implemented as a Python function of `t`), fits the `b` term, and\nchecks if `u` fulfills the discrete equations:\n\n!bc pycod\nimport sympy as sym\n\ndef analyze(u):\n    t, dt, a = sym.symbols('t dt a')\n\n    print 'Analyzing u_e(t)=%s' % u(t)\n    print 'u(0)=%s' % u(t).subs(t, 0)\n\n    # Fit source term to the given u(t)\n    b = sym.diff(u(t), t) + a*u(t)\n    b = sym.simplify(b)\n    print 'Source term b:', b\n\n    # Residual in discrete equations; Forward Euler step\n    R_step1 = (u(t+dt) - u(t))/dt + a*u(t) - b\n    R_step1 = sym.simplify(R_step1)\n    print 'Residual Forward Euler step:', R_step1\n\n    # Residual in discrete equations; Leapfrog steps\n    R = (u(t+dt) - u(t-dt))/(2*dt) + a*u(t) - b\n    R = sym.simplify(R)\n    print 'Residual Leapfrog steps:', R\n\ndef u_e(t):\n    return c*t + I\n\nanalyze(u_e)\n# or short form: analyze(lambda t: c*t + I)\n\n!ec"],
             'solution': '',
             'text': 'Show mathematically that a linear solution in $t$ fulfills the\nForward Euler scheme for the first step and the Leapfrog scheme\nfor the subsequent steps. Use this linear solution to verify\nthe implementation, and automate the verification through a test\nfunction.'},
            {'aftertext': '\n',
             'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Show that a second-order polynomial in $t$ cannot be a solution of the discrete\nequations. However, if a Crank-Nicolson scheme is used for the first\nstep, a second-order polynomial solves the equations exactly.'},
            {'aftertext': '\n#A possible test case is\n#$u^{\\prime}=-au + b$, $u(0)=0$, where $\\uex(t)=b/a + (I - b/a)e^{-at}$ if\n#$a$ and $b$ are constants.\n',
             'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Create a manufactured solution $u(t)=\\sin(t)$ for the ODE\n$u^{\\prime}=-au+b$.\nCompute the convergence rate of the Leapfrog scheme using this\nmanufactured solution. The expected convergence rate of the\nLeapfrog scheme is $\\Oof{\\Delta t^2}$. Does the use of a\n1st-order method for the first step impact the convergence rate?'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Set up a set of experiments to demonstrate that the Leapfrog scheme\n(ref{decay:fd2:exer:leapfrog1:scheme}) is associated with numerical artifacts\n(instabilities). Document the main results from this investigation.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Analyze and explain the\ninstabilities of the Leapfrog scheme (ref{decay:fd2:exer:leapfrog1:scheme}):\n\n o Choose $a=\\mbox{const}$ and $b=0$. Assume that an exact solution\n   of the discrete equations has\n   the form $u^n=A^n$, where $A$ is an amplification factor to\n   be determined. Derive an equation for $A$ by inserting $u^n=A^n$\n   in the Leapfrog scheme.\n o Compute $A$ either by hand and/or with the aid of `sympy`.\n   The polynomial for $A$ has two roots, $A_1$ and $A_2$. Let\n   $u^n$ be a linear combination $u^n=C_1A_1^n + C_2A_2^n$.\n o Show that one of the roots is the reason for instability.\n o Compare $A$ with the exact expression, using a Taylor series approximation.\n o How can $C_1$ and $C_2$ be determined?'},
            {'aftertext': '\n',
             'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Since the original Leapfrog scheme is unconditionally unstable as time\ngrows, it demands some stabilization.  This can be done by filtering,\nwhere we first find $u^{n+1}$ from the original Leapfrog scheme and\nthen replace $u^{n}$ by $u^n + \\gamma (u^{n-1} - 2u^n +\nu^{n+1})$, where $\\gamma$ can be taken as 0.6.  Implement the filtered\nLeapfrog scheme and check that it can handle tests where the original\nLeapfrog scheme is unstable.'}],
  'text': 'A Leapfrog scheme\nfor the ODE $u^{\\prime}(t) = -a(t)u(t) + b(t)$ is defined by\n\n!bt\n\\begin{equation}\n\\lbrack D_{2t}u = -au+b\\rbrack^n\\tp\nlabel{decay:fd2:exer:leapfrog1:scheme}\n\\end{equation}\n\n!et\nA separate method is needed to compute $u^1$. The Forward Euler\nscheme is a possible candidate.',
  'title': 'Implement and investigate the Leapfrog scheme',
  'type': 'Project',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 7,
  'chapter_no': 4,
  'chapter_title': 'Generalizations',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['decay_schemes_unified'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:uni',
  'no': 15,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Consider the linear ODE problem $u^{\\prime}(t)=-a(t)u(t) + b(t)$, $u(0)=I$.\nExplicit schemes for this problem can be written in the general form\n!bt\n\\begin{equation}\nu^{n+1} = \\sum_{j=0}^m c_ju^{n-j},\nlabel{decay:analysis:exer:sumcj}\n\\end{equation}\n\n!et\nfor some choice of $c_0,\\ldots,c_m$.\nFind expressions for the $c_j$ coefficients in case of the\n$\\theta$-rule, the three-level backward scheme,\nthe Leapfrog scheme, the 2nd-order Runge-Kutta method,\nand the 3rd-order Adams-Bashforth scheme.\n\nMake a class `ExpDecay` that implements the\ngeneral updating formula (ref{decay:analysis:exer:sumcj}).\nThe formula cannot be applied for $n < m$, and for those $n$ values, other\nschemes must be used. Assume for simplicity that we just\nrepeat Crank-Nicolson steps until (ref{decay:analysis:exer:sumcj}) can be used.\nUse a subclass\nto specify the list $c_0,\\ldots,c_m$ for a particular method, and\nimplement subclasses for all the mentioned schemes.\nVerify the implementation by testing with a linear solution, which should\nbe exactly reproduced by all methods.',
  'title': 'Make a unified implementation of many schemes',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 1,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['carbon14'],
  'heading': '=====',
  'hints': ['Let $A$ be the amount of Carbon-14. The ODE problem is then\n$A^{\\prime}(t)=-aA(t)$, $A(0)=I$. Introduced the scaled amount\n$u=A/I$. The ODE problem for $u$ is $u^{\\prime}=-au$, $u(0)=1$.\nMeasure time in years.\nSimulate until the first mesh point $t_m$ such that $u(t_m)\\leq 0.084$.',
            'Use simulations with $5,730\\pm 40$ y as input\nand find the corresponding uncertainty interval for the result.'],
  'keywords': None,
  'label': 'decay:app:exer:radio:C14',
  'no': 16,
  'solution': 'We need a tailored solver function for this exercise:\n\n!bc pycod\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef solver(I, a, u_crit, dt, theta):\n    """\n    Solve u\'=-a*u, u(0)=I, for t in (0,t_m] until u <= u_crit\n    with steps of dt. Return t_m.\n    """\n    # Use list for u and t since we do not know how many points\n    # that are needed\n    dt = float(dt)               # avoid integer division\n    u = []\n    t = []\n\n    u.append(I)                  # assign initial condition\n    t.append(0)\n    while u[-1] > u_crit:\n        u_new = (1 - (1-theta)*a*dt)/(1 + theta*dt*a)*u[-1]\n        u.append(u_new)\n        t.append(t[-1] + dt)\n    return t[-1]\n\n\nhalf_life = 5730\na  = np.log(2)/half_life\nprint \'Age:\', solver(I=1, a=a, u_crit=0.084, dt=10, theta=0.5)\n\n!ec\nRunning this code gives an age of 20,480 years.\n\nThe uncertainty can be estimated by the following code:\n\n!bc pycod\nhalf_life_min = 5730 - 40\nhalf_life_max = 5730 + 40\na_min = np.log(2)/half_life_min\na_max = np.log(2)/half_life_max\nage_min = solver(I=1, a=a_max, u_crit=0.084, dt=10, theta=0.5)\nage_max = solver(I=1, a=a_min, u_crit=0.084, dt=10, theta=0.5)\nprint \'Uncertainty: [%g, %g]\' % (age_min, age_max)\n\n!ec',
  'solution_file': None,
  'subex': [],
  'text': 'The "Carbon-14": "http://en.wikipedia.org/wiki/Carbon-14" isotope,\nwhose radioactive decay is used extensively in dating organic material\nthat is tens of thousands of years old, has a half-life of $5,730$\nyears.  Determine the age of an organic material that contains 8.4 percent\nof its initial amount of Carbon-14.  Use a time unit of 1 year in the\ncomputations.  The uncertainty in the half time of Carbon-14 is $\\pm\n40$ years.  What is the corresponding uncertainty in the estimate of\nthe age?',
  'title': 'Radioactive decay of Carbon-14',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 2,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['schemes_cooling'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:cooling:schemes',
  'no': 17,
  'solution': 'The idea of the Forward Euler scheme is to sample the ODE at $t=t_n$\nand apply a forward difference approximation to the derivative:\n\n!bt\n\\[ \\frac{T^{n+1}-T^n}{\\Delta t} = -k(T^n - T_s(t_n))\\tp\\]\n\n!et\nThe Backward Euler applies a backward difference instead:\n\n!bt\n\\[ \\frac{T^{n}-T^{n-1}}{\\Delta t} = -k(T^n - T_s(t_n))\\tp\\]\n\n!et\nThe Crank-Nicolson scheme samples the ODE at $t_{n+\\half}$, applies\na centered difference approximation, and an arithmetic mean approximation\nto $T^{n+\\half}$:\n\n!bt\n\\[ \\frac{T^{n+1}-T^n}{\\Delta t} = -k(T^{n+\\half} - T_s(t_{n+\\half}))\n\\approx -k(\\half(T^n + T^{n+1}) - T_s(t_{n+\\half}))\\tp\\]\n\n!et\nFor each scheme we solve with respect to the unknown $T^{n+1}$ (note\nthat we switch index from $n$ to $n+1$ in the Backward Euler scheme):\n\n!bt\n\\begin{align*}\nT^{n+1} &= T^n - k\\Delta t(T^n - T_s(t_n)),\\\\ \nT^{n+1} &= \\frac{T^n + k\\Delta t T_s(t_{n+1})}{1 + k\\Delta t},\\\\ \nT^{n+1} &= \\frac{T^n - \\half k\\Delta t T^n + k\\Delta t T_s(t_{n+\\half})}{1 + \\half k\\Delta t}\\tp\n\\end{align*}\n\n!et\nA $\\theta$ scheme can be formulated as\n\n!bt\n\\[ T^{n+1} = \\frac{T^n - (1-\\theta) k\\Delta t T^n + k\\Delta t T_s((1-\\theta) t_n+ \\theta t_{n+1})}{1 + \\theta k\\Delta t}\n\\]\n\n!et',
  'solution_file': None,
  'subex': [],
  'text': "Show in detail how we can apply the ideas of the Forward Euler,\nBackward Euler, and Crank-Nicolson\ndiscretizations to derive explicit\ncomputational formulas for new temperature values in Newton's law of\ncooling (see Section ref{decay:app:Newton:cooling}):\n\n!bt\n\\[\n\\frac{dT}{dt} = -k(T-T_s(t)),\\quad T(0)=T_0\\tp\n\\]\n\n!et\nHere, $T$ is the temperature of the body, $T_s(t)$ is the temperature\nof the surroundings, $t$ is time, $k$ is the heat transfer\ncoefficient, and $T_0$ is the initial temperature of the body.\nSummarize the discretizations in a $\\theta$-rule\nsuch that you can get the three\nschemes from a single formula by varying the $\\theta$ parameter.",
  'title': "Derive schemes for Newton's law of cooling",
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 3,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['cooling'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:cooling:py',
  'no': 18,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': 'Here is an appropriate function:\n\n!bc pycod\nimport numpy as np\n\ndef cooling(T0, k, T_s, t_end, dt, theta=0.5):\n    """\n    Solve T\'=-k(T-T_s(t)), T(0)=T0,\n    for t in (0,t_end] with steps of dt.\n    T_s(t) is a Python function of t.\n    theta=0.5 means Crank-Nicolson, 1 is Backward\n    Euler, and 0 is Forward Euler scheme.\n    """\n    dt = float(dt)                  # avoid integer division\n    Nt = int(round(t_end/dt))       # no of time intervals\n    t_end = Nt*dt                   # adjust to fit time step dt\n    T = np.zeros(Nt+1)              # array of T[n] values\n    t = np.linspace(0, t_end, Nt+1) # time mesh\n    T[0] = T0                       # set initial condition\n    for n in range(0, Nt):          # n=0,1,...,Nt-1\n        T[n+1] = ((1 - dt*(1 - theta)*k)*T[n] + \\ \n        dt*k*(theta*T_s(t[n+1]) + (1 - theta)*T_s(t[n])))/ \\ \n        (1 + dt*theta*k)\n    return T, t\n\n!ec',
             'text': 'Implement the $\\theta$-rule from\nExercise ref{decay:app:exer:cooling:schemes} in a function\n\n!bc\ncooling(T0, k, T_s, t_end, dt, theta=0.5)\n\n!ec \nwhere `T0` is the initial temperature, `k` is\nthe heat transfer coefficient, `T_s` is a function of `t` for\nthe temperature of the\nsurroundings, `t_end` is the end time of the simulation, `dt` is the\ntime step, and `theta` corresponds to $\\theta$.  The `cooling`\nfunction should return the temperature as an array `T` of values at\nthe mesh points and the time mesh `t`.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': 'Apply the limit to the ODE:\n\n!bt\n\\[ \\lim_{t\\rightarrow\\infty}\\frac{dT}{dt} = -k(\\lim_{t\\rightarrow\\infty} T\n- \\lim_{t\\rightarrow\\infty} T_s)\\tp\n\\]\n\n!et\nAssuming steady state behavior, $dT/dt\\rightarrow\\infty$ as\n$t\\rightarrow\\infty$. Then we get\n\n!bt\n\\[ 0 = -k(\\lim_{t\\rightarrow\\infty} T\n- C),\n\\]\n\n!et\nwhich means\n\n!bt\n\\[ \\lim_{t\\rightarrow\\infty} T = C\\tp\\]\n\n!et\n\nA corresponding test function takes the form\n\n!bc pycod\ndef test_asymptotic():\n    """\n    Test that ``any\'\' initial condition leads to\n    the same asymptotic behavior when T_s=constant.\n    """\n    import matplotlib.pyplot as plt\n    plt.figure()\n    T_s = 5.\n    k = 1.2\n    dt = 0.1\n    tol = 0.01  # tolerance for testing asymptotic value\n    t_end = 7    # make sure t_end is large enough for tol\n    T0_values = [0, 2, 4, 5, 6, 8, 10] # test many cases\n\n    for T0 in [0, 2, 4, 5, 6, 8, 10]:\n        u, t = cooling(T0, k, lambda t: T_s, t_end, dt)\n        plt.plot(t, u)\n\n        assert abs(u[-1] - T_s) < tol, \'%s != %s\' % (u[-1], T_s)\n\n    plt.legend([\'T0=%g\' % T0 for T0 in T0_values])\n    plt.title(\'Testing asymptotic behavior T_s=%g\' % T_s)\n    plt.xlabel(\'t\')\n    plt.ylabel(\'T\')\n    plt.savefig(\'tmp1.png\');  plt.savefig(\'tmp1.pdf\')\n    plt.show()\n\n!ec\nNote that we have added a plot in the test function for convenience.\nLetting test functions perform plotting is, however, not a good idea\nif you want to run a large set of tests.\n\nFIGURE: [fig-models/cooling_asymptotic, width=600 frac=0.8]',
             'text': 'In the case $\\lim_{t\\rightarrow\\infty}T_s(t)=C=\\mbox{const}$,\nexplain why $T(t)\\rightarrow C$. Construct an example where you\ncan illustrate this property in a plot. Implement a corresponding\ntest function that checks the correctness of the asymptotic\nvalue of the solution.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': 'First we implement a general tool for piecewise constant functions:\n\n!bc pycod\nclass Piecewise(object):\n    """Class for holding a piecewise constant function."""\n    def __init__(self, C0, C1, t_star):\n        self.C0, self.C1 = C0, C1\n        self.t_star = t_star\n\n    def __call__(self, t):\n        """\n        Return value of piecewise constant function.\n        t can be float or numpy array.\n        """\n        if isinstance(t, (float,int)):\n            if t <= self.t_star:\n                T_s = self.C0\n            elif t > self.t_star:\n                T_s = self.C1\n        else:\n            # assume numpy array\n            T_s = np.piecewise(t,\n                               [t <= self.t_star, t > self.t_star],\n                               [self.C0, self.C1])\n            # Alternative\n            # T_s = np.where(t <= self.t_star, C0, C1)\n        return T_s\n\n!ec\n\nIt is convenient to scale the problem such that we do not need to find\nphysically relevant values for $k$. A common scaling of $T$ is\n\n!bt\n\\[ \\bar T = \\frac{T-T_0}{T_s-T_0},\\]\n\n!et\nwhen $T_s$ is constant since then $\\bar T\\in [0,1]$. Here, we may choose\nthe long-term value of $T_s$ in the denominator such that $\\lim_{t\\rightarrow\\infty}\\bar T=1$, i.e.,\n\n!bt\n\\[ \\bar T = \\frac{T-T_0}{0.5T_0-T_0}= -2\\frac{T-T_0}{T_0},\\]\n\n!et\nbut it leads to a shift in the sign of the temperature on the\nright-hand side of the ODE, and we cannot reuse the code for the\noriginal problem in the dimensionless case. We therefore avoid the negative\nsign and use a temperature scale $2T_0-T_0$,\n\n!bt\n\\[ \\bar T = \\frac{T-T_0}{2T_0-T_0}= \\frac{T-T_0}{T_0},\\]\n\n!et\nwhich gives $\\bar T$ varying from $0$ initially to a maximum of\n$1$ and finally to a minimum of $-\\half$.\nWe scale $T_s$ by its maximum value $2T_0$ so $\\bar T_s\\in [0,1]$:\n\n!bt\n\\[ \\bar T_s(\\bar t) = \\frac{T_s(t)}{\\max_t T_s(t)} = \\frac{T_s(t_c\\bar t)}{2T_0} = \\left\\lbrace\\begin{array}{ll}\n1, & \\bar t < t^*/t_c,\\\\ \n\\frac{1}{4},& \\bar t \\geq t^*/t_c\n\\end{array}\\right.\n\\]\n\n!et\nwhere $t_c$ is the time scale. Inserted in the ODE we get\n\n!bt\n\\[\n\\frac{T_0}{t_c}\\frac{d\\bar T}{d\\bar t} = -k(T_0\\bar T + T_0 -\n2T_0\\bar T_s,\n\\]\n\n!et\nleading to\n\n!bt\n\\[\n\\frac{d\\bar T}{d\\bar t} = -kt_c(\\bar T + 1 - 2\\bar T_s)\\tp\n\\]\n\n!et\nA natural choice is $t_c=1/k$ so we get the scaled problem\n\n!bt\n\\[\n\\frac{d\\bar T}{d\\bar t} = -(\\bar T + 1 - 2\\bar T_s) =\n-(\\bar T -(2\\bar T_s - 1)),\\quad \\bar T(0)=0\\tp\n\\]\n\n!et\nWe can simulate this problem using the code for the original\nproblem by choosing $k=1$, $T_0=0$, and\n$T_s= (2-1)=1$ for $t < 3$ and $T_s=(2\\frac{1}{4}-1)=-\\half$\nfor $t > 3$.\n\nThe appropriate code becomes\n\n!bc pycod\ndef simulate_piecewise_constant_Ts():\n    """\n    Simulate scaled problem: T\' = -(T - (2T_s-1)), T(0)=0,\n    where T_s=1 for t < 3 and -0.5 for t > 3.\n    """\n    k = 1\n    T0 = 0\n    t_star = 3.0\n    C0 = 1\n    C1 = -0.5\n    T_s = Piecewise(C0, C1, t_star)\n    dt = t_star/100.0\n    T, t = cooling(T0, k, T_s, t_end=3*t_star, dt=dt, theta=0.5)\n    import matplotlib.pyplot as plt\n    plt.figure()\n    plt.plot(t, T)\n    plt.xlabel(\'t\');  plt.ylabel(\'u\')\n    plt.savefig(\'tmp2.png\');  plt.savefig(\'tmp2.pdf\')\n    plt.show()\n\n!ec\nThe plot looks like this:\n\nFIGURE: [fig-models/cooling_piecewise, width=600 frac=0.8]\n\nThe result is reasonable because first $T_s=1$ and the body\'s temperature\nwill try to rise from $0$ to $1$, and it almost gets there in\nthe time $[0,3]$, before $T_s=-0.5$ and then the body is cooled down\nto $-0.5$ as $t$ increases, and this is also the asymptotic value.',
             'text': 'A piecewise constant surrounding temperature,\n\n!bt\n\\[ T_s(t) = \\left\\lbrace\\begin{array}{ll} C_0,& 0\\leq t\\leq t^*\\\\ \nC_1, & t>t^*,\\end{array}\\right.\n\\]\n\n!et\ncorresponds to a sudden change in the environment\nat $t=t^*$. Choose $C_0=2T_0$, $C_1=\\frac{1}{2}T_0$, and\n$t^*=3/k$. Plot the solution $T(t)$ and explain why it seems physically\nreasonable.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': 'In the unscaled problem, the first stage of the simulation\ncovers the time interval $[0,t^*]=[0, 3/k]$. It makes sense to\nchoose $\\Delta t$ significantly smaller than $3/k$, and the\nstability limit $2/k$ is a too large step. The next time level\nis then $4/k$, and it sounds reasonable to include the point $t^*=3/k$\nas a mesh point. Oscillations would then occur if we choose\n$\\Delta t = 3/k$, but this means only one step through the first\ninterval $[0,t^*]$, which is a very coarse mesh. Halving $\\Delta t$\nis still a coarse mesh, but then there cannot be oscillations.',
             'text': 'We know from the ODE $u^\\prime =-au$ that the Crank-Nicolson scheme\ncan give non-physical oscillations for $\\Delta t > 2/a$.\nIn the present problem, this results indicates\nthat the Crank-Nicolson scheme give undesired\noscillations for $\\Delta t > 2/k$.\nDiscuss if this a potential problem in the physical case from c).'},
            {'answer': '',
             'file': None,
             'hints': ['The exact solution can be derived by multiplying (ref{decay:Newton:cooling})\nby the integrating factor $e^{kt}$.'],
             'solution': 'Multiplication of $e^{kt}$, using the product rule for differentiation\n``backwards\'\', and integrating from 0 to $t$, results in\n\n!bt\n\\[ \\int_0^t (e^{kt}T)^{\\prime}dt = k\\int_0^t e^{kt}T_sdt\\tp\\]\n\n!et\nThe left-hand side becomes $e^{kt}T(t)-T_0$. Multiplying by $e^{-kt}$\nthen gives\n\n!bt\n\\[ T(t) = T_0e^{-kt} + ke^{-kt}\\int_0^t e^{k\\tau}T_s(\\tau)d\\tau,\\]\n\n!et\nwhich is the general expression for the exact solution.\n\nAs a check, we consider the case where $T_s$ is constant.\nThat problem can easily be solved by introducing $u=T-T_s$, resulting in\n$u^{\\prime}=-ku$, $u(0)=T_0-T_s$, with solution $u(t)=(T_0-T_s)e^{-kt}$,\nand consequently $T=T_s + (T_0-T_s)e^{-kt}$. With a constant $T_s$ in\nthe general solution above, the solution becomes\n\n!bt\n\\begin{align*}\nT(t) &= T_0e^{-kt} + ke^{-kt}\\int_0^t e^{kt}T_sdt\\\\ \n& = T_0e^{-kt} + ke^{-kt}T_sk^{-1}(e^{kt} - 1)\\\\ \n& = T_0e^{-kt} + T_s - T_se^{-kt}\\\\ \n& = T_s + (T_0-T_s)e^{-kt},\n\\end{align*}\n\n!et\nas desired.\n\nWe choose the same test problem as in c) and use SymPy to do the\nintegration. A function doing the integration and returning\nPython functions for the formulas for $t < t^*$ and $t\\geq t^*$\nis convenient:\n\n!bc pycod\ndef T_exact_symbolic(verbose=False):\n    """Compute the exact solution formula via sympy."""\n    # sol1: solution for t < t_star,\n    # sol2: solution for t > t_star\n    import sympy as sym\n    T0 = sym.symbols(\'T0\')\n    k = sym.symbols(\'k\', positive=True)\n    # Piecewise linear T_sunction\n    t, t_star, C0, C1 = sym.symbols(\'t t_star C0 C1\')\n    T_s = C0\n    I = sym.integrate(sym.exp(k*t)*T_s, (t, 0, t))\n    sol1 = T0*sym.exp(-k*t) + k*sym.exp(-k*t)*I\n    sol1 = sym.simplify(sym.expand(sol1))\n    if verbose:\n        # Some debugging print\n        print \'solution t < t_star:\', sol1\n        #print sym.latex(sol1)\n    T_s = C1\n    I = sym.integrate(sym.exp(k*t)*C0, (t, 0, t_star)) + \\ \n        sym.integrate(sym.exp(k*t)*C1, (t, t_star, t))\n    sol2 = T0*sym.exp(-k*t) + k*sym.exp(-k*t)*I\n    sol2 = sym.simplify(sym.expand(sol2))\n    if verbose:\n        print \'solution t > t_star:\', sol2\n        #print sym.latex(sol2)\n\n    # Convert to numerical functions\n    exact0 = sym.lambdify([t, C0, k, T0],\n                          sol1, modules=\'numpy\')\n    exact1 = sym.lambdify([t, C0, C1, t_star, k, T0],\n                          sol2, modules=\'numpy\')\n    return exact0, exact1\n\n!ec\nThen we need a function that can evaluate the exact solution as\na mesh function:\n\n!bc pycod\ndef evaluate_T_exact(t, k, T0, C0, C1, t_star, verbose=False):\n    """\n    Return exact (analytical) solution of the problem.\n    Exact solution is produced by sympy.\n    """\n    exact0, exact1 = T_exact_symbolic()\n    # exact0/1 works with t as numpy array\n    if isinstance(t, (float,int)):\n        if t < t_star:\n            return exact0(t, C0, k, T0)\n        else:\n            return exact1(t, C0, C1, t_star, k, T0)\n    else:\n        # assume numpy array\n        return np.where(\n            t < t_star,\n            exact0(t, C0, k, T0),\n            exact1(t, C0, C1, t_star, k, T0))\n\n!ec\nFinally we can run the comparison:\n\n!bc pycod\ndef compare_numerical_and_exact_solution():\n    """\n    Compare exact and numerical solution with piecewise\n    constant surrounding temperature. Use scaled problem\n    from function simulate_piecewise_constant_Ts.\n    """\n    T0 = 0\n    k = 1\n    C0 = 1\n    C1 = -0.5\n    t_star = 3\n    t_end = 7\n\n    T_s = Piecewise(C0, C1, t_star)\n\n    import matplotlib.pyplot as plt\n    plt.figure()\n    dt_values = [1, 0.5, 0.025]\n    #dt_values = [0.025]\n    for dt in dt_values:\n        T, t = cooling(T0, k, T_s, t_end, dt, theta=0.5)\n        plt.plot(t, T)\n\n    t_e = np.linspace(0, t_end, 1001)  # find mesh for T_e\n    # Could use sym.Rational(1,2) instead of 0.5, but not necessary\n    # when we are not interested in symbolic formulas\n    T_e = evaluate_T_exact(t_e, k, T0, C0, C1, t_star)\n    plt.plot(t_e, T_e)\n    plt.legend([\'CN, dt=%g\' % dt for dt in dt_values] + [\'exact\'])\n    plt.title(\'T(t) for piecewise constant $T_s(t)$\')\n    plt.xlabel(\'t\')\n    plt.ylabel(\'T\')\n    plt.savefig(\'tmp3.png\');  plt.savefig(\'tmp3.pdf\')\n    plt.show()\n\n!ec\nThe $\\Delta t$ values were found after some trial and error, but they\nillustrate crude approximations and one with the biggest possible\n$\\Delta t$ such that the exact solution and the numerical solution cannot\nbe visually distinguished:\n\nFIGURE: [fig-models/cooling_piecewise_compare, width=600 frac=0.8]\n\nWe can now start to introduce bugs in the `cooling` function to\nsee if it is possible to have some $\\Delta t$ and still find\ncoinciding curves.\n\n=== Bug 1: Wrong time level in the $T_s$ function ===\n\nWe replace `T_s[n]` by `T_s[n+1]` in the implementation of the scheme\nand rerun the case. Now the lowest $\\Delta t$ is still on top of\nthe exact solution, but the numerical solution on the two coarser\nmeshes are more accurate! This is because we lower the surrounding\ntemperature somewhat earlier in the buggy scheme and this reduces\nthe ``overshoot\'\' on the coarsest meshes in the figure above.\n\nFIGURE: [fig-models/cooling_piecewise_bug1, width=600 frac=0.8]\n\n=== Bug 2: Wrong time level in the $T$ function ===\n\nWe can replace `T[n]` by `T[n+1]` on the right-hand side of the scheme.\nThis is a serious error since `T[n+1]` is not yet computed and therefore\nequal to zero when `T` was made by calling `np.zeros`. The results\nare also nonsense, and one would immediately look for a bug.\n\nFIGURE: [fig-models/cooling_piecewise_bug2, width=600 frac=0.8]\n\n=== Bug 3: Missing $\\theta$ in a term ===\n\nLet us forget to multiply by `theta` in the nominator of the scheme, i.e.,\nwe replace\n\n!bc pycod\nT[n+1] = ((1 - dt*(1 - theta)*k)*T[n] + \\ \n         dt*k*(theta*T_s(t[n+1]) + (1 - theta)*T_s(t[n])))/ \\ \n         (1 + dt*theta*k)\n\n!ec\nby\n\n!bc pycod\nT[n+1] = ((1 - dt*(1 - theta)*k)*T[n] + \\ \n         dt*k*(T_s(t[n+1]) + (1 - theta)*T_s(t[n])))/ \\ \n         (1 + dt*theta*k)\n\n!ec\nThis error leads to convergence towards a wrong solution:\n\nFIGURE: [fig-models/cooling_piecewise_bug3, width=600 frac=0.8]\n\nIf we did not have the exact solution, one could be led to think\nthat the solution was correct, but it is non-physical since we\ndo not expect the temperature to rise from $T_0$ to a level\n*above* the surrounding temperature. The plot shows that $\\bar T>1$,\nthe value of the (scaled) surrounding temperature.\nNote that if we used the Backward Euler scheme instead of the\nCrank-Nicolson scheme, this bug would have no effect!\n\n=== Bug 4: Missing `k` in the updating formula ===\n\nObviously, when we solve the scaled problem where $k=1$ by definition,\nsuch a programming mistake has no effect. Otherwise, $k$ influences\nthe time scale, so there will be a stretch of the time axis in the\nnumerical solution and this should be easily detected in a plot.\n\n=== Bug 5: Using `1-theta` instead of `theta` ===\n\nSuch an error is not detectable in the Crank-Nicolson scheme, but\nwill have a significant effect in the other schemes.\nAs a test, we replace `1-theta` in the nominator by `theta`.\nThis leads to $T=0$ in the Forward Euler scheme, but a reasonable shape\nin the Backward Euler scheme, although the solution becomes larger\nthan the surrounding temperature (1 in the scaled problem).\n\nFIGURE: [fig-models/cooling_piecewise_bug5, width=600 frac=0.8]',
             'text': 'Find an expression for the exact solution of\n$T^{\\prime} = -k(T-T_s(t))$, $T(0)=T_0$.\nConstruct a test case and compare the\nnumerical and exact solution in a plot.\n\nFind a value of the time step\n$\\Delta t$ such that the two solution curves cannot (visually) be\ndistinguished from each other. Many scientists will claim that such a\nplot provides evidence for a correct implementation, but point out why\nthere still may be errors in the code.  Can you introduce bugs in the\n`cooling` function and still achieve visually coinciding curves?'},
            {'answer': '',
             'file': None,
             'hints': ['The exact solution of the\ndiscrete equations in the case $T_s$ is a constant can be found by\nintroducing $u=T-T_s$ to get a problem $u^{\\prime}=-ku$, $u(0)=T_0-T_s$.\nThe solution of the discrete equations is then of the form\n$u^{n}=(T_0-T_s)A^n$ for some amplification factor $A$. The\nexpression for $T^n$ is then $T^n = T_s(t_n) + u^n =\nT_s + (T_0-T_s)A^n$.\nWe find that\n\n!bt\n\\[ A = \\frac{1 - (1-\\theta) k\\Delta t}{1 + \\theta k\\Delta t}\\tp\\]\n\n!et\nThe test function, testing several $\\theta$ values for a quite coarse\nmesh, may take the form\n\n!bc pycod\ndef test_discrete_solution():\n    """\n    Compare the numerical solution with an exact solution of the scheme\n    when the T_s is constant.\n    """\n    T_s = 10\n    T0 = 2\n    k = 1.2\n    dt = 0.1   # can use any mesh\n    N_t = 6    # any no of steps will do\n    t_end = dt*N_t\n    t = np.linspace(0, t_end, N_t+1)\n\n    for theta in [0, 0.5, 1, 0.2]:\n        u, t = cooling(T0, k, lambda t: T_s , t_end, dt, theta)\n        A = (1 - (1-theta)*k*dt)/(1 + theta*k*dt)\n        u_discrete_exact = T_s + (T0-T_s)*A**(np.arange(len(t)))\n        diff = np.abs(u - u_discrete_exact).max()\n        print \'diff computed and exact discrete solution:\', diff\n        tol = 1E-14\n        success = diff < tol\n        assert success, \'diff=%g\' % diff\n\n!ec\nRunning this function shows that the `diff` variable is `3.55E-15`\nas maximum so a tolerance of $10^{-14}$ is appropriate.\nThis is a good test that the `cooling` function works!'],
             'solution': '',
             'text': 'Implement a test function for checking that the solution returned by\nthe `cooling` function is identical to the exact numerical\nsolution of the problem (to machine precision) when $T_s$ is constant.'}],
  'text': 'The goal of this exercise is to implement the schemes from\nExercise ref{decay:app:exer:cooling:schemes} and investigate\nseveral approaches for verifying the implementation.',
  'title': "Implement schemes for Newton's law of cooling",
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 4,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['detective'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:cooling:murder',
  'no': 19,
  'solution': 'A Forward Euler step from $T^0$ to $T^1$ reads\n\n!bt\n\\[ T^1 = T_0 + -k\\Delta t (T^0 - T_s),\\]\n\n!et\nand solving with respect to $k$ results in\n\n!bt\n\\[ k = \\frac{T^1 - T^0}{\\Delta t(T_s - T_0)}\\tp\\]\n\n!et\nWe implement this formula in a function,\n\n!bc pycod\ndef estimate_k(T0, T1, Ts, dt):\n    return float(T1 - T0)/(dt*(Ts - T0))\n\n!ec\nWe have $T_0=26.7$ C, $T_1=25.8$ C, $T_s=20$ C, and $\\Delta t = 1$ h,\ni.e., $\\Delta t = 3600$ s. The proper call is therefore\n\n!bc pycod\nk = estimate_k(26.7, 25.8, 20, 3600)\n\n!ec\n\nFor the simulation we use the Forward Euler method,\n\n!bt\n\\[ T^{n+1} = T^n - k\\Delta t(T^n - T_s),\\]\n\n!et\nand simulate as long as $T > 25.8$ C:\n\n!bc pycod\nT = 37\nTs = 20\nfrom cooling import cooling\nwhile T > 25.8:\n    T = T - k*dt*(T - Ts)\n    t+= dt\n\nminutes, seconds = divmod(t, 60)\nhours, minutes = divmod(minutes, 60)\nprint """\nThe death occurred %d hours, %d minutes,\nand %g seconds before 3am.""" % (hours, minutes, seconds)\n\n!ec\nThe result of running the code becomes\n\n!bc sys\nTerminal> python detective.py\nk=3.73134e-05\n\nThe death occurred 8 hours, 0 minutes,\nand 19 seconds before 3am.\n\n!ec',
  'solution_file': None,
  'subex': [],
  'text': '# URL: "http://www.biology.arizona.edu/BioMath/tutorials/Applications/Cooling.html"\n\nA detective measures the temperature of a dead body to be 26.7 C at 2\npm. One hour later the temperature is 25.8 C. The question is when\ndeath occurred.\n\nAssume that Newton\'s law of cooling (ref{decay:Newton:cooling}) is an\nappropriate mathematical model for the evolution of the temperature in\nthe body.  First, determine $k$ in (ref{decay:Newton:cooling}) by\nformulating a Forward Euler approximation with one time steep from\ntime 2 am to time 3 am, where knowing the two temperatures allows for\nfinding $k$. Assume the temperature in the air to be 20 C. Thereafter,\nsimulate the temperature evolution from the time of murder, taken as\n$t=0$, when $T=37\\hbox{ C}$, until the temperature reaches 25.8 C. The\ncorresponding time allows for answering when death occurred.',
  'title': 'Find time of murder from body temperature',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 5,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['osc_cooling'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:cooling:osc',
  'no': 20,
  'solution': 'We can reuse the `cooling` function from Exercise ref{decay:app:exer:cooling:py}\nto do the simulations:\n\n!bc pycod\nimport numpy as np\n\ndef cooling(T0, k, T_s, t_end, dt, theta=0.5):\n    """\n    Solve T\'=-k(T-T_s(t)), T(0)=T0,\n    for t in (0,t_end] with steps of dt.\n    T_s(t) is a Python function of t.\n    theta=0.5 means Crank-Nicolson, 1 is Backward\n    Euler, and 0 is Forward Euler scheme.\n    """\n    dt = float(dt)                  # avoid integer division\n    Nt = int(round(t_end/dt))       # no of time intervals\n    t_end = Nt*dt                   # adjust to fit time step dt\n    T = np.zeros(Nt+1)              # array of T[n] values\n    t = np.linspace(0, t_end, Nt+1) # time mesh\n    T[0] = T0                       # set initial condition\n    for n in range(0, Nt):          # n=0,1,...,Nt-1\n        T[n+1] = ((1 - dt*(1 - theta)*k)*T[n] + \\ \n        dt*k*(theta*T_s(t[n+1]) + (1 - theta)*T_s(t[n])))/ \\ \n        (1 + dt*theta*k)\n    return T, t\n\n!ec\n\nThe challenge is to use the right units\nfor the input data. We can use Celsius for temperature since it has\nthe same increments as Kelvin. Time quantities should be measured\nin seconds:\n\n!bt\n\\begin{align*}\nk &= 20 \\hbox{ min}^{-1} = \\frac{20}{60}\\hbox{ s}^{-1},\\\\ \nP &= (1 \\hbox{ h} = 3600\\hbox{ s}, 10\\hbox{ min} = 600\\hbox{ s},\n6\\hbox{ h}=6\\cdot 3600\\hbox{ s})\\tp\n\\end{align*}\n\n!et\n\nTo achieve reasonable accuracy,\nwe choose $\\Delta t$ as 40 steps per the\nshortest period of the $T_s$ oscillations:\n$\\Delta t = 600/40$. With some trials we find\nan appropriate simulation interval for all three cases to be\n$[0,8]$ h.\n\nThe code becomes\n\n!bc pypro\nfrom cooling import cooling\nfrom numpy import pi, sin\n\ndef T_s(t):\n    return Tm + a*sin((2*pi/P)*t)\n\nTm = 25\na = 2.5\nP_values = [3600, 600, 3600*6]\nk = 0.05/60\nT0 = 5\n\nimport matplotlib.pyplot as plt\nfor P in P_values:\n    T, t = cooling(T0, k, T_s, t_end=8*3600, dt=600/40)\n    plt.plot(t, T)\nplt.plot(t, T_s(t), \'k--\')  # T_s for largest P to show amplitude\nlegends = [\'P=1 h\', \'P=10 min\', \'P=6 h\', \'$T_s$\']\nplt.legend(legends, loc=\'lower right\')\nplt.xlabel(\'t\'); plt.ylabel(\'T\')\nplt.savefig(\'tmp.png\');  plt.savefig(\'tmp.pdf\')\nplt.show()\n\n!ec\n\nFIGURE: [fig-models/osc_cooling, width=700 frac=0.8]\n\n\n__Discussion of the results.__\nWe see that it takes some time to increase the temperature from $T_0$\nto oscillations around $T_m$. When $T_s$ oscillates fast ($P=10$ min),\n$k$ is not large enough so that $T$ can reach the surrounding temperature\nin the time available before the surrounding temperature decreases.\nHowever, for large $P$ (6 h), there is almost enough time to heat\nand cool the object to reach the maximum and minimum temperatures\nof the surroundings.',
  'solution_file': None,
  'subex': [],
  'text': "The surrounding temperature $T_s$ in Newton's law of cooling\n(ref{decay:Newton:cooling}) may vary in time. Assume that the\nvariations are periodic with period $P$ and amplitude $a$ around\na constant mean temperature $T_m$:\n\n!bt\n\\begin{equation}\nT_s(t) = T_m + a\\sin\\left(\\frac{2\\pi}{P}t\\right)\n\\tp\n\\end{equation}\n\n!et\nSimulate a process with the following data: $k=0.05 \\hbox{ min}^{-1}$,\n$T(0)=5$ C, $T_m=25$ C, $a=2.5$ C, and $P=1$ h, $P=10$ min, and $P=6$ h.\nPlot the $T$ solutions and $T_s$ in the same plot.",
  'title': 'Simulate an oscillating cooling process',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 6,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['stochastic_decay'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:stoch:nuclear',
  'no': 21,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The purpose of this exercise is to implement the stochastic model\ndescribed in Section ref{decay:app:nuclear} and show that its\nmean behavior approximates the solution of the corresponding\nODE model.\n\nThe simulation goes on for a time interval $[0,T]$ divided into\n$N_t$ intervals of length $\\Delta t$. We start with $N_0$\natoms. In some time interval, we have $N$ atoms that have survived.\nSimulate $N$ Bernoulli trials with probability $\\lambda\\Delta t$\nin this interval by drawing $N$ random numbers, each being 0 (survival)\nor 1 (decay), where the probability of getting 1 is $\\lambda\\Delta t$.\nWe are interested in the number of decays, $d$, and the number of\nsurvived atoms in the next interval is then $N-d$.\nThe Bernoulli trials\nare simulated by drawing $N$ uniformly distributed real numbers on\n$[0,1]$ and saying that 1 corresponds to a value less than $\\lambda\\Delta t$:\n\n!bc pycod\n# Given lambda_, dt, N\nimport numpy as np\nuniform = np.random.uniform(N)\nBernoulli_trials = np.asarray(uniform < lambda_*dt, dtype=np.int)\nd = Bernoulli_trials.size\n\n!ec\nObserve that `uniform < lambda_*dt` is a boolean array whose true\nand false values become 1 and 0, respectively, when converted to an\ninteger array.\n\nRepeat the simulation over $[0,T]$ a large number of times, compute the average\nvalue of $N$ in each interval, and compare with the solution of\nthe corresponding ODE model.',
  'title': 'Simulate stochastic radioactive decay',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 7,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['radioactive_decay_2subst'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:radio:twosubst',
  'no': 22,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Make a simulation program that solves for $u_A(t)$ and $u_B(t)$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Verify the implementation by computing analytically\nthe limiting values of\n$u_A$ and $u_B$ as $t\\rightarrow \\infty$ (assume $u_A^{\\prime},u_B^{\\prime}\\rightarrow 0$)\nand comparing these with those obtained numerically.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Run the program for the case of $A_{1/2}=10$ minutes and $B_{1/2}=50$ minutes.\nUse a time unit of 1 minute. Plot $u_A$ and $u_B$ versus time in the same\nplot.'}],
  'text': 'Consider two radioactive substances A and B. The nuclei in substance A\ndecay to form nuclei of type B with a half-life $A_{1/2}$, while\nsubstance B decay to form type A nuclei with a half-life $B_{1/2}$.\nLetting $u_A$ and $u_B$ be the fractions of the initial amount of\nmaterial in substance A and B, respectively, the following system of\nODEs governs the evolution of $u_A(t)$ and $u_B(t)$:\n!bt\n\\begin{align}\n\\frac{1}{\\ln 2} u_A^{\\prime} &= u_B/B_{1/2} - u_A/A_{1/2},\\\\ \n\\frac{1}{\\ln 2} u_B^{\\prime} &= u_A/A_{1/2} - u_B/B_{1/2},\n\\end{align}\n\n!et\nwith $u_A(0)=u_B(0)=1$.',
  'title': 'Radioactive decay of two substances',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 8,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['chemcial_kinetics_AB'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:kinetics:AB',
  'no': 23,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Consider the simple chemical reaction where a substance A is turned\ninto a substance B according to\n\n!bt\n\\begin{align*}\n\\frac{d[A]}{dt} &= -k[A],\\\\ \n\\frac{d[B]}{dt} &= k[A],\\\\ \n\\end{align*}\n\n!et\nwhere $[A]$ and $[B]$ are the concentrations of A and B, respectively.\nIt may be a challenge to find appropriate values of $k$, but we can avoid\nthis problem by working with a scaled model (as explained in\nSection ref{decay:app:scaling}).\nScale the model above, using a time scale $1/k$, and use\nthe initial concentration\nof $[A]$ as scale for $[A]$ and $[B]$. Show that the scaled system\nreads\n\n!bt\n\\begin{align*}\n\\frac{du}{dt} &= -u,\\\\ \n\\frac{dv}{dt} &= u,\\\\ \n\\end{align*}\n\n!et\nwith initial conditions $u(0)=1$, and $v(0)=\\alpha$, where\n$\\alpha = [B](0)/[A](0)$ is a dimensionless number, and\n$u$ and $v$ are the scaled concentrations of $[A]$ and $[B]$,\nrespectively. Implement a numerical scheme that can be used to\nfind the solutions\n$u(t)$ and $v(t)$. Visualize $u$ and $v$ in the same plot.',
  'title': 'Simulate a simple chemical reaction',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 9,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['chemcial_kinetics_ABn'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:kinetics:ABn',
  'no': 24,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'An $n$-order chemical reaction, generalizing the model in\nExercise ref{decay:app:exer:kinetics:AB}, takes the form\n\n!bt\n\\begin{align*}\n\\frac{d[A]}{dt} &= -k[A]^n,\\\\ \n\\frac{d[B]}{dt} &= k[A]^n,\\\\ \n\\end{align*}\n\n!et\nwhere symbols are as defined in Exercise ref{decay:app:exer:kinetics:AB}.\nBring this model on dimensionless form, using a time scale $[A](0)^{n-1}/k$,\nand show that the dimensionless model simplifies to\n\n!bt\n\\begin{align*}\n\\frac{du}{dt} &= -u^n,\\\\ \n\\frac{dv}{dt} &= u^n,\\\\ \n\\end{align*}\n\n!et\nwith $u(0)=1$ and $v(0)=\\alpha = [B](0)/[A](0)$. Solve numerically for\n$u(t)$ and show a plot with $u$ for $n=0.5, 1, 2, 4$.',
  'title': 'Simulate an $n$-th order chemical reaction',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 10,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['biochem'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:MMK',
  'no': 25,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': 'Replacing the unknowns and $t$ by their dimensionless equivalents\nleads to\n\n!bt\n\\begin{align*}\n\\frac{d\\bar Q}{d\\bar t} &= t_ck_+\\frac{E_0S_0}{Q_c}\\bar E\\bar S\n- t_c(k_v + k_-)\\bar Q,\\\\ \n\\frac{d\\bar P}{d\\bar t} &= t_ck_v\\frac{Q_c}{P_c}\\bar Q,\\\\ \n\\frac{d\\bar S}{d\\bar t} &= -t_ck_+E_0\\bar E\\bar S\n+ t_ck_-\\frac{Q_c}{S_0}\\bar Q,\\\\ \n\\frac{d\\bar E}{d\\bar t} &= -t_ck_+S_0\\bar E\\bar S\n+ t_c(k_- + k_v)\\frac{Q_c}{E_0}\\bar Q\\tp\n\\end{align*}\n\n!et\nInserting the choice of scales brings us to the given equations, after\nquite some algebra and identifying coefficients in terms of the\nprovided dimensionless numbers.',
             'text': 'Scale (ref{decay:app:MMK:ES1})-(ref{decay:app:MMK:E1}) such that\nwe can work with dimensionless parameters, which are easier to prescribe.\nIntroduce\n\n!bt\n\\[ \\bar Q = \\frac{[ES]}{Q_c},\\quad\n\\bar P = \\frac{P}{P_c},\\quad \\bar S = \\frac{S}{S_0},\\quad \\bar E = \\frac{E}{E_0},\\quad \\bar t = \\frac{t}{t_c},\\]\n\n!et\nwhere appropriate scales are\n\n!bt\n\\[ Q_c = \\frac{S_0E_0}{K},\\quad P_c = Q_c, \\quad t_c=\\frac{1}{k_+E_0},\\]\n\n!et\nwith $K=(k_v+k_-)/k_+$ (Michaelis constant). Show that the scaled\nsystem becomes\n\n!bt\n\\begin{align}\n\\frac{d\\bar Q}{d\\bar t} &= \\alpha (\\bar E\\bar S\n- \\bar Q),\nlabel{decay:app:MMK:Q2}\\\\ \n\\frac{d\\bar P}{d\\bar t} &= \\beta\\bar Q,\nlabel{decay:app:MMK:P2}\\\\ \n\\frac{d\\bar S}{d\\bar t} &= -\\bar E\\bar S\n+ (1 - \\beta\\alpha^{-1})\\bar Q,\nlabel{decay:app:MMK:S2}\\\\ \n\\epsilon\\frac{d\\bar E}{d\\bar t} &= -\\bar E\\bar S + \\bar Q,\nlabel{decay:app:MMK:E2}\n\\end{align}\n\n!et\nwhere we have three dimensionless parameters\n\n!bt\n\\[ \\alpha = \\frac{K}{E_0},\\quad \\beta = \\frac{k_v}{k_+ E_0},\\quad\n\\epsilon = \\frac{E_0}{S_0}\\tp\n\\]\nThe corresponding initial conditions are $\\bar Q=\\bar P=0$ and\n$\\bar S=\\bar E=1$.\n\n!et'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': 'Let us use Odespy to solve the differential equations, although a plain\nForward Euler scheme will be fine.\n\n!bc pycod\nimport odespy\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sys\n\ndef solver(alpha, beta, epsilon, T, dt=0.1):\n    def f(u, t):\n        Q, P, S, E = u\n        return [\n            alpha*(E*S - Q),\n            beta*Q,\n            -E*S + (1-beta/alpha)*Q,\n            (-E*S + Q)/epsilon,\n            ]\n\n    Nt = int(round(T/dt))\n    t_mesh = np.linspace(0, Nt*dt, Nt+1)\n\n    solver = odespy.RK4(f)\n    solver.set_initial_condition([0, 0, 1, 1])\n    u, t = solver.solve(t_mesh)\n    Q = u[:,0]\n    P = u[:,1]\n    S = u[:,2]\n    E = u[:,3]\n    return Q, P, S, E\n\n!ec',
             'text': 'Implement a function for\nsolving (ref{decay:app:MMK:Q2})-(ref{decay:app:MMK:E2}).'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': "Adding\n(ref{decay:app:MMK:ES1}) and (ref{decay:app:MMK:E1}) shows that\n\n!bt\n\\[ \\frac{d[ES]}{dt} + \\frac{d[E]}{dt} = 0,\\]\n\n!et\nand therefore $[ES] + [E]=\\hbox{const}$. Since $[ES](0)=0$ and\n$[E](0)=E_0$, the constant is $E_0$ at $t=0$ and will remain so.\nSimilarly, adding (ref{decay:app:MMK:ES1}),\n(ref{decay:app:MMK:S1}), and (ref{decay:app:MMK:P1})\nshows that their time derivatives sum up to zero, and therefore\n$[ES] + [S] + [P] =\\hbox{const}$. Since $[P](0)=0$, the constant\nmust be $0+S_0+0=S_0$.\n\nTo use the conservation as a consistency check in the software, we need\nto find the equivalent dimensionless versions:\n\n!bt\n\\[ [ES] + [E] = E_0\\quad\\Rightarrow\\quad Q_c\\bar Q + E_0\\bar E = E_0,\\]\n\n!et\nand from this we get, after a little algebra,\n\n!bt\n\\[ \\alpha^{-1}\\epsilon^{-1}\\bar Q + \\bar E = 1\\tp\\]\n\n!et\nThe other conservation equation becomes\n\n!bt\n\\[ \\bar Q + \\alpha\\bar S + \\bar P  = \\alpha\\tp\\]\n\n!et\n\nThe implementation may go like\n\n!bc pycod\ncomputed = Q[n+1]/(alpha*epsilon) + E[n+1]\nexpected = 1\ndiff1 = abs(computed - expected)\n\ncomputed = Q[n+1] + alpha*S[n+1] + P[n+1]\nexpected = alpha\ndiff2 = abs(computed - expected)\n\ntol = 1E-14\nif diff1 < tol or diff2 < tol:\n    print '*** Consistency check failed:', diff1, diff2\n\n!ec",
             'text': 'There are two conservation equations implied by\n(ref{decay:app:MMK:ES1})-(ref{decay:app:MMK:E1}):\n\n!bt\n\\begin{align}\n[ES] + [E] &= E_0,\\\\ \n[ES] + [S] + [P] &= S_0\\tp\n\\end{align}\n\n!et\nDerive these two equations. Use these properties in the function\nin b) to do a partial verification of the solution at each time step.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': "!bc pycod\ndef demo():\n    alpha = 1\n    beta = 4\n    epsilon = 0.1\n    T = 8\n    dt = float(sys.argv[1]) if len(sys.argv) >= 2 else 0.1\n    Q, P, S, E = solver(alpha, beta, epsilon, T, dt)\n    plt.plot(t, Q, t, P, t, S, t, E)\n    plt.legend(['complex', 'product', 'substrate', 'enzyme'],\n               loc='upper right')\n    plt.title('alpha=%g, beta=%g, epsilon=%g' %\n              (alpha, beta, epsilon))\n    plt.savefig('tmp.png');  plt.savefig('tmp.pdf')\n    plt.show()\n\nif __name__ == '__main__':\n    demo()\n\n!ec\n\nFIGURE: [fig-models/biochem, width=700 frac=1]",
             'text': 'Simulate a case with $T=8$, $\\alpha = 1$, $\\beta=4$, and two\n$\\epsilon$ values: 0.9 and 0.1.'}],
  'text': 'The purpose of this exercise is to simulate the ODE system\n(ref{decay:app:MMK:ES1})-(ref{decay:app:MMK:E1}) modeling a simple\nbiochemical process.',
  'title': 'Simulate a biochemical process',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 11,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['SIR'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:SIR',
  'no': 26,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': 'We introduce\n\n!bt\n\\[ \\bar t = \\frac{t}{\\nu^{-1}},\\quad \\bar S = \\frac{S}{N},\\quad\n\\bar I = \\frac{I}{N},\\quad \\bar R = \\frac{R}{N}\\tp\\]\n\n!et\nInserting these expressions in the governing equations and dividing by\n$\\nu N$ gives the listed dimensionless ODEs. The scaled initial condition\nfor $\\bar S(0)$ follows from\n$\\bar S(0) = S(0)/N = (N-I(0))/N = 1 - \\alpha$, since initially,\n$R(0)=0$ and therefore $N=S(0) + I(0)$.',
             'text': 'Estimating the parameter $\\beta$\nis difficult so it can be handy to scale the equations. Use\n$t_c=1/\\nu$ as time scale, and scale $S$, $I$, and $R$ by\nthe population size $N=S(0)+I(0)+R(0)$. Show that the resulting dimensionless\nmodel becomes\n\n!bt\n\\begin{align}\n\\frac{d\\bar S}{d\\bar t} &= - R_0\\bar S\\bar I,\nlabel{decay:app:SIR:S2}\\\\ \n\\frac{d\\bar I}{d\\bar t} &= R_0 \\bar S\\bar I - \\bar I,\nlabel{decay:app:SIR:I2}\\\\ \n\\frac{d\\bar R}{d\\bar t} &= I,\nlabel{decay:SIR:R2}\\\\ \n\\bar S(0) &= 1-\\alpha,\\\\ \n\\bar I(0) &= \\alpha,\\\\ \n\\bar R(0) &= 0,\n\\end{align}\n\n!et\nwhere $R_0$ and $\\alpha$ are the only parameters in the problem:\n\n!bt\n\\[ R_0 = \\frac{N\\beta}{\\nu}, \\quad \\alpha = \\frac{I(0)}{N}\\tp\\]\n\n!et\nA quantity with a bar denotes a dimensionless version of that quantity, e.g,\n$\\bar t$ is dimensionless time, and $\\bar t = \\nu t$.'},
            {'answer': '',
             'file': None,
             'hints': ['Spreading means $dI/dt>0$.'],
             'solution': 'For $dI/dt$ to be positive, we must have $(R_0 \\bar S - 1)\\bar I > 0$, i.e.,\n$R_0 \\bar S - 1 > 0$ since $\\bar I\\geq 0$. At $t=0$, we get\n$R_0 \\bar S(0) > 1$ as the criterion, or\n\n!bt\n\\[\n\\tilde R_0\\bar S(0) = \\frac{N\\beta}{\\nu}\\frac{S(0)}{N} = \\frac{S(0)\\beta}{\\nu} >1\n\\tp\\]\n\n!et\nThe dimensionless parameter $S(0)\\beta /\\nu$ is denoted by $R_0$ in\nthe epidemiology literature and known as the *basic reproductive number*.',
             'text': 'Show that the $R_0$ parameter governs whether the disease will spread\nor not at $t=0$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': "We may use Odespy and the RK4 method to solve the system:\n\n!bc pycod\nimport odespy\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sys\n\ndef solver(R0, alpha, T, dt=0.1):\n    def f(u, t):\n        S, I, R = u\n        return [\n            -R0*S*I,\n            R0*S*I - I,\n            I]\n\n    Nt = int(round(T/dt))\n    t_mesh = np.linspace(0, Nt*dt, Nt+1)\n\n    solver = odespy.RK4(f)\n    solver.set_initial_condition([1-alpha, alpha, 0])\n    u, t = solver.solve(t_mesh)\n    S = u[:,0]\n    I = u[:,1]\n    R = u[:,2]\n    # Consistency check\n    N = 1\n    tol = 1E-15\n    for i in range(len(S)):\n        if abs(S[i] + I[i] + R[i] - N) > tol:\n            print 'Consistency error: S+I+R=%g != %g' % \\ \n                  (S[i] + I[i] + R[i], N)\n    return S, I, R, t\n\n!ec",
             'text': 'Implement the scaled SIR model. Check at every time step,\nas a verification, that\n$\\bar S + \\bar I + \\bar R = 1$.'},
            {'aftertext': '\n',
             'answer': '',
             'file': None,
             'hints': [],
             'solution': "The given data means that $\\bar I(0)=\\alpha = 0.02$ and $\\bar S(0)=0.98$.\n\n!bc pycod\ndef demo():\n    alpha = 0.02\n    R0 = 5\n    T = 8\n    dt = float(sys.argv[1]) if len(sys.argv) >= 2 else 0.1\n    S, I, R, t = solver(R0, alpha, T, dt)\n    plt.plot(t, S, t, I, t, R)\n    plt.legend(['S', 'I', 'R'], loc='lower right')\n    plt.title('R0=%g, alpha=%g' % (R0, alpha))\n    plt.savefig('tmp.png');  plt.savefig('tmp.pdf')\n    plt.show()\n\n!ec\n\nFIGURE: [fig-models/SIR1, width=800 frac=1]",
             'text': 'Simulate the spreading of a disease where $R_0=2, 5$ and 2 percent of\nthe population is infected at time $t=0$.'}],
  'text': 'The SIR model (ref{decay:app:SIR:S})-(ref{decay:app:SIR:R}) can be used\nto simulate spreading of an epidemic disease.',
  'title': 'Simulate spreading of a disease',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 12,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['predator_prey'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:predprey',
  'no': 27,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': 'We introduce dimensionless time $\\bar t=t/t_c$, where $t_c^{-1}=bH_0$,\nand scale $H$ and $L$\nas $\\bar H = H/H_0$ and $\\bar L = L/H_0$. Inserted in the equations, we\narrive at\n\n!bt\n\\begin{align*}\n\\frac{H_0}{t_c}\\frac{d\\bar H}{d\\bar t} &= H_0\\bar H(a - bH_0\\bar L),\n\\\\ \n\\frac{H_0}{t_c}\\frac{d\\bar L}{d\\bar t} &= H_0\\bar L(dH_0\\bar H - c)\\tp\n\\end{align*}\n\n!et\nInserting $t_c^{-1}=bH_0$ and rearranging simplify the equations to\n\n!bt\n\\begin{align*}\n\\frac{d\\bar H}{d\\bar t} &= \\frac{a}{bH_0}\\bar H  - \\bar L\\bar H,\n\\\\ \n\\frac{d\\bar L}{d\\bar t} &= \\frac{d}{b}\\bar L \\bar H - \\frac{c}{bH_0}\\bar L)\\tp\n\\end{align*}\n\n!et\nThe initial conditions become $\\bar H(0)=1$, $\\bar L(0)=L_0/H_0$.\nWith the dimensionless parameters\n\n!bt\n\\[ \\alpha = \\frac{a}{bH_0},\\quad\\beta = \\frac{d}{b},\\quad\\gamma =\n\\frac{c}{bH_0},\\quad \\delta = \\frac{H_0}{L_0},\\]\n\n!et\nwe can write the dimensionless problem as\n\n!bt\n\\begin{align*}\n\\frac{d\\bar H}{d\\bar t} &= \\alpha\\bar H  - \\bar L\\bar H,\\\\ \n\\frac{d\\bar L}{d\\bar t} &= \\beta\\bar L \\bar H - \\gamma\\bar L),\\\\ \n\\bar H(0) &= 1,\\\\ \n\\bar L(0) &= \\delta \\tp\n\\end{align*}\n\n!et\n\nThe quantity $bH_0$ is the number of eaten preys per predator.\nThen $\\alpha$ measures the ratio of natural population growth of\nthe prey, due to nutrition, and the number of eaten preys per predator.\nThe $\\beta$ parameter measures the fraction of the eaten preys and\nthe amount of this that actually\nleads to population growth of the predator.\nThe number $\\gamma$ reflects the ratio of\npredator deaths and the eaten preys per predator, and $\\delta$ is\nthe initial fraction of preys and predators.',
             'text': 'Scale the equations (ref{decay:app:predprey:eqH})-(ref{decay:app:predprey:eqL}).\nUse the initial population $H(0)=H_0$ of $H$ has scale for $H$ and $L$, and\nlet the time scale be $1/(bH_0)$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': "Here are two functions:\n\n!bc pycod\nimport odespy\nimport numpy as np\n#import scitools.std as plt\nimport matplotlib.pyplot as plt\nfig_counter = 0  # used in plot file names\n\ndef simulate(alpha, beta, gamma, delta, T=20):\n    def f(u, t, alpha, beta, gamma):\n        H, L = u\n        return [alpha*H - L*H, beta*L*H - gamma*L]\n\n\n    t = np.linspace(0, T, 1501)\n    solver = odespy.RK4(f, f_args=(alpha, beta, gamma))\n    solver.set_initial_condition([1, delta])\n    u, t = solver.solve(t)\n    H = u[:,0]\n    L = u[:,1]\n\n    plt.figure()\n    global fig_counter\n    fig_counter += 1\n    plt.plot(t, H, t, L)\n    plt.legend(['H', 'L'])\n    plt.title(r'$\\alpha=%g$, $\\beta=%g$, $\\gamma=%g$, $\\delta=%g$'\n              % (alpha, beta, gamma, delta))\n    plt.savefig('tmp%d.png' % fig_counter)\n    plt.savefig('tmp%d.pdf' % fig_counter)\n    return H, L, t\n\ndef demo():\n    simulate(alpha=1.5, beta=0.5, gamma=0.8, delta=0.5, T=20)\n    simulate(alpha=0.5, beta=0.5, gamma=0.2, delta=0.5, T=50)\n\n!ec\nWe must call `demo()` from the main program.\n\nHere are two examples. The one to the left has a good birth-death rate\ncompared to how many that are eaten by predators ($\\alpha=1.5$),\nhalf of the eaten preys contribute to growth of the predator population\n($\\beta = 0.5$), the death rate of predators is slightly smaller than how many\npreys they eat (per predator) ($\\gamma=0.8$), and we start out with\ntwice as many preys as predators.\n\nThe figure to the right features less nutrition for the preys\ncompared to being eaten\nby predators ($\\alpha =0.5$), and a lower death rate in the predator\npopulation. Note the different scales in the two plots.\n\nFIGURE: [fig-models/predator_prey, width=800 frac=1]",
             'text': 'Implement the scaled model from a). Run illustrating cases how the\ntwo populations develop.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': 'Inserting\n\n!bt\n\\[ \\bar t = \\frac{t}{c_c},\\quad \\bar H=\\frac{H}{H_c},\\quad \\bar L\n= \\frac{L}{L_c},\\]\n\n!et\nin the ODEs (ref{decay:app:predprey:eqH})-(ref{decay:app:predprey:eqL}),\nwe arrive at\n\n!bt\n\\begin{align*}\n\\frac{H_c}{t_c}\\frac{d\\bar H}{d\\bar t} &= H_c\\bar H(a - bL_c\\bar L),\\\\ \n\\frac{L_c}{t_c}\\frac{d\\bar L}{d\\bar t} &= L_c\\bar L(dH_c\\bar H - c)\\tp\n\\end{align*}\n\n!et\nNow we divide by $H_c$ and $L_c$ in the $H$ and $L$ equations, respectively,\nand multiply by $t_c$:\n\n!bt\n\\begin{align*}\n\\frac{d\\bar H}{d\\bar t} &= t_c\\bar H(a - bL_c\\bar L),\\\\ \n\\frac{d\\bar L}{d\\bar t} &= t_c\\bar L(dH_c\\bar H - c)\\tp\n\\end{align*}\n\n!et\nChoosing $t_c=1/a$ and $t_caL_c=1$, i.e., $L_c=a/b$, makes the\nfirst equation free of parameters: $\\bar H^{\\prime}=\\bar H(1-\\bar L)$.\nFactoring out $c$ in the equation for $L$ and choosing\n$H_c d/c=1$, i.e., $H_c=c/d$, leaves us with the $L$ equation\nas $\\bar L^{\\prime}=(c/a)\\bar L(\\bar H-1)$. The ratio $c/a$ equals\n$\\gamma/\\alpha$ from a) and is here called $\\mu$.\n\nWe remark that $L_c=a/b$ and $H_c=c/d$ could also be found from\nthe *stationary points* of the ODE system, where\n$H^{\\prime}=L^{\\prime}=0$. The stationary points are in our case $H=L=0$ and\n$H=c/d$ and $L=a/b$.\n\nThe initial conditions become $\\bar H(0) = H_0/H_c=H_0d/c =\\beta/\\gamma = \\nu$,\nand $\\bar L(0)=L_0/L_c = L_0b/a = \\delta/\\alpha = \\omega$.\n\nThe resulting dimensionless problem takes the form\n\n!bt\n\\begin{align}\n\\frac{d\\bar H}{d\\bar t} &= \\bar H(1 - \\bar L),\\\\ \n\\frac{d\\bar L}{d\\bar t} &= \\mu \\bar L(\\bar H - 1) = \\gamma\\alpha^{-1} \\bar L(\\bar H - 1),\\\\ \n\\bar H(0) &= \\nu = \\beta/\\gamma,\\\\ \n\\bar L(0) &= \\omega = \\delta/\\alpha,\n\\end{align}\n\n!et\nwith\n\n!bt\n\\[ \\mu = \\frac{c}{a},\\quad \\nu = H_0\\frac{d}{c},\\quad \\omega = L_0\\frac{b}{a}\n\\tp\\]\n\n!et\n\nThe unknowns $\\bar H$ and $\\bar L$ now have less intuitive scalings,\n\n!bt\n\\[ \\bar H = \\frac{Hd}{c},\\quad \\bar L = \\frac{Lb}{a},\\]\n\n!et\nwhile time is measured in the units based on the exponential growth\ndue to births and deaths of preys ($a$). The number of dimensionless parameters\nis one less since we have one more scale (for $L_c$) at our\ndisposal. Simplicity in one initial conditions in a) is\nexchanged with more simplicity in the ODEs, which now have\nonly one dimensionless parameter. Note that $\\nu$ and $\\omega$ must be\ndifferent from unity to avoid $\\bar H\\neq 0$ and $\\bar L\\neq 0$ because\nof the factors $1-L$ and $H-1$ in the equations that can make\n$\\bar H^{\\prime}=0$ and $\\bar L^{\\prime}=0$.',
             'text': 'The scaling in a) used a scale for $H$ and $L$ based on the\ninitial condition $H(0)=H_0$. An alternative scaling is to make\nthe ODEs as simple as possible by introducing separate scales\n$H_c$ and $L_c$ for $H$ and $L$, respectively. Fit $H_c$,\n$L_c$, and the time scale $t_c$ such that there are as few\ndimensionless parameters as possible in the ODEs. Scale the initial\nconditions. Compare the number and type of dimensionless parameters\nwith a).'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': "Modified `simulate` and `demo` go as follows.\n\n!bc pycod\ndef simulate2(mu, nu, omega, T=20):\n    def f(u, t, mu):\n        H, L = u\n        return [H*(1-L), mu*L*(H-1)]\n\n\n    t = np.linspace(0, T, 1501)\n    solver = odespy.RK4(f, f_args=(mu,))\n    solver.set_initial_condition([nu, omega])\n    u, t = solver.solve(t)\n    H = u[:,0]\n    L = u[:,1]\n\n    plt.figure()\n    global fig_counter\n    fig_counter += 1\n    plt.plot(t, H, t, L)\n    plt.legend(['H', 'L'])\n    plt.title(r'$\\mu=%g$, $\\nu=%g$, $\\omega=%g$' % (mu, nu, omega))\n    plt.savefig('tmp%d.png' % fig_counter)\n    plt.savefig('tmp%d.pdf' % fig_counter)\n    return H, L, t\n\ndef demo2():\n    simulate2(mu=0.5, nu=0.5, omega=1.5, T=20)\n    simulate2(mu=2, nu=0.5, omega=1.5, T=20)\n\n!ec\n\nFIGURE: [fig-models/predator_prey2, width=800 frac=1]",
             'text': 'Compute with the scaled model from c) and create plots to illustrate\nthe typical solutions.'}],
  'text': 'Section ref{decay:app:predprey} describes a model for the\ninteraction of predator and prey populations, such as lynx and hares.',
  'title': 'Simulate predator-prey interaction',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 13,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['atmospheric_pressure'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:atm1',
  'no': 28,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'We consider the models for atmospheric pressure in\nSection ref{decay:app:atm}.\nMake a program with three functions,\n\n * one computing the pressure $p(z)$ using a seven-layer model\n   and varying $L$,\n * one computing $p(z)$ using a seven-layer model,\n   but with constant temperature in each layer, and\n * one computing $p(z)$ based on the\n   one-layer model.\n\nHow can these implementations be verified? Should ease of verification\nimpact how you code the functions?\nCompare the three models in a plot.',
  'title': 'Simulate the pressure drop in the atmosphere',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 14,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['vertical_motion'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:drag:prog',
  'no': 29,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Implement the Stokes' drag model (ref{decay:app:fallingbody:model:S})\nand the quadratic drag model (ref{decay:app:fallingbody:model:q}) from\nSection ref{decay:app:drag}, using the Crank-Nicolson\nscheme and a geometric mean for $|v|v$ as explained, and assume\nconstant fluid density.\nAt each time level, compute the Reynolds number\nRe and choose the Stokes' drag model if $\\hbox{Re} < 1$ and the\nquadratic drag model otherwise.\n\nThe computation of the numerical solution should take place either in\na stand-alone function or in a solver class that looks up a problem\nclass for physical data. Create a module and equip it with pytest/nose\ncompatible test functions for automatically verifying the code.\n\nVerification tests can be based on\n\n * the terminal velocity (see Section ref{decay:app:drag}),\n * the exact solution when the drag force is neglected\n   (see Section ref{decay:app:drag}),\n * the method of manufactured solutions (see Section ref{decay:MMS})\n   combined with computing\n   convergence rates (see Section ref{decay:convergence:rate}).\n\nUse, e.g., a quadratic polynomial for the velocity in the method of\nmanufactured solutions. The expected error is $\\Oof{\\Delta t^2}$\nfrom the centered finite difference approximation and the geometric\nmean approximation for $|v|v$.\n\nA solution that is linear in $t$ will also be an exact solution of the\ndiscrete equations in many problems.  Show that this is true for\nlinear drag (by adding a source term that depends on $t$), but not\nfor quadratic drag because of the geometric mean approximation.  Use\nthe method of manufactured solutions to add a source term *in the\ndiscrete equations for quadratic drag* such that a linear function of\n$t$ is a solution. Add a test function for checking that the linear\nfunction is reproduced to machine precision in the case of both linear\nand quadratic drag.\n\nApply the software to a case where a ball rises in water.  The\nbuoyancy force is here the driving force, but the drag will be\nsignificant and balance the other forces after a short time.  A soccer\nball has radius 11 cm and mass 0.43 kg.  Start the motion from rest, set\nthe density of water, $\\varrho$, to $1000\\hbox{ kg/m}^3$, set the\ndynamic viscosity, $\\mu$, to $10^{-3}\\hbox{ Pa s}$, and use a drag\ncoefficient for a sphere: 0.45. Plot the velocity of the rising ball.",
  'title': 'Make a program for vertical motion in a fluid',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 15,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['parachuting'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:parachute',
  'no': 30,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Set up the differential equation problem that governs the velocity\nof the motion.\nThe parachute jumper is subject to the gravity force and a quadratic\ndrag force. Assume constant density.\nAdd an extra source term to be used for program verification.\nIdentify the input data to the problem.'},
            {'answer': '',
             'file': None,
             'hints': ['Use the Crank-Nicolson scheme with a geometric mean of $|v|v$ in time to\nlinearize the equation of motion with quadratic drag.',
                       'You can either use functions or classes for implementation.\nIf you choose functions, make a function\n`solver` that takes all the input data in the problem as\narguments and that returns the velocity (as a mesh function) and\nthe time mesh. In case of a class-based implementation, introduce\na problem class with the physical data\nand a solver class with the numerical data and a `solve` method\nthat stores the velocity and the mesh in the class.\n\nAllow for a time-dependent area and drag coefficient in the\nformula for the drag force.'],
             'solution': '',
             'text': 'Make a Python module for computing the velocity of the motion.\nAlso equip the module with functionality for plotting the velocity.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Show that a linear function of $t$ does not fulfill the discrete\nequations because of the geometric mean approximation\nused for the quadratic drag\nterm.  Fit a source term, as in the method of manufactured solutions,\nsuch that a linear function of $t$ is a solution of the discrete\nequations. Make a test function to check that this solution is reproduced\nto machine precision.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'The expected error in this problem goes like $\\Delta t^2$ because we\nuse a centered finite difference approximation with error $\\Oof{\\Delta t^2}$\nand a geometric mean approximation with error $\\Oof{\\Delta t^2}$.\nUse the method of manufactured solutions combined with computing\nconvergence rate to verify the code. Make a test function for checking\nthat the convergence rate is correct.'},
            {'answer': '',
             'file': None,
             'hints': ['You can either make a function `forces(v, t, plot=None)`\nthat returns the forces (as mesh functions) and `t`, and shows\na plot on the screen and also saves the plot to a file with name\nstored in `plot`\nif `plot` is not `None`, or you can extend the solver class with\ncomputation of forces and include plotting of forces in the\nvisualization class.'],
             'solution': '',
             'text': 'Compute the drag force, the gravity\nforce, and the buoyancy force as a function of time. Create\na plot with these three forces.'},
            {'answer': '',
             'file': None,
             'hints': ['Meade and Struthers cite{parachute_1999} provide some data relevant\nto "skydiving": "http://en.wikipedia.org/wiki/Parachuting".\nThe mass of the human body and equipment\ncan be set to $100$ kg.\nA skydiver in spread-eagle formation has a cross-section of 0.5 $\\hbox{m}^2$\nin the horizontal plane.\nThe density of air decreases with altitude, but can be taken\nas constant, 1 $\\hbox{kg/m}^3$, for altitudes relevant to\nskydiving (0-4000 m).\nThe drag coefficient for a man in upright position can be set to 1.2.\nStart with a zero velocity.\nA free fall typically has a terminating velocity of 45 m/s. (This value\ncan be used to tune other parameters.)'],
             'solution': '',
             'text': 'Compute the velocity of\na skydiver in free fall before the parachute opens.'},
            {'answer': '',
             'file': None,
             'hints': ['Following Meade and Struthers cite{parachute_1999}, one can set the\ncross-section area perpendicular to the motion to 44 $\\hbox{m}^2$\nwhen the parachute is open. Assume that it takes 8 s to increase\nthe area linearly from the original to the final value.\nThe drag coefficient for an open\nparachute can be taken as 1.8, but tuned using the known value\nof the typical terminating velocity reached before landing:\n5.3 m/s. One can take the drag coefficient as a piecewise constant\nfunction with an abrupt change at $t_p$.\nThe parachute is typically released after $t_p=60$ s, but\nlarger values of $t_p$ can be used to make plots more illustrative.'],
             'solution': '',
             'text': 'The next task is to simulate\na parachute jumper during free fall and after the parachute opens.\nAt time $t_p$, the parachute opens and\nthe drag coefficient and the cross-sectional\narea change dramatically.\nUse the program to simulate a jump from $z=3000$ m to the ground $z=0$.\nWhat is the maximum acceleration, measured in units of $g$,\nexperienced by the jumper?'}],
  'text': 'The aim of this project is to develop a general solver for the\nvertical motion of a body with quadratic air drag, verify the solver,\napply the solver to a skydiver in free fall, and finally apply the\nsolver to a complete parachute jump.\n\nAll the pieces of software implemented in this project should be\nrealized as Python functions and/or classes and collected in one\nmodule.',
  'title': 'Simulate parachuting',
  'type': 'Project',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 16,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['falling_in_variable_density'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:drag:atm1',
  'no': 31,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Vertical motion of a body in the atmosphere needs to take into\naccount a varying air density if the range of altitudes is\nmany kilometers. In this case, $\\varrho$ varies with the altitude $z$.\nThe equation of motion for the body is given in\nSection ref{decay:app:drag}. Let us assume quadratic drag force\n(otherwise the body has to be very, very small).\nA differential equation problem for the air density, based on\nthe information for the one-layer atmospheric model in\nSection ref{decay:app:atm}, can be set up as\n\n!bt\n\\begin{align}\np^{\\prime}(z) &= -\\frac{Mg}{R^*(T_0+Lz)} p,\\\\ \n\\varrho &= p \\frac{M}{R^*T}\n\\tp\n\\end{align}\n\n!et\nTo evaluate $p(z)$ we need the altitude $z$. From the principle that the\nvelocity is the derivative of the position we have that\n\n!bt\n\\begin{equation}\nz^{\\prime}(t) = v(t),\n\\end{equation}\n\n!et\nwhere $v$ is the velocity of the body.\n\nExplain in detail how the governing equations can be discretized\nby the Forward Euler and the Crank-Nicolson methods.\nDiscuss pros and cons of the two methods.',
  'title': 'Formulate vertical motion in the atmosphere',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 17,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['falling_in_variable_density'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:drag:atm2',
  'no': 32,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Implement the Forward Euler or the Crank-Nicolson scheme\nderived in Exercise ref{decay:app:exer:drag:atm1}.\nDemonstrate the effect of air density variation on a falling\nhuman, e.g., the famous fall of "Felix Baumgartner": "http://en.wikipedia.org/wiki/Felix_Baumgartner". The drag coefficient can be set to 1.2.',
  'title': 'Simulate vertical motion in the atmosphere',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 18,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['signum'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:signum',
  'no': 33,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Consider the ODE problem\n!bt\n\\[\ny^{\\prime}(x) = \\left\\lbrace\\begin{array}{ll}\n-1, & x < 0,\\\\ \n1, & x \\geq 0\n\\end{array}\\right.\\quad x\\in (-1, 1],\n\\quad y(1-)=1,\n\\]\n\n!et\nwhich has the solution $y(x)=|x|$.\nUsing a mesh $x_0=-1$, $x_1=0$, and $x_2=1$, calculate by hand\n$y_1$ and $y_2$ from the Forward Euler, Backward Euler, Crank-Nicolson,\nand Leapfrog methods. Use all of the former three methods for computing\nthe $y_1$ value to be used in the Leapfrog calculation of $y_2$.\nThereafter, visualize how these schemes perform for a uniformly partitioned\nmesh with $N=10$ and $N=11$ points.',
  'title': 'Compute $y=|x|$ by solving an ODE',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 19,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['random_interest'],
  'heading': '=====',
  'hints': ['The following code snippet computes $p^{n+1}$:\n114 <<<!!CODE_BLOCK  pycod',
            'If $u_i(t)$ is the value of the fortune in experiment number $i$,\n$i=0,\\ldots,N-1$,\nthe mean evolution of the fortune is\n294 <<<!!MATH_BLOCK\nand the standard deviation is\n295 <<<!!MATH_BLOCK\nSuppose $u_i(t)$ is stored in an array `u`.\nThe mean and the standard deviation of the fortune\nis most efficiently computed by\nusing two accumulation arrays, `sum_u` and `sum_u2`, and\nperforming `sum_u += u` and `sum_u2 += u**2` after every experiment.\nThis technique avoids storing all the $u_i(t)$ time series for\ncomputing the statistics.'],
  'keywords': None,
  'label': 'decay:app:exer:interest',
  'no': 34,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The goal of this exercise is to compute the value of a fortune subject\nto inflation and a random interest rate.\nSuppose that the inflation is constant at $i$ percent per year and that the\nannual interest rate, $p$, changes randomly at each time step,\nstarting at some value $p_0$ at $t=0$.\nThe random change is from a value $p^n$ at $t=t_n$ to\n$p_n +\\Delta p$ with probability 0.25 and $p_n -\\Delta p$ with probability 0.25.\nNo change occurs with probability 0.5. There is also no change if\n$p^{n+1}$ exceeds 15 or becomes below 1.\nUse a time step of one month, $p_0=i$, initial fortune scaled to 1,\nand simulate 1000 scenarios of\nlength 20 years. Compute the mean evolution of one unit of money and the\ncorresponding\nstandard deviation. Plot the mean curve along with the mean plus one\nstandard deviation and the mean minus one standard deviation. This will\nillustrate the uncertainty in the mean curve.',
  'title': 'Simulate fortune growth with random interest rate',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 20,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['population.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:pop:at',
  'no': 35,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Assume that there is a sudden drop (increase) in the birth (death)\nrate at time $t=t_r$,\nbecause of limited nutrition or food supply:\n!bt\n\\[ r(t) =\\left\\lbrace\\begin{array}{ll}\n\\varrho, & t < t_r,\\\\ \n\\varrho - A, & t\\geq t_r,\\end{array}\\right.\n\\]\n\n!et\nThis drop in population growth is compensated by a sudden net immigration\nat time $t_f > t_r$:\n!bt\n\\[ f(t) =\\left\\lbrace\\begin{array}{ll}\n0, & t < t_f,\\\\ \nf_0, & t\\geq t_a,\\end{array}\\right.\n\\]\n\n!et\nStart with $\\varrho$ and make $A > \\varrho$. Experiment with\nthese and other parameters to\nillustrate the interplay of growth and decay in such a problem.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Now we assume that the environmental conditions changes periodically with\ntime so that we may take\n!bt\n\\[ r(t) = {\\varrho} + A\\sin\\left(\\frac{2\\pi}{P}t\\right)\n\\tp\n\\]\n\n!et\nThat is, the combined birth and death rate oscillates around $\\varrho$ with\na maximum change of $\\pm A$ repeating over a period of length $P$ in time.\nSet $f=0$ and experiment with the other parameters to illustrate typical\nfeatures of the solution.'}],
  'text': 'We shall study a population modeled by (ref{decay:app:pop:ueq}) where\nthe environment, represented by $r$ and $f$, undergoes changes with time.',
  'title': 'Simulate a population in a changing environment',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 21,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['logistic_CN'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:pop:logistic1',
  'no': 36,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Solve the logistic ODE\n(ref{decay:app:pop:logistic}) using a Crank-Nicolson scheme where\n$(u^{n+\\half})^2$ is approximated by a *geometric mean*:\n!bt\n\\[ (u^{n+\\half})^2 \\approx u^{n+1}u^n\n\\tp\n\\]\n\n!et\nThis trick makes the discrete equation linear in $u^{n+1}$.',
  'title': 'Simulate logistic growth',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 22,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['interest_modeling'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:interest:derive',
  'no': 37,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The ODE model (ref{decay:app:interest:eq2}) was derived under the assumption\nthat $r$ was constant. Perform an alternative derivation without\nthis assumption: 1) start with (ref{decay:app:interest:eq1});\n2) introduce a time step $\\Delta t$ instead of $m$: $\\Delta t = 1/m$ if\n$t$ is measured in years; 3) divide by $\\Delta t$ and take the\nlimit $\\Delta t\\rightarrow 0$. Simulate a case where the inflation is\nat a constant level $I$ percent per year and the interest rate oscillates:\n$r=-I/2 + r_0\\sin(2\\pi t)$.\nCompare solutions for $r_0=I, 3I/2, 2I$.',
  'title': 'Rederive the equation for continuous compound interest',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 23,
  'chapter_no': 5,
  'chapter_title': 'Models',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['KelvinVoigt'],
  'heading': '=====',
  'hints': ['To avoid finding proper values of the $E$ and $\\eta$ parameters for\na polymer, one can scale the problem. A common dimensionless\ntime is $\\bar t= tE/\\eta$. Note that $\\varepsilon$ is already\ndimensionless by definition, but it takes on small values, say up to 0.1,\nso we introduce a scaling: $\\bar u=10\\varepsilon$ such that $\\bar u$\ntakes on values up to about unity.\n\nShow that the material model then\ntakes the form $\\bar u^{\\prime} = -\\bar u + 10\\sigma(t)/E$.\nWork with the dimensionless force $F=10\\sigma(t)/E$, and let\n$F=1$ for $\\bar t\\in (0,\\bar t_1)$ and $F=0$ for $\\bar t\\geq \\bar t_1$.\nA possible choice of $t_1$ is the characteristic time $\\eta/E$, which\nmeans that $\\bar t_1 = 1$.'],
  'keywords': None,
  'label': 'decay:app:exer:viscoelasticity1',
  'no': 38,
  'solution': "Inserting the scaling $\\bar u=10\\varepsilon$ and $\\bar t = tE/\\eta$\nin the ODE for $\\varepsilon$ results in\n\n!bt\n\\[ \\frac{E}{10 \\eta}\\frac{d\\bar u}{d\\bar t} = -\\frac{E}{\\eta 10}\\bar u\n+ \\frac{\\sigma(t)}{\\eta}\\tp\\]\n\n!et\nThis reduces to\n\n!bt\n\\[ \\frac{d\\bar u}{d\\bar t} = -\\bar u + \\frac{10\\sigma}{E}\\tp\\]\n\n!et\n\nWe can use the module `decay_vc` for solving $u^{\\prime}=-a(t)u+b(t)$:\n\n!bc pycod\n# Scaled model: u' = -u + b(t), b=1 for t < 1 else 0\neps, t = solver(I=0, a=lambda t: 1,\n                b=lambda t: 1 if t < 1 else 0,\n                T=4, dt=0.01, theta=0.5)\n\nimport matplotlib.pyplot as plt\nplt.plot(t, eps)\nplt.xlabel('Dimensionless time'); plt.ylabel('10*strain')\nplt.savefig('tmp.png');  plt.savefig('tmp.pdf')\nplt.show()\n\n!ec\n\nFIGURE: [fig-models/KelvinVoigt, width=600 frac=0.8]",
  'solution_file': None,
  'subex': [],
  'text': "Stretching a rod made of polymer will cause deformations that are\nwell described with a Kelvin-Voigt material model\n(ref{decay:app:viscoelasticity:se}). At $t=0$ we apply a constant\nforce $\\sigma = \\sigma_0$, but at $t=t_1$, we remove the force\nso $\\sigma=0$. Compute numerically the corresponding strain\n(elongation divided by the rod's length) and visualize how it\nresponds in time.",
  'title': 'Simulate the deformation of a viscoelastic material',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 1,
  'chapter_no': 6,
  'chapter_title': 'Scientific software engineering',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['curvediff'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:derivative',
  'no': 39,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Write a function\n`differentiate(x, y)` for differentiating a curve\nwith coordinates in the arrays `x` and `y`, using the\nformulas above. The function should return the coordinate arrays\nof the resulting differentiated curve.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Since the formulas for differentiation used here are only approximate,\nwith unknown approximation errors, it is challenging to construct\ntest cases. Here are three approaches, which should be implemented\nin three separate test functions.\n\n o Consider a curve with three points and compute $d_i$, $i=0,1,2$,\n   by hand. Make a test that compares the hand-calculated results with those\n   from the function in a).\n o The formulas for $d_i$ are exact for points on\n   a straight line, as all the $d_i$ values are then the same, equal to\n   the slope of the line. A test can check this property.\n o For points lying on a parabola, the values for $d_i$, $i=1,\\ldots,n-1$,\n   should equal the exact derivative of the parabola. Make a test based on\n   this property.'},
            {'aftertext': '\n# Using a 2nd-order backward formula at x=1 does not improve the\n# results much, one gets large errors at the end points.\n\n',
             'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Start with a curve corresponding to $y=\\sin(\\pi x)$ and $n+1$\npoints in $[0,1]$. Apply `differentiate` four times and plot the\nresulting curve and the exact $y=\\sin\\pi x$ for $n=6, 11, 21, 41$.'}],
  'text': 'Suppose we have a curve specified through a set\nof discrete coordinates $(x_i,y_i)$, $i=0,\\ldots,n$, where the $x_i$\nvalues are uniformly distributed with spacing $\\Delta x$: $x_i=\\Delta x$.\nThe derivative of this curve, defined as a new curve with points\n$(x_i, d_i)$, can be computed via finite differences:\n\n!bt\n\\begin{align}\nd_0 &= \\frac{y_1-y_0}{\\Delta x},\\\\ \nd_i &= \\frac{y_{i+1}-y_{i-1}}{2\\Delta x},\\quad i=1,\\ldots,n-1,\\\\ \nd_n &= \\frac{y_n-y_{n-1}}{\\Delta x}\\tp\n\\end{align}\n\n!et',
  'title': 'Make a tool for differentiating curves',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 2,
  'chapter_no': 6,
  'chapter_title': 'Scientific software engineering',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['trapezoidal'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:integral:flat',
  'no': 40,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': "The ``flat'' implementation above suffers from serious flaws:\n\n o A general numerical algorithm (the Trapezoidal rule) is implemented\n   in a specialized form where the formula for $f$ is inserted directly\n   into the code for the general integration formula.\n o A general numerical algorithm is not encapsulated as a general\n   function, with appropriate parameters, which can be reused\n   across a wide range of applications.\n o The lazy programmer dropped the first terms in the general formula\n   since $\\sin(0)=\\sin(\\pi)=0$.\n o The sloppy programmer used `np` (number of points?) as variable for\n   `n` in the formula and a counter `k` instead of `i`. Such small\n   deviations from the mathematical notation are completely unnecessary.\n   The closer the code and the mathematics can get, the easier it is\n   to spot errors in formulas.\n\nWrite a function `trapezoidal` that fixes these flaws.\nPlace the function in a module `trapezoidal`."},
            {'answer': '',
             'file': None,
             'hints': ['Note that even if you know the value of the integral, you do not know\nthe error in the approximation produced by the Trapezoidal rule.\nHowever, the Trapezoidal rule will integrate linear functions\nexactly (i.e., to machine precision). Base a test function\non a linear $f(x)$.'],
             'solution': '',
             'text': 'Write a test function `test_trapezoidal`. Call the test function\nexplicitly to check that it works. Remove the call and run pytest\non the module:\n\n!bc sys\nTerminal> py.test -s -v trapezoidal\n\n!ec'},
            {'answer': '',
             'file': None,
             'hints': ['To translate a string formula on the command line, like `sin(x)**2`,\ninto a Python function, you can wrap a function declaration around\nthe formula and run `exec` on the string to turn it into live Python code:\n\n!bc pycod\nimport math, sys\nformula = sys.argv[1]\nf_code = """\ndef f(x):\n    return %s\n""" % formula\nexec(code, math.__dict__)\n\n!ec\nThe result is the same as if we had hardcoded\n\n!bc pycod\nfrom math import *\n\ndef f(x):\n    return sin(x)**2\n\n!ec\nin the program. Note that `exec` needs the namespace\n`math.__dict__`, i.e., all names in the `math` module, such that\nit understands `sin` and other mathematical functions.\nSimilarly, to allow $a$ and $b$ to be `math` expressions like `pi/4`\nand `exp(4)`, do\n\n!bc sys\na = eval(sys.argv[2], math.__dict__)\nb = eval(sys.argv[2], math.__dict__)\n\n!ec'],
             'solution': '',
             'text': "Add functionality such that we can compute $\\int_a^b f(x)dx$ by providing\n$f$, $a$, $b$, and $n$ as positional command-line arguments to the\nmodule file:\n\n!bc sys\nTerminal> python trapezoidal.py 'sin(x)**2' 0 pi 20\n\n!ec\nHere, $a=0$, $b=\\pi$, and $n=20$.\n\nNote that the `trapezoidal.py` file must still be a valid module file, so the\ninterpretation of command-line data and computation of the integral\nmust be performed from calls in a test block."},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Write a test function for verifying the implementation of\ndata reading from the command line.'}],
  'text': 'An integral\n\n!bt\n\\[ \\int_a^b f(x)dx \\]\n\n!et\ncan be numerically approximated by the Trapezoidal rule,\n\n!bt\n\\[ \\int_a^b f(x)dx \\approx \\frac{h}{2}(f(a) + f(b)) + h\\sum_{i=1}^{n-1} f(x_i),\n\\]\n\n!et\nwhere $x_i$ is a set of uniformly spaced points in $[a,b]$:\n\n!bt\n\\[ h = \\frac{b-a}{n},\\quad x_i=a + ih,\\ i=1,\\ldots,n-1\\tp \\]\n\n!et\n\nSomebody has used this rule to compute the integral $\\int_0^\\pi \\sin^2x\\, dx$:\n\n!bc pypro\nfrom math import pi, sin\nnp = 20\nh = pi/np\nI = 0\nfor k in range(1, np):\n    I += sin(k*h)**2\nprint I\n\n!ec',
  'title': 'Make solid software for the Trapezoidal rule',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 3,
  'chapter_no': 6,
  'chapter_title': 'Scientific software engineering',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['trapezoidal_class'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:integral:flat2',
  'no': 41,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'We consider the same problem setting as in Problem\nref{softeng1:exer:integral:flat}. Make a module with a class `Problem`\nrepresenting the mathematical problem to be solved and a class\n`Solver` representing the solution method.  The rest of the\nfunctionality of the module, including test functions and reading data\nfrom the command line, should be as in Problem\nref{softeng1:exer:integral:flat}.',
  'title': 'Implement classes for the Trapezoidal rule',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 4,
  'chapter_no': 6,
  'chapter_title': 'Scientific software engineering',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['test_roots'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:doctest1',
  'no': 42,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Equip the `roots` function with a doctest.\nMake sure to test both real and complex roots.\nWrite out numbers in the doctest with 14 digits or less.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Make a test function for the `roots` function. Perform the\nsame mathematical tests as in a), but with different\nprogramming technology.'}],
  'text': 'Type in the following program:\n\n!bc pypro\nimport sys\n# This sqrt(x) returns real if x>0 and complex if x<0\nfrom numpy.lib.scimath import sqrt\n\ndef roots(a, b, c):\n    """\n    Return the roots of the quadratic polynomial\n    p(x) = a*x**2 + b*x + c.\n\n    The roots are real or complex objects.\n    """\n    q = b**2 - 4*a*c\n    r1 = (-b + sqrt(q))/(2*a)\n    r2 = (-b - sqrt(q))/(2*a)\n    return r1, r2\n\na, b, c = [float(arg) for arg in sys.argv[1:]]\nprint roots(a, b, c)\n\n!ec',
  'title': 'Write a doctest and a test function',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 5,
  'chapter_no': 6,
  'chapter_title': 'Scientific software engineering',
  'chapter_type': 'Chapter',
  'closing_remarks': 'You will experience that if `a` and `b` are large, as they can be\nin geophysical applications where lengths measured in meters can be of size\n$10^6$ m, `tol` must be about $10^{-9}$, while `a` and `b` around unity can\nhave `tol` of size $10^{-15}$.',
  'file': ['tolerance'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:tol',
  'no': 43,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'When we replace a comparison `a == b`, where `a` and/or `b` are\n`float` objects, by a comparison with tolerance, `abs(a-b) < tol`,\nthe appropriate size of `tol` depends on the size of `a` and `b`.\nInvestigate how the size of `abs(a-b)` varies when `b` takes on\nvalues $10^k$, $k=-5,-9,\\ldots,20$ and `a=1.0/49*b*49`.',
  'title': 'Experiment with tolerances in comparisons',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 6,
  'chapter_no': 6,
  'chapter_title': 'Scientific software engineering',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['experiment_compare_dt_class'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:class:dts',
  'no': 44,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Implement the `experiment_compare_dt` function from `decay.py`\nusing class `Problem` and class `Solver` from\nSection ref{softeng1:prog:se:class}.\nThe parameters `I`, `a`, `T`, the scheme name, and a series of\n`dt` values should be read from the command line.',
  'title': 'Make use of a class implementation',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 7,
  'chapter_no': 6,
  'chapter_title': 'Scientific software engineering',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': ['logistic'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:logistic',
  'no': 45,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'We have the following evolutionary difference equation for the number\nof individuals $u^n$ of a certain specie at time $n\\Delta t$:\n\n!bt\n\\begin{equation}\nu^{n+1} = u^n + \\Delta t\\, r u^n\\left(1 - \\frac{u^n}{M^n}\\right),\n\\quad u^0=U_0\\tp\n\\label{softeng1:exer:logistic:eq}\n\\end{equation}\n\n!et\nHere, $n$ is a counter in time, $\\Delta t$ is time between time levels\n$n$ and $n+1$ (assumed constant), $r$ is a net reproduction rate\nfor the specie,\nand $M^n$ is the upper limit of the population that the environment can\nsustain at time level $n$.',
  'title': 'Make solid software for a difference equation',
  'type': 'Problem',
  'type_visible': True}]