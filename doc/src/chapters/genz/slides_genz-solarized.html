<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study guide: Generalizations of exponential decay models">
<meta name="keywords" content="lambda functions,method of manufactured solutions,MMS (method of manufactured solutions),implicit schemes,explicit schemes,theta-rule,$\theta$-rule,backward scheme, 2-step,BDF2 scheme,Leapfrog scheme,Leapfrog scheme, filtered,Heun's method,Runge-Kutta, 2nd-order scheme,Adams-Bashforth scheme, 2nd order,Adams-Bashforth scheme, 3rd order">

<title>Study guide: Generalizations of exponential decay models</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Model extensions',
               1,
               'decay:generalizations',
               'decay:generalizations'),
              ('Extension to a variable coefficient; Forward and Backward Euler',
               2,
               None,
               '___sec1'),
              ('Extension to a variable coefficient; Crank-Nicolson',
               2,
               None,
               '___sec2'),
              ('Extension to a variable coefficient; $\\theta$-rule',
               2,
               None,
               '___sec3'),
              ('Extension to a variable coefficient; operator notation',
               2,
               None,
               '___sec4'),
              ('Extension to a source term',
               2,
               'decay:source',
               'decay:source'),
              ('Implementation of the generalized model problem',
               2,
               'decay:general',
               'decay:general'),
              ('Implementations of variable coefficients; functions',
               2,
               None,
               '___sec7'),
              ('Implementations of variable coefficients; classes',
               2,
               None,
               '___sec8'),
              ('Implementations of variable coefficients; lambda function',
               2,
               None,
               '___sec9'),
              ('Verification via trivial solutions',
               2,
               'decay:verify:trivial',
               'decay:verify:trivial'),
              ('Verification via trivial solutions; test function',
               2,
               None,
               '___sec11'),
              ('Verification via manufactured solutions',
               2,
               'decay:MMS',
               'decay:MMS'),
              ('Linear manufactured solution', 2, None, '___sec13'),
              ('Test function for linear manufactured solution',
               2,
               None,
               '___sec14'),
              ('Computing convergence rates',
               1,
               'decay:convrates',
               'decay:convrates'),
              ('Estimating the convergence rate $r$', 2, None, '___sec16'),
              ('Brief implementation', 2, None, '___sec17'),
              ('We embed the code in a real test function',
               2,
               None,
               '___sec18'),
              ('The manufactured solution can be computed by sympy',
               2,
               None,
               '___sec19'),
              ('Execution', 2, None, '___sec20'),
              ('Debugging via convergence rates', 2, None, '___sec21'),
              ('Extension to systems of ODEs', 2, None, '___sec22'),
              ('The Backward Euler method gives a system of algebraic equations',
               2,
               None,
               '___sec23'),
              ('Methods for general first-order ODEs',
               1,
               'decay:1stODEs',
               'decay:1stODEs'),
              ('Generic form', 2, None, '___sec25'),
              ('The $\\theta$-rule', 2, None, '___sec26'),
              ('Implicit 2-step backward scheme', 2, None, '___sec27'),
              ('The Leapfrog scheme', 2, None, '___sec28'),
              ('The filtered Leapfrog scheme', 2, None, '___sec29'),
              ('2nd-order Runge-Kutta scheme', 2, None, '___sec30'),
              ('4th-order Runge-Kutta scheme',
               2,
               'decay:fd2:RK4',
               'decay:fd2:RK4'),
              ('2nd-order Adams-Bashforth scheme', 2, None, '___sec32'),
              ('3rd-order Adams-Bashforth scheme', 2, None, '___sec33'),
              ('The Odespy software', 2, None, '___sec34'),
              ('Example: Runge-Kutta methods', 2, None, '___sec35'),
              ('Plots from the experiments', 2, None, '___sec36'),
              ('Example: Adaptive Runge-Kutta methods', 2, None, '___sec37')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
$$




    
<!-- ------------------- main content ---------------------- -->



<center><h1>Study guide: Generalizations of exponential decay models</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>

<p>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>
<br>
<p>
<center><h4>Oct 10, 2015</h4></center> <!-- date -->
<br>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Table of contents</h2>

<p>
<a href="#decay:generalizations"> Model extensions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec1"> Extension to a variable coefficient; Forward and Backward Euler </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec2"> Extension to a variable coefficient; Crank-Nicolson </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec3"> Extension to a variable coefficient; \( \theta \)-rule </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec4"> Extension to a variable coefficient; operator notation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:source"> Extension to a source term </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:general"> Implementation of the generalized model problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec7"> Implementations of variable coefficients; functions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec8"> Implementations of variable coefficients; classes </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec9"> Implementations of variable coefficients; lambda function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:verify:trivial"> Verification via trivial solutions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec11"> Verification via trivial solutions; test function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:MMS"> Verification via manufactured solutions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec13"> Linear manufactured solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec14"> Test function for linear manufactured solution </a><br>
<a href="#decay:convrates"> Computing convergence rates </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec16"> Estimating the convergence rate \( r \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec17"> Brief implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec18"> We embed the code in a real test function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec19"> The manufactured solution can be computed by sympy </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec20"> Execution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec21"> Debugging via convergence rates </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec22"> Extension to systems of ODEs </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec23"> The Backward Euler method gives a system of algebraic equations </a><br>
<a href="#decay:1stODEs"> Methods for general first-order ODEs </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec25"> Generic form </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec26"> The \( \theta \)-rule </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec27"> Implicit 2-step backward scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec28"> The Leapfrog scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec29"> The filtered Leapfrog scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec30"> 2nd-order Runge-Kutta scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:fd2:RK4"> 4th-order Runge-Kutta scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec32"> 2nd-order Adams-Bashforth scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec33"> 3rd-order Adams-Bashforth scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec34"> The Odespy software </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec35"> Example: Runge-Kutta methods  </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec36"> Plots from the experiments </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec37"> Example: Adaptive Runge-Kutta methods  </a><br>
</p>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="decay:generalizations">Model extensions</h1>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec1">Extension to a variable coefficient; Forward and Backward Euler </h2>

$$
\begin{equation}
u'(t) = -a(t)u(t),\quad t\in (0,T],\quad u(0)=I
\label{decay:problem:a}
\end{equation}
$$

<p>
The Forward Euler scheme:

$$
\begin{equation}
\frac{u^{n+1} - u^n}{\Delta t} = -a(t_n)u^n
\label{_auto1}
\end{equation}
$$

<p>
The Backward Euler scheme:
$$
\begin{equation}
\frac{u^{n} - u^{n-1}}{\Delta t} = -a(t_n)u^n
\label{_auto2}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec2">Extension to a variable coefficient; Crank-Nicolson </h2>

<p>
Eevaluting \( a(t_{n+\half}) \) and
using an average for \( u \):
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -a(t_{n+\half})\half(u^n + u^{n+1})
\label{_auto3}
\end{equation}
$$

<p>
Using an average for \( a \) and \( u \):
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -\half(a(t_n)u^n + a(t_{n+1})u^{n+1})
\label{_auto4}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec3">Extension to a variable coefficient; \( \theta \)-rule </h2>

<p>
The \( \theta \)-rule unifies the three mentioned schemes,

$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -a((1-\theta)t_n + \theta t_{n+1})((1-\theta) u^n + \theta u^{n+1})
\label{_auto5}
\end{equation}
$$

or,
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -(1-\theta) a(t_n)u^n - \theta
a(t_{n+1})u^{n+1}
\label{_auto6}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec4">Extension to a variable coefficient; operator notation </h2>

$$
\begin{align*}
\lbrack D^+_t u &= -au\rbrack^n,\\ 
\lbrack D^-_t u &= -au\rbrack^n,\\ 
\lbrack D_t u &= -a\overline{u}^t\rbrack^{n+\half},\\ 
\lbrack D_t u &= -\overline{au}^t\rbrack^{n+\half}\\ 
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="decay:source">Extension to a source term</h2>

$$
\begin{equation}
u'(t) = -a(t)u(t) + b(t),\quad t\in (0,T],\quad u(0)=I
\label{decay:problem:ab}
\end{equation}
$$


$$
\begin{align*}
\lbrack D^+_t u &= -au + b\rbrack^n,\\ 
\lbrack D^-_t u &= -au + b\rbrack^n,\\ 
\lbrack D_t u   &= -a\overline{u}^t + b\rbrack^{n+\half},\\ 
\lbrack D_t u   &= \overline{-au+b}^t\rbrack^{n+\half}
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="decay:general">Implementation of the generalized model problem</h2>

$$
\begin{equation}
u^{n+1} = ((1 - \Delta t(1-\theta)a^n)u^n
+ \Delta t(\theta b^{n+1} + (1-\theta)b^n))(1 + \Delta t\theta a^{n+1})^{-1}
\label{_auto7}
\end{equation}
$$

<p>
Implementation where \( a(t) \) and \( b(t) \) are given as
Python functions (see file <a href="http://tinyurl.com/ofkw6kc/genz/decay_vc.py" target="_self"><tt>decay_vc.py</tt></a>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, a, b, T, dt, theta):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Solve u&#39;=-a(t)*u + b(t), u(0)=I,</span>
<span style="color: #CD5555">    for t in (0,T] with steps of dt.</span>
<span style="color: #CD5555">    a and b are Python functions of t.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    dt = <span style="color: #658b00">float</span>(dt)            <span style="color: #228B22"># avoid integer division</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))     <span style="color: #228B22"># no of time intervals</span>
    T = Nt*dt                 <span style="color: #228B22"># adjust T to fit time step dt</span>
    u = zeros(Nt+<span style="color: #B452CD">1</span>)           <span style="color: #228B22"># array of u[n] values</span>
    t = linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># time mesh</span>

    u[<span style="color: #B452CD">0</span>] = I                  <span style="color: #228B22"># assign initial condition</span>
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):    <span style="color: #228B22"># n=0,1,...,Nt-1</span>
        u[n+<span style="color: #B452CD">1</span>] = ((<span style="color: #B452CD">1</span> - dt*(<span style="color: #B452CD">1</span>-theta)*a(t[n]))*u[n] + \ 
                  dt*(theta*b(t[n+<span style="color: #B452CD">1</span>]) + (<span style="color: #B452CD">1</span>-theta)*b(t[n])))/\ 
                  (<span style="color: #B452CD">1</span> + dt*theta*a(t[n+<span style="color: #B452CD">1</span>]))
    <span style="color: #8B008B; font-weight: bold">return</span> u, t
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec7">Implementations of variable coefficients; functions </h2>

<p>
Plain functions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">a</span>(t):
    <span style="color: #8B008B; font-weight: bold">return</span> a_0 <span style="color: #8B008B; font-weight: bold">if</span> t &lt; tp <span style="color: #8B008B; font-weight: bold">else</span> k*a_0

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">b</span>(t):
    <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">1</span>
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec8">Implementations of variable coefficients; classes </h2>

<p>
Better implementation: class with the parameters <code>a0</code>, <code>tp</code>, and <code>k</code>
as attributes and a <em>special method</em> <code>__call__</code> for evaluating \( a(t) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">A</span>:
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__init__</span>(<span style="color: #658b00">self</span>, a0=<span style="color: #B452CD">1</span>, k=<span style="color: #B452CD">2</span>):
        <span style="color: #658b00">self</span>.a0, <span style="color: #658b00">self</span>.k = a0, k

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__call__</span>(<span style="color: #658b00">self</span>, t):
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #658b00">self</span>.a0 <span style="color: #8B008B; font-weight: bold">if</span> t &lt; <span style="color: #658b00">self</span>.tp <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #658b00">self</span>.k*<span style="color: #658b00">self</span>.a0

a = A(a0=<span style="color: #B452CD">2</span>, k=<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># a behaves as a function a(t)</span>
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec9">Implementations of variable coefficients; lambda function </h2>

<p>
Quick writing: a one-liner <em>lambda function</em>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">a = <span style="color: #8B008B; font-weight: bold">lambda</span> t: a_0 <span style="color: #8B008B; font-weight: bold">if</span> t &lt; tp <span style="color: #8B008B; font-weight: bold">else</span> k*a_0
</pre></div>
</td></tr></table><p>
In general,
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">f = <span style="color: #8B008B; font-weight: bold">lambda</span> arg1, arg2, ...: expressin
</pre></div>
</td></tr></table><p>
is equivalent to
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">f</span>(arg1, arg2, ...):
    <span style="color: #8B008B; font-weight: bold">return</span> expression
</pre></div>
</td></tr></table><p>
One can use lambda functions directly in calls:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u, t = solver(<span style="color: #B452CD">1</span>, <span style="color: #8B008B; font-weight: bold">lambda</span> t: <span style="color: #B452CD">1</span>, <span style="color: #8B008B; font-weight: bold">lambda</span> t: <span style="color: #B452CD">1</span>, T, dt, theta)
</pre></div>
</td></tr></table><p>
for a problem \( u'=-u+1 \), \( u(0)=1 \).

<p>
A lambda function can appear anywhere where a variable can appear.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="decay:verify:trivial">Verification via trivial solutions</h2>

<ul>
 <p><li> Start debugging of a new code with trying a problem
   where \( u=\hbox{const} \neq 0 \).</li>
 <p><li> Choose \( u=C \) (a constant). Choose any \( a(t) \) and set
   \( b=a(t)C \) and
   \( I=C \).</li>
 <p><li> "All" numerical methods will reproduce \( u=_{\hbox{const}} \)
   exactly (machine precision).</li>
 <p><li> Often \( u=C \) eases debugging.</li>
 <p><li> In this example: <em>any error</em> in the formula for \( u^{n+1} \)
   make \( u\neq C \)!</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec11">Verification via trivial solutions; test function </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_constant_solution</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Test problem where u=u_const is the exact solution, to be</span>
<span style="color: #CD5555">    reproduced (to machine precision) by any relevant method.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">u_exact</span>(t):
        <span style="color: #8B008B; font-weight: bold">return</span> u_const

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">a</span>(t):
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">2.5</span>*(<span style="color: #B452CD">1</span>+t**<span style="color: #B452CD">3</span>)  <span style="color: #228B22"># can be arbitrary</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">b</span>(t):
        <span style="color: #8B008B; font-weight: bold">return</span> a(t)*u_const

    u_const = <span style="color: #B452CD">2.15</span>
    theta = <span style="color: #B452CD">0.4</span>; I = u_const; dt = <span style="color: #B452CD">4</span>
    Nt = <span style="color: #B452CD">4</span>  <span style="color: #228B22"># enough with a few steps</span>
    u, t = solver(I=I, a=a, b=b, T=Nt*dt, dt=dt, theta=theta)
    <span style="color: #8B008B; font-weight: bold">print</span> u
    u_e = u_exact(t)
    difference = <span style="color: #658b00">abs</span>(u_e - u).max()  <span style="color: #228B22"># max deviation</span>
    tol = <span style="color: #B452CD">1E-14</span>
    <span style="color: #8B008B; font-weight: bold">assert</span> difference &lt; tol
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="decay:MMS">Verification via manufactured solutions</h2>

<ul>
 <p><li> Choose <em>any</em> formula for \( u(t) \)</li>
 <p><li> Fit \( I \), \( a(t) \), and \( b(t) \) in \( u'=-au+b \), \( u(0)=I \),
   to make the chosen formula a solution of the ODE problem</li>
 <p><li> Then we can always have an analytical solution (!)</li>
 <p><li> Ideal for verification: testing convergence rates</li>
 <p><li> Called the <em>method of manufactured solutions</em> (MMS)</li>
 <p><li> Special case: \( u \) linear in \( t \), because all sound numerical
   methods will reproduce a linear \( u \) exactly (machine precision)</li>
 <p><li> \( u(t) = ct + d \). \( u(0)=0 \) means \( d=I \)</li>
 <p><li> ODE implies \( c = -a(t)u + b(t) \)</li>
 <p><li> Choose \( a(t) \) and \( c \), and set \( b(t) = c + a(t)(ct + I) \)</li>
 <p><li> Any error in the formula for \( u^{n+1} \) makes \( u\neq ct+I \)!</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec13">Linear manufactured solution </h2>

<p>
\( u^n = ct_n+I \) fulfills the discrete
equations!

<p>
First,
$$
\begin{align}
\lbrack D_t^+ t\rbrack^n &= \frac{t_{n+1}-t_n}{\Delta t}=1,
\label{decay:fd2:Dop:tn:fw}\\ 
\lbrack D_t^- t\rbrack^n &= \frac{t_{n}-t_{n-1}}{\Delta t}=1,
\label{decay:fd2:Dop:tn:bw}\\ 
\lbrack D_t t\rbrack^n &= \frac{t_{n+\half}-t_{n-\half}}{\Delta t}=\frac{(n+\half)\Delta t - (n-\half)\Delta t}{\Delta t}=1\label{decay:fd2:Dop:tn:cn}
\end{align}
$$

<p>
Forward Euler:

$$ [D^+ u = -au + b]^n $$

<p>
\( a^n=a(t_n) \), \( b^n=c + a(t_n)(ct_n + I) \), and \( u^n=ct_n + I \)
results in

$$ c = -a(t_n)(ct_n+I) + c + a(t_n)(ct_n + I) = c $$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec14">Test function for linear manufactured solution </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_linear_solution</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Test problem where u=c*t+I is the exact solution, to be</span>
<span style="color: #CD5555">    reproduced (to machine precision) by any relevant method.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">u_exact</span>(t):
        <span style="color: #8B008B; font-weight: bold">return</span> c*t + I

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">a</span>(t):
        <span style="color: #8B008B; font-weight: bold">return</span> t**<span style="color: #B452CD">0.5</span>  <span style="color: #228B22"># can be arbitrary</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">b</span>(t):
        <span style="color: #8B008B; font-weight: bold">return</span> c + a(t)*u_exact(t)

    theta = <span style="color: #B452CD">0.4</span>; I = <span style="color: #B452CD">0.1</span>; dt = <span style="color: #B452CD">0.1</span>; c = -<span style="color: #B452CD">0.5</span>
    T = <span style="color: #B452CD">4</span>
    Nt = <span style="color: #658b00">int</span>(T/dt)  <span style="color: #228B22"># no of steps</span>
    u, t = solver(I=I, a=a, b=b, T=Nt*dt, dt=dt, theta=theta)
    u_e = u_exact(t)
    difference = <span style="color: #658b00">abs</span>(u_e - u).max()  <span style="color: #228B22"># max deviation</span>
    <span style="color: #8B008B; font-weight: bold">print</span> difference
    tol = <span style="color: #B452CD">1E-14</span>  <span style="color: #228B22"># depends on c!</span>
    <span style="color: #8B008B; font-weight: bold">assert</span> difference &lt; tol
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="decay:convrates">Computing convergence rates</h1>

<p>
Frequent assumption on the relation between the numerical error \( E \) and
some discretization parameter \( \Delta t \):

$$
\begin{equation}
E = C\Delta t^r,
\label{decay:E:dt}
\end{equation}
$$


<ul>
 <p><li> Unknown: \( C \) and \( r \).</li>
 <p><li> Goal: estimate \( r \) (and \( C \)) from numerical experiments</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec16">Estimating the convergence rate \( r \) </h2>

<p>
Perform numerical experiments: \( (\Delta t_i, E_i) \), \( i=0,\ldots,m-1 \).
Two methods for finding \( r \) (and \( C \)):

<ol>
 <p><li> Take the logarithm of \eqref{decay:E:dt}, \( \ln E = r\ln \Delta t + \ln C \),
    and fit a straight line to the data points \( (\Delta t_i, E_i) \),
    \( i=0,\ldots,m-1 \).</li>
 <p><li> Consider two consecutive experiments, \( (\Delta t_i, E_i) \) and
    \( (\Delta t_{i-1}, E_{i-1}) \). Dividing the equation
    \( E_{i-1}=C\Delta t_{i-1}^r \) by \( E_{i}=C\Delta t_{i}^r \) and solving
    for \( r \) yields</li>
</ol>

$$
\begin{equation}
r_{i-1} = \frac{\ln (E_{i-1}/E_i)}{\ln (\Delta t_{i-1}/\Delta t_i)}
\label{decay:conv:rate}
\end{equation}
$$

for \( i=1,=\ldots,m-1 \).

<p>
Method 2 is best.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec17">Brief implementation </h2>

<p>
Compute \( r_0, r_1, \ldots, r_{m-2} \) from \( E_i \) and \( \Delta t_i \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">compute_rates</span>(dt_values, E_values):
    m = <span style="color: #658b00">len</span>(dt_values)
    r = [log(E_values[i-<span style="color: #B452CD">1</span>]/E_values[i])/
         log(dt_values[i-<span style="color: #B452CD">1</span>]/dt_values[i])
         <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, m, <span style="color: #B452CD">1</span>)]
    <span style="color: #228B22"># Round to two decimals</span>
    r = [<span style="color: #658b00">round</span>(r_, <span style="color: #B452CD">2</span>) <span style="color: #8B008B; font-weight: bold">for</span> r_ <span style="color: #8B008B">in</span> r]
    <span style="color: #8B008B; font-weight: bold">return</span> r
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec18">We embed the code in a real test function </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_convergence_rates</span>():
    <span style="color: #228B22"># Create a manufactured solution</span>
    <span style="color: #228B22"># define u_exact(t), a(t), b(t)</span>

    dt_values = [<span style="color: #B452CD">0.1</span>*<span style="color: #B452CD">2</span>**(-i) <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">7</span>)]
    I = u_exact(<span style="color: #B452CD">0</span>)

    <span style="color: #8B008B; font-weight: bold">for</span> theta <span style="color: #8B008B">in</span> (<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">0.5</span>):
        E_values = []
        <span style="color: #8B008B; font-weight: bold">for</span> dt <span style="color: #8B008B">in</span> dt_values:
            u, t = solver(I=I, a=a, b=b, T=<span style="color: #B452CD">6</span>, dt=dt, theta=theta)
            u_e = u_exact(t)
            e = u_e - u
            E = sqrt(dt*<span style="color: #658b00">sum</span>(e**<span style="color: #B452CD">2</span>))
            E_values.append(E)
        r = compute_rates(dt_values, E_values)
        <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;theta=%g, r: %s&#39;</span> % (theta, r)
        expected_rate = <span style="color: #B452CD">2</span> <span style="color: #8B008B; font-weight: bold">if</span> theta == <span style="color: #B452CD">0.5</span> <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #B452CD">1</span>
        tol = <span style="color: #B452CD">0.1</span>
        diff = <span style="color: #658b00">abs</span>(expected_rate - r[-<span style="color: #B452CD">1</span>])
        <span style="color: #8B008B; font-weight: bold">assert</span> diff &lt; tol
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec19">The manufactured solution can be computed by sympy </h2>

<p>
We choose \( \uex(t) = \sin(t)e^{-2t} \), \( a(t)=t^2 \), fit \( b(t)=u'(t)-a(t) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #228B22"># Create a manufactured solution with sympy</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sym</span>
t = sym.symbols(<span style="color: #CD5555">&#39;t&#39;</span>)
u_exact = sym.sin(t)*sym.exp(-<span style="color: #B452CD">2</span>*t)
a = t**<span style="color: #B452CD">2</span>
b = sym.diff(u_exact, t) + a*u_exact

<span style="color: #228B22"># Turn sympy expressions into Python function</span>
u_exact = sym.lambdify([t], u_exact, modules=<span style="color: #CD5555">&#39;numpy&#39;</span>)
a = sym.lambdify([t], a, modules=<span style="color: #CD5555">&#39;numpy&#39;</span>)
b = sym.lambdify([t], b, modules=<span style="color: #CD5555">&#39;numpy&#39;</span>)
</pre></div>
</td></tr></table><p>
Complete code: <a href="http://tinyurl.com/ofkw6kc/genz/decay_vc.py" target="_self"><tt>decay_vc.py</tt></a>.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec20">Execution </h2>

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay_vc.py
...
theta=0, r: [1.06, 1.03, 1.01, 1.01, 1.0, 1.0]
theta=1, r: [0.94, 0.97, 0.99, 0.99, 1.0, 1.0]
theta=0.5, r: [2.0, 2.0, 2.0, 2.0, 2.0, 2.0]
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec21">Debugging via convergence rates </h2>

<p>
Potential bug: missing <code>a</code> in the denominator,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u[n+<span style="color: #B452CD">1</span>] = (<span style="color: #B452CD">1</span> - (<span style="color: #B452CD">1</span>-theta)*a*dt)/(<span style="color: #B452CD">1</span> + theta*dt)*u[n]
</pre></div>
</td></tr></table><p>
Running <code>decay_convrate.py</code> gives same rates.

<p>
Why? The value of \( a \)... (\( a=1 \))

<p>
0 and 1 are <em>bad values</em> in tests!

<p>
Better:
<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay_convrate.py --a 2.1 --I 0.1  \ 
          --dt 0.5 0.25 0.1 0.05 0.025 0.01
...
Pairwise convergence rates for theta=0:
1.49 1.18 1.07 1.04 1.02

Pairwise convergence rates for theta=0.5:
-1.42 -0.22 -0.07 -0.03 -0.01

Pairwise convergence rates for theta=1:
0.21 0.12 0.06 0.03 0.01
</pre></div>
</td></tr></table><p>
Forward Euler works...because \( \theta=0 \) hides the bug.

<p>
This bug gives \( r\approx 0 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u[n+<span style="color: #B452CD">1</span>] = ((<span style="color: #B452CD">1</span>-theta)*a*dt)/(<span style="color: #B452CD">1</span> + theta*dt*a)*u[n]
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec22">Extension to systems of ODEs </h2>

<p>
Sample system:

$$
\begin{align}
u' &= a u + bv
\label{_auto8}\\ 
v' &= cu +  dv
\label{_auto9}
\end{align}
$$

<p>
The Forward Euler method:

$$
\begin{align}
u^{n+1} &= u^n + \Delta t (a u^n + b v^n)
\label{_auto10}\\ 
v^{n+1} &= u^n + \Delta t (cu^n + dv^n)
\label{_auto11}
\end{align}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec23">The Backward Euler method gives a system of algebraic equations </h2>

<p>
The Backward Euler scheme:

$$
\begin{align}
u^{n+1} &= u^n + \Delta t (a u^{n+1} + b v^{n+1})
\label{_auto12}\\ 
v^{n+1} &= v^n + \Delta t (c u^{n+1} + d v^{n+1})
\label{_auto13}
\end{align}
$$

which is a \( 2\times 2 \) linear system:

$$
\begin{align}
(1 - \Delta t a)u^{n+1} + bv^{n+1} &= u^n 
\label{_auto14}\\ 
c u^{n+1} + (1 - \Delta t d) v^{n+1} &= v^n
\label{_auto15}
\end{align}
$$

<p>
Crank-Nicolson also gives a \( 2\times 2 \) linear system.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="decay:1stODEs">Methods for general first-order ODEs</h1>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec25">Generic form </h2>

<p>
The standard form for ODEs:
$$
\begin{equation}
u' = f(u,t),\quad u(0)=I
\label{decay:ode:general}
\end{equation}
$$

<p>
\( u \) and \( f \): scalar or vector.

<p>
Vectors in case of ODE systems:
$$ u(t) = (u^{(0)}(t),u^{(1)}(t),\ldots,u^{(m-1)}(t))   $$


$$
\begin{align*}
f(u, t) = ( & f^{(0)}(u^{(0)},\ldots,u^{(m-1)})\\ 
            & f^{(1)}(u^{(0)},\ldots,u^{(m-1)}),\\ 
            & \vdots\\ 
            & f^{(m-1)}(u^{(0)}(t),\ldots,u^{(m-1)}(t)))
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec26">The \( \theta \)-rule </h2>

$$
\begin{equation}
\frac{u^{n+1}-u^n}{\Delta t} = \theta f(u^{n+1},t_{n+1}) +
(1-\theta)f(u^n, t_n)
\label{decay:fd2:theta}
\end{equation}
$$

Bringing the unknown \( u^{n+1} \) to the left-hand side and the known terms
on the right-hand side gives

$$
\begin{equation}
u^{n+1} - \Delta t \theta f(u^{n+1},t_{n+1}) =
u^n + \Delta t(1-\theta)f(u^n, t_n)
\label{_auto16}
\end{equation}
$$

This is a <em>nonlinear</em> equation in \( u^{n+1} \) (unless \( f \) is linear in \( u \))!

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec27">Implicit 2-step backward scheme </h2>

$$ u'(t_{n+1}) \approx \frac{3u^{n+1} - 4u^{n} + u^{n-1}}{2\Delta t}$$

<p>
Scheme:
$$ u^{n+1} = \frac{4}{3}u^n - \frac{1}{3}u^{n-1} +
\frac{2}{3}\Delta t f(u^{n+1}, t_{n+1})
\label{decay:fd2:bw:2step}
$$

Nonlinear equation for \( u^{n+1} \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec28">The Leapfrog scheme </h2>

<p>
Idea:
$$
\begin{equation}
u'(t_n)\approx \frac{u^{n+1}-u^{n-1}}{2\Delta t} = [D_{2t} u]^n
\label{_auto17}
\end{equation}
$$

<p>
Scheme:

$$ [D_{2t} u = f(u,t)]^n$$

or written out,
$$
\begin{equation}
u^{n+1} = u^{n-1} + \Delta t f(u^n, t_n)
\label{decay:fd2:leapfrog}
\end{equation}
$$


<ul>
 <p><li> Some other scheme must be used as starter (\( u^1 \)).</li>
 <p><li> Explicit scheme - a nonlinear \( f \) (in \( u \)) is trivial to handle.</li>
 <p><li> Downside: Leapfrog is always unstable after some time.</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec29">The filtered Leapfrog scheme </h2>

<p>
After computing \( u^{n+1} \), stabilize Leapfrog by
$$
\begin{equation}
u^n\ \leftarrow\ u^n + \gamma (u^{n-1} - 2u^n + u^{n+1})
\label{decay:fd2:leapfrog:filtered}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec30">2nd-order Runge-Kutta scheme </h2>

<p>
Forward-Euler + approximate Crank-Nicolson:
$$
\begin{align}
u^* &= u^n + \Delta t f(u^n, t_n),
\label{decay:fd2:RK2:s1}\\ 
u^{n+1} &= u^n + \Delta t \half \left( f(u^n, t_n) + f(u^*, t_{n+1})
\right)
\label{decay:fd2:RK2:s2}
\end{align}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="decay:fd2:RK4">4th-order Runge-Kutta scheme</h2>

<ul>
 <p><li> The most famous and widely used ODE method</li>
 <p><li> 4 evaluations of \( f \) per time step</li>
 <p><li> Its <a href="http://tinyurl.com/nclmcng/pub/sphinx-decay/._main_decay007.html#th-order-runge-kutta-scheme" target="_self">derivation</a> is a very good illustration of numerical thinking!</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec32">2nd-order Adams-Bashforth scheme </h2>

$$
\begin{equation}
u^{n+1} = u^n + \half\Delta t\left( 3f(u^n, t_n) - f(u^{n-1}, t_{n-1})
\right)
\label{decay:fd2:AB2}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec33">3rd-order Adams-Bashforth scheme </h2>

$$
\begin{equation}
u^{n+1} = u^n + \frac{1}{12}\left( 23f(u^n, t_n) - 16 f(u^{n-1},t_{n-1})
+ 5f(u^{n-2}, t_{n-2})\right)
\label{decay:fd2:AB3}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec34">The Odespy software </h2>

<p>
<a href="https://github.com/hplgit/odespy" target="_self">Odespy</a>
features simple Python implementations of the most fundamental
schemes as well as Python interfaces to several famous packages for
solving ODEs: <a href="https://computation.llnl.gov/casc/odepack/odepack_home.html" target="_self">ODEPACK</a>,
<a href="https://computation.llnl.gov/casc/odepack/odepack_home.html" target="_self">Vode</a>,
<a href="http://www.netlib.org/ode/rkc.f" target="_self">rkc.f</a>,
<a href="http://www.netlib.org/ode/rkf45.f" target="_self">rkf45.f</a>,
<a href="http://www.unige.ch/~hairer/software.html" target="_self">Radau5</a>, as well
as the ODE solvers in
<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.html" target="_self">SciPy</a>,
<a href="http://docs.sympy.org/dev/modules/mpmath/calculus/odes.html" target="_self">SymPy</a>, and
<a href="http://olivierverdier.github.com/odelab/" target="_self">odelab</a>.

<p>
Typical usage:

<p>

<!-- code=text typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"># Define right-hand side of ODE
def f(u, t):
    return -a*u

import odespy
import numpy as np

# Set parameters and time mesh
I = 1; a = 2; T = 6; dt = 1.0
Nt = int(round(T/dt))
t_mesh = np.linspace(0, T, Nt+1)

# Use a 4th-order Runge-Kutta method
solver = odespy.RK4(f)
solver.set_initial_condition(I)
u, t = solver.solve(t_mesh)
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec35">Example: Runge-Kutta methods  </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">solvers = [odespy.RK2(f),
           odespy.RK3(f),
           odespy.RK4(f),
           odespy.BackwardEuler(f, nonlinear_solver=<span style="color: #CD5555">&#39;Newton&#39;</span>)]

<span style="color: #8B008B; font-weight: bold">for</span> solver <span style="color: #8B008B">in</span> solvers:
    solver.set_initial_condition(I)
    u, t = solver.solve(t)

<span style="color: #228B22"># + lots of plot code...</span>
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec36">Plots from the experiments </h2>

<p>
<center><p><img src="fig-genz/decay_odespy1_png.png" align="bottom" width=800></p></center>

<p>
The 4-th order Runge-Kutta method (<code>RK4</code>) is the method of choice!

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec37">Example: Adaptive Runge-Kutta methods  </h2>

<ul>
 <p><li> Adaptive methods find "optimal" locations of the mesh points
   to ensure that the error is less than a given tolerance.</li>
 <p><li> Downside: approximate error estimation, not always optimal
   location of points.</li>
 <p><li> "Industry standard ODE solver": Dormand-Prince 4/5-th order
   Runge-Kutta (MATLAB's famous <code>ode45</code>).</li>
</ul>

<center><p><img src="fig-genz/decay_DormandPrince_adaptivity.png" align="bottom" width=800></p></center>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

