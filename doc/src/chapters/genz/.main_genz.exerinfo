
# Information about all exercises in the file main_genz.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main_genz.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['test_precision'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:precision',
  'no': 1,
  'solution': 'We modify the `decay_vc.py` program to\n\n!bc pypro\nfrom numpy import *\nfrom matplotlib.pyplot import *\n\ndef solver(I, a, b, T, dt, theta):\n    """\n    Solve u\'=-a(t)*u + b(t), u(0)=I,\n    for t in (0,T] with steps of dt.\n    a and b are Python functions of t.\n    """\n    dt = float(dt)            # avoid integer division\n    Nt = int(round(T/dt))     # no of time intervals\n    T = Nt*dt                 # adjust T to fit time step dt\n    u = zeros(Nt+1)           # array of u[n] values\n    t = linspace(0, T, Nt+1)  # time mesh\n\n    u[0] = I                  # assign initial condition\n    for n in range(0, Nt):    # n=0,1,...,Nt-1\n        u[n+1] = ((1 - dt*(1-theta)*a(t[n]))*u[n] + \\\n                  dt*(theta*b(t[n+1]) + (1-theta)*b(t[n])))/\\\n                  (1 + dt*theta*a(t[n+1]))\n    return u, t\n\ndef test_linear_solution():\n    """\n    Test problem where u=c*t+I is the exact solution, to be\n    reproduced (to machine precision) by any relevant method.\n    """\n    def u_exact(t):\n        return c*t + I\n\n    def a(t):\n        return t**0.5  # can be arbitrary\n\n    def b(t):\n        return c + a(t)*u_exact(t)\n\n    theta = 0.4; I = 0.1; dt = 0.1\n    T = 4\n    Nt = int(T/dt)  # no of steps\n\n    c_values = [1E-5, 0.1, 1, 10, 100, 1000, 10000,\n                1E+7, 1E+10, 1E+20]\n    for c in c_values:\n        u, t = solver(I=I, a=a, b=b, T=Nt*dt, dt=dt, theta=theta)\n        u_e = u_exact(t)\n        difference = abs(u_e - u).max()  # max deviation\n        print \'c=%6g, difference=%g\' % (c, difference)\n\ntest_linear_solution()\n\n!ec\nRunning this program gives the output\n\n!bc\nc= 1e-05, difference=2.77556e-17\nc=   0.1, difference=1.11022e-16\nc=     1, difference=8.88178e-16\nc=    10, difference=7.10543e-15\nc=   100, difference=1.13687e-13\nc=  1000, difference=9.09495e-13\nc= 10000, difference=1.09139e-11\nc= 1e+07, difference=7.45058e-09\nc= 1e+10, difference=1.14441e-05\nc= 1e+20, difference=131072\n\n!ec \nThe tolerance must in each case be chosen less than the size of\n`difference`. It is an essential point to avoid parameters in\nODEs that are very large. Scaling the problem is then a good\nidea.',
  'solution_file': None,
  'subex': [],
  'text': 'It is claimed in Section ref{decay:MMS} that most numerical methods will\nreproduce a linear exact solution to machine precision. Test this\nassertion using the test function `test_linear_solution` in the\n"`decay_vc.py`": "http://tinyurl.com/ofkw6kc/genz/decay_vc.py" program.\nVary the parameter `c` from very small, via `c=1` to many larger values,\nand print out the maximum difference between the numerical solution\nand the exact solution. What is the relevant value of the tolerance\nin the float comparison in each case?',
  'title': 'Experiment with precision in tests and the size of $u$',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['decay_backward2step'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:bw2',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Implement the 2-step backward method (ref{decay:fd2:bw:2step}) for the\nmodel $u^{\\prime}(t) = -a(t)u(t) + b(t)$, $u(0)=I$.  Allow the first step to\nbe computed by either the Backward Euler scheme or the Crank-Nicolson\nscheme. Verify the implementation by choosing $a(t)$ and $b(t)$ such\nthat the exact solution is linear in $t$ (see Section\nref{decay:MMS}). Show mathematically that a linear solution is indeed a\nsolution of the discrete equations.\n\nCompute convergence rates (see Section ref{decay:convergence:rate}) in\na test case using $a=\\hbox{const}$ and $b=0$, where we easily have an exact\nsolution, and determine if the choice of a first-order scheme\n(Backward Euler) for the first step has any impact on the overall\naccuracy of this scheme. The expected error goes like $\\Oof{\\Delta t^2}$.',
  'title': 'Implement the 2-step backward scheme',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['decay_AdamsBashforth2'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:AB2',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Implement the 2nd-order Adams-Bashforth method (ref{decay:fd2:AB2})\nfor the decay problem $u^{\\prime}=-a(t)u + b(t)$, $u(0)=I$, $t\\in (0, T]$.\nUse the Forward Euler method for the first step such that the overall\nscheme is explicit. Verify the implementation using an exact\nsolution that is linear in time.\nAnalyze the scheme by searching for solutions $u^n=A^n$ when $a=\\hbox{const}$\nand $b=0$. Compare this second-order scheme to the Crank-Nicolson scheme.',
  'title': 'Implement the 2nd-order Adams-Bashforth scheme',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['decay_AdamsBashforth3'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:AB3',
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Implement the 3rd-order Adams-Bashforth method (ref{decay:fd2:AB3})\nfor the decay problem $u^{\\prime}=-a(t)u + b(t)$, $u(0)=I$, $t\\in (0, T]$.\nSince the scheme is explicit, allow it to be started by two steps with\nthe Forward Euler method.  Investigate experimentally the case where\n$b=0$ and $a$ is a constant: Can we have oscillatory solutions for\nlarge $\\Delta t$?',
  'title': 'Implement the 3rd-order Adams-Bashforth scheme',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['decay_RK2_Taylor2'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:RK2:Taylor:analysis',
  'no': 5,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Show that the schemes (ref{decay:fd2:RK2:s2}) and\n(ref{decay:fd2:Taylor2}) are identical in the case $f(u,t)=-a$, where\n$a>0$ is a constant. Assume that the numerical solution reads\n$u^n=A^n$ for some unknown amplification factor $A$ to be determined.\nFind $A$ and derive stability criteria. Can the scheme produce\noscillatory solutions of $u^{\\prime}=-au$? Plot the numerical and exact\namplification factor.',
  'title': 'Analyze explicit 2nd-order methods',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['decay_leapfrog'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:leapfrog1',
  'no': 6,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Implement the Leapfrog scheme for the model equation.\nPlot the solution in the case $a=1$, $b=0$, $I=1$,\n$\\Delta t = 0.01$, $t\\in [0,4]$. Compare with the exact\nsolution $\\uex(t)=e^{-t}$.'},
            {'answer': '',
             'file': None,
             'hints': ["It can be wise to automate the calculations such that it is easy to\nredo the calculations for other types of solutions. Here is\na possible `sympy` function that takes a symbolic expression `u`\n(implemented as a Python function of `t`), fits the `b` term, and\nchecks if `u` fulfills the discrete equations:\n\n!bc pycod\nimport sympy as sym\n\ndef analyze(u):\n    t, dt, a = sym.symbols('t dt a')\n\n    print 'Analyzing u_e(t)=%s' % u(t)\n    print 'u(0)=%s' % u(t).subs(t, 0)\n\n    # Fit source term to the given u(t)\n    b = sym.diff(u(t), t) + a*u(t)\n    b = sym.simplify(b)\n    print 'Source term b:', b\n\n    # Residual in discrete equations; Forward Euler step\n    R_step1 = (u(t+dt) - u(t))/dt + a*u(t) - b\n    R_step1 = sym.simplify(R_step1)\n    print 'Residual Forward Euler step:', R_step1\n\n    # Residual in discrete equations; Leapfrog steps\n    R = (u(t+dt) - u(t-dt))/(2*dt) + a*u(t) - b\n    R = sym.simplify(R)\n    print 'Residual Leapfrog steps:', R\n\ndef u_e(t):\n    return c*t + I\n\nanalyze(u_e)\n# or short form: analyze(lambda t: c*t + I)\n\n!ec"],
             'solution': '',
             'text': 'Show mathematically that a linear solution in $t$ fulfills the\nForward Euler scheme for the first step and the Leapfrog scheme\nfor the subsequent steps. Use this linear solution to verify\nthe implementation, and automate the verification through a test\nfunction.'},
            {'aftertext': '\n',
             'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Show that a second-order polynomial in $t$ cannot be a solution of the discrete\nequations. However, if a Crank-Nicolson scheme is used for the first\nstep, a second-order polynomial solves the equations exactly.'},
            {'aftertext': '\n#A possible test case is\n#$u^{\\prime}=-au + b$, $u(0)=0$, where $\\uex(t)=b/a + (I - b/a)e^{-at}$ if\n#$a$ and $b$ are constants.\n',
             'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Create a manufactured solution $u(t)=\\sin(t)$ for the ODE\n$u^{\\prime}=-au+b$.\nCompute the convergence rate of the Leapfrog scheme using this\nmanufactured solution. The expected convergence rate of the\nLeapfrog scheme is $\\Oof{\\Delta t^2}$. Does the use of a\n1st-order method for the first step impact the convergence rate?'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Set up a set of experiments to demonstrate that the Leapfrog scheme\n(ref{decay:fd2:exer:leapfrog1:scheme}) is associated with numerical artifacts\n(instabilities). Document the main results from this investigation.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Analyze and explain the\ninstabilities of the Leapfrog scheme (ref{decay:fd2:exer:leapfrog1:scheme}):\n\n o Choose $a=\\mbox{const}$ and $b=0$. Assume that an exact solution\n   of the discrete equations has\n   the form $u^n=A^n$, where $A$ is an amplification factor to\n   be determined. Derive an equation for $A$ by inserting $u^n=A^n$\n   in the Leapfrog scheme.\n o Compute $A$ either by hand and/or with the aid of `sympy`.\n   The polynomial for $A$ has two roots, $A_1$ and $A_2$. Let\n   $u^n$ be a linear combination $u^n=C_1A_1^n + C_2A_2^n$.\n o Show that one of the roots is the reason for instability.\n o Compare $A$ with the exact expression, using a Taylor series approximation.\n o How can $C_1$ and $C_2$ be determined?'},
            {'aftertext': '\n',
             'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Since the original Leapfrog scheme is unconditionally unstable as time\ngrows, it demands some stabilization.  This can be done by filtering,\nwhere we first find $u^{n+1}$ from the original Leapfrog scheme and\nthen replace $u^{n}$ by $u^n + \\gamma (u^{n-1} - 2u^n +\nu^{n+1})$, where $\\gamma$ can be taken as 0.6.  Implement the filtered\nLeapfrog scheme and check that it can handle tests where the original\nLeapfrog scheme is unstable.'}],
  'text': 'A Leapfrog scheme\nfor the ODE $u^{\\prime}(t) = -a(t)u(t) + b(t)$ is defined by\n\n!bt\n\\begin{equation}\n\\lbrack D_{2t}u = -au+b\\rbrack^n\\tp\nlabel{decay:fd2:exer:leapfrog1:scheme}\n\\end{equation}\n\n!et\nA separate method is needed to compute $u^1$. The Forward Euler\nscheme is a possible candidate.',
  'title': 'Implement and investigate the Leapfrog scheme',
  'type': 'Project',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['decay_schemes_unified'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:uni',
  'no': 7,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Consider the linear ODE problem $u^{\\prime}(t)=-a(t)u(t) + b(t)$, $u(0)=I$.\nExplicit schemes for this problem can be written in the general form\n!bt\n\\begin{equation}\nu^{n+1} = \\sum_{j=0}^m c_ju^{n-j},\nlabel{decay:analysis:exer:sumcj}\n\\end{equation}\n\n!et\nfor some choice of $c_0,\\ldots,c_m$.\nFind expressions for the $c_j$ coefficients in case of the\n$\\theta$-rule, the three-level backward scheme,\nthe Leapfrog scheme, the 2nd-order Runge-Kutta method,\nand the 3rd-order Adams-Bashforth scheme.\n\nMake a class `ExpDecay` that implements the\ngeneral updating formula (ref{decay:analysis:exer:sumcj}).\nThe formula cannot be applied for $n < m$, and for those $n$ values, other\nschemes must be used. Assume for simplicity that we just\nrepeat Crank-Nicolson steps until (ref{decay:analysis:exer:sumcj}) can be used.\nUse a subclass\nto specify the list $c_0,\\ldots,c_m$ for a particular method, and\nimplement subclasses for all the mentioned schemes.\nVerify the implementation by testing with a linear solution, which should\nbe exactly reproduced by all methods.',
  'title': 'Make a unified implementation of many schemes',
  'type': 'Problem',
  'type_visible': True}]