
# Information about all exercises in the file main_softeng.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main_softeng.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['curvediff'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:derivative',
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Write a function\n`differentiate(x, y)` for differentiating a curve\nwith coordinates in the arrays `x` and `y`, using the\nformulas above. The function should return the coordinate arrays\nof the resulting differentiated curve.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Since the formulas for differentiation used here are only approximate,\nwith unknown approximation errors, it is challenging to construct\ntest cases. Here are three approaches, which should be implemented\nin three separate test functions.\n\n o Consider a curve with three points and compute $d_i$, $i=0,1,2$,\n   by hand. Make a test that compares the hand-calculated results with those\n   from the function in a).\n o The formulas for $d_i$ are exact for points on\n   a straight line, as all the $d_i$ values are then the same, equal to\n   the slope of the line. A test can check this property.\n o For points lying on a parabola, the values for $d_i$, $i=1,\\ldots,n-1$,\n   should equal the exact derivative of the parabola. Make a test based on\n   this property.'},
            {'aftertext': '\n# Using a 2nd-order backward formula at x=1 does not improve the\n# results much, one gets large errors at the end points.\n\n',
             'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Start with a curve corresponding to $y=\\sin(\\pi x)$ and $n+1$\npoints in $[0,1]$. Apply `differentiate` four times and plot the\nresulting curve and the exact $y=\\sin\\pi x$ for $n=6, 11, 21, 41$.'}],
  'text': 'Suppose we have a curve specified through a set\nof discrete coordinates $(x_i,y_i)$, $i=0,\\ldots,n$, where the $x_i$\nvalues are uniformly distributed with spacing $\\Delta x$: $x_i=\\Delta x$.\nThe derivative of this curve, defined as a new curve with points\n$(x_i, d_i)$, can be computed via finite differences:\n\n!bt\n\\begin{equation}\nd_0 = \\frac{y_1-y_0}{\\Delta x},\nlabel{_auto1}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \nd_i = \\frac{y_{i+1}-y_{i-1}}{2\\Delta x},\\quad i=1,\\ldots,n-1,\nlabel{_auto2}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \nd_n = \\frac{y_n-y_{n-1}}{\\Delta x}\\tp\nlabel{_auto3}\n\\end{equation}\n\n!et',
  'title': 'Make a tool for differentiating curves',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['trapezoidal'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:integral:flat',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': "The ``flat'' implementation above suffers from serious flaws:\n\n o A general numerical algorithm (the Trapezoidal rule) is implemented\n   in a specialized form where the formula for $f$ is inserted directly\n   into the code for the general integration formula.\n o A general numerical algorithm is not encapsulated as a general\n   function, with appropriate parameters, which can be reused\n   across a wide range of applications.\n o The lazy programmer dropped the first terms in the general formula\n   since $\\sin(0)=\\sin(\\pi)=0$.\n o The sloppy programmer used `np` (number of points?) as variable for\n   `n` in the formula and a counter `k` instead of `i`. Such small\n   deviations from the mathematical notation are completely unnecessary.\n   The closer the code and the mathematics can get, the easier it is\n   to spot errors in formulas.\n\nWrite a function `trapezoidal` that fixes these flaws.\nPlace the function in a module `trapezoidal`."},
            {'answer': '',
             'file': None,
             'hints': ['Note that even if you know the value of the integral, you do not know\nthe error in the approximation produced by the Trapezoidal rule.\nHowever, the Trapezoidal rule will integrate linear functions\nexactly (i.e., to machine precision). Base a test function\non a linear $f(x)$.'],
             'solution': '',
             'text': 'Write a test function `test_trapezoidal`. Call the test function\nexplicitly to check that it works. Remove the call and run pytest\non the module:\n\n!bc sys\nTerminal> py.test -s -v trapezoidal\n\n!ec'},
            {'answer': '',
             'file': None,
             'hints': ['To translate a string formula on the command line, like `sin(x)**2`,\ninto a Python function, you can wrap a function declaration around\nthe formula and run `exec` on the string to turn it into live Python code:\n\n!bc pycod\nimport math, sys\nformula = sys.argv[1]\nf_code = """\ndef f(x):\n    return %s\n""" % formula\nexec(code, math.__dict__)\n\n!ec\nThe result is the same as if we had hardcoded\n\n!bc pycod\nfrom math import *\n\ndef f(x):\n    return sin(x)**2\n\n!ec\nin the program. Note that `exec` needs the namespace\n`math.__dict__`, i.e., all names in the `math` module, such that\nit understands `sin` and other mathematical functions.\nSimilarly, to allow $a$ and $b$ to be `math` expressions like `pi/4`\nand `exp(4)`, do\n\n!bc sys\na = eval(sys.argv[2], math.__dict__)\nb = eval(sys.argv[2], math.__dict__)\n\n!ec'],
             'solution': '',
             'text': "Add functionality such that we can compute $\\int_a^b f(x)dx$ by providing\n$f$, $a$, $b$, and $n$ as positional command-line arguments to the\nmodule file:\n\n!bc sys\nTerminal> python trapezoidal.py 'sin(x)**2' 0 pi 20\n\n!ec\nHere, $a=0$, $b=\\pi$, and $n=20$.\n\nNote that the `trapezoidal.py` file must still be a valid module file, so the\ninterpretation of command-line data and computation of the integral\nmust be performed from calls in a test block."},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Write a test function for verifying the implementation of\ndata reading from the command line.'}],
  'text': 'An integral\n\n!bt\n\\[ \\int_a^b f(x)dx \\]\n\n!et\ncan be numerically approximated by the Trapezoidal rule,\n\n!bt\n\\[ \\int_a^b f(x)dx \\approx \\frac{h}{2}(f(a) + f(b)) + h\\sum_{i=1}^{n-1} f(x_i),\n\\]\n\n!et\nwhere $x_i$ is a set of uniformly spaced points in $[a,b]$:\n\n!bt\n\\[ h = \\frac{b-a}{n},\\quad x_i=a + ih,\\ i=1,\\ldots,n-1\\tp \\]\n\n!et\n\nSomebody has used this rule to compute the integral $\\int_0^\\pi \\sin^2x\\, dx$:\n\n!bc pypro\nfrom math import pi, sin\nnp = 20\nh = pi/np\nI = 0\nfor k in range(1, np):\n    I += sin(k*h)**2\nprint I\n\n!ec',
  'title': 'Make solid software for the Trapezoidal rule',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['trapezoidal_class'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:integral:flat2',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'We consider the same problem setting as in Problem\nref{softeng1:exer:integral:flat}. Make a module with a class `Problem`\nrepresenting the mathematical problem to be solved and a class\n`Solver` representing the solution method.  The rest of the\nfunctionality of the module, including test functions and reading data\nfrom the command line, should be as in Problem\nref{softeng1:exer:integral:flat}.',
  'title': 'Implement classes for the Trapezoidal rule',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['test_roots'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:doctest1',
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Equip the `roots` function with a doctest.\nMake sure to test both real and complex roots.\nWrite out numbers in the doctest with 14 digits or less.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Make a test function for the `roots` function. Perform the\nsame mathematical tests as in a), but with different\nprogramming technology.'}],
  'text': 'Type in the following program:\n\n!bc pypro\nimport sys\n# This sqrt(x) returns real if x>0 and complex if x<0\nfrom numpy.lib.scimath import sqrt\n\ndef roots(a, b, c):\n    """\n    Return the roots of the quadratic polynomial\n    p(x) = a*x**2 + b*x + c.\n\n    The roots are real or complex objects.\n    """\n    q = b**2 - 4*a*c\n    r1 = (-b + sqrt(q))/(2*a)\n    r2 = (-b - sqrt(q))/(2*a)\n    return r1, r2\n\na, b, c = [float(arg) for arg in sys.argv[1:]]\nprint roots(a, b, c)\n\n!ec',
  'title': 'Write a doctest and a test function',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': 'You will experience that if `a` and `b` are large, as they can be\nin geophysical applications where lengths measured in meters can be of size\n$10^6$ m, `tol` must be about $10^{-9}$, while `a` and `b` around unity can\nhave `tol` of size $10^{-15}$.',
  'file': ['tolerance'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:tol',
  'no': 5,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'When we replace a comparison `a == b`, where `a` and/or `b` are\n`float` objects, by a comparison with tolerance, `abs(a-b) < tol`,\nthe appropriate size of `tol` depends on the size of `a` and `b`.\nInvestigate how the size of `abs(a-b)` varies when `b` takes on\nvalues $10^k$, $k=-5,-9,\\ldots,20$ and `a=1.0/49*b*49`.',
  'title': 'Experiment with tolerances in comparisons',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['experiment_compare_dt_class'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:class:dts',
  'no': 6,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Implement the `experiment_compare_dt` function from `decay.py`\nusing class `Problem` and class `Solver` from\nSection ref{softeng1:prog:se:class}.\nThe parameters `I`, `a`, `T`, the scheme name, and a series of\n`dt` values should be read from the command line.',
  'title': 'Make use of a class implementation',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['logistic'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:logistic',
  'no': 7,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'We have the following evolutionary difference equation for the number\nof individuals $u^n$ of a certain specie at time $n\\Delta t$:\n\n!bt\n\\begin{equation}\nu^{n+1} = u^n + \\Delta t\\, r u^n\\left(1 - \\frac{u^n}{M^n}\\right),\n\\quad u^0=U_0\\tp\n\\label{softeng1:exer:logistic:eq}\n\\end{equation}\n\n!et\nHere, $n$ is a counter in time, $\\Delta t$ is time between time levels\n$n$ and $n+1$ (assumed constant), $r$ is a net reproduction rate\nfor the specie,\nand $M^n$ is the upper limit of the population that the environment can\nsustain at time level $n$.',
  'title': 'Make solid software for a difference equation',
  'type': 'Problem',
  'type_visible': True}]