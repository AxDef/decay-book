
# Information about all exercises in the file main_models.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main_models.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['carbon14'],
  'heading': '=====',
  'hints': ['Let $A$ be the amount of Carbon-14. The ODE problem is then\n$A^{\\prime}(t)=-aA(t)$, $A(0)=I$. Introduced the scaled amount\n$u=A/I$. The ODE problem for $u$ is $u^{\\prime}=-au$, $u(0)=1$.\nMeasure time in years.\nSimulate until the first mesh point $t_m$ such that $u(t_m)\\leq 0.084$.',
            'Use simulations with $5,730\\pm 40$ y as input\nand find the corresponding uncertainty interval for the result.'],
  'keywords': None,
  'label': 'decay:app:exer:radio:C14',
  'no': 1,
  'solution': 'We need a tailored solver function for this exercise:\n\n!bc pycod\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef solver(I, a, u_crit, dt, theta):\n    """\n    Solve u\'=-a*u, u(0)=I, for t in (0,t_m] until u <= u_crit\n    with steps of dt. Return t_m.\n    """\n    # Use list for u and t since we do not know how many points\n    # that are needed\n    dt = float(dt)               # avoid integer division\n    u = []\n    t = []\n\n    u.append(I)                  # assign initial condition\n    t.append(0)\n    while u[-1] > u_crit:\n        u_new = (1 - (1-theta)*a*dt)/(1 + theta*dt*a)*u[-1]\n        u.append(u_new)\n        t.append(t[-1] + dt)\n    return t[-1]\n\n\nhalf_life = 5730\na  = np.log(2)/half_life\nprint \'Age:\', solver(I=1, a=a, u_crit=0.084, dt=10, theta=0.5)\n\n!ec\nRunning this code gives an age of 20,480 years.\n\nThe uncertainty can be estimated by the following code:\n\n!bc pycod\nhalf_life_min = 5730 - 40\nhalf_life_max = 5730 + 40\na_min = np.log(2)/half_life_min\na_max = np.log(2)/half_life_max\nage_min = solver(I=1, a=a_max, u_crit=0.084, dt=10, theta=0.5)\nage_max = solver(I=1, a=a_min, u_crit=0.084, dt=10, theta=0.5)\nprint \'Uncertainty: [%g, %g]\' % (age_min, age_max)\n\n!ec',
  'solution_file': None,
  'subex': [],
  'text': 'The "Carbon-14": "http://en.wikipedia.org/wiki/Carbon-14" isotope,\nwhose radioactive decay is used extensively in dating organic material\nthat is tens of thousands of years old, has a half-life of $5,730$\nyears.  Determine the age of an organic material that contains 8.4 percent\nof its initial amount of Carbon-14.  Use a time unit of 1 year in the\ncomputations.  The uncertainty in the half time of Carbon-14 is $\\pm\n40$ years.  What is the corresponding uncertainty in the estimate of\nthe age?',
  'title': 'Radioactive decay of Carbon-14',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['schemes_cooling'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:cooling:schemes',
  'no': 2,
  'solution': 'The idea of the Forward Euler scheme is to sample the ODE at $t=t_n$\nand apply a forward difference approximation to the derivative:\n\n!bt\n\\[ \\frac{T^{n+1}-T^n}{\\Delta t} = -k(T^n - T_s(t_n))\\tp\\]\n\n!et\nThe Backward Euler applies a backward difference instead:\n\n!bt\n\\[ \\frac{T^{n}-T^{n-1}}{\\Delta t} = -k(T^n - T_s(t_n))\\tp\\]\n\n!et\nThe Crank-Nicolson scheme samples the ODE at $t_{n+\\half}$, applies\na centered difference approximation, and an arithmetic mean approximation\nto $T^{n+\\half}$:\n\n!bt\n\\[ \\frac{T^{n+1}-T^n}{\\Delta t} = -k(T^{n+\\half} - T_s(t_{n+\\half}))\n\\approx -k(\\half(T^n + T^{n+1}) - T_s(t_{n+\\half}))\\tp\\]\n\n!et\nFor each scheme we solve with respect to the unknown $T^{n+1}$ (note\nthat we switch index from $n$ to $n+1$ in the Backward Euler scheme):\n\n!bt\n\\begin{align*}\nT^{n+1} &= T^n - k\\Delta t(T^n - T_s(t_n)),\\\\ \nT^{n+1} &= \\frac{T^n + k\\Delta t T_s(t_{n+1})}{1 + k\\Delta t},\\\\ \nT^{n+1} &= \\frac{T^n - \\half k\\Delta t T^n + k\\Delta t T_s(t_{n+\\half})}{1 + \\half k\\Delta t}\\tp\n\\end{align*}\n\n!et\nA $\\theta$ scheme can be formulated as\n\n!bt\n\\[ T^{n+1} = \\frac{T^n - (1-\\theta) k\\Delta t T^n + k\\Delta t T_s((1-\\theta) t_n+ \\theta t_{n+1})}{1 + \\theta k\\Delta t}\n\\]\n\n!et',
  'solution_file': None,
  'subex': [],
  'text': "Show in detail how we can apply the ideas of the Forward Euler,\nBackward Euler, and Crank-Nicolson\ndiscretizations to derive explicit\ncomputational formulas for new temperature values in Newton's law of\ncooling (see Section ref{decay:app:Newton:cooling}):\n\n!bt\n\\[\n\\frac{dT}{dt} = -k(T-T_s(t)),\\quad T(0)=T_0\\tp\n\\]\n\n!et\nHere, $T$ is the temperature of the body, $T_s(t)$ is the temperature\nof the surroundings, $t$ is time, $k$ is the heat transfer\ncoefficient, and $T_0$ is the initial temperature of the body.\nSummarize the discretizations in a $\\theta$-rule\nsuch that you can get the three\nschemes from a single formula by varying the $\\theta$ parameter.",
  'title': "Derive schemes for Newton's law of cooling",
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['cooling'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:cooling:py',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': 'Here is an appropriate function:\n\n!bc pycod\nimport numpy as np\n\ndef cooling(T0, k, T_s, t_end, dt, theta=0.5):\n    """\n    Solve T\'=-k(T-T_s(t)), T(0)=T0,\n    for t in (0,t_end] with steps of dt.\n    T_s(t) is a Python function of t.\n    theta=0.5 means Crank-Nicolson, 1 is Backward\n    Euler, and 0 is Forward Euler scheme.\n    """\n    dt = float(dt)                  # avoid integer division\n    Nt = int(round(t_end/dt))       # no of time intervals\n    t_end = Nt*dt                   # adjust to fit time step dt\n    T = np.zeros(Nt+1)              # array of T[n] values\n    t = np.linspace(0, t_end, Nt+1) # time mesh\n    T[0] = T0                       # set initial condition\n    for n in range(0, Nt):          # n=0,1,...,Nt-1\n        T[n+1] = ((1 - dt*(1 - theta)*k)*T[n] + \\ \n        dt*k*(theta*T_s(t[n+1]) + (1 - theta)*T_s(t[n])))/ \\ \n        (1 + dt*theta*k)\n    return T, t\n\n!ec',
             'text': 'Implement the $\\theta$-rule from\nExercise ref{decay:app:exer:cooling:schemes} in a function\n\n!bc\ncooling(T0, k, T_s, t_end, dt, theta=0.5)\n\n!ec \nwhere `T0` is the initial temperature, `k` is\nthe heat transfer coefficient, `T_s` is a function of `t` for\nthe temperature of the\nsurroundings, `t_end` is the end time of the simulation, `dt` is the\ntime step, and `theta` corresponds to $\\theta$.  The `cooling`\nfunction should return the temperature as an array `T` of values at\nthe mesh points and the time mesh `t`.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': 'Apply the limit to the ODE:\n\n!bt\n\\[ \\lim_{t\\rightarrow\\infty}\\frac{dT}{dt} = -k(\\lim_{t\\rightarrow\\infty} T\n- \\lim_{t\\rightarrow\\infty} T_s)\\tp\n\\]\n\n!et\nAssuming steady state behavior, $dT/dt\\rightarrow\\infty$ as\n$t\\rightarrow\\infty$. Then we get\n\n!bt\n\\[ 0 = -k(\\lim_{t\\rightarrow\\infty} T\n- C),\n\\]\n\n!et\nwhich means\n\n!bt\n\\[ \\lim_{t\\rightarrow\\infty} T = C\\tp\\]\n\n!et\n\nA corresponding test function takes the form\n\n!bc pycod\ndef test_asymptotic():\n    """\n    Test that ``any\'\' initial condition leads to\n    the same asymptotic behavior when T_s=constant.\n    """\n    import matplotlib.pyplot as plt\n    plt.figure()\n    T_s = 5.\n    k = 1.2\n    dt = 0.1\n    tol = 0.01  # tolerance for testing asymptotic value\n    t_end = 7    # make sure t_end is large enough for tol\n    T0_values = [0, 2, 4, 5, 6, 8, 10] # test many cases\n\n    for T0 in [0, 2, 4, 5, 6, 8, 10]:\n        u, t = cooling(T0, k, lambda t: T_s, t_end, dt)\n        plt.plot(t, u)\n\n        assert abs(u[-1] - T_s) < tol, \'%s != %s\' % (u[-1], T_s)\n\n    plt.legend([\'T0=%g\' % T0 for T0 in T0_values])\n    plt.title(\'Testing asymptotic behavior T_s=%g\' % T_s)\n    plt.xlabel(\'t\')\n    plt.ylabel(\'T\')\n    plt.savefig(\'tmp1.png\');  plt.savefig(\'tmp1.pdf\')\n    plt.show()\n\n!ec\nNote that we have added a plot in the test function for convenience.\nLetting test functions perform plotting is, however, not a good idea\nif you want to run a large set of tests.\n\nFIGURE: [fig-models/cooling_asymptotic, width=600 frac=0.8]',
             'text': 'In the case $\\lim_{t\\rightarrow\\infty}T_s(t)=C=\\mbox{const}$,\nexplain why $T(t)\\rightarrow C$. Construct an example where you\ncan illustrate this property in a plot. Implement a corresponding\ntest function that checks the correctness of the asymptotic\nvalue of the solution.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': 'First we implement a general tool for piecewise constant functions:\n\n!bc pycod\nclass Piecewise(object):\n    """Class for holding a piecewise constant function."""\n    def __init__(self, C0, C1, t_star):\n        self.C0, self.C1 = C0, C1\n        self.t_star = t_star\n\n    def __call__(self, t):\n        """\n        Return value of piecewise constant function.\n        t can be float or numpy array.\n        """\n        if isinstance(t, (float,int)):\n            if t <= self.t_star:\n                T_s = self.C0\n            elif t > self.t_star:\n                T_s = self.C1\n        else:\n            # assume numpy array\n            T_s = np.piecewise(t,\n                               [t <= self.t_star, t > self.t_star],\n                               [self.C0, self.C1])\n            # Alternative\n            # T_s = np.where(t <= self.t_star, C0, C1)\n        return T_s\n\n!ec\n\nIt is convenient to scale the problem such that we do not need to find\nphysically relevant values for $k$. A common scaling of $T$ is\n\n!bt\n\\[ \\bar T = \\frac{T-T_0}{T_s-T_0},\\]\n\n!et\nwhen $T_s$ is constant since then $\\bar T\\in [0,1]$. Here, we may choose\nthe long-term value of $T_s$ in the denominator such that $\\lim_{t\\rightarrow\\infty}\\bar T=1$, i.e.,\n\n!bt\n\\[ \\bar T = \\frac{T-T_0}{0.5T_0-T_0}= -2\\frac{T-T_0}{T_0},\\]\n\n!et\nbut it leads to a shift in the sign of the temperature on the\nright-hand side of the ODE, and we cannot reuse the code for the\noriginal problem in the dimensionless case. We therefore avoid the negative\nsign and use a temperature scale $2T_0-T_0$,\n\n!bt\n\\[ \\bar T = \\frac{T-T_0}{2T_0-T_0}= \\frac{T-T_0}{T_0},\\]\n\n!et\nwhich gives $\\bar T$ varying from $0$ initially to a maximum of\n$1$ and finally to a minimum of $-\\half$.\nWe scale $T_s$ by its maximum value $2T_0$ so $\\bar T_s\\in [0,1]$:\n\n!bt\n\\[ \\bar T_s(\\bar t) = \\frac{T_s(t)}{\\max_t T_s(t)} = \\frac{T_s(t_c\\bar t)}{2T_0} = \\left\\lbrace\\begin{array}{ll}\n1, & \\bar t < t^*/t_c,\\\\ \n\\frac{1}{4},& \\bar t \\geq t^*/t_c\n\\end{array}\\right.\n\\]\n\n!et\nwhere $t_c$ is the time scale. Inserted in the ODE we get\n\n!bt\n\\[\n\\frac{T_0}{t_c}\\frac{d\\bar T}{d\\bar t} = -k(T_0\\bar T + T_0 -\n2T_0\\bar T_s,\n\\]\n\n!et\nleading to\n\n!bt\n\\[\n\\frac{d\\bar T}{d\\bar t} = -kt_c(\\bar T + 1 - 2\\bar T_s)\\tp\n\\]\n\n!et\nA natural choice is $t_c=1/k$ so we get the scaled problem\n\n!bt\n\\[\n\\frac{d\\bar T}{d\\bar t} = -(\\bar T + 1 - 2\\bar T_s) =\n-(\\bar T -(2\\bar T_s - 1)),\\quad \\bar T(0)=0\\tp\n\\]\n\n!et\nWe can simulate this problem using the code for the original\nproblem by choosing $k=1$, $T_0=0$, and\n$T_s= (2-1)=1$ for $t < 3$ and $T_s=(2\\frac{1}{4}-1)=-\\half$\nfor $t > 3$.\n\nThe appropriate code becomes\n\n!bc pycod\ndef simulate_piecewise_constant_Ts():\n    """\n    Simulate scaled problem: T\' = -(T - (2T_s-1)), T(0)=0,\n    where T_s=1 for t < 3 and -0.5 for t > 3.\n    """\n    k = 1\n    T0 = 0\n    t_star = 3.0\n    C0 = 1\n    C1 = -0.5\n    T_s = Piecewise(C0, C1, t_star)\n    dt = t_star/100.0\n    T, t = cooling(T0, k, T_s, t_end=3*t_star, dt=dt, theta=0.5)\n    import matplotlib.pyplot as plt\n    plt.figure()\n    plt.plot(t, T)\n    plt.xlabel(\'t\');  plt.ylabel(\'u\')\n    plt.savefig(\'tmp2.png\');  plt.savefig(\'tmp2.pdf\')\n    plt.show()\n\n!ec\nThe plot looks like this:\n\nFIGURE: [fig-models/cooling_piecewise, width=600 frac=0.8]\n\nThe result is reasonable because first $T_s=1$ and the body\'s temperature\nwill try to rise from $0$ to $1$, and it almost gets there in\nthe time $[0,3]$, before $T_s=-0.5$ and then the body is cooled down\nto $-0.5$ as $t$ increases, and this is also the asymptotic value.',
             'text': 'A piecewise constant surrounding temperature,\n\n!bt\n\\[ T_s(t) = \\left\\lbrace\\begin{array}{ll} C_0,& 0\\leq t\\leq t^*\\\\ \nC_1, & t>t^*,\\end{array}\\right.\n\\]\n\n!et\ncorresponds to a sudden change in the environment\nat $t=t^*$. Choose $C_0=2T_0$, $C_1=\\frac{1}{2}T_0$, and\n$t^*=3/k$. Plot the solution $T(t)$ and explain why it seems physically\nreasonable.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': 'In the unscaled problem, the first stage of the simulation\ncovers the time interval $[0,t^*]=[0, 3/k]$. It makes sense to\nchoose $\\Delta t$ significantly smaller than $3/k$, and the\nstability limit $2/k$ is a too large step. The next time level\nis then $4/k$, and it sounds reasonable to include the point $t^*=3/k$\nas a mesh point. Oscillations would then occur if we choose\n$\\Delta t = 3/k$, but this means only one step through the first\ninterval $[0,t^*]$, which is a very coarse mesh. Halving $\\Delta t$\nis still a coarse mesh, but then there cannot be oscillations.',
             'text': 'We know from the ODE $u^\\prime =-au$ that the Crank-Nicolson scheme\ncan give non-physical oscillations for $\\Delta t > 2/a$.\nIn the present problem, this results indicates\nthat the Crank-Nicolson scheme give undesired\noscillations for $\\Delta t > 2/k$.\nDiscuss if this a potential problem in the physical case from c).'},
            {'answer': '',
             'file': None,
             'hints': ['The exact solution can be derived by multiplying (ref{decay:Newton:cooling})\nby the integrating factor $e^{kt}$.'],
             'solution': 'Multiplication of $e^{kt}$, using the product rule for differentiation\n``backwards\'\', and integrating from 0 to $t$, results in\n\n!bt\n\\[ \\int_0^t (e^{kt}T)^{\\prime}dt = k\\int_0^t e^{kt}T_sdt\\tp\\]\n\n!et\nThe left-hand side becomes $e^{kt}T(t)-T_0$. Multiplying by $e^{-kt}$\nthen gives\n\n!bt\n\\[ T(t) = T_0e^{-kt} + ke^{-kt}\\int_0^t e^{k\\tau}T_s(\\tau)d\\tau,\\]\n\n!et\nwhich is the general expression for the exact solution.\n\nAs a check, we consider the case where $T_s$ is constant.\nThat problem can easily be solved by introducing $u=T-T_s$, resulting in\n$u^{\\prime}=-ku$, $u(0)=T_0-T_s$, with solution $u(t)=(T_0-T_s)e^{-kt}$,\nand consequently $T=T_s + (T_0-T_s)e^{-kt}$. With a constant $T_s$ in\nthe general solution above, the solution becomes\n\n!bt\n\\begin{align*}\nT(t) &= T_0e^{-kt} + ke^{-kt}\\int_0^t e^{kt}T_sdt\\\\ \n& = T_0e^{-kt} + ke^{-kt}T_sk^{-1}(e^{kt} - 1)\\\\ \n& = T_0e^{-kt} + T_s - T_se^{-kt}\\\\ \n& = T_s + (T_0-T_s)e^{-kt},\n\\end{align*}\n\n!et\nas desired.\n\nWe choose the same test problem as in c) and use SymPy to do the\nintegration. A function doing the integration and returning\nPython functions for the formulas for $t < t^*$ and $t\\geq t^*$\nis convenient:\n\n!bc pycod\ndef T_exact_symbolic(verbose=False):\n    """Compute the exact solution formula via sympy."""\n    # sol1: solution for t < t_star,\n    # sol2: solution for t > t_star\n    import sympy as sym\n    T0 = sym.symbols(\'T0\')\n    k = sym.symbols(\'k\', positive=True)\n    # Piecewise linear T_sunction\n    t, t_star, C0, C1 = sym.symbols(\'t t_star C0 C1\')\n    T_s = C0\n    I = sym.integrate(sym.exp(k*t)*T_s, (t, 0, t))\n    sol1 = T0*sym.exp(-k*t) + k*sym.exp(-k*t)*I\n    sol1 = sym.simplify(sym.expand(sol1))\n    if verbose:\n        # Some debugging print\n        print \'solution t < t_star:\', sol1\n        #print sym.latex(sol1)\n    T_s = C1\n    I = sym.integrate(sym.exp(k*t)*C0, (t, 0, t_star)) + \\ \n        sym.integrate(sym.exp(k*t)*C1, (t, t_star, t))\n    sol2 = T0*sym.exp(-k*t) + k*sym.exp(-k*t)*I\n    sol2 = sym.simplify(sym.expand(sol2))\n    if verbose:\n        print \'solution t > t_star:\', sol2\n        #print sym.latex(sol2)\n\n    # Convert to numerical functions\n    exact0 = sym.lambdify([t, C0, k, T0],\n                          sol1, modules=\'numpy\')\n    exact1 = sym.lambdify([t, C0, C1, t_star, k, T0],\n                          sol2, modules=\'numpy\')\n    return exact0, exact1\n\n!ec\nThen we need a function that can evaluate the exact solution as\na mesh function:\n\n!bc pycod\ndef evaluate_T_exact(t, k, T0, C0, C1, t_star, verbose=False):\n    """\n    Return exact (analytical) solution of the problem.\n    Exact solution is produced by sympy.\n    """\n    exact0, exact1 = T_exact_symbolic()\n    # exact0/1 works with t as numpy array\n    if isinstance(t, (float,int)):\n        if t < t_star:\n            return exact0(t, C0, k, T0)\n        else:\n            return exact1(t, C0, C1, t_star, k, T0)\n    else:\n        # assume numpy array\n        return np.where(\n            t < t_star,\n            exact0(t, C0, k, T0),\n            exact1(t, C0, C1, t_star, k, T0))\n\n!ec\nFinally we can run the comparison:\n\n!bc pycod\ndef compare_numerical_and_exact_solution():\n    """\n    Compare exact and numerical solution with piecewise\n    constant surrounding temperature. Use scaled problem\n    from function simulate_piecewise_constant_Ts.\n    """\n    T0 = 0\n    k = 1\n    C0 = 1\n    C1 = -0.5\n    t_star = 3\n    t_end = 7\n\n    T_s = Piecewise(C0, C1, t_star)\n\n    import matplotlib.pyplot as plt\n    plt.figure()\n    dt_values = [1, 0.5, 0.025]\n    #dt_values = [0.025]\n    for dt in dt_values:\n        T, t = cooling(T0, k, T_s, t_end, dt, theta=0.5)\n        plt.plot(t, T)\n\n    t_e = np.linspace(0, t_end, 1001)  # find mesh for T_e\n    # Could use sym.Rational(1,2) instead of 0.5, but not necessary\n    # when we are not interested in symbolic formulas\n    T_e = evaluate_T_exact(t_e, k, T0, C0, C1, t_star)\n    plt.plot(t_e, T_e)\n    plt.legend([\'CN, dt=%g\' % dt for dt in dt_values] + [\'exact\'])\n    plt.title(\'T(t) for piecewise constant $T_s(t)$\')\n    plt.xlabel(\'t\')\n    plt.ylabel(\'T\')\n    plt.savefig(\'tmp3.png\');  plt.savefig(\'tmp3.pdf\')\n    plt.show()\n\n!ec\nThe $\\Delta t$ values were found after some trial and error, but they\nillustrate crude approximations and one with the biggest possible\n$\\Delta t$ such that the exact solution and the numerical solution cannot\nbe visually distinguished:\n\nFIGURE: [fig-models/cooling_piecewise_compare, width=600 frac=0.8]\n\nWe can now start to introduce bugs in the `cooling` function to\nsee if it is possible to have some $\\Delta t$ and still find\ncoinciding curves.\n\n=== Bug 1: Wrong time level in the $T_s$ function ===\n\nWe replace `T_s[n]` by `T_s[n+1]` in the implementation of the scheme\nand rerun the case. Now the lowest $\\Delta t$ is still on top of\nthe exact solution, but the numerical solution on the two coarser\nmeshes are more accurate! This is because we lower the surrounding\ntemperature somewhat earlier in the buggy scheme and this reduces\nthe ``overshoot\'\' on the coarsest meshes in the figure above.\n\nFIGURE: [fig-models/cooling_piecewise_bug1, width=600 frac=0.8]\n\n=== Bug 2: Wrong time level in the $T$ function ===\n\nWe can replace `T[n]` by `T[n+1]` on the right-hand side of the scheme.\nThis is a serious error since `T[n+1]` is not yet computed and therefore\nequal to zero when `T` was made by calling `np.zeros`. The results\nare also nonsense, and one would immediately look for a bug.\n\nFIGURE: [fig-models/cooling_piecewise_bug2, width=600 frac=0.8]\n\n=== Bug 3: Missing $\\theta$ in a term ===\n\nLet us forget to multiply by `theta` in the nominator of the scheme, i.e.,\nwe replace\n\n!bc pycod\nT[n+1] = ((1 - dt*(1 - theta)*k)*T[n] + \\ \n         dt*k*(theta*T_s(t[n+1]) + (1 - theta)*T_s(t[n])))/ \\ \n         (1 + dt*theta*k)\n\n!ec\nby\n\n!bc pycod\nT[n+1] = ((1 - dt*(1 - theta)*k)*T[n] + \\ \n         dt*k*(T_s(t[n+1]) + (1 - theta)*T_s(t[n])))/ \\ \n         (1 + dt*theta*k)\n\n!ec\nThis error leads to convergence towards a wrong solution:\n\nFIGURE: [fig-models/cooling_piecewise_bug3, width=600 frac=0.8]\n\nIf we did not have the exact solution, one could be led to think\nthat the solution was correct, but it is non-physical since we\ndo not expect the temperature to rise from $T_0$ to a level\n*above* the surrounding temperature. The plot shows that $\\bar T>1$,\nthe value of the (scaled) surrounding temperature.\nNote that if we used the Backward Euler scheme instead of the\nCrank-Nicolson scheme, this bug would have no effect!\n\n=== Bug 4: Missing `k` in the updating formula ===\n\nObviously, when we solve the scaled problem where $k=1$ by definition,\nsuch a programming mistake has no effect. Otherwise, $k$ influences\nthe time scale, so there will be a stretch of the time axis in the\nnumerical solution and this should be easily detected in a plot.\n\n=== Bug 5: Using `1-theta` instead of `theta` ===\n\nSuch an error is not detectable in the Crank-Nicolson scheme, but\nwill have a significant effect in the other schemes.\nAs a test, we replace `1-theta` in the nominator by `theta`.\nThis leads to $T=0$ in the Forward Euler scheme, but a reasonable shape\nin the Backward Euler scheme, although the solution becomes larger\nthan the surrounding temperature (1 in the scaled problem).\n\nFIGURE: [fig-models/cooling_piecewise_bug5, width=600 frac=0.8]',
             'text': 'Find an expression for the exact solution of\n$T^{\\prime} = -k(T-T_s(t))$, $T(0)=T_0$.\nConstruct a test case and compare the\nnumerical and exact solution in a plot.\n\nFind a value of the time step\n$\\Delta t$ such that the two solution curves cannot (visually) be\ndistinguished from each other. Many scientists will claim that such a\nplot provides evidence for a correct implementation, but point out why\nthere still may be errors in the code.  Can you introduce bugs in the\n`cooling` function and still achieve visually coinciding curves?'},
            {'answer': '',
             'file': None,
             'hints': ['The exact solution of the\ndiscrete equations in the case $T_s$ is a constant can be found by\nintroducing $u=T-T_s$ to get a problem $u^{\\prime}=-ku$, $u(0)=T_0-T_s$.\nThe solution of the discrete equations is then of the form\n$u^{n}=(T_0-T_s)A^n$ for some amplification factor $A$. The\nexpression for $T^n$ is then $T^n = T_s(t_n) + u^n =\nT_s + (T_0-T_s)A^n$.\nWe find that\n\n!bt\n\\[ A = \\frac{1 - (1-\\theta) k\\Delta t}{1 + \\theta k\\Delta t}\\tp\\]\n\n!et\nThe test function, testing several $\\theta$ values for a quite coarse\nmesh, may take the form\n\n!bc pycod\ndef test_discrete_solution():\n    """\n    Compare the numerical solution with an exact solution of the scheme\n    when the T_s is constant.\n    """\n    T_s = 10\n    T0 = 2\n    k = 1.2\n    dt = 0.1   # can use any mesh\n    N_t = 6    # any no of steps will do\n    t_end = dt*N_t\n    t = np.linspace(0, t_end, N_t+1)\n\n    for theta in [0, 0.5, 1, 0.2]:\n        u, t = cooling(T0, k, lambda t: T_s , t_end, dt, theta)\n        A = (1 - (1-theta)*k*dt)/(1 + theta*k*dt)\n        u_discrete_exact = T_s + (T0-T_s)*A**(np.arange(len(t)))\n        diff = np.abs(u - u_discrete_exact).max()\n        print \'diff computed and exact discrete solution:\', diff\n        tol = 1E-14\n        success = diff < tol\n        assert success, \'diff=%g\' % diff\n\n!ec\nRunning this function shows that the `diff` variable is `3.55E-15`\nas maximum so a tolerance of $10^{-14}$ is appropriate.\nThis is a good test that the `cooling` function works!'],
             'solution': '',
             'text': 'Implement a test function for checking that the solution returned by\nthe `cooling` function is identical to the exact numerical\nsolution of the problem (to machine precision) when $T_s$ is constant.'}],
  'text': 'The goal of this exercise is to implement the schemes from\nExercise ref{decay:app:exer:cooling:schemes} and investigate\nseveral approaches for verifying the implementation.',
  'title': "Implement schemes for Newton's law of cooling",
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['detective'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:cooling:murder',
  'no': 4,
  'solution': 'A Forward Euler step from $T^0$ to $T^1$ reads\n\n!bt\n\\[ T^1 = T_0 + -k\\Delta t (T^0 - T_s),\\]\n\n!et\nand solving with respect to $k$ results in\n\n!bt\n\\[ k = \\frac{T^1 - T^0}{\\Delta t(T_s - T_0)}\\tp\\]\n\n!et\nWe implement this formula in a function,\n\n!bc pycod\ndef estimate_k(T0, T1, Ts, dt):\n    return float(T1 - T0)/(dt*(Ts - T0))\n\n!ec\nWe have $T_0=26.7$ C, $T_1=25.8$ C, $T_s=20$ C, and $\\Delta t = 1$ h,\ni.e., $\\Delta t = 3600$ s. The proper call is therefore\n\n!bc pycod\nk = estimate_k(26.7, 25.8, 20, 3600)\n\n!ec\n\nFor the simulation we use the Forward Euler method,\n\n!bt\n\\[ T^{n+1} = T^n - k\\Delta t(T^n - T_s),\\]\n\n!et\nand simulate as long as $T > 25.8$ C:\n\n!bc pycod\nT = 37\nTs = 20\nfrom cooling import cooling\nwhile T > 25.8:\n    T = T - k*dt*(T - Ts)\n    t+= dt\n\nminutes, seconds = divmod(t, 60)\nhours, minutes = divmod(minutes, 60)\nprint """\nThe death occurred %d hours, %d minutes,\nand %g seconds before 3am.""" % (hours, minutes, seconds)\n\n!ec\nThe result of running the code becomes\n\n!bc sys\nTerminal> python detective.py\nk=3.73134e-05\n\nThe death occurred 8 hours, 0 minutes,\nand 19 seconds before 3am.\n\n!ec',
  'solution_file': None,
  'subex': [],
  'text': '# URL: "http://www.biology.arizona.edu/BioMath/tutorials/Applications/Cooling.html"\n\nA detective measures the temperature of a dead body to be 26.7 C at 2\npm. One hour later the temperature is 25.8 C. The question is when\ndeath occurred.\n\nAssume that Newton\'s law of cooling (ref{decay:Newton:cooling}) is an\nappropriate mathematical model for the evolution of the temperature in\nthe body.  First, determine $k$ in (ref{decay:Newton:cooling}) by\nformulating a Forward Euler approximation with one time steep from\ntime 2 am to time 3 am, where knowing the two temperatures allows for\nfinding $k$. Assume the temperature in the air to be 20 C. Thereafter,\nsimulate the temperature evolution from the time of murder, taken as\n$t=0$, when $T=37\\hbox{ C}$, until the temperature reaches 25.8 C. The\ncorresponding time allows for answering when death occurred.',
  'title': 'Find time of murder from body temperature',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['osc_cooling'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:cooling:osc',
  'no': 5,
  'solution': 'We can reuse the `cooling` function from Exercise ref{decay:app:exer:cooling:py}\nto do the simulations:\n\n!bc pycod\nimport numpy as np\n\ndef cooling(T0, k, T_s, t_end, dt, theta=0.5):\n    """\n    Solve T\'=-k(T-T_s(t)), T(0)=T0,\n    for t in (0,t_end] with steps of dt.\n    T_s(t) is a Python function of t.\n    theta=0.5 means Crank-Nicolson, 1 is Backward\n    Euler, and 0 is Forward Euler scheme.\n    """\n    dt = float(dt)                  # avoid integer division\n    Nt = int(round(t_end/dt))       # no of time intervals\n    t_end = Nt*dt                   # adjust to fit time step dt\n    T = np.zeros(Nt+1)              # array of T[n] values\n    t = np.linspace(0, t_end, Nt+1) # time mesh\n    T[0] = T0                       # set initial condition\n    for n in range(0, Nt):          # n=0,1,...,Nt-1\n        T[n+1] = ((1 - dt*(1 - theta)*k)*T[n] + \\ \n        dt*k*(theta*T_s(t[n+1]) + (1 - theta)*T_s(t[n])))/ \\ \n        (1 + dt*theta*k)\n    return T, t\n\n!ec\n\nThe challenge is to use the right units\nfor the input data. We can use Celsius for temperature since it has\nthe same increments as Kelvin. Time quantities should be measured\nin seconds:\n\n!bt\n\\begin{align*}\nk &= 20 \\hbox{ min}^{-1} = \\frac{20}{60}\\hbox{ s}^{-1},\\\\ \nP &= (1 \\hbox{ h} = 3600\\hbox{ s}, 10\\hbox{ min} = 600\\hbox{ s},\n6\\hbox{ h}=6\\cdot 3600\\hbox{ s})\\tp\n\\end{align*}\n\n!et\n\nTo achieve reasonable accuracy,\nwe choose $\\Delta t$ as 40 steps per the\nshortest period of the $T_s$ oscillations:\n$\\Delta t = 600/40$. With some trials we find\nan appropriate simulation interval for all three cases to be\n$[0,8]$ h.\n\nThe code becomes\n\n!bc pypro\nfrom cooling import cooling\nfrom numpy import pi, sin\n\ndef T_s(t):\n    return Tm + a*sin((2*pi/P)*t)\n\nTm = 25\na = 2.5\nP_values = [3600, 600, 3600*6]\nk = 0.05/60\nT0 = 5\n\nimport matplotlib.pyplot as plt\nfor P in P_values:\n    T, t = cooling(T0, k, T_s, t_end=8*3600, dt=600/40)\n    plt.plot(t, T)\nplt.plot(t, T_s(t), \'k--\')  # T_s for largest P to show amplitude\nlegends = [\'P=1 h\', \'P=10 min\', \'P=6 h\', \'$T_s$\']\nplt.legend(legends, loc=\'lower right\')\nplt.xlabel(\'t\'); plt.ylabel(\'T\')\nplt.savefig(\'tmp.png\');  plt.savefig(\'tmp.pdf\')\nplt.show()\n\n!ec\n\nFIGURE: [fig-models/osc_cooling, width=700 frac=0.8]\n\n\n__Discussion of the results.__\nWe see that it takes some time to increase the temperature from $T_0$\nto oscillations around $T_m$. When $T_s$ oscillates fast ($P=10$ min),\n$k$ is not large enough so that $T$ can reach the surrounding temperature\nin the time available before the surrounding temperature decreases.\nHowever, for large $P$ (6 h), there is almost enough time to heat\nand cool the object to reach the maximum and minimum temperatures\nof the surroundings.',
  'solution_file': None,
  'subex': [],
  'text': "The surrounding temperature $T_s$ in Newton's law of cooling\n(ref{decay:Newton:cooling}) may vary in time. Assume that the\nvariations are periodic with period $P$ and amplitude $a$ around\na constant mean temperature $T_m$:\n\n!bt\n\\begin{equation}\nT_s(t) = T_m + a\\sin\\left(\\frac{2\\pi}{P}t\\right)\n\\tp\nlabel{_auto25}\n\\end{equation}\n\n!et\nSimulate a process with the following data: $k=0.05 \\hbox{ min}^{-1}$,\n$T(0)=5$ C, $T_m=25$ C, $a=2.5$ C, and $P=1$ h, $P=10$ min, and $P=6$ h.\nPlot the $T$ solutions and $T_s$ in the same plot.",
  'title': 'Simulate an oscillating cooling process',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['stochastic_decay'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:stoch:nuclear',
  'no': 6,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The purpose of this exercise is to implement the stochastic model\ndescribed in Section ref{decay:app:nuclear} and show that its\nmean behavior approximates the solution of the corresponding\nODE model.\n\nThe simulation goes on for a time interval $[0,T]$ divided into\n$N_t$ intervals of length $\\Delta t$. We start with $N_0$\natoms. In some time interval, we have $N$ atoms that have survived.\nSimulate $N$ Bernoulli trials with probability $\\lambda\\Delta t$\nin this interval by drawing $N$ random numbers, each being 0 (survival)\nor 1 (decay), where the probability of getting 1 is $\\lambda\\Delta t$.\nWe are interested in the number of decays, $d$, and the number of\nsurvived atoms in the next interval is then $N-d$.\nThe Bernoulli trials\nare simulated by drawing $N$ uniformly distributed real numbers on\n$[0,1]$ and saying that 1 corresponds to a value less than $\\lambda\\Delta t$:\n\n!bc pycod\n# Given lambda_, dt, N\nimport numpy as np\nuniform = np.random.uniform(N)\nBernoulli_trials = np.asarray(uniform < lambda_*dt, dtype=np.int)\nd = Bernoulli_trials.size\n\n!ec\nObserve that `uniform < lambda_*dt` is a boolean array whose true\nand false values become 1 and 0, respectively, when converted to an\ninteger array.\n\nRepeat the simulation over $[0,T]$ a large number of times, compute the average\nvalue of $N$ in each interval, and compare with the solution of\nthe corresponding ODE model.',
  'title': 'Simulate stochastic radioactive decay',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['radioactive_decay_2subst'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:radio:twosubst',
  'no': 7,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Make a simulation program that solves for $u_A(t)$ and $u_B(t)$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Verify the implementation by computing analytically\nthe limiting values of\n$u_A$ and $u_B$ as $t\\rightarrow \\infty$ (assume $u_A^{\\prime},u_B^{\\prime}\\rightarrow 0$)\nand comparing these with those obtained numerically.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Run the program for the case of $A_{1/2}=10$ minutes and $B_{1/2}=50$ minutes.\nUse a time unit of 1 minute. Plot $u_A$ and $u_B$ versus time in the same\nplot.'}],
  'text': 'Consider two radioactive substances A and B. The nuclei in substance A\ndecay to form nuclei of type B with a half-life $A_{1/2}$, while\nsubstance B decay to form type A nuclei with a half-life $B_{1/2}$.\nLetting $u_A$ and $u_B$ be the fractions of the initial amount of\nmaterial in substance A and B, respectively, the following system of\nODEs governs the evolution of $u_A(t)$ and $u_B(t)$:\n!bt\n\\begin{equation}\n\\frac{1}{\\ln 2} u_A^{\\prime} = u_B/B_{1/2} - u_A/A_{1/2},\nlabel{_auto26}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\frac{1}{\\ln 2} u_B^{\\prime} = u_A/A_{1/2} - u_B/B_{1/2},\nlabel{_auto27}\n\\end{equation}\n\n!et\nwith $u_A(0)=u_B(0)=1$.',
  'title': 'Radioactive decay of two substances',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['chemcial_kinetics_AB'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:kinetics:AB',
  'no': 8,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Consider the simple chemical reaction where a substance A is turned\ninto a substance B according to\n\n!bt\n\\begin{align*}\n\\frac{d[A]}{dt} &= -k[A],\\\\ \n\\frac{d[B]}{dt} &= k[A],\\\\ \n\\end{align*}\n\n!et\nwhere $[A]$ and $[B]$ are the concentrations of A and B, respectively.\nIt may be a challenge to find appropriate values of $k$, but we can avoid\nthis problem by working with a scaled model (as explained in\nSection ref{decay:app:scaling}).\nScale the model above, using a time scale $1/k$, and use\nthe initial concentration\nof $[A]$ as scale for $[A]$ and $[B]$. Show that the scaled system\nreads\n\n!bt\n\\begin{align*}\n\\frac{du}{dt} &= -u,\\\\ \n\\frac{dv}{dt} &= u,\\\\ \n\\end{align*}\n\n!et\nwith initial conditions $u(0)=1$, and $v(0)=\\alpha$, where\n$\\alpha = [B](0)/[A](0)$ is a dimensionless number, and\n$u$ and $v$ are the scaled concentrations of $[A]$ and $[B]$,\nrespectively. Implement a numerical scheme that can be used to\nfind the solutions\n$u(t)$ and $v(t)$. Visualize $u$ and $v$ in the same plot.',
  'title': 'Simulate a simple chemical reaction',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['chemcial_kinetics_ABn'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:kinetics:ABn',
  'no': 9,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'An $n$-order chemical reaction, generalizing the model in\nExercise ref{decay:app:exer:kinetics:AB}, takes the form\n\n!bt\n\\begin{align*}\n\\frac{d[A]}{dt} &= -k[A]^n,\\\\ \n\\frac{d[B]}{dt} &= k[A]^n,\\\\ \n\\end{align*}\n\n!et\nwhere symbols are as defined in Exercise ref{decay:app:exer:kinetics:AB}.\nBring this model on dimensionless form, using a time scale $[A](0)^{n-1}/k$,\nand show that the dimensionless model simplifies to\n\n!bt\n\\begin{align*}\n\\frac{du}{dt} &= -u^n,\\\\ \n\\frac{dv}{dt} &= u^n,\\\\ \n\\end{align*}\n\n!et\nwith $u(0)=1$ and $v(0)=\\alpha = [B](0)/[A](0)$. Solve numerically for\n$u(t)$ and show a plot with $u$ for $n=0.5, 1, 2, 4$.',
  'title': 'Simulate an $n$-th order chemical reaction',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['biochem'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:MMK',
  'no': 10,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': 'Replacing the unknowns and $t$ by their dimensionless equivalents\nleads to\n\n!bt\n\\begin{align*}\n\\frac{d\\bar Q}{d\\bar t} &= t_ck_+\\frac{E_0S_0}{Q_c}\\bar E\\bar S\n- t_c(k_v + k_-)\\bar Q,\\\\ \n\\frac{d\\bar P}{d\\bar t} &= t_ck_v\\frac{Q_c}{P_c}\\bar Q,\\\\ \n\\frac{d\\bar S}{d\\bar t} &= -t_ck_+E_0\\bar E\\bar S\n+ t_ck_-\\frac{Q_c}{S_0}\\bar Q,\\\\ \n\\frac{d\\bar E}{d\\bar t} &= -t_ck_+S_0\\bar E\\bar S\n+ t_c(k_- + k_v)\\frac{Q_c}{E_0}\\bar Q\\tp\n\\end{align*}\n\n!et\nInserting the choice of scales brings us to the given equations, after\nquite some algebra and identifying coefficients in terms of the\nprovided dimensionless numbers.',
             'text': 'Scale (ref{decay:app:MMK:ES1})-(ref{decay:app:MMK:E1}) such that\nwe can work with dimensionless parameters, which are easier to prescribe.\nIntroduce\n\n!bt\n\\[ \\bar Q = \\frac{[ES]}{Q_c},\\quad\n\\bar P = \\frac{P}{P_c},\\quad \\bar S = \\frac{S}{S_0},\\quad \\bar E = \\frac{E}{E_0},\\quad \\bar t = \\frac{t}{t_c},\\]\n\n!et\nwhere appropriate scales are\n\n!bt\n\\[ Q_c = \\frac{S_0E_0}{K},\\quad P_c = Q_c, \\quad t_c=\\frac{1}{k_+E_0},\\]\n\n!et\nwith $K=(k_v+k_-)/k_+$ (Michaelis constant). Show that the scaled\nsystem becomes\n\n!bt\n\\begin{equation}\n\\frac{d\\bar Q}{d\\bar t} = \\alpha (\\bar E\\bar S\n- \\bar Q),\nlabel{decay:app:MMK:Q2}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\frac{d\\bar P}{d\\bar t} = \\beta\\bar Q,\nlabel{decay:app:MMK:P2}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\frac{d\\bar S}{d\\bar t} = -\\bar E\\bar S\n+ (1 - \\beta\\alpha^{-1})\\bar Q,\nlabel{decay:app:MMK:S2}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\epsilon\\frac{d\\bar E}{d\\bar t} = -\\bar E\\bar S + \\bar Q,\nlabel{decay:app:MMK:E2}\n\\end{equation}\n\n!et\nwhere we have three dimensionless parameters\n\n!bt\n\\[ \\alpha = \\frac{K}{E_0},\\quad \\beta = \\frac{k_v}{k_+ E_0},\\quad\n\\epsilon = \\frac{E_0}{S_0}\\tp\n\\]\nThe corresponding initial conditions are $\\bar Q=\\bar P=0$ and\n$\\bar S=\\bar E=1$.\n\n!et'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': 'Let us use Odespy to solve the differential equations, although a plain\nForward Euler scheme will be fine.\n\n!bc pycod\nimport odespy\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sys\n\ndef solver(alpha, beta, epsilon, T, dt=0.1):\n    def f(u, t):\n        Q, P, S, E = u\n        return [\n            alpha*(E*S - Q),\n            beta*Q,\n            -E*S + (1-beta/alpha)*Q,\n            (-E*S + Q)/epsilon,\n            ]\n\n    Nt = int(round(T/dt))\n    t_mesh = np.linspace(0, Nt*dt, Nt+1)\n\n    solver = odespy.RK4(f)\n    solver.set_initial_condition([0, 0, 1, 1])\n    u, t = solver.solve(t_mesh)\n    Q = u[:,0]\n    P = u[:,1]\n    S = u[:,2]\n    E = u[:,3]\n    return Q, P, S, E\n\n!ec',
             'text': 'Implement a function for\nsolving (ref{decay:app:MMK:Q2})-(ref{decay:app:MMK:E2}).'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': "Adding\n(ref{decay:app:MMK:ES1}) and (ref{decay:app:MMK:E1}) shows that\n\n!bt\n\\[ \\frac{d[ES]}{dt} + \\frac{d[E]}{dt} = 0,\\]\n\n!et\nand therefore $[ES] + [E]=\\hbox{const}$. Since $[ES](0)=0$ and\n$[E](0)=E_0$, the constant is $E_0$ at $t=0$ and will remain so.\nSimilarly, adding (ref{decay:app:MMK:ES1}),\n(ref{decay:app:MMK:S1}), and (ref{decay:app:MMK:P1})\nshows that their time derivatives sum up to zero, and therefore\n$[ES] + [S] + [P] =\\hbox{const}$. Since $[P](0)=0$, the constant\nmust be $0+S_0+0=S_0$.\n\nTo use the conservation as a consistency check in the software, we need\nto find the equivalent dimensionless versions:\n\n!bt\n\\[ [ES] + [E] = E_0\\quad\\Rightarrow\\quad Q_c\\bar Q + E_0\\bar E = E_0,\\]\n\n!et\nand from this we get, after a little algebra,\n\n!bt\n\\[ \\alpha^{-1}\\epsilon^{-1}\\bar Q + \\bar E = 1\\tp\\]\n\n!et\nThe other conservation equation becomes\n\n!bt\n\\[ \\bar Q + \\alpha\\bar S + \\bar P  = \\alpha\\tp\\]\n\n!et\n\nThe implementation may go like\n\n!bc pycod\ncomputed = Q[n+1]/(alpha*epsilon) + E[n+1]\nexpected = 1\ndiff1 = abs(computed - expected)\n\ncomputed = Q[n+1] + alpha*S[n+1] + P[n+1]\nexpected = alpha\ndiff2 = abs(computed - expected)\n\ntol = 1E-14\nif diff1 < tol or diff2 < tol:\n    print '*** Consistency check failed:', diff1, diff2\n\n!ec",
             'text': 'There are two conservation equations implied by\n(ref{decay:app:MMK:ES1})-(ref{decay:app:MMK:E1}):\n\n!bt\n\\begin{equation}\n[ES] + [E] = E_0,\nlabel{_auto28}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n[ES] + [S] + [P] = S_0\\tp\nlabel{_auto29}\n\\end{equation}\n\n!et\nDerive these two equations. Use these properties in the function\nin b) to do a partial verification of the solution at each time step.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': "!bc pycod\ndef demo():\n    alpha = 1\n    beta = 4\n    epsilon = 0.1\n    T = 8\n    dt = float(sys.argv[1]) if len(sys.argv) >= 2 else 0.1\n    Q, P, S, E = solver(alpha, beta, epsilon, T, dt)\n    plt.plot(t, Q, t, P, t, S, t, E)\n    plt.legend(['complex', 'product', 'substrate', 'enzyme'],\n               loc='upper right')\n    plt.title('alpha=%g, beta=%g, epsilon=%g' %\n              (alpha, beta, epsilon))\n    plt.savefig('tmp.png');  plt.savefig('tmp.pdf')\n    plt.show()\n\nif __name__ == '__main__':\n    demo()\n\n!ec\n\nFIGURE: [fig-models/biochem, width=700 frac=1]",
             'text': 'Simulate a case with $T=8$, $\\alpha = 1$, $\\beta=4$, and two\n$\\epsilon$ values: 0.9 and 0.1.'}],
  'text': 'The purpose of this exercise is to simulate the ODE system\n(ref{decay:app:MMK:ES1})-(ref{decay:app:MMK:E1}) modeling a simple\nbiochemical process.',
  'title': 'Simulate a biochemical process',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['SIR'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:SIR',
  'no': 11,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': 'We introduce\n\n!bt\n\\[ \\bar t = \\frac{t}{\\nu^{-1}},\\quad \\bar S = \\frac{S}{N},\\quad\n\\bar I = \\frac{I}{N},\\quad \\bar R = \\frac{R}{N}\\tp\\]\n\n!et\nInserting these expressions in the governing equations and dividing by\n$\\nu N$ gives the listed dimensionless ODEs. The scaled initial condition\nfor $\\bar S(0)$ follows from\n$\\bar S(0) = S(0)/N = (N-I(0))/N = 1 - \\alpha$, since initially,\n$R(0)=0$ and therefore $N=S(0) + I(0)$.',
             'text': 'Estimating the parameter $\\beta$\nis difficult so it can be handy to scale the equations. Use\n$t_c=1/\\nu$ as time scale, and scale $S$, $I$, and $R$ by\nthe population size $N=S(0)+I(0)+R(0)$. Show that the resulting dimensionless\nmodel becomes\n\n!bt\n\\begin{equation}\n\\frac{d\\bar S}{d\\bar t} = - R_0\\bar S\\bar I,\nlabel{decay:app:SIR:S2}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\frac{d\\bar I}{d\\bar t} = R_0 \\bar S\\bar I - \\bar I,\nlabel{decay:app:SIR:I2}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\frac{d\\bar R}{d\\bar t} = I,\nlabel{decay:SIR:R2}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\bar S(0) = 1-\\alpha,\nlabel{_auto30}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\bar I(0) = \\alpha,\nlabel{_auto31}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\bar R(0) = 0,\nlabel{_auto32}\n\\end{equation}\n\n!et\nwhere $R_0$ and $\\alpha$ are the only parameters in the problem:\n\n!bt\n\\[ R_0 = \\frac{N\\beta}{\\nu}, \\quad \\alpha = \\frac{I(0)}{N}\\tp\\]\n\n!et\nA quantity with a bar denotes a dimensionless version of that quantity, e.g,\n$\\bar t$ is dimensionless time, and $\\bar t = \\nu t$.'},
            {'answer': '',
             'file': None,
             'hints': ['Spreading means $dI/dt>0$.'],
             'solution': 'For $dI/dt$ to be positive, we must have $(R_0 \\bar S - 1)\\bar I > 0$, i.e.,\n$R_0 \\bar S - 1 > 0$ since $\\bar I\\geq 0$. At $t=0$, we get\n$R_0 \\bar S(0) > 1$ as the criterion, or\n\n!bt\n\\[\n\\tilde R_0\\bar S(0) = \\frac{N\\beta}{\\nu}\\frac{S(0)}{N} = \\frac{S(0)\\beta}{\\nu} >1\n\\tp\\]\n\n!et\nThe dimensionless parameter $S(0)\\beta /\\nu$ is denoted by $R_0$ in\nthe epidemiology literature and known as the *basic reproductive number*.',
             'text': 'Show that the $R_0$ parameter governs whether the disease will spread\nor not at $t=0$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': "We may use Odespy and the RK4 method to solve the system:\n\n!bc pycod\nimport odespy\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sys\n\ndef solver(R0, alpha, T, dt=0.1):\n    def f(u, t):\n        S, I, R = u\n        return [\n            -R0*S*I,\n            R0*S*I - I,\n            I]\n\n    Nt = int(round(T/dt))\n    t_mesh = np.linspace(0, Nt*dt, Nt+1)\n\n    solver = odespy.RK4(f)\n    solver.set_initial_condition([1-alpha, alpha, 0])\n    u, t = solver.solve(t_mesh)\n    S = u[:,0]\n    I = u[:,1]\n    R = u[:,2]\n    # Consistency check\n    N = 1\n    tol = 1E-15\n    for i in range(len(S)):\n        if abs(S[i] + I[i] + R[i] - N) > tol:\n            print 'Consistency error: S+I+R=%g != %g' % \\ \n                  (S[i] + I[i] + R[i], N)\n    return S, I, R, t\n\n!ec",
             'text': 'Implement the scaled SIR model. Check at every time step,\nas a verification, that\n$\\bar S + \\bar I + \\bar R = 1$.'},
            {'aftertext': '\n',
             'answer': '',
             'file': None,
             'hints': [],
             'solution': "The given data means that $\\bar I(0)=\\alpha = 0.02$ and $\\bar S(0)=0.98$.\n\n!bc pycod\ndef demo():\n    alpha = 0.02\n    R0 = 5\n    T = 8\n    dt = float(sys.argv[1]) if len(sys.argv) >= 2 else 0.1\n    S, I, R, t = solver(R0, alpha, T, dt)\n    plt.plot(t, S, t, I, t, R)\n    plt.legend(['S', 'I', 'R'], loc='lower right')\n    plt.title('R0=%g, alpha=%g' % (R0, alpha))\n    plt.savefig('tmp.png');  plt.savefig('tmp.pdf')\n    plt.show()\n\n!ec\n\nFIGURE: [fig-models/SIR1, width=800 frac=1]",
             'text': 'Simulate the spreading of a disease where $R_0=2, 5$ and 2 percent of\nthe population is infected at time $t=0$.'}],
  'text': 'The SIR model (ref{decay:app:SIR:S})-(ref{decay:app:SIR:R}) can be used\nto simulate spreading of an epidemic disease.',
  'title': 'Simulate spreading of a disease',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['predator_prey'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:predprey',
  'no': 12,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': 'We introduce dimensionless time $\\bar t=t/t_c$, where $t_c^{-1}=bH_0$,\nand scale $H$ and $L$\nas $\\bar H = H/H_0$ and $\\bar L = L/H_0$. Inserted in the equations, we\narrive at\n\n!bt\n\\begin{align*}\n\\frac{H_0}{t_c}\\frac{d\\bar H}{d\\bar t} &= H_0\\bar H(a - bH_0\\bar L),\n\\\\ \n\\frac{H_0}{t_c}\\frac{d\\bar L}{d\\bar t} &= H_0\\bar L(dH_0\\bar H - c)\\tp\n\\end{align*}\n\n!et\nInserting $t_c^{-1}=bH_0$ and rearranging simplify the equations to\n\n!bt\n\\begin{align*}\n\\frac{d\\bar H}{d\\bar t} &= \\frac{a}{bH_0}\\bar H  - \\bar L\\bar H,\n\\\\ \n\\frac{d\\bar L}{d\\bar t} &= \\frac{d}{b}\\bar L \\bar H - \\frac{c}{bH_0}\\bar L)\\tp\n\\end{align*}\n\n!et\nThe initial conditions become $\\bar H(0)=1$, $\\bar L(0)=L_0/H_0$.\nWith the dimensionless parameters\n\n!bt\n\\[ \\alpha = \\frac{a}{bH_0},\\quad\\beta = \\frac{d}{b},\\quad\\gamma =\n\\frac{c}{bH_0},\\quad \\delta = \\frac{H_0}{L_0},\\]\n\n!et\nwe can write the dimensionless problem as\n\n!bt\n\\begin{align*}\n\\frac{d\\bar H}{d\\bar t} &= \\alpha\\bar H  - \\bar L\\bar H,\\\\ \n\\frac{d\\bar L}{d\\bar t} &= \\beta\\bar L \\bar H - \\gamma\\bar L),\\\\ \n\\bar H(0) &= 1,\\\\ \n\\bar L(0) &= \\delta \\tp\n\\end{align*}\n\n!et\n\nThe quantity $bH_0$ is the number of eaten preys per predator.\nThen $\\alpha$ measures the ratio of natural population growth of\nthe prey, due to nutrition, and the number of eaten preys per predator.\nThe $\\beta$ parameter measures the fraction of the eaten preys and\nthe amount of this that actually\nleads to population growth of the predator.\nThe number $\\gamma$ reflects the ratio of\npredator deaths and the eaten preys per predator, and $\\delta$ is\nthe initial fraction of preys and predators.',
             'text': 'Scale the equations (ref{decay:app:predprey:eqH})-(ref{decay:app:predprey:eqL}).\nUse the initial population $H(0)=H_0$ of $H$ has scale for $H$ and $L$, and\nlet the time scale be $1/(bH_0)$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': "Here are two functions:\n\n!bc pycod\nimport odespy\nimport numpy as np\n#import scitools.std as plt\nimport matplotlib.pyplot as plt\nfig_counter = 0  # used in plot file names\n\ndef simulate(alpha, beta, gamma, delta, T=20):\n    def f(u, t, alpha, beta, gamma):\n        H, L = u\n        return [alpha*H - L*H, beta*L*H - gamma*L]\n\n\n    t = np.linspace(0, T, 1501)\n    solver = odespy.RK4(f, f_args=(alpha, beta, gamma))\n    solver.set_initial_condition([1, delta])\n    u, t = solver.solve(t)\n    H = u[:,0]\n    L = u[:,1]\n\n    plt.figure()\n    global fig_counter\n    fig_counter += 1\n    plt.plot(t, H, t, L)\n    plt.legend(['H', 'L'])\n    plt.title(r'$\\alpha=%g$, $\\beta=%g$, $\\gamma=%g$, $\\delta=%g$'\n              % (alpha, beta, gamma, delta))\n    plt.savefig('tmp%d.png' % fig_counter)\n    plt.savefig('tmp%d.pdf' % fig_counter)\n    return H, L, t\n\ndef demo():\n    simulate(alpha=1.5, beta=0.5, gamma=0.8, delta=0.5, T=20)\n    simulate(alpha=0.5, beta=0.5, gamma=0.2, delta=0.5, T=50)\n\n!ec\nWe must call `demo()` from the main program.\n\nHere are two examples. The one to the left has a good birth-death rate\ncompared to how many that are eaten by predators ($\\alpha=1.5$),\nhalf of the eaten preys contribute to growth of the predator population\n($\\beta = 0.5$), the death rate of predators is slightly smaller than how many\npreys they eat (per predator) ($\\gamma=0.8$), and we start out with\ntwice as many preys as predators.\n\nThe figure to the right features less nutrition for the preys\ncompared to being eaten\nby predators ($\\alpha =0.5$), and a lower death rate in the predator\npopulation. Note the different scales in the two plots.\n\nFIGURE: [fig-models/predator_prey, width=800 frac=1]",
             'text': 'Implement the scaled model from a). Run illustrating cases how the\ntwo populations develop.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': 'Inserting\n\n!bt\n\\[ \\bar t = \\frac{t}{c_c},\\quad \\bar H=\\frac{H}{H_c},\\quad \\bar L\n= \\frac{L}{L_c},\\]\n\n!et\nin the ODEs (ref{decay:app:predprey:eqH})-(ref{decay:app:predprey:eqL}),\nwe arrive at\n\n!bt\n\\begin{align*}\n\\frac{H_c}{t_c}\\frac{d\\bar H}{d\\bar t} &= H_c\\bar H(a - bL_c\\bar L),\\\\ \n\\frac{L_c}{t_c}\\frac{d\\bar L}{d\\bar t} &= L_c\\bar L(dH_c\\bar H - c)\\tp\n\\end{align*}\n\n!et\nNow we divide by $H_c$ and $L_c$ in the $H$ and $L$ equations, respectively,\nand multiply by $t_c$:\n\n!bt\n\\begin{align*}\n\\frac{d\\bar H}{d\\bar t} &= t_c\\bar H(a - bL_c\\bar L),\\\\ \n\\frac{d\\bar L}{d\\bar t} &= t_c\\bar L(dH_c\\bar H - c)\\tp\n\\end{align*}\n\n!et\nChoosing $t_c=1/a$ and $t_caL_c=1$, i.e., $L_c=a/b$, makes the\nfirst equation free of parameters: $\\bar H^{\\prime}=\\bar H(1-\\bar L)$.\nFactoring out $c$ in the equation for $L$ and choosing\n$H_c d/c=1$, i.e., $H_c=c/d$, leaves us with the $L$ equation\nas $\\bar L^{\\prime}=(c/a)\\bar L(\\bar H-1)$. The ratio $c/a$ equals\n$\\gamma/\\alpha$ from a) and is here called $\\mu$.\n\nWe remark that $L_c=a/b$ and $H_c=c/d$ could also be found from\nthe *stationary points* of the ODE system, where\n$H^{\\prime}=L^{\\prime}=0$. The stationary points are in our case $H=L=0$ and\n$H=c/d$ and $L=a/b$.\n\nThe initial conditions become $\\bar H(0) = H_0/H_c=H_0d/c =\\beta/\\gamma = \\nu$,\nand $\\bar L(0)=L_0/L_c = L_0b/a = \\delta/\\alpha = \\omega$.\n\nThe resulting dimensionless problem takes the form\n\n!bt\n\\begin{equation}\n\\frac{d\\bar H}{d\\bar t} = \\bar H(1 - \\bar L),\nlabel{_auto33}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\frac{d\\bar L}{d\\bar t} = \\mu \\bar L(\\bar H - 1) = \\gamma\\alpha^{-1} \\bar L(\\bar H - 1),\nlabel{_auto34}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\bar H(0) = \\nu = \\beta/\\gamma,\nlabel{_auto35}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\bar L(0) = \\omega = \\delta/\\alpha,\nlabel{_auto36}\n\\end{equation}\n\n!et\nwith\n\n!bt\n\\[ \\mu = \\frac{c}{a},\\quad \\nu = H_0\\frac{d}{c},\\quad \\omega = L_0\\frac{b}{a}\n\\tp\\]\n\n!et\n\nThe unknowns $\\bar H$ and $\\bar L$ now have less intuitive scalings,\n\n!bt\n\\[ \\bar H = \\frac{Hd}{c},\\quad \\bar L = \\frac{Lb}{a},\\]\n\n!et\nwhile time is measured in the units based on the exponential growth\ndue to births and deaths of preys ($a$). The number of dimensionless parameters\nis one less since we have one more scale (for $L_c$) at our\ndisposal. Simplicity in one initial conditions in a) is\nexchanged with more simplicity in the ODEs, which now have\nonly one dimensionless parameter. Note that $\\nu$ and $\\omega$ must be\ndifferent from unity to avoid $\\bar H\\neq 0$ and $\\bar L\\neq 0$ because\nof the factors $1-L$ and $H-1$ in the equations that can make\n$\\bar H^{\\prime}=0$ and $\\bar L^{\\prime}=0$.',
             'text': 'The scaling in a) used a scale for $H$ and $L$ based on the\ninitial condition $H(0)=H_0$. An alternative scaling is to make\nthe ODEs as simple as possible by introducing separate scales\n$H_c$ and $L_c$ for $H$ and $L$, respectively. Fit $H_c$,\n$L_c$, and the time scale $t_c$ such that there are as few\ndimensionless parameters as possible in the ODEs. Scale the initial\nconditions. Compare the number and type of dimensionless parameters\nwith a).'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': "Modified `simulate` and `demo` go as follows.\n\n!bc pycod\ndef simulate2(mu, nu, omega, T=20):\n    def f(u, t, mu):\n        H, L = u\n        return [H*(1-L), mu*L*(H-1)]\n\n\n    t = np.linspace(0, T, 1501)\n    solver = odespy.RK4(f, f_args=(mu,))\n    solver.set_initial_condition([nu, omega])\n    u, t = solver.solve(t)\n    H = u[:,0]\n    L = u[:,1]\n\n    plt.figure()\n    global fig_counter\n    fig_counter += 1\n    plt.plot(t, H, t, L)\n    plt.legend(['H', 'L'])\n    plt.title(r'$\\mu=%g$, $\\nu=%g$, $\\omega=%g$' % (mu, nu, omega))\n    plt.savefig('tmp%d.png' % fig_counter)\n    plt.savefig('tmp%d.pdf' % fig_counter)\n    return H, L, t\n\ndef demo2():\n    simulate2(mu=0.5, nu=0.5, omega=1.5, T=20)\n    simulate2(mu=2, nu=0.5, omega=1.5, T=20)\n\n!ec\n\nFIGURE: [fig-models/predator_prey2, width=800 frac=1]",
             'text': 'Compute with the scaled model from c) and create plots to illustrate\nthe typical solutions.'}],
  'text': 'Section ref{decay:app:predprey} describes a model for the\ninteraction of predator and prey populations, such as lynx and hares.',
  'title': 'Simulate predator-prey interaction',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['atmospheric_pressure'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:atm1',
  'no': 13,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'We consider the models for atmospheric pressure in\nSection ref{decay:app:atm}.\nMake a program with three functions,\n\n * one computing the pressure $p(z)$ using a seven-layer model\n   and varying $L$,\n * one computing $p(z)$ using a seven-layer model,\n   but with constant temperature in each layer, and\n * one computing $p(z)$ based on the\n   one-layer model.\n\nHow can these implementations be verified? Should ease of verification\nimpact how you code the functions?\nCompare the three models in a plot.',
  'title': 'Simulate the pressure drop in the atmosphere',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['vertical_motion'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:drag:prog',
  'no': 14,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Implement the Stokes' drag model (ref{decay:app:fallingbody:model:S})\nand the quadratic drag model (ref{decay:app:fallingbody:model:q}) from\nSection ref{decay:app:drag}, using the Crank-Nicolson\nscheme and a geometric mean for $|v|v$ as explained, and assume\nconstant fluid density.\nAt each time level, compute the Reynolds number\nRe and choose the Stokes' drag model if $\\hbox{Re} < 1$ and the\nquadratic drag model otherwise.\n\nThe computation of the numerical solution should take place either in\na stand-alone function or in a solver class that looks up a problem\nclass for physical data. Create a module and equip it with pytest/nose\ncompatible test functions for automatically verifying the code.\n\nVerification tests can be based on\n\n * the terminal velocity (see Section ref{decay:app:drag}),\n * the exact solution when the drag force is neglected\n   (see Section ref{decay:app:drag}),\n * the method of manufactured solutions (see Section ref{decay:MMS})\n   combined with computing\n   convergence rates (see Section ref{decay:convergence:rate}).\n\nUse, e.g., a quadratic polynomial for the velocity in the method of\nmanufactured solutions. The expected error is $\\Oof{\\Delta t^2}$\nfrom the centered finite difference approximation and the geometric\nmean approximation for $|v|v$.\n\nA solution that is linear in $t$ will also be an exact solution of the\ndiscrete equations in many problems.  Show that this is true for\nlinear drag (by adding a source term that depends on $t$), but not\nfor quadratic drag because of the geometric mean approximation.  Use\nthe method of manufactured solutions to add a source term *in the\ndiscrete equations for quadratic drag* such that a linear function of\n$t$ is a solution. Add a test function for checking that the linear\nfunction is reproduced to machine precision in the case of both linear\nand quadratic drag.\n\nApply the software to a case where a ball rises in water.  The\nbuoyancy force is here the driving force, but the drag will be\nsignificant and balance the other forces after a short time.  A soccer\nball has radius 11 cm and mass 0.43 kg.  Start the motion from rest, set\nthe density of water, $\\varrho$, to $1000\\hbox{ kg/m}^3$, set the\ndynamic viscosity, $\\mu$, to $10^{-3}\\hbox{ Pa s}$, and use a drag\ncoefficient for a sphere: 0.45. Plot the velocity of the rising ball.",
  'title': 'Make a program for vertical motion in a fluid',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['parachuting'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:parachute',
  'no': 15,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Set up the differential equation problem that governs the velocity\nof the motion.\nThe parachute jumper is subject to the gravity force and a quadratic\ndrag force. Assume constant density.\nAdd an extra source term to be used for program verification.\nIdentify the input data to the problem.'},
            {'answer': '',
             'file': None,
             'hints': ['Use the Crank-Nicolson scheme with a geometric mean of $|v|v$ in time to\nlinearize the equation of motion with quadratic drag.',
                       'You can either use functions or classes for implementation.\nIf you choose functions, make a function\n`solver` that takes all the input data in the problem as\narguments and that returns the velocity (as a mesh function) and\nthe time mesh. In case of a class-based implementation, introduce\na problem class with the physical data\nand a solver class with the numerical data and a `solve` method\nthat stores the velocity and the mesh in the class.\n\nAllow for a time-dependent area and drag coefficient in the\nformula for the drag force.'],
             'solution': '',
             'text': 'Make a Python module for computing the velocity of the motion.\nAlso equip the module with functionality for plotting the velocity.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Show that a linear function of $t$ does not fulfill the discrete\nequations because of the geometric mean approximation\nused for the quadratic drag\nterm.  Fit a source term, as in the method of manufactured solutions,\nsuch that a linear function of $t$ is a solution of the discrete\nequations. Make a test function to check that this solution is reproduced\nto machine precision.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'The expected error in this problem goes like $\\Delta t^2$ because we\nuse a centered finite difference approximation with error $\\Oof{\\Delta t^2}$\nand a geometric mean approximation with error $\\Oof{\\Delta t^2}$.\nUse the method of manufactured solutions combined with computing\nconvergence rate to verify the code. Make a test function for checking\nthat the convergence rate is correct.'},
            {'answer': '',
             'file': None,
             'hints': ['You can either make a function `forces(v, t, plot=None)`\nthat returns the forces (as mesh functions) and `t`, and shows\na plot on the screen and also saves the plot to a file with name\nstored in `plot`\nif `plot` is not `None`, or you can extend the solver class with\ncomputation of forces and include plotting of forces in the\nvisualization class.'],
             'solution': '',
             'text': 'Compute the drag force, the gravity\nforce, and the buoyancy force as a function of time. Create\na plot with these three forces.'},
            {'answer': '',
             'file': None,
             'hints': ['Meade and Struthers cite{parachute_1999} provide some data relevant\nto "skydiving": "http://en.wikipedia.org/wiki/Parachuting".\nThe mass of the human body and equipment\ncan be set to $100$ kg.\nA skydiver in spread-eagle formation has a cross-section of 0.5 $\\hbox{m}^2$\nin the horizontal plane.\nThe density of air decreases with altitude, but can be taken\nas constant, 1 $\\hbox{kg/m}^3$, for altitudes relevant to\nskydiving (0-4000 m).\nThe drag coefficient for a man in upright position can be set to 1.2.\nStart with a zero velocity.\nA free fall typically has a terminating velocity of 45 m/s. (This value\ncan be used to tune other parameters.)'],
             'solution': '',
             'text': 'Compute the velocity of\na skydiver in free fall before the parachute opens.'},
            {'answer': '',
             'file': None,
             'hints': ['Following Meade and Struthers cite{parachute_1999}, one can set the\ncross-section area perpendicular to the motion to 44 $\\hbox{m}^2$\nwhen the parachute is open. Assume that it takes 8 s to increase\nthe area linearly from the original to the final value.\nThe drag coefficient for an open\nparachute can be taken as 1.8, but tuned using the known value\nof the typical terminating velocity reached before landing:\n5.3 m/s. One can take the drag coefficient as a piecewise constant\nfunction with an abrupt change at $t_p$.\nThe parachute is typically released after $t_p=60$ s, but\nlarger values of $t_p$ can be used to make plots more illustrative.'],
             'solution': '',
             'text': 'The next task is to simulate\na parachute jumper during free fall and after the parachute opens.\nAt time $t_p$, the parachute opens and\nthe drag coefficient and the cross-sectional\narea change dramatically.\nUse the program to simulate a jump from $z=3000$ m to the ground $z=0$.\nWhat is the maximum acceleration, measured in units of $g$,\nexperienced by the jumper?'}],
  'text': 'The aim of this project is to develop a general solver for the\nvertical motion of a body with quadratic air drag, verify the solver,\napply the solver to a skydiver in free fall, and finally apply the\nsolver to a complete parachute jump.\n\nAll the pieces of software implemented in this project should be\nrealized as Python functions and/or classes and collected in one\nmodule.',
  'title': 'Simulate parachuting',
  'type': 'Project',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['falling_in_variable_density'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:drag:atm1',
  'no': 16,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Vertical motion of a body in the atmosphere needs to take into\naccount a varying air density if the range of altitudes is\nmany kilometers. In this case, $\\varrho$ varies with the altitude $z$.\nThe equation of motion for the body is given in\nSection ref{decay:app:drag}. Let us assume quadratic drag force\n(otherwise the body has to be very, very small).\nA differential equation problem for the air density, based on\nthe information for the one-layer atmospheric model in\nSection ref{decay:app:atm}, can be set up as\n\n!bt\n\\begin{equation}\np^{\\prime}(z) = -\\frac{Mg}{R^*(T_0+Lz)} p,\nlabel{_auto37}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\varrho = p \\frac{M}{R^*T}\n\\tp\nlabel{_auto38}\n\\end{equation}\n\n!et\nTo evaluate $p(z)$ we need the altitude $z$. From the principle that the\nvelocity is the derivative of the position we have that\n\n!bt\n\\begin{equation}\nz^{\\prime}(t) = v(t),\nlabel{_auto39}\n\\end{equation}\n\n!et\nwhere $v$ is the velocity of the body.\n\nExplain in detail how the governing equations can be discretized\nby the Forward Euler and the Crank-Nicolson methods.\nDiscuss pros and cons of the two methods.',
  'title': 'Formulate vertical motion in the atmosphere',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['falling_in_variable_density'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:drag:atm2',
  'no': 17,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Implement the Forward Euler or the Crank-Nicolson scheme\nderived in Exercise ref{decay:app:exer:drag:atm1}.\nDemonstrate the effect of air density variation on a falling\nhuman, e.g., the famous fall of "Felix Baumgartner": "http://en.wikipedia.org/wiki/Felix_Baumgartner". The drag coefficient can be set to 1.2.',
  'title': 'Simulate vertical motion in the atmosphere',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['signum'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:signum',
  'no': 18,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Consider the ODE problem\n!bt\n\\[\ny^{\\prime}(x) = \\left\\lbrace\\begin{array}{ll}\n-1, & x < 0,\\\\ \n1, & x \\geq 0\n\\end{array}\\right.\\quad x\\in (-1, 1],\n\\quad y(1-)=1,\n\\]\n\n!et\nwhich has the solution $y(x)=|x|$.\nUsing a mesh $x_0=-1$, $x_1=0$, and $x_2=1$, calculate by hand\n$y_1$ and $y_2$ from the Forward Euler, Backward Euler, Crank-Nicolson,\nand Leapfrog methods. Use all of the former three methods for computing\nthe $y_1$ value to be used in the Leapfrog calculation of $y_2$.\nThereafter, visualize how these schemes perform for a uniformly partitioned\nmesh with $N=10$ and $N=11$ points.',
  'title': 'Compute $y=|x|$ by solving an ODE',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['random_interest'],
  'heading': '=====',
  'hints': ['The following code snippet computes $p^{n+1}$:\n27 <<<!!CODE_BLOCK  pycod',
            'If $u_i(t)$ is the value of the fortune in experiment number $i$,\n$i=0,\\ldots,N-1$,\nthe mean evolution of the fortune is\n175 <<<!!MATH_BLOCK\nand the standard deviation is\n176 <<<!!MATH_BLOCK\nSuppose $u_i(t)$ is stored in an array `u`.\nThe mean and the standard deviation of the fortune\nis most efficiently computed by\nusing two accumulation arrays, `sum_u` and `sum_u2`, and\nperforming `sum_u += u` and `sum_u2 += u**2` after every experiment.\nThis technique avoids storing all the $u_i(t)$ time series for\ncomputing the statistics.'],
  'keywords': None,
  'label': 'decay:app:exer:interest',
  'no': 19,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The goal of this exercise is to compute the value of a fortune subject\nto inflation and a random interest rate.\nSuppose that the inflation is constant at $i$ percent per year and that the\nannual interest rate, $p$, changes randomly at each time step,\nstarting at some value $p_0$ at $t=0$.\nThe random change is from a value $p^n$ at $t=t_n$ to\n$p_n +\\Delta p$ with probability 0.25 and $p_n -\\Delta p$ with probability 0.25.\nNo change occurs with probability 0.5. There is also no change if\n$p^{n+1}$ exceeds 15 or becomes below 1.\nUse a time step of one month, $p_0=i$, initial fortune scaled to 1,\nand simulate 1000 scenarios of\nlength 20 years. Compute the mean evolution of one unit of money and the\ncorresponding\nstandard deviation. Plot the mean curve along with the mean plus one\nstandard deviation and the mean minus one standard deviation. This will\nillustrate the uncertainty in the mean curve.',
  'title': 'Simulate fortune growth with random interest rate',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['population.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:pop:at',
  'no': 20,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Assume that there is a sudden drop (increase) in the birth (death)\nrate at time $t=t_r$,\nbecause of limited nutrition or food supply:\n!bt\n\\[ r(t) =\\left\\lbrace\\begin{array}{ll}\n\\varrho, & t < t_r,\\\\ \n\\varrho - A, & t\\geq t_r,\\end{array}\\right.\n\\]\n\n!et\nThis drop in population growth is compensated by a sudden net immigration\nat time $t_f > t_r$:\n!bt\n\\[ f(t) =\\left\\lbrace\\begin{array}{ll}\n0, & t < t_f,\\\\ \nf_0, & t\\geq t_a,\\end{array}\\right.\n\\]\n\n!et\nStart with $\\varrho$ and make $A > \\varrho$. Experiment with\nthese and other parameters to\nillustrate the interplay of growth and decay in such a problem.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Now we assume that the environmental conditions changes periodically with\ntime so that we may take\n!bt\n\\[ r(t) = {\\varrho} + A\\sin\\left(\\frac{2\\pi}{P}t\\right)\n\\tp\n\\]\n\n!et\nThat is, the combined birth and death rate oscillates around $\\varrho$ with\na maximum change of $\\pm A$ repeating over a period of length $P$ in time.\nSet $f=0$ and experiment with the other parameters to illustrate typical\nfeatures of the solution.'}],
  'text': 'We shall study a population modeled by (ref{decay:app:pop:ueq}) where\nthe environment, represented by $r$ and $f$, undergoes changes with time.',
  'title': 'Simulate a population in a changing environment',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['logistic_CN'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:pop:logistic1',
  'no': 21,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Solve the logistic ODE\n(ref{decay:app:pop:logistic}) using a Crank-Nicolson scheme where\n$(u^{n+\\half})^2$ is approximated by a *geometric mean*:\n!bt\n\\[ (u^{n+\\half})^2 \\approx u^{n+1}u^n\n\\tp\n\\]\n\n!et\nThis trick makes the discrete equation linear in $u^{n+1}$.',
  'title': 'Simulate logistic growth',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['interest_modeling'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:interest:derive',
  'no': 22,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The ODE model (ref{decay:app:interest:eq2}) was derived under the assumption\nthat $r$ was constant. Perform an alternative derivation without\nthis assumption: 1) start with (ref{decay:app:interest:eq1});\n2) introduce a time step $\\Delta t$ instead of $m$: $\\Delta t = 1/m$ if\n$t$ is measured in years; 3) divide by $\\Delta t$ and take the\nlimit $\\Delta t\\rightarrow 0$. Simulate a case where the inflation is\nat a constant level $I$ percent per year and the interest rate oscillates:\n$r=-I/2 + r_0\\sin(2\\pi t)$.\nCompare solutions for $r_0=I, 3I/2, 2I$.',
  'title': 'Rederive the equation for continuous compound interest',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['KelvinVoigt'],
  'heading': '=====',
  'hints': ['To avoid finding proper values of the $E$ and $\\eta$ parameters for\na polymer, one can scale the problem. A common dimensionless\ntime is $\\bar t= tE/\\eta$. Note that $\\varepsilon$ is already\ndimensionless by definition, but it takes on small values, say up to 0.1,\nso we introduce a scaling: $\\bar u=10\\varepsilon$ such that $\\bar u$\ntakes on values up to about unity.\n\nShow that the material model then\ntakes the form $\\bar u^{\\prime} = -\\bar u + 10\\sigma(t)/E$.\nWork with the dimensionless force $F=10\\sigma(t)/E$, and let\n$F=1$ for $\\bar t\\in (0,\\bar t_1)$ and $F=0$ for $\\bar t\\geq \\bar t_1$.\nA possible choice of $t_1$ is the characteristic time $\\eta/E$, which\nmeans that $\\bar t_1 = 1$.'],
  'keywords': None,
  'label': 'decay:app:exer:viscoelasticity1',
  'no': 23,
  'solution': "Inserting the scaling $\\bar u=10\\varepsilon$ and $\\bar t = tE/\\eta$\nin the ODE for $\\varepsilon$ results in\n\n!bt\n\\[ \\frac{E}{10 \\eta}\\frac{d\\bar u}{d\\bar t} = -\\frac{E}{\\eta 10}\\bar u\n+ \\frac{\\sigma(t)}{\\eta}\\tp\\]\n\n!et\nThis reduces to\n\n!bt\n\\[ \\frac{d\\bar u}{d\\bar t} = -\\bar u + \\frac{10\\sigma}{E}\\tp\\]\n\n!et\n\nWe can use the module `decay_vc` for solving $u^{\\prime}=-a(t)u+b(t)$:\n\n!bc pycod\n# Scaled model: u' = -u + b(t), b=1 for t < 1 else 0\neps, t = solver(I=0, a=lambda t: 1,\n                b=lambda t: 1 if t < 1 else 0,\n                T=4, dt=0.01, theta=0.5)\n\nimport matplotlib.pyplot as plt\nplt.plot(t, eps)\nplt.xlabel('Dimensionless time'); plt.ylabel('10*strain')\nplt.savefig('tmp.png');  plt.savefig('tmp.pdf')\nplt.show()\n\n!ec\n\nFIGURE: [fig-models/KelvinVoigt, width=600 frac=0.8]",
  'solution_file': None,
  'subex': [],
  'text': "Stretching a rod made of polymer will cause deformations that are\nwell described with a Kelvin-Voigt material model\n(ref{decay:app:viscoelasticity:se}). At $t=0$ we apply a constant\nforce $\\sigma = \\sigma_0$, but at $t=t_1$, we remove the force\nso $\\sigma=0$. Compute numerically the corresponding strain\n(elongation divided by the rod's length) and visualize how it\nresponds in time.",
  'title': 'Simulate the deformation of a viscoelastic material',
  'type': 'Exercise',
  'type_visible': True}]