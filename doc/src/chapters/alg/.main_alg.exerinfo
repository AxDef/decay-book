
# Information about all exercises in the file main_alg.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main_alg.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': 'In Section ref{decay:computing:error} we show how easy it is to\ncompute a mesh function by array arithmetics (or array computing).\nUsing this technique, one could simply implement `mesh_function(f,t)`\nas `return f(t)`. However, `f(t)` will not work if there are\nif tests involving `t` inside `f` as is the case in b). Typically,\n`if t < 3` must have `t < 3` as a boolean expression, but if `t` is\narray, `t < 3`, is an *array of boolean values*, which is not legal\nas a boolean expression in an if test.\nComputing one element\nat a time as suggested in a) is a way of out of this problem.\n\nWe also remark that the function in b) is the solution of $u^{\\prime}=-au$,\n$u(0)=1$, for $t\\in [0,4]$, where $a=1$ for $t\\in [0,3]$ and $a=3$ for\n$t\\in [3,4]$.',
  'file': ['mesh_function'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:meshfunc',
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': 'The function may look like\n\n!bc pycod\ndef mesh_function(f, t):\n    u = np.zeros(len(t))  # or t.size\n    for i in range(len(t)):\n        u[i] = f(t[i])\n    return u\n\n!ec',
             'text': 'Write a function `mesh_function(f, t)` that returns an array with\nmesh point values $f(t_0),\\ldots,f(t_{N_t})$, where `f` is a Python\nfunction implementing a mathematical function `f(t)` and $t_0,\\ldots,t_{N_t}$\nare mesh points stored in the array `t`. Use a loop over the mesh\npoints and compute one mesh function value at the time.'},
            {'aftertext': '\n\n',
             'answer': '',
             'file': None,
             'hints': [],
             'solution': "An appropriate function is\n\n!bc pycod\ndef demo():\n    def f(t):\n        if t <= 3:\n            return np.exp(-t)\n        else:\n            return np.exp(-3*t)\n\n    # Compute mesh and mesh function\n    t = np.linspace(0, 4, 41)\n    u = mesh_function(f, t)\n\n    # Plot\n    import matplotlib.pyplot as plt\n    plt.plot(t, u)\n    plt.xlabel('t')\n    plt.ylabel('mesh function')\n    plt.savefig('tmp.png'); plt.savefig('tmp.pdf')\n    plt.show()\n\n!ec",
             'text': 'Use `mesh_function` to compute the mesh function corresponding to\n\n!bt\n\\[\nf(t) = \\left\\lbrace\n\\begin{array}{ll}\ne^{-t},& 0\\leq t\\leq 3,\\\\ \ne^{-3t}, & 3 < t\\leq 4\n\\end{array}\\right.\n\\]\n\n!et\nChoose a mesh $t_n=n\\Delta t$ with $\\Delta t=0.1$.\nPlot the mesh function.'}],
  'text': '',
  'title': 'Define a mesh function and visualize it',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['differentiate'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:dudt',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': ['The three differentiation formulas are\nexact for quadratic polynomials. Use this property to verify the program.'],
             'solution': 'The functions can be written as\n\n!bc pycod\nimport numpy as np\n\ndef differentiate(u, dt):\n    dudt = np.zeros(len(u))\n    for i in range(1, len(dudt)-1, 1):\n        dudt[i] = (u[i+1] - u[i-1])/(2*dt)\n    i = 0\n    dudt[i] = (u[i+1] - u[i])/dt\n    i = len(dudt)-1\n    dudt[i] = (u[i] - u[i-1])/dt\n    return dudt\n\ndef test_differentiate():\n    """Test differentiate with a linear u."""\n    # Expect exact results\n    t = np.linspace(0, 4, 9)\n    u = 2*t + 7\n    dudt = differentiate(u, dt=t[1]-t[0])\n    diff = abs(dudt - 2).max()\n    tol = 1E-15\n    assert diff < tol\n\n!ec',
             'text': 'Write a function\n`differentiate(u, dt)` that returns the discrete derivative $d^n$ of the\nmesh function $u^n$. The parameter `dt` reflects the\nmesh spacing $\\Delta t$. Write a corresponding test function\n`test_differentiate()` for verifying the implementation.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': 'Appropriate functions are\n\n!bc pycod\ndef differentiate_vec(u, dt):\n    dudt = np.zeros(len(u))\n    dudt[1:-1] = (u[2:] - u[0:-2])/(2*dt)\n    dudt[0] = (u[1] - u[0])/dt\n    dudt[-1] = (u[-1] - u[-2])/dt\n    return dudt\n\ndef test_differentiate_vec():\n    """Test differentiate_vec by comparing with differentiate."""\n    t = np.linspace(0, 4, 9)\n    u = 2*np.sin(t) + 7\n    dudt_expected = differentiate(u, dt=t[1]-t[0])\n    dudt_computed = differentiate_vec(u, dt=t[1]-t[0])\n    diff = abs(dudt_expected - dudt_computed).max()\n    tol = 1E-15\n    assert diff < tol\n\n!ec',
             'text': 'A standard implementation of the formula (ref{decay:exer:dudt:D2t}) is to\nhave a loop over $i$. For large $N_t$, such loop may run slowly in\nPython. A technique for speeding up the computations, called vectorization\nor array computing,\nreplaces the loop by array operations. To see how this can be done in\nthe present mathematical problem, we\ndefine two arrays\n\n!bt\n\\begin{align*}\nu^+ &= (u^2,u^3,\\ldots,u^{N_t}),\nu^- &= (u^0,u^1,\\ldots,u^{N_t-2}){\\thinspace .}\n\\end{align*}\n\n!et\nThe formula (ref{decay:exer:dudt:D2t}) can now be expressed as\n\n!bt\n\\[ (d^1,d^2,\\ldots,d^{N_t-1}) = \\frac{1}{2\\Delta t}(u^+ - u^-){\\thinspace .}\\]\n\n!et\nThe corresponding Python code reads\n\n!bc pycod\nd[1:-1] = (u[2:] - u[0:-2])/(2*dt)\n# or\nd[1:N_t] = (u[2:N_t+1] - u[0:N_t-1])/(2*dt)\n\n!ec\nRecall that an array slice `u[1:-1]` contains the elements in `u` starting\nwith index 1 and going all indices up to, but not including, the last one\n(`-1`).\n\nUse the ideas above to implement a vectorized version of the\n`differentiate` function without loops. Make a corresponding\ntest function that compares the result with that of\n`differentiate`.'}],
  'text': 'idx{array arithmetics} idx{array computing} idx{vectorization}\n\nGiven a mesh function $u^n$ as an array `u` with $u^n$ values at mesh\npoints $t_n=n\\Delta t$, the discrete derivative can be based on\ncentered differences:\n\n!bt\n\\begin{equation}\nd^n = [D_{2t}u]^n =\n\\frac{u^{n+1}-u^{n-1}}{2\\Delta t},\\quad n=1,\\ldots,N_t-1{\\thinspace .}\nlabel{decay:exer:dudt:D2t}\n\\end{equation}\n\n!et\nAt the end points we use forward and backward differences:\n\n!bt\n\\[ d^0 = [D_t^+u]^n = \\frac{u^{1}-u^{0}}{\\Delta t},\\]\n\n!et\nand\n\n!bt\n\\[ d^{N_t} = [D_t^-u]^n = \\frac{u^{N_t}-u^{N_t-1}}{\\Delta t}{\\thinspace .}\\]\n\n!et',
  'title': 'Differentiate a function',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['pyproblems'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:intdiv',
  'no': 3,
  'solution': "We add some more investigations of the types and values involved\nin the computations:\n\n!bc pyshell\n>>> dt = 3\n>>> T = 8\n>>> Nt = T/dt\n>>> Nt\n2\n>>> type(Nt)\n<type 'int'>\n>>> from numpy import linspace\n>>> theta = 1; a = 1\n>>> (1 - (1-theta)*a*dt)/(1 + theta*dt*a)\n0\n>>> (1 - (1-theta)*a*dt)\n1\n>>> (1 + theta*dt*a)\n2\n\n!ec\nFrom this we realize that the unexpected results are caused by\ninteger division: `int` object divided by `int` object.\nFor example,\n`Nt` is an integer, not a real as we want, because 8/3 according integer\ndivision is 2, not the 2.66666 approximation to $\\frac{8}{3}$.",
  'solution_file': None,
  'subex': [],
  'text': 'Explain what happens in the following computations, where\nsome are mathematically unexpected:\n\n!bc ipy\n>>> dt = 3\n>>> T = 8\n>>> Nt = T/dt\n>>> Nt\n2\n>>> theta = 1; a = 1\n>>> (1 - (1-theta)*a*dt)/(1 + theta*dt*a)\n0\n\n!ec',
  'title': 'Experiment with divisions',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['decay_v1_err'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:decay1err',
  'no': 4,
  'solution': 'A code for investigating this problem may look as follows.\n\n!bc pypro\ndef solver(I, a, T, dt, theta):\n    """Solve u\'=-a*u, u(0)=I, for t in (0,T] with steps of dt."""\n    Nt = int(T/dt)            # no of time intervals\n    T = Nt*dt                 # adjust T to fit time step dt\n    u = zeros(Nt+1)           # array of u[n] values\n    t = linspace(0, T, Nt+1)  # time mesh\n\n    u[0] = I                  # assign initial condition\n    for n in range(0, Nt):    # n=0,1,...,Nt-1\n        factor1 = (1 - (1-theta)*a*dt)\n        factor2 = (1 + theta*dt*a)\n        factor3 = factor1/factor2\n        print factor1, type(factor1), factor2, type(factor2),\n        print factor3, type(factor3)\n        u[n+1] = (1 - (1-theta)*a*dt)/(1 + theta*dt*a)*u[n]\n    return u, t\n\nfrom numpy import *\nu, t = solver(I=1, a=1, T=7, dt=2, theta=1)\n\n# Write out a table of t and u values:\nfor i in range(len(t)):\n    print \'t=%6.3f u=%g\' % (t[i], u[i])\n    # or print \'t={t:6.3f} u={u:g}\'.format(t=t[i], u=u[i])\n\n!ec\nRunning this code shows\n\n!bc sys\nTerminal> python decay_v1_err.py\n1 <type \'int\'> 3 <type \'int\'> 0 <type \'int\'>\n1 <type \'int\'> 3 <type \'int\'> 0 <type \'int\'>\n1 <type \'int\'> 3 <type \'int\'> 0 <type \'int\'>\nt= 0.000 u=1\nt= 2.000 u=0\nt= 4.000 u=0\nt= 6.000 u=0\n\n!ec\nWe realize that we have integer divided by integer in the numerical\nformula, i.e., the result of 1/3 is 0 because of integer division.\nThis fraction is multiplied by `u[n]`, but the result remains zero.',
  'solution_file': None,
  'subex': [],
  'text': 'Consider the `solver` function in the "`decay_v1.py`":\n"http://tinyurl.com/ofkw6kc/alg/decay_v1.py" file\nand the following call:\n\n!bc pycod\nu, t = solver(I=1, a=1, T=7, dt=2, theta=1)\n\n!ec\nThe output becomes\n\n!bc dat\nt= 0.000 u=1\nt= 2.000 u=0\nt= 4.000 u=0\nt= 6.000 u=0\n\n!ec\nPrint out the result of all intermediate computations and use\n`type(v)` to see the object type of the result stored in some variable `v`.\nExamine the intermediate calculations and explain\nwhy `u` is wrong and why we compute up to $t=6$ only even though we\nspecified $T=7$.',
  'title': 'Experiment with wrong computations',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['decay_plot_error'],
  'heading': '=====',
  'hints': ['Modify the "`decay_plot_mpl.py`": "http://tinyurl.com/ofkw6kc/alg/decay_plot_mpl.py" code.'],
  'keywords': None,
  'label': 'decay:exer:plot:error',
  'no': 5,
  'solution': 'Looking at the `decay_plot_mpl.py` file, we realize that we only\nneed to change the `explore` method such that the error and not\nthe solutions are plotted. We also need to run a loop over\n$\\Delta t$ values and get all the corresponding curves in the same\nplot. Quite some editing is necessary. Also the `main` function needs\nsome edits.\n\nThe `solver` and `exact_solution` functions are not altered.\nThe `explore` and `main` functions as well as the call to `main` are\nedited to:\n\n!bc pycod\ndef explore(I, a, T, dt_values, theta=0.5):\n    """\n    Run cases with the solver, compute error measure,\n    and plot the error.\n    """\n    figure() # create new plot\n    for dt in dt_values:\n        print \'dt\', dt\n        u, t = solver(I, a, T, dt, theta)\n        # Numerical solution\n        u_e = u_exact(t, I, a)\n        e = u_e - u\n        plot(t, e)\n        hold(\'on\')\n    legend([\'dt=%g\' % dt for dt in dt_values])\n    xlabel(\'t\')\n    ylabel(\'u\')\n    title(\'theta=%g\' % theta)\n    theta2name = {0: \'FE\', 1: \'BE\', 0.5: \'CN\'}\n    savefig(\'%s_%g.png\' % (theta2name[theta], dt))\n    savefig(\'%s_%g.pdf\' % (theta2name[theta], dt))\n\ndef main(I, a, T, dt_values, theta_values=(0, 0.5, 1)):\n    for theta in theta_values:\n        explore(I, a, T, dt_values, theta)\n\ndt = 0.1\ndt_values = [dt, dt/4, dt/8]\nmain(I=1, a=2, T=5, dt_values=dt_values)\nshow()\n\n!ec\n\nFIGURE: [fig-alg/decay_plot_error, width=800 frac=1]',
  'solution_file': None,
  'subex': [],
  'text': "Solve the problem $u'=-au$, $u(0)=I$, using the Forward Euler, Backward\nEuler, and Crank-Nicolson schemes. For each scheme, plot the error mesh\nfunction $e^n = {u_{\\small\\mbox{e}}}(t_n)-u^n$ for $\\Delta t=0.1, 0.05, 0.025$,\nwhere ${u_{\\small\\mbox{e}}}$ is the exact solution of the ODE and\n$u^n$ is the numerical solution at mesh point $t_n$.",
  'title': 'Plot the error function',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['decay_memsave_v2'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:inexact:output',
  'no': 6,
  'solution': 'The new formatting is obtained by replacing the format `%.16E` for\n`t` by `%.3f` and the format for `u` must be `%.5f`.\n\nWith only 5 decimals in the file, the `test_solver_minmem` function compares\ntruncated elements `u`, accurate only to $10^{-5}$ with the\nexact discrete solution and applies a far too small `tol` value.\n`tol` must be `1E-4`.',
  'solution_file': None,
  'subex': [],
  'text': 'The "`decay_memsave.py`":\n"http://tinyurl.com/ofkw6kc/alg/decay_memsave.py" program\nwrites the time values and solution values to a file which looks\nlike\n!bc\n0.0000000000000000E+00  1.0000000000000000E+00\n2.0000000000000001E-01  8.3333333333333337E-01\n4.0000000000000002E-01  6.9444444444444453E-01\n6.0000000000000009E-01  5.7870370370370383E-01\n8.0000000000000004E-01  4.8225308641975323E-01\n1.0000000000000000E+00  4.0187757201646102E-01\n1.2000000000000000E+00  3.3489797668038418E-01\n1.3999999999999999E+00  2.7908164723365347E-01\n\n!ec \nModify the file output such that it looks like\n!bc dat\n0.000  1.00000\n0.200  0.83333\n0.400  0.69444\n0.600  0.57870\n0.800  0.48225\n1.000  0.40188\n1.200  0.33490\n1.400  0.27908\n\n!ec\nIf you have just modified the formatting of numbers in the file,\nrunning the modified program\n!bc sys\nTerminal> python decay_memsave_v2.py --T 10 --theta 1 \\ \n          --dt 0.2 --makeplot\n\n!ec\nleads to printing of the message `Bug in the implementation!` in the\nterminal window. Why?',
  'title': 'Change formatting of numbers and debug',
  'type': 'Problem',
  'type_visible': True}]