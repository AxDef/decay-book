<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Finite Difference Computing with Exponential Decay Models">
<meta name="keywords" content="decay ODE,exponential decay,mesh,grid,mesh function,finite differences,forward difference,finite differences forward,difference equation,discrete equation,algebraic equation,finite difference scheme,Forward Euler scheme,backward difference,finite differences backward,backward scheme, 1-step,Backward Euler scheme,Crank-Nicolson scheme,centered difference,finite differences centered,averaging arithmetic,weighted average,theta-rule,$\theta$-rule,time step,finite difference operator notation,operator notation, finite differences,directory,folder,doc strings,printf format,format string syntax (Python),plotting curves,visualizing curves,representative (mesh function),array arithmetics,array computing,vectorization,continuous function norms,norm continuous,discrete function norms,mesh function norms,norm discrete (mesh function),error norms,scalar computing,PNG plot,PDF plot,EPS plot,viewing graphics files,cropping images,array arithmetics,array computing,vectorization,stability,amplification factor,A-stable methods,L-stable methods,interactive Python,error amplification factor,error global,consistency,stability,convergence,lambda functions,method of manufactured solutions,MMS (method of manufactured solutions),convergence rate,verification,implicit schemes,explicit schemes,theta-rule,$\theta$-rule,backward scheme, 2-step,BDF2 scheme,Leapfrog scheme,Leapfrog scheme, filtered,Heun's method,Runge-Kutta, 2nd-order method,Taylor-series methods (for ODEs),Adams-Bashforth scheme, 2nd-order,Adams-Bashforth scheme, 3rd order,Runge-Kutta, 4th-order method,RK4,adaptive time stepping,Dormand-Prince Runge-Kutta 4-5 method,population dynamics,logistic model,radioactive decay,chemical reactions irreversible,chemical reactions reversible,Lotka-Volterra model,predator-pray model,terminal velocity,geometric mean,averaging geometric,scaling,Kelvin-Vogt material model,viscoelasticity,refactoring,importing modules,list comprehension,command-line arguments,option-value pairs (command line),command-line arguments,reading the command line,doctests,software testing doctests,unit testing,software testing nose,software testing pytest,test function,software testing test function,doctest in test function,unit testing,software testing unit testing (class-based),Distutils,GitHub,importing modules,problem class,solver class,wrapper (code),reproducibility,replicability,Unix wildcard notation,wildcard notation (Unix),Word (Microsoft),LibreOffice,OpenOffice,Google Docs,HTML,MathJax,LaTeX,Sphinx (typesetting tool),Markdown,IPython notebooks,Jupyter notebooks,DocOnce,replicability">

<title>Finite Difference Computing with Exponential Decay Models</title>

<!-- Bootstrap style: bootswatch_readable -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/readable/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }

/*
in.collapse+a.btn.showdetails:before { content:'Hide details'; }
.collapse+a.btn.showdetails:before { content:'Show details'; }
*/
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [('Preface', 0, 'ch:preface', 'ch:preface'),
              ('Acknowledgments', 3, None, '___sec1'),
              ('Algorithms and implementations', 0, None, '___sec2'),
              ('Finite difference methods',
               1,
               'decay:basics',
               'decay:basics'),
              ('A basic model for exponential decay',
               2,
               'decay:model',
               'decay:model'),
              ('The exact solution', 3, None, '___sec5'),
              ('A complete problem formulation', 3, None, '___sec6'),
              ('The Forward Euler scheme',
               2,
               'decay:schemes:FE',
               'decay:schemes:FE'),
              ('Step 1: Discretizing the domain', 3, None, '___sec8'),
              ('Step 2: Fulfilling the equation at discrete time points',
               3,
               None,
               '___sec9'),
              ('Step 3: Replacing derivatives by finite differences',
               3,
               None,
               '___sec10'),
              ('Step 4: Formulating a recursive algorithm',
               3,
               None,
               '___sec11'),
              ('Interpretation', 3, None, '___sec12'),
              ('Computing with the recursive formula', 3, None, '___sec13'),
              ('The Backward Euler scheme',
               2,
               'decay:schemes:BE',
               'decay:schemes:BE'),
              ('The Crank-Nicolson scheme',
               2,
               'decay:schemes:CN',
               'decay:schemes:CN'),
              ('The unifying $\\theta$-rule',
               2,
               'decay:schemes:theta',
               'decay:schemes:theta'),
              ('Constant time step', 2, None, '___sec17'),
              ('Mathematical derivation of finite difference formulas',
               2,
               'decay:fd:taylor',
               'decay:fd:taylor'),
              ('The forward difference', 3, None, '___sec19'),
              ('The backward difference', 3, None, '___sec20'),
              ('The centered difference', 3, None, '___sec21'),
              ('Compact operator notation for finite differences',
               2,
               'decay:fd:op',
               'decay:fd:op'),
              ('Implementation', 1, 'decay:impl1', 'decay:impl1'),
              ('Computer language: Python', 2, None, '___sec24'),
              ('Making a solver function', 2, 'decay:py1', 'decay:py1'),
              ('Integer division', 2, None, '___sec26'),
              ('Doc strings', 2, None, '___sec27'),
              ('Formatting numbers', 2, None, '___sec28'),
              ('Running the program', 2, None, '___sec29'),
              ('Plotting the solution', 2, None, '___sec30'),
              ('Verifying the implementation', 2, None, '___sec31'),
              ('Running a few algorithmic steps by hand',
               3,
               None,
               '___sec32'),
              ('Computing the numerical error as a mesh function',
               2,
               'decay:computing:error',
               'decay:computing:error'),
              ('Computing the norm of the error mesh function',
               2,
               'decay:computing:error:norm',
               'decay:computing:error:norm'),
              ('Scalar computing', 3, None, '___sec35'),
              ('Experiments with computing and plotting',
               2,
               None,
               '___sec36'),
              ('Combining plot files', 3, None, '___sec37'),
              ('Plotting with SciTools', 3, None, '___sec38'),
              ('Memory-saving implementation', 2, None, '___sec39'),
              ('Exercises', 1, None, '___sec40'),
              ('Exercise 1: Define a mesh function and visualize it',
               2,
               'decay:exer:meshfunc',
               'decay:exer:meshfunc'),
              ('Remarks', 3, None, '___sec42'),
              ('Exercise 2: Differentiate a function',
               2,
               'decay:exer:dudt',
               'decay:exer:dudt'),
              ('Exercise 3: Experiment with divisions',
               2,
               'decay:exer:intdiv',
               'decay:exer:intdiv'),
              ('Exercise 4: Experiment with wrong computations',
               2,
               'decay:exer:decay1err',
               'decay:exer:decay1err'),
              ('Exercise 5: Plot the error function',
               2,
               'decay:exer:plot:error',
               'decay:exer:plot:error'),
              ('Exercise 6: Change formatting of numbers and debug',
               2,
               'decay:exer:inexact:output',
               'decay:exer:inexact:output'),
              ('Analysis', 0, 'decay:analysis', 'decay:analysis'),
              ('Experimental investigations', 1, None, '___sec49'),
              ('Discouraging numerical solutions', 2, None, '___sec50'),
              ('Detailed experiments', 2, None, '___sec51'),
              ('Stability', 1, None, '___sec52'),
              ('Exact numerical solution', 2, None, '___sec53'),
              ('Stability properties derived from the amplification factor',
               2,
               None,
               '___sec54'),
              ('Accuracy', 1, None, '___sec55'),
              ('Visual comparison of amplification factors',
               2,
               None,
               '___sec56'),
              ('Series expansion of amplification factors',
               2,
               None,
               '___sec57'),
              ('The ratio of numerical and exact amplification factors',
               2,
               None,
               '___sec58'),
              ('The global error at a point',
               2,
               'decay:analysis:gobal:error',
               'decay:analysis:gobal:error'),
              ('Integrated error',
               2,
               'decay:analysis:gobal:error_int',
               'decay:analysis:gobal:error_int'),
              ('Truncation error',
               2,
               'decay:analysis:trunc',
               'decay:analysis:trunc'),
              ('Consistency, stability, and convergence',
               2,
               None,
               '___sec62'),
              ('Exercises', 1, None, '___sec63'),
              ('Exercise 7: Visualize the accuracy of finite differences',
               2,
               'decay:analysis:exer:fd:exp:plot',
               'decay:analysis:exer:fd:exp:plot'),
              ('Exercise 8: Explore the $\\theta$-rule for exponential growth',
               2,
               'decay:analysis:exer:growth',
               'decay:analysis:exer:growth'),
              ('Generalizations', 0, None, '___sec66'),
              ('Model extensions', 1, None, '___sec67'),
              ('Generalization: including a variable coefficient',
               2,
               None,
               '___sec68'),
              ('Generalization: including a source term',
               2,
               'decay:source',
               'decay:source'),
              ('Implementation of the generalized model problem',
               2,
               'decay:general',
               'decay:general'),
              ('Deriving the $\\theta$-rule formula', 3, None, '___sec71'),
              ('Python code', 3, None, '___sec72'),
              ('Coding of variable coefficients', 3, None, '___sec73'),
              ('Verifying a constant solution',
               2,
               'decay:verify:trivial',
               'decay:verify:trivial'),
              ('Verification via manufactured solutions',
               2,
               'decay:MMS',
               'decay:MMS'),
              ('Computing convergence rates',
               2,
               'decay:convergence:rate',
               'decay:convergence:rate'),
              ('Estimating $r$', 3, None, '___sec77'),
              ('Implementation', 3, None, '___sec78'),
              ('Extension to systems of ODEs', 2, None, '___sec79'),
              ('General first-order ODEs', 1, None, '___sec80'),
              ('Generic form of first-order ODEs', 2, None, '___sec81'),
              ('The $\\theta$-rule', 2, None, '___sec82'),
              ('An implicit 2-step backward scheme', 2, None, '___sec83'),
              ('Leapfrog schemes', 2, None, '___sec84'),
              ('The ordinary Leapfrog scheme', 3, None, '___sec85'),
              ('The filtered Leapfrog scheme', 3, None, '___sec86'),
              ('The 2nd-order Runge-Kutta method', 2, None, '___sec87'),
              ('A 2nd-order Taylor-series method', 2, None, '___sec88'),
              ('The 2nd- and 3rd-order Adams-Bashforth schemes',
               2,
               None,
               '___sec89'),
              ('The 4th-order Runge-Kutta method',
               2,
               'decay:fd2:RK4',
               'decay:fd2:RK4'),
              ('The Odespy software', 2, None, '___sec91'),
              ('Example: Runge-Kutta methods', 2, None, '___sec92'),
              ('Remark about using the $\\theta$-rule in Odespy',
               3,
               None,
               '___sec93'),
              ('Example: Adaptive Runge-Kutta methods',
               2,
               'decay:fd2:adaptiveRK',
               'decay:fd2:adaptiveRK'),
              ('Exercises', 1, None, '___sec95'),
              ('Exercise 9: Experiment with precision in tests and the size of $u$',
               2,
               'decay:fd2:exer:precision',
               'decay:fd2:exer:precision'),
              ('Exercise 10: Implement the 2-step backward scheme',
               2,
               'decay:fd2:exer:bw2',
               'decay:fd2:exer:bw2'),
              ('Exercise 11: Implement the 2nd-order Adams-Bashforth scheme',
               2,
               'decay:fd2:exer:AB2',
               'decay:fd2:exer:AB2'),
              ('Exercise 12: Implement the 3rd-order Adams-Bashforth scheme',
               2,
               'decay:fd2:exer:AB3',
               'decay:fd2:exer:AB3'),
              ('Exercise 13: Analyze explicit 2nd-order methods',
               2,
               'decay:exer:RK2:Taylor:analysis',
               'decay:exer:RK2:Taylor:analysis'),
              ('Project 14: Implement and investigate the Leapfrog scheme',
               2,
               'decay:fd2:exer:leapfrog1',
               'decay:fd2:exer:leapfrog1'),
              ('Problem 15: Make a unified implementation of many schemes',
               2,
               'decay:fd2:exer:uni',
               'decay:fd2:exer:uni'),
              ('Models', 0, 'decay:app', 'decay:app'),
              ('Scaling', 1, 'decay:app:scaling', 'decay:app:scaling'),
              ('Dimensionless variables', 2, None, '___sec105'),
              ('Dimensionless numbers', 2, None, '___sec106'),
              ('A scaling for vanishing initial condition',
               2,
               None,
               '___sec107'),
              ('Evolution of a population',
               1,
               'decay:app:pop',
               'decay:app:pop'),
              ('Exponential growth',
               2,
               'decay:app:pop:exp',
               'decay:app:pop:exp'),
              ('Logistic growth',
               2,
               'decay:app:pop:log',
               'decay:app:pop:log'),
              ('Compound interest and inflation',
               1,
               'decay:app:interest',
               'decay:app:interest'),
              ("Newton's law of cooling",
               1,
               'decay:app:Newton:cooling',
               'decay:app:Newton:cooling'),
              ('Radioactive decay',
               1,
               'decay:app:nuclear',
               'decay:app:nuclear'),
              ('Deterministic model', 2, None, '___sec114'),
              ('Stochastic model', 2, None, '___sec115'),
              ('Relation between stochastic and deterministic models',
               2,
               None,
               '___sec116'),
              ('Generalization of the radioactive decay modeling',
               2,
               'decay:app:waitingtime',
               'decay:app:waitingtime'),
              ('Chemical kinetics',
               1,
               'decay:app:kinetics',
               'decay:app:kinetics'),
              ('Irreversible reaction of two substances',
               2,
               None,
               '___sec119'),
              ('Reversible reaction of two substances', 2, None, '___sec120'),
              ('Irreversible reaction of two substances into a third',
               2,
               None,
               '___sec121'),
              ('A biochemical reaction', 2, None, '___sec122'),
              ('Spreading of diseases', 1, 'decay:app:SIR', 'decay:app:SIR'),
              ('Predator-pray models in ecology',
               1,
               'decay:app:predpray',
               'decay:app:predpray'),
              ('Decay of atmospheric pressure with altitude',
               1,
               'decay:app:atm',
               'decay:app:atm'),
              ('The general model', 2, None, '___sec126'),
              ('Multiple atmospheric layers', 2, None, '___sec127'),
              ('Simplifications', 2, None, '___sec128'),
              ('Constant layer temperature', 3, None, '___sec129'),
              ('One-layer model', 3, None, '___sec130'),
              ('Compaction of sediments',
               1,
               'decay:app:sediment',
               'decay:app:sediment'),
              ('Vertical motion of a body in a viscous fluid',
               1,
               'decay:app:drag',
               'decay:app:drag'),
              ('Overview of forces', 2, None, '___sec133'),
              ('Equation of motion', 2, None, '___sec134'),
              ('Terminal velocity', 2, None, '___sec135'),
              ('A Crank-Nicolson scheme', 2, None, '___sec136'),
              ('Physical data', 2, None, '___sec137'),
              ('Verification', 2, None, '___sec138'),
              ('Scaling',
               2,
               'decay:app:drag:scaling',
               'decay:app:drag:scaling'),
              ('Viscoelastic materials',
               1,
               'decay:app:viscoelasticity',
               'decay:app:viscoelasticity'),
              ('Decay ODEs from solving a PDE by Fourier expansions',
               1,
               'decay:app:diffusion:Fourier',
               'decay:app:diffusion:Fourier'),
              ('Exercises', 1, None, '___sec142'),
              ('Exercise 16: Radioactive decay of Carbon-14',
               2,
               'decay:app:exer:radio:C14',
               'decay:app:exer:radio:C14'),
              ("Exercise 17: Derive schemes for Newton's law of cooling",
               2,
               'decay:app:exer:cooling:schemes',
               'decay:app:exer:cooling:schemes'),
              ("Exercise 18: Implement schemes for Newton's law of cooling",
               2,
               'decay:app:exer:cooling:py',
               'decay:app:exer:cooling:py'),
              ('Bug 1: Wrong time level in the $T_s$ function',
               3,
               None,
               '___sec146'),
              ('Bug 2: Wrong time level in the $T$ function',
               3,
               None,
               '___sec147'),
              ('Bug 3: Missing $\\theta$ in a term', 3, None, '___sec148'),
              ('Bug 4: Missing `k` in the updating formula',
               3,
               None,
               '___sec149'),
              ('Bug 5: Using `1-theta` instead of `theta`',
               3,
               None,
               '___sec150'),
              ('Exercise 19: Find time of murder from body temperature',
               2,
               'decay:app:exer:cooling:murder',
               'decay:app:exer:cooling:murder'),
              ('Exercise 20: Simulate an oscillating cooling process',
               2,
               'decay:app:exer:cooling:osc',
               'decay:app:exer:cooling:osc'),
              ('Exercise 21: Simulate stochastic radioactive decay',
               2,
               'decay:app:exer:stoch:nuclear',
               'decay:app:exer:stoch:nuclear'),
              ('Exercise 22: Radioactive decay of two substances',
               2,
               'decay:app:exer:radio:twosubst',
               'decay:app:exer:radio:twosubst'),
              ('Exercise 23: Simulate a simple chemical reaction',
               2,
               'decay:app:exer:kinetics:AB',
               'decay:app:exer:kinetics:AB'),
              ('Exercise 24: Simulate an $n$-th order chemical reaction',
               2,
               'decay:app:exer:kinetics:ABn',
               'decay:app:exer:kinetics:ABn'),
              ('Exercise 25: Simulate a biochemical process',
               2,
               'decay:app:exer:MMK',
               'decay:app:exer:MMK'),
              ('Exercise 26: Simulate spreading of a disease',
               2,
               'decay:app:exer:SIR',
               'decay:app:exer:SIR'),
              ('Exercise 27: Simulate predator-pray interaction',
               2,
               'decay:app:exer:predpray',
               'decay:app:exer:predpray'),
              ('Exercise 28: Simulate the pressure drop in the atmosphere',
               2,
               'decay:app:exer:atm1',
               'decay:app:exer:atm1'),
              ('Exercise 29: Make a program for vertical motion in a fluid',
               2,
               'decay:app:exer:drag:prog',
               'decay:app:exer:drag:prog'),
              ('Project 30: Simulate parachuting',
               2,
               'decay:app:exer:parachute',
               'decay:app:exer:parachute'),
              ('Exercise 31: Formulate vertical motion in the atmosphere',
               2,
               'decay:app:exer:drag:atm1',
               'decay:app:exer:drag:atm1'),
              ('Exercise 32: Simulate vertical motion in the atmosphere',
               2,
               'decay:app:exer:drag:atm2',
               'decay:app:exer:drag:atm2'),
              ('Problem 33: Compute $y=|x|$ by solving an ODE',
               2,
               'decay:app:exer:signum',
               'decay:app:exer:signum'),
              ('Problem 34: Simulate fortune growth with random interest rate',
               2,
               'decay:app:exer:interest',
               'decay:app:exer:interest'),
              ('Exercise 35: Simulate a population in a changing environment',
               2,
               'decay:app:exer:pop:at',
               'decay:app:exer:pop:at'),
              ('Exercise 36: Simulate logistic growth',
               2,
               'decay:app:exer:pop:logistic1',
               'decay:app:exer:pop:logistic1'),
              ('Exercise 37: Rederive the equation for continuous compound interest',
               2,
               'decay:app:exer:interest:derive',
               'decay:app:exer:interest:derive'),
              ('Exercise 38: Simulate the deformation of a viscoelastic material',
               2,
               'decay:app:exer:viscoelasticity1',
               'decay:app:exer:viscoelasticity1'),
              ('Scientific software engineering', 0, 'decay:se', 'decay:se'),
              ('Basic implementations',
               1,
               'softeng1:basic',
               'softeng1:basic'),
              ('Mathematical problem and solution technique',
               2,
               'softeng1:basic:math',
               'softeng1:basic:math'),
              ('A first, quick implementation',
               2,
               'softeng1:basic:impl1',
               'softeng1:basic:impl1'),
              ('A more decent program',
               2,
               'softeng1:basic:impl2',
               'softeng1:basic:impl2'),
              ('Comments in a program', 3, None, '___sec176'),
              ('Refactoring into functions', 3, None, '___sec177'),
              ('Program file vs IDE vs notebook', 3, None, '___sec178'),
              ('Prefixing imported functions by the module name',
               2,
               'softeng1:basic:modprefix',
               'softeng1:basic:modprefix'),
              ('Implementing the numerical algorithm in a function',
               2,
               'softeng1:basic:func',
               'softeng1:basic:func'),
              ('Do not have several versions of a code',
               2,
               None,
               '___sec181'),
              ('Making a module',
               2,
               'softeng1:basic:module',
               'softeng1:basic:module'),
              ('Example on extending the module code',
               2,
               'softeng1:basic:experiment2',
               'softeng1:basic:experiment2'),
              ('Documenting functions and modules',
               2,
               'softeng1:basic:docstring',
               'softeng1:basic:docstring'),
              ('User interfaces',
               1,
               'softeng1:basic:UI',
               'softeng1:basic:UI'),
              ('Command-line arguments', 2, None, '___sec186'),
              ('Positional command-line arguments', 2, None, '___sec187'),
              ('Option-value pairs on the command line',
               2,
               None,
               '___sec188'),
              ('Creating a graphical web user interface',
               2,
               None,
               '___sec189'),
              ('Making a compute function', 3, None, '___sec190'),
              ('Generating the user interface', 3, None, '___sec191'),
              ('Running the web application', 3, None, '___sec192'),
              ('Tests for verifying implementations', 1, None, '___sec193'),
              ('Doctests', 2, None, '___sec194'),
              ('Unit tests and test functions', 2, None, '___sec195'),
              ('Two Python test frameworks: nose and pytest',
               3,
               None,
               '___sec196'),
              ('Test function requirements', 3, None, '___sec197'),
              ('Comparison of real numbers', 3, None, '___sec198'),
              ('Special assert functions from nose', 3, None, '___sec199'),
              ('Locating test functions', 3, None, '___sec200'),
              ('Running tests', 3, None, '___sec201'),
              ('Embedding doctests in a test function', 3, None, '___sec202'),
              ('Installing nose and pytest', 3, None, '___sec203'),
              ('Test function for the solver', 2, None, '___sec204'),
              ('Test function for reading positional command-line arguments',
               2,
               None,
               '___sec205'),
              ('Test function for reading option-value pairs',
               2,
               None,
               '___sec206'),
              ('Classical class-based unit testing',
               2,
               'softeng1:basic:unittest',
               'softeng1:basic:unittest'),
              ('Sharing the software with other users',
               1,
               'softeng1:prog:se:git',
               'softeng1:prog:se:git'),
              ('Organizing the software directory tree',
               2,
               None,
               '___sec209'),
              ('Distributing just a module file', 3, None, '___sec210'),
              ('Distributing a package', 3, None, '___sec211'),
              ('Publishing the software at GitHub', 2, None, '___sec212'),
              ('Downloading and installing the software',
               2,
               None,
               '___sec213'),
              ('Installing just a module file', 3, None, '___sec214'),
              ('Installing a package', 3, None, '___sec215'),
              ('Classes for problem and solution method',
               1,
               'softeng1:prog:se:class',
               'softeng1:prog:se:class'),
              ('The problem class', 2, None, '___sec217'),
              ('The solver class', 2, None, '___sec218'),
              ('Combining the objects', 3, None, '___sec219'),
              ('Improving the problem and solver classes',
               2,
               'softeng1:prog:se:class2',
               'softeng1:prog:se:class2'),
              ('A generic class for parameters', 3, None, '___sec221'),
              ('Automating scientific experiments',
               1,
               'softeng1:experiments',
               'softeng1:experiments'),
              ('Available software', 2, None, '___sec223'),
              ('The results we want to produce', 2, None, '___sec224'),
              ('Combining plot files', 2, None, '___sec225'),
              ('Running a program from Python', 2, None, '___sec226'),
              ('The automating script', 2, None, '___sec227'),
              ('Making a report',
               2,
               'softeng1:exper:report',
               'softeng1:exper:report'),
              ('Word, OpenOffice, GoogleDocs', 3, None, '___sec229'),
              ('HTML with MathJax', 3, None, '___sec230'),
              ('LaTeX', 3, None, '___sec231'),
              ('Sphinx', 3, None, '___sec232'),
              ('Markdown', 3, None, '___sec233'),
              ('IPython/Jupyter notebooks', 3, None, '___sec234'),
              ('Wiki formats', 3, None, '___sec235'),
              ('DocOnce', 3, None, '___sec236'),
              ('Publishing a complete project',
               2,
               'softeng1:exper:github',
               'softeng1:exper:github'),
              ('Exercises', 1, None, '___sec238'),
              ('Problem 39: Make a tool for differentiating curves',
               2,
               'softeng1:exer:derivative',
               'softeng1:exer:derivative'),
              ('Problem 40: Make solid software for the Trapezoidal rule',
               2,
               'softeng1:exer:integral:flat',
               'softeng1:exer:integral:flat'),
              ('Problem 41: Implement classes for the Trapezoidal rule',
               2,
               'softeng1:exer:integral:flat2',
               'softeng1:exer:integral:flat2'),
              ('Problem 42: Write a doctest and a test function',
               2,
               'softeng1:exer:doctest1',
               'softeng1:exer:doctest1'),
              ('Problem 43: Experiment with tolerances in comparisons',
               2,
               'softeng1:exer:tol',
               'softeng1:exer:tol'),
              ('Remarks', 3, None, '___sec244'),
              ('Exercise 44: Make use of a class implementation',
               2,
               'softeng1:exer:class:dts',
               'softeng1:exer:class:dts'),
              ('Exercise 45: Make solid software for a difference equation',
               2,
               'softeng1:exer:logistic',
               'softeng1:exer:logistic'),
              ('Summarizing multiple-choice questions', 0, None, '___sec247'),
              ('Quiz', 1, None, '___sec248'),
              ('Exercise 46: Characterize a finite difference',
               2,
               'decay:quiz:fd:FE',
               'decay:quiz:fd:FE'),
              ('Exercise 47: Characterize a finite difference',
               2,
               'decay:quiz:fd:CN',
               'decay:quiz:fd:CN'),
              ('Exercise 48: What is the problem with this program?',
               2,
               'decay:quiz:program',
               'decay:quiz:program'),
              ('Exercise 49: Is the solution correct?',
               2,
               'decay:quiz:stability',
               'decay:quiz:stability'),
              ('Exercise 50: Is this a proper test function?',
               2,
               'decay:quiz:testfunc',
               'decay:quiz:testfunc'),
              ('Exercise 51: Rewrite an expression with array arithmetics',
               2,
               'decay:quiz:arrayarithm',
               'decay:quiz:arrayarithm'),
              ('Exercise 52: What is the truncation error?',
               2,
               'decay:quiz:trunc',
               'decay:quiz:trunc'),
              ('Exercise 53: Recognize a programming language',
               2,
               'decay:quiz:prog:m',
               'decay:quiz:prog:m'),
              ('Exercise 54: Recognize a programming language',
               2,
               'decay:quiz:prog:py',
               'decay:quiz:prog:py'),
              ('Exercise 55: Recognize a programming language',
               2,
               'decay:quiz:prog:f77',
               'decay:quiz:prog:f77'),
              ('Exercise 56: Recognize a programming language',
               2,
               'decay:quiz:prog:c',
               'decay:quiz:prog:c'),
              ('Exercise 57: What is SymPy?',
               2,
               'decay:quiz:sympy1',
               'decay:quiz:sympy1'),
              ('Exercise 58: Testing of code',
               2,
               'decay:quiz:testing1',
               'decay:quiz:testing1'),
              ('Exercise 59: What kind of scheme is this?',
               2,
               'decay:quiz:scheme:CN_error',
               'decay:quiz:scheme:CN_error'),
              ('Exercise 60: What kind of scheme is this?',
               2,
               'decay:quiz:scheme:BE',
               'decay:quiz:scheme:BE'),
              ('Exercise 61: What kind of scheme is this?',
               2,
               'decay:quiz:scheme:leapfrog',
               'decay:quiz:scheme:leapfrog'),
              ('References', 1, None, '___sec265')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\stress}{\boldsymbol{\sigma}}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href=".trash82dee82e1274a586571086dca04d00308d3a0d86.html">Finite Difference Computing with Exponential Decay Models</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86001.html#ch:preface" style="font-size: 80%;">Preface</a></li>
     <!-- navigation toc: --> <li><a href="#___sec2" style="font-size: 80%;">Algorithms and implementations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#decay:analysis" style="font-size: 80%;">Analysis</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#___sec66" style="font-size: 80%;">Generalizations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86008.html#decay:app" style="font-size: 80%;">Models</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#decay:se" style="font-size: 80%;">Scientific software engineering</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#___sec247" style="font-size: 80%;">Summarizing multiple-choice questions</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0003"></a>
<!-- !split -->

<center><h1 id="___sec2">Algorithms and implementations </h1></center> <!-- chapter heading -->
Throughout industry and science it is common today to study nature or
technological devices through models on a computer. With such models
the computer acts as a virtual lab where experiments can be done
in a fast, reliable, safe, and cheap way. In some fields, e.g., aerospace
engineering, the computer models are now so sophisticated that they
can replace physical experiments to a large extent.

<p>
<!-- Computational science is a widely used term for doing scientific discoveries -->
<!-- using computer models. Similarly, computational engineering is about -->
<!-- engineering based on heavy use of computer models. The present book does -->
<!-- not cover how to do scientific discoveries or engineering, but -->
<!-- targets how to create reliable computer models. This task is often -->
<!-- called scientific computing -->

<p>
A vast amount of computer models are based on ordinary and partial
differential equations. This book is an introduction to the
various scientific ingredients we need for reliable computing with such
type of models. A key theme is to solve differential equations
<em>numerically</em> on a computer. Many methods are available for this purpose,
but the focus here is on <em>finite difference methods</em>, because these
are simple, yet versatile, for solving a wide range of ordinary and
partial differential equations. The present chapter first presents the
mathematical ideas of finite difference methods and derives algorithms,
i.e., formulations of the methods ready for computer programming.
Then we create programs and learn how we can be sure that the programs
really work correctly.

<h1 id="decay:basics">Finite difference methods</h1>

<p>
This section explains the basic ideas of finite difference methods
via the simple ordinary differential equation \( u^{\prime}=-au \).
Emphasis is put on the reasoning behind problem discretizing and
introduction of key concepts such as mesh, mesh function,
finite difference approximations, averaging in a mesh,
derivation of algorithms, and discrete operator notation.

<h2 id="decay:model">A basic model for exponential decay</h2>

<p>
Our model problem is perhaps the simplest ordinary differential
equation (ODE):

$$
\begin{equation*}
u^{\prime}(t) = -au(t)\tp
\end{equation*}
$$

In this equation, \( u(t) \) is a scalar function of time \( t \),
\( a \) is a constant, and \( u^{\prime}(t) \) means differentiation with
respect to \( t \). This type of equation arises in a number of
widely different phenomena where some quantity \( u \) undergoes
exponential reduction. Examples include radioactive decay, population
decay, investment decay, cooling of an object, pressure decay in the
atmosphere, and retarded motion in fluids (for some of these models,
\( a \) can be negative as
well), see the chapter <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86008.html#decay:app">Models</a> for details and motivation.
We have chosen this particular ODE not only because
its applications are relevant, but even more because studying
numerical solution methods for this particular ODE gives important insight
that can be reused in far more complicated settings, in particular
when solving diffusion-type partial differential equations.

<h3 id="___sec5">The exact solution </h3>

<p>
Although our interest is in <em>approximate</em> numerical solutions of \( u^{\prime}=-au \), it is convenient to know the exact analytical solution of the problem so
we can compute the error in numerical approximations.
The analytical solution of this ODE is found by
separation of variables, which results in

$$
\begin{equation*} u(t) = Ce^{-at},\end{equation*}
$$

for any arbitrary constant \( C \).
To obtain a unique solution, we need a condition to fix the value of \( C \).
This condition is known as the <em>initial condition</em> and stated as
\( u(0)=I \). That is, we know that the value of \( u \) is \( I \) when the process
starts at \( t=0 \). With this knowledge, the exact solution becomes
\( u(t)=Ie^{-at} \). The initial condition is also crucial for numerical
methods: without it, we can never start the numerical algorithms!

<h3 id="___sec6">A complete problem formulation </h3>

<p>
Besides an initial condition for the ODE, we also need to specify a
time interval for the solution: \( t\in (0,T] \).
The point \( t=0 \) is not
included since we know that \( u(0)=I \) and assume that the equation governs
\( u \) for \( t>0 \).
Let us now summarize the information that is required to
state the complete problem formulation:
find \( u(t) \)
such that

$$
\begin{equation}
u^{\prime} = -au,\ t\in (0,T], \quad u(0)=I\tp   \tag{1}
\end{equation}
$$

This is known as a <em>continuous problem</em> because the parameter \( t \)
varies continuously from \( 0 \) to \( T \). For each \( t \) we have a corresponding
\( u(t) \). There are hence infinitely many values of \( t \) and \( u(t) \).
The purpose of a numerical method is to formulate a corresponding
<em>discrete</em> problem whose solution is characterized by a finite number of values,
which can be computed in a finite number of steps on a computer.
Typically, we choose a finite set of time values \( t_0,t_1,\ldots,t_{N_t} \),
and create algorithms that generate the corresponding \( u \) values
\( u_0,u_1,\ldots,u_{N_t} \).

<h2 id="decay:schemes:FE">The Forward Euler scheme</h2>

<p>
Solving an ODE like <a href="#mjx-eqn-1">(1)</a> by a finite difference method
consists of the following four steps:

<ol>
<li> discretizing the domain,</li>
<li> requiring fulfillment of the equation at discrete time points,</li>
<li> replacing derivatives by finite differences,</li>
<li> formulating a recursive algorithm.</li>
</ol>

<h3 id="___sec8">Step 1: Discretizing the domain </h3>

<p>
The time domain \( [0,T] \) is represented by a finite number of
\( N_t+1 \) points

$$
\begin{equation}
0 = t_0 < t_1 < t_2 < \cdots < t_{N_t-1} < t_{N_t} = T\tp
\end{equation}
$$

The collection of points \( t_0,t_1,\ldots,t_{N_t} \) constitutes a <em>mesh</em>
or <em>grid</em>. Often the mesh points will be uniformly spaced in
the domain \( [0,T] \), which means that the spacing \( t_{n+1}-t_n \) is
the same for all \( n \). This spacing is often denoted by \( \Delta t \),
which means that \( t_n=n\Delta t \).

<p>
We want the solution \( u \) at the mesh points:
\( u(t_n) \), \( n=0,1,\ldots,N_t \).
A notational short-form for \( u(t_n) \),
which will be used extensively, is \( u^{n} \). More precisely, we let
\( u^n \) be the <em>numerical approximation</em> to the exact solution \( u(t_n) \)
at \( t=t_n \).

<p>
When we need to clearly distinguish between the numerical and exact solution,
we often place a subscript e on the exact solution, as in \( \uex(t_n) \).
Figure <a href="#decay:fdu:e">1</a> shows the \( t_n \) and \( u^n \) points for \( n=0,1,\ldots,N_t=7 \) as well as \( \uex(t) \) as the dashed line.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Time mesh with discrete solution values at points and a dashed line indicating the true solution. <div id="decay:fdu:e"></div> </p></center>
<p><img src="fig-alg/fdm_u_ue.png" align="bottom" width=600></p>
</center>

<p>
We say that the numerical approximation, i.e.,
the collection of \( u^n \) values for \( n=0,\ldots,N_t \),
constitutes a <em>mesh function</em>.
A &quot;normal&quot; continuous function is a curve defined for all real \( t \)
values in \( [0,T] \), but a mesh function is only defined at discrete
points in time. If you want to compute the mesh function <em>between</em> the
mesh points, where it is not defined, an <em>interpolation method</em> must be
used. Usually, linear interpolation, i.e., drawing a straight line between
the mesh function values, see Figure <a href="#decay:fdu:e">1</a>, suffices.
To compute the solution for some \( t\in [t_n, t_{n+1}] \), we use the
linear interpolation formula

$$
\begin{equation}
u(t) \approx u^n + \frac{u^{n+1}-u^n}{t_{n+1}-t_n}(t - t_n)\tp
\end{equation}
$$

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Linear interpolation between the discrete solution values (dashed curve is exact solution). <div id="decay:fdu:ei"></div> </p></center>
<p><img src="fig-alg/fdm_u_uei.png" align="bottom" width=600></p>
</center>

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Notice.</b>
The goal of a numerical solution method for ODEs is
to compute the mesh function by solving a finite set of
<em>algebraic equations</em> derived from the original ODE problem.
</div>


<h3 id="___sec9">Step 2: Fulfilling the equation at discrete time points </h3>

<p>
The ODE is supposed to hold for all \( t\in (0,T] \), i.e., at an infinite
number of points. Now we relax that requirement and require that
the ODE is fulfilled at a finite set of discrete points in time.
The mesh points \( t_0,t_1,\ldots,t_{N_t} \) are a natural
(but not the only) choice of points.
The original ODE is then reduced to  the following equations:

$$
\begin{equation}
u^{\prime}(t_n) = -au(t_n),\quad n=0,\ldots,N_t,\quad u(0)=I\tp
\tag{2}
\end{equation}
$$

Even though the original ODE is not stated to be valid at \( t=0 \), it
is valid as close to \( t=0 \) as we like, and it turns out that it
is useful for construction of numerical methods to have
<a href="#mjx-eqn-2">(2)</a> valid for \( n=0 \). The next two steps show that we
need <a href="#mjx-eqn-2">(2)</a> for \( n=0 \).

<h3 id="___sec10">Step 3: Replacing derivatives by finite differences </h3>

<p>
The next and most essential step of the method is to replace the
derivative \( u^{\prime} \) by a finite difference approximation. Let us first
try a <em>forward</em> difference approximation (see Figure <a href="#decay:sketch:FE">3</a>),

$$
\begin{equation}
u^{\prime}(t_n) \approx \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n}\tp
\tag{3}
\end{equation}
$$

The name forward relates to the fact that we use a value forward in
time, \( u^{n+1} \), together with the value \( u^n \) at the point \( t_n \), where
we seek the derivative, to approximate \( u^{\prime}(t_n) \).
Inserting this approximation in <a href="#mjx-eqn-2">(2)</a> results in

$$
\begin{equation}
\frac{u^{n+1}-u^{n}}{t_{n+1}-t_n} = -au^{n},\quad n=0,1,\ldots,N_t-1\tp
\tag{4}
\end{equation}
$$

Note that if we want to compute the solution
up to time level \( N_t \),
we only need <a href="#mjx-eqn-2">(2)</a> to hold for \( n=0,\ldots,N_t-1 \) since
<a href="#mjx-eqn-4">(4)</a> for \( n=N_t-1 \) creates an equation for the final
value \( u^{N_t} \).

<p>
Also note that we use the approximation symbol \( \approx \) in <a href="#mjx-eqn-3">(3)</a>,
but not in <a href="#mjx-eqn-4">(4)</a>. Instead, we view <a href="#mjx-eqn-4">(4)</a> as
an equation that is not mathematically equivalent to <a href="#mjx-eqn-3">(3)</a>,
but represents an approximation to the equation <a href="#mjx-eqn-3">(3)</a>.

<p>
Equation <a href="#mjx-eqn-4">(4)</a>
is the discrete counterpart to the original ODE problem
<a href="#mjx-eqn-1">(1)</a>, and often referred to as a <em>finite difference scheme</em>
or more generally as the <em>discrete equations</em> of the problem.
The fundamental feature of these equations is that they are <em>algebraic</em>
and can hence be straightforwardly solved to produce the mesh function, i.e.,
the approximate values of \( u \) at
the mesh points: \( u^n \), \( n=1,2,\ldots,N_t \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Illustration of a forward difference. <div id="decay:sketch:FE"></div> </p></center>
<p><img src="fig-alg/fd_forward.png" align="bottom" width=400></p>
</center>

<h3 id="___sec11">Step 4: Formulating a recursive algorithm </h3>

<p>
The final step is to identify the computational algorithm to be implemented
in a program. The key observation here is to realize that
<a href="#mjx-eqn-4">(4)</a> can be used to compute \( u^{n+1} \) if \( u^n \) is known.
Starting with \( n=0 \), \( u^0 \) is known since \( u^0=u(0)=I \), and
<a href="#mjx-eqn-4">(4)</a> gives an equation for \( u^1 \). Knowing \( u^1 \),
\( u^2 \) can be found from <a href="#mjx-eqn-4">(4)</a>. In general, \( u^n \)
in <a href="#mjx-eqn-4">(4)</a> can be assumed known, and then we can easily solve for
the unknown \( u^{n+1} \):

$$
\begin{equation}
u^{n+1} = u^n - a(t_{n+1} -t_n)u^n\tp
\tag{5}
\end{equation}
$$

We shall refer to <a href="#mjx-eqn-5">(5)</a> as the Forward Euler (FE) scheme
for our model problem. From a mathematical point of view,
equations of the form <a href="#mjx-eqn-5">(5)</a> are known as
<em>difference equations</em> since they express how differences in
the dependent variable, here \( u \), evolve with \( n \). In our case,
the differences in \( u \) are given by \( u^{n+1}-u^n = -a(t_{n+1}-t_n)u^n \).
The finite difference method can be viewed as a method for turning
a differential equation into an algebraic difference equation that
can be easily solved by repeated use of a formula like <a href="#mjx-eqn-5">(5)</a>.

<h3 id="___sec12">Interpretation </h3>

<p>
There is a very intuitive interpretation of the FE scheme, illustrated
in the sketch below. We have computed some point values
on the solution curve (small red disks), and the question is how we reason
about the next point. Since we know \( u \) and \( t \) at the most recently
computed point, the differential equation gives us the <em>slope</em> of
the solution curve: \( u'=-au \). We can draw this slope as a red line
and continue the solution curve along that slope. As soon as we have
chosen the next point on this line, we have a new \( t \) and \( u \) value and
can compute a new slope and continue the process.

<p>
<br />
<br />

<p>
<center><p><img src="fig-alg/FE_idea.png" align="bottom" width=600></p></center>

<p>
<br />
<br />

<h3 id="___sec13">Computing with the recursive formula </h3>

<p>
Mathematical computation with <a href="#mjx-eqn-5">(5)</a> is straightforward:

$$
\begin{align*}
u_0 &= I,\\ 
u_1 & = u^0 - a(t_{1} -t_0)u^0 = I(1-a(t_1-t_0)),\\ 
u_2 & = u^1 - a(t_{2} -t_1)u^1 = I(1-a(t_1-t_0))(1 - a(t_2-t_1)),\\ 
u^3 &= u^2 - a(t_{3} -t_2)u^2 = I(1-a(t_1-t_0))(1 - a(t_2-t_1))(1 - a(t_3-t_2)),
\end{align*}
$$

and so on until we reach \( u^{N_t} \).
Very often, \( t_{n+1}-t_n \) is constant for all \( n \), so we can introduce
the common symbol
\( \Delta t = t_{n+1}-t_n \), \( n=0,1,\ldots,N_t-1 \).
Using a constant mesh spacing \( \Delta t \) in the above calculations gives

$$
\begin{align*}
u_0 &= I,\\ 
u_1 & = I(1-a\Delta t),\\ 
u_2 & = I(1-a\Delta t)^2,\\ 
u^3 &= I(1-a\Delta t)^3,\\ 
&\vdots\\ 
u^{N_t} &= I(1-a\Delta t)^{N_t}\tp
\end{align*}
$$

This means that we have found a closed formula for \( u^n \), and there is
no need to let a computer generate the sequence \( u^1, u^2, u^3, \ldots \).
However, finding such a formula for \( u^n \) is possible only for a few very
simple problems, so in general finite difference equations must be
solved on a computer.

<p>
As the next sections will show, the scheme <a href="#mjx-eqn-5">(5)</a> is just one
out of many alternative finite difference (and other) methods for
the model problem <a href="#mjx-eqn-1">(1)</a>.

<h2 id="decay:schemes:BE">The Backward Euler scheme</h2>

<p>
There are several choices of difference approximations in step 3 of
the finite difference method as presented in the previous section.
Another alternative is

$$
\begin{equation}
u^{\prime}(t_n) \approx \frac{u^{n}-u^{n-1}}{t_{n}-t_{n-1}}\tp
\tag{6}
\end{equation}
$$

Since this difference is based on going backward in time (\( t_{n-1} \))
for information, it is known as a <em>backward</em> difference, also called
Backward Euler difference.
Figure <a href="#decay:sketch:BE">4</a> explains the idea.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Illustration of a backward difference. <div id="decay:sketch:BE"></div> </p></center>
<p><img src="fig-alg/fd_backward.png" align="bottom" width=400></p>
</center>

<p>
Inserting <a href="#mjx-eqn-6">(6)</a> in <a href="#mjx-eqn-2">(2)</a> yields
the Backward Euler (BE) scheme:

$$
\begin{equation}
\frac{u^{n}-u^{n-1}}{t_{n}-t_{n-1}} = -a u^n,\quad n=1,\ldots,N_t\tp
\tag{7}
\end{equation}
$$

We assume, as explained under step 4 in the section <a href="#decay:schemes:FE">The Forward Euler scheme</a>,
that we have computed \( u^0, u^1, \ldots, u^{n-1} \) such that
<a href="#mjx-eqn-7">(7)</a> can be used to compute \( u^n \). Note that
<a href="#mjx-eqn-7">(7)</a> needs \( n \) to start at 1 (then it involves \( u^0 \), but
no \( u^{-1} \)) and end at \( N_t \).

<p>
For direct similarity with the formula for the
Forward Euler scheme <a href="#mjx-eqn-5">(5)</a>
we replace \( n \) by \( n+1 \) in <a href="#mjx-eqn-7">(7)</a> and solve for the
unknown value \( u^{n+1} \):

$$
\begin{equation}
u^{n+1} = \frac{1}{1+ a(t_{n+1}-t_n)} u^n,\quad n=0,\ldots,N_t-1\tp
\tag{8}
\end{equation}
$$

<h2 id="decay:schemes:CN">The Crank-Nicolson scheme</h2>

<p>
The finite difference approximations
<a href="#mjx-eqn-3">(3)</a> and <a href="#mjx-eqn-6">(6)</a> used to derive the schemes
<a href="#mjx-eqn-5">(5)</a> and <a href="#mjx-eqn-8">(8)</a>, respectively,
are both one-sided differences, i.e.,
we collect information either forward or backward in time when approximating
the derivative at a point. Such one-sided differences are
known to be less accurate than central (or midpoint)
differences, where we use information both forward and backward in
time. A natural next step is therefore to construct
a central difference approximation that will yield a more accurate
numerical solution.

<p>
The central difference approximation to the derivative is sought at the
point \( t_{n+\half}=\half (t_n + t_{n+1}) \) (or
\( t_{n+\half}=(n+\half)\Delta t \) if the mesh spacing is uniform in time).
The approximation reads

$$
\begin{equation}
u^{\prime}(t_{n+\half}) \approx \frac{u^{n+1}-u^n}{t_{n+1}-t_n}\tp
\tag{9}
\end{equation}
$$

Figure <a href="#decay:sketch:CN">5</a> sketches the geometric interpretation of
such a centered difference.
Note that the fraction on the right-hand side is the same as for the
Forward Euler approximation <a href="#mjx-eqn-3">(3)</a> and
the Backward Euler approximation <a href="#mjx-eqn-6">(6)</a> (with
\( n \) replaced by \( n+1 \)). The accuracy of this fraction as an approximation
to the derivative of \( u \) depends on <em>where</em> we seek the derivative:
in the center of the interval \( [t_{n},t_{n+1}] \) or at the end points.
We shall later see that it is more accurate at the center point.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  Illustration of a centered difference. <div id="decay:sketch:CN"></div> </p></center>
<p><img src="fig-alg/fd_centered_CN.png" align="bottom" width=400></p>
</center>

<p>
With the formula <a href="#mjx-eqn-9">(9)</a>, where \( u^{\prime} \) is evaluated at
\( t_{n+\half} \), it is natural to demand the
ODE to be fulfilled at the time points <em>between</em> the mesh points:

$$
\begin{equation}
u^{\prime}(t_{n+\half}) = -au(t_{n+\half}),\quad n=0,
\ldots,N_t-1\tp
\tag{10}
\end{equation}
$$

Using <a href="#mjx-eqn-9">(9)</a> in <a href="#mjx-eqn-10">(10)</a> results in
the approximate discrete equation

$$
\begin{equation}
\frac{u^{n+1}-u^n}{t_{n+1}-t_n} = -au^{n+\half},\quad n=0,\ldots,N_t-1,
\tag{11}
\end{equation}
$$

where \( u^{n+\half} \) is a short form for the numerical approximation
to \( u(t_{n+\half}) \).

<p>
There is a fundamental problem with the right-hand side of
<a href="#mjx-eqn-11">(11)</a>: we aim to compute \( u^n \) for integer \( n \), which means
that \( u^{n+\half} \) is not a quantity computed by our method. The
quantity must
therefore be
expressed by the quantities that we actually produce, i.e.,
the numerical solution at the
mesh points. One possibility is to approximate \( u^{n+\half} \)
as an arithmetic mean of the \( u \) values at the neighboring mesh points:

$$
\begin{equation}
u^{n+\half} \approx \half (u^n + u^{n+1})\tp
\tag{12}
\end{equation}
$$

Using <a href="#mjx-eqn-12">(12)</a> in <a href="#mjx-eqn-11">(11)</a> results in a new
approximate discrete equation

$$
\begin{equation}
\frac{u^{n+1}-u^n}{t_{n+1}-t_n} = -a\half (u^n + u^{n+1})\tp
\tag{13}
\end{equation}
$$

There are three approximation steps leading to this formula:
1) the ODE is only valid at discrete points (between the mesh points),
2) the derivative is approximated by a finite difference, and 3) the
value of \( u \) between mesh points is approximated by an arithmetic mean
value. Despite one more approximation than for the Backward and Forward
Euler schemes, the use of a centered difference leads to a more
accurate method.

<p>
To formulate a recursive algorithm,
we assume that \( u^n \) is already computed so that \( u^{n+1} \) is the
unknown, which we can solve for:

$$
\begin{equation}
u^{n+1} = \frac{1-\half a(t_{n+1}-t_n)}{1 + \half a(t_{n+1}-t_n)}u^n\tp
\tag{14}
\end{equation}
$$

The finite difference scheme <a href="#mjx-eqn-14">(14)</a> is often called
the Crank-Nicolson (CN) scheme or a midpoint or centered scheme.
Note that <a href="#mjx-eqn-14">(14)</a> as well as <a href="#mjx-eqn-5">(5)</a> and <a href="#mjx-eqn-8">(8)</a>
apply whether the spacing in the time mesh, \( t_{n+1}-t_n \), depends on \( n \)
or is constant.

<h2 id="decay:schemes:theta">The unifying \( \theta \)-rule</h2>

<p>
The Forward Euler, Backward Euler, and Crank-Nicolson schemes can be
formulated as one scheme with a varying parameter \( \theta \):

$$
\begin{equation}
\frac{u^{n+1}-u^{n}}{t_{n+1}-t_n} = -a (\theta u^{n+1} + (1-\theta) u^{n})
\tag{15}
\tp
\end{equation}
$$

<p>
Observe:

<ul>
 <li> \( \theta =0 \) gives the Forward Euler scheme</li>
 <li> \( \theta =1 \) gives the Backward Euler scheme, and</li>
 <li> \( \theta =\half \) gives the Crank-Nicolson scheme.</li>
</ul>

We shall later, in the chapter <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#decay:analysis">Analysis</a>, learn the pros and cons
of the three alternatives.
One may alternatively choose any other value of \( \theta \) in \( [0,1] \), but
this is not so common since the accuracy and stability of
the scheme do not improve compared
to the values \( \theta=0,1,\half \).

<p>
As before, \( u^n \) is considered known and \( u^{n+1} \) unknown, so
we solve for the latter:

$$
\begin{equation}
u^{n+1} = \frac{1 - (1-\theta) a(t_{n+1}-t_n)}{1 + \theta a(t_{n+1}-t_n)}\tp
\tag{16}
\end{equation}
$$

This scheme is known as the \( \theta \)-rule, or alternatively written as
the &quot;theta-rule&quot;.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Derivation.</b>
We start with replacing \( u^{\prime} \) by the fraction

$$
\begin{equation*} \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n},\end{equation*}
$$

in the Forward Euler, Backward Euler,
and Crank-Nicolson schemes. Then we observe that
the difference between the methods concerns which point this
fraction approximates the derivative. Or in other words, at which point we
sample the ODE. So far this has been the
end points or the midpoint of \( [t_n,t_{n+1}] \). However, we may choose any point
\( \tilde t \in [t_n,t_{n+1}] \).
The difficulty
is that evaluating the right-hand side \( -au \) at an arbitrary point
faces the same problem as in
the section <a href="#decay:schemes:CN">The Crank-Nicolson scheme</a>: the point value must be expressed
by the discrete \( u \) quantities that we compute by the scheme, i.e.,
\( u^n \) and \( u^{n+1} \). Following the averaging idea from
the section <a href="#decay:schemes:CN">The Crank-Nicolson scheme</a>,
the value of \( u \) at an arbitrary point \( \tilde t \) can be
calculated as a <em>weighted average</em>, which generalizes the arithmetic mean
\( \half u^n + {\half}u^{n+1} \).
The weighted average reads

$$
\begin{equation}
u(\tilde t) \approx \theta u^{n+1} + (1-\theta) u^{n},
\tag{17}
\end{equation}
$$

where \( \theta\in [0,1] \) is a weighting factor.
We can also express \( \tilde t \) as a similar weighted average

$$
\begin{equation}
\tilde t \approx \theta t_{n+1} + (1-\theta) t_{n}\tp
\tag{18}
\end{equation}
$$

<p>
Let now the ODE hold at the point
\( \tilde t\in [t_n,t_{n+1}] \), approximate \( u^{\prime} \) by the fraction
\( (u^{n+1}-u^{n})/(t_{n+1}-t_n) \), and approximate the right-hand
side \( -au \) by the weighted average <a href="#mjx-eqn-17">(17)</a>.
The result is <a href="#mjx-eqn-15">(15)</a>.

<p>
</div>


<h2 id="___sec17">Constant time step </h2>

<p>
All schemes up to now have been formulated for a general non-uniform
mesh in time: \( t_0 < t_1 < \cdots < t_{N_t} \).
Non-uniform meshes are highly relevant
since one can use many points in regions where \( u \) varies rapidly, and
fewer points in regions where \( u \) is slowly varying. This idea saves
the total number of points and therefore makes it faster to compute the mesh
function \( u^n \). Non-uniform meshes are used together with
<em>adaptive</em> methods that are able to adjust the time mesh during the
computations (the section <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#decay:fd2:adaptiveRK">Example: Adaptive Runge-Kutta methods</a> applies adaptive methods).

<p>
However, a uniformly distributed set of mesh points is not only
convenient, but also
sufficient for many applications. Therefore, it is a very common
choice. We shall
present the finite difference schemes for a uniform point distribution
\( t_n=n\Delta t \), where \( \Delta t \) is the constant spacing between
the mesh points, also referred to as the <em>time step</em>.
The resulting formulas look simpler and are more
well known.

<p>
<div class="alert alert-block alert-warning alert-text-normal"><b>Summary of schemes for constant time step.</b>
$$
\begin{align}
u^{n+1} &= (1 - a\Delta t )u^n  \quad (\hbox{FE})
\tag{19}\\ 
u^{n+1} &= \frac{1}{1+ a\Delta t} u^n  \quad (\hbox{BE})
\tag{20}\\ 
u^{n+1} &= \frac{1-\half a\Delta t}{1 + \half a\Delta t} u^n \quad (\hbox{CN})
\tag{21}\\ 
u^{n+1} &= \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n \quad (\theta-\hbox{rule})
\tag{22}
\end{align}
$$
</div>


<p>
It is not accidental that we focus on presenting the Forward Euler, Backward
Euler, and Crank-Nicolson schemes. They complement each other with their
different pros and cons, thus providing a useful collection of
solution methods for many differential equation problems.
The unifying notation of the \( \theta \)-rule makes it convenient to
work with all three methods through just one formula.

<p>
<div class="alert alert-block alert-info alert-text-normal"><b>Test your understanding.</b>
To check that key concepts are really understood, the reader is
encouraged to apply the explained finite difference techniques
to a slightly different equation. For this purpose, we recommend
you do <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86008.html#decay:app:exer:cooling:schemes">Exercise 17: Derive schemes for Newton's law of cooling</a> now!
</div>


<h2 id="decay:fd:taylor">Mathematical derivation of finite difference formulas</h2>

<p>
The finite difference formulas for approximating the first derivative
of a function have so far been somewhat justified through graphical
illustrations in Figures <a href="#decay:sketch:FE">3</a>, <a href="#decay:sketch:BE">4</a>,
and <a href="#decay:sketch:CN">5</a>. The task is to approximate the derivative
at a point of a curve using only two function values. By drawing
a straight line through the points, we have some approximation to
the tangent of the curve and use the slope of this line as
an approximation to the derivative. The slope can be computed by
inspecting the figures.

<p>
However, we can alternatively derive the finite difference formulas by
pure mathematics. The key tool for this approach is Taylor series,
or more precisely, approximation of functions by lower-order
Taylor polynomials. Given a function \( f(x) \) that is sufficiently
smooth (i.e., \( f(x) \) has &quot;enough derivatives&quot;),
a Taylor polynomial of degree \( m \) can be used to approximate the
value of the function \( f(x) \) if we know the values of \( f \) and its
first \( m \) derivatives at some other point \( x=a \). The formula for the
Taylor polynomial reads

$$
\begin{align}
f(x) & \approx f(a) + f'(a)(x-a) + \frac{1}{2}f''(a)(x-a)^2 +
\frac{1}{6}f'''(a)(x-a)^3 + \cdots \nonumber\\ 
 &\quad + \frac{1}{m!}\frac{df^{(m)}}{dx^m}(a)(x-a)^m\tp
\end{align}
$$

For a function of time, \( f(t) \), related to a mesh with spacing \( \Delta t \),
we often need the Taylor polynomial approximation at \( f(t_n\pm\Delta t) \)
given \( f \) and its derivatives at \( t=t_n \). Replacing \( x \) by \( t_n+\Delta t \) and
\( a \) by \( t_n \) gives

$$
\begin{align}
f(t_n+\Delta t) & \approx f(t_n) + f'(t_n)\Delta t + \frac{1}{2}f''(t_n)
\Delta t^2 +
\frac{1}{6}f'''(t_n)\Delta t^3 + \cdots\nonumber\\ 
&\quad + \frac{1}{m!}\frac{df^{(m)}}{dx^m}(t_n)\Delta t^m\tp
\tag{23}
\end{align}
$$

<h3 id="___sec19">The forward difference </h3>

<p>
We can use <a href="#mjx-eqn-23">(23)</a> to find an approximation for
\( f'(t_n) \) simply by solving with respect to this quantity:

$$
\begin{align}
f'(t_n) & \approx  \frac{f(t_n+\Delta t) - f(t_n)}{\Delta t}
- \frac{1}{2}f''(t_n)\Delta t -
\frac{1}{6}f'''(t_n)\Delta t^2 + \cdots\nonumber\\ 
&\quad - \frac{1}{m!}\frac{df^{(m)}}{dx^m}(t_n)\Delta t^{m-1}\tp
\tag{24}
\end{align}
$$

By letting \( m\rightarrow\infty \), this formula is exact, but that is not
so much of practical value. A more interesting observation is that
all the power terms in \( \Delta t \) vanish as \( \Delta t\rightarrow 0 \), i.e.,
the formula

$$
\begin{equation}
f'(t_n) \approx \frac{f(t_n+\Delta t) - f(t_n)}{\Delta t}
\tag{25}
\end{equation}
$$

is exact in the limit \( \Delta t\rightarrow 0 \).

<p>
The interesting feature of <a href="#mjx-eqn-24">(24)</a> is that we have
a measure of the error in the formula <a href="#mjx-eqn-25">(25)</a>: the
error is given by the extra terms on the right-hand side of
<a href="#mjx-eqn-24">(24)</a>. We assume that \( \Delta t \) is a small quantity
(\( \Delta t\ll 1 \)).
Then \( \Delta t^2\ll\Delta t \), \( \Delta t^3\ll \Delta t^2 \), and so on,
which means that the first term is the dominating term. This first
term reads \( -\frac{1}{2}f''(t_n)\Delta t \) and can be taken as a
measure of the error in the Forward Euler formula.

<h3 id="___sec20">The backward difference </h3>

<p>
To derive the backward difference, we use the Taylor polynomial
approximation at \( f(t_n-\Delta t) \):

$$
\begin{align}
f(t_n-\Delta t) &\approx f(t_n) - f'(t_n)\Delta t + \frac{1}{2}f''(t_n)
\Delta t^2 -
\frac{1}{6}f'''(t_n)\Delta t^3+ \cdots\nonumber\\ 
&\quad + \frac{1}{m!}\frac{df^{(m)}}{dx^m}(t_n)\Delta t^m\tp
\tag{26}
\end{align}
$$

Solving with respect to \( f'(t_n) \) gives

$$
\begin{align}
f'(t_n) &\approx \frac{f(t_n) - f(t_n-\Delta t)}{\Delta t}
+ \frac{1}{2}f''(t_n)\Delta t -
\frac{1}{6}f'''(t_n)\Delta t^2+ \cdots\nonumber\\ 
&\quad - \frac{1}{m!}\frac{df^{(m)}}{dx^m}(t_n)\Delta t^{m-1}\tp
\tag{27}
\end{align}
$$

The term \( \frac{1}{2}f''(t_n)\Delta t \) can be taken as a simple measure of
the approximation error since it will dominate over the other terms
as \( \Delta t\rightarrow 0 \).

<h3 id="___sec21">The centered difference </h3>

<p>
The centered difference approximates the derivative at
\( t_n+\frac{1}{2}\Delta t \). Let us write up the Taylor polynomial
approximations to \( f(t_n) \) and \( f(t_{n+1}) \) around \( t_n+\frac{1}{2}\Delta t \):

$$
\begin{align}
f(t_n) &\approx f(t_n+\frac{1}{2}\Delta t) -
f'(t_n+\frac{1}{2}\Delta t)\frac{1}{2}\Delta t +
f''(t_n+\frac{1}{2}\Delta t)(\frac{1}{2}\Delta t)^2 -\nonumber\\ 
& \quad f'''(t_n+\frac{1}{2}\Delta t)(\frac{1}{2}\Delta t)^3 + \cdots\\ 
f(t_{n+1}) & \approx f(t_n+\frac{1}{2}\Delta t) +
f'(t_n+\frac{1}{2}\Delta t)\frac{1}{2}\Delta t +
f''(t_n+\frac{1}{2}\Delta t)(\frac{1}{2}\Delta t)^2 +\nonumber\\ 
&\quad f'''(t_n+\frac{1}{2}\Delta t)(\frac{1}{2}\Delta t)^3 + \cdots
\end{align}
$$

Subtracting the first from the second gives

$$
\begin{equation}
f(t_{n+1}) - f(t_n) = f'(t_n+\frac{1}{2}\Delta t)\Delta t
+ 2f'''(t_n+\frac{1}{2}\Delta t)(\frac{1}{2}\Delta t)^3 + \cdots
\tag{28}
\end{equation}
$$

Solving with respect to \( f'(t_n+\frac{1}{2}\Delta t) \) results
in

$$
\begin{equation}
f'(t_n+\frac{1}{2}\Delta t) \approx \frac{f(t_{n+1}) - f(t_n)}{\Delta t}
- \frac{1}{4}f'''(t_n+\frac{1}{2}\Delta t)\Delta t^2 + c
\cdots
\tag{29}
\end{equation}
$$

This time the error measure goes like \( \frac{1}{4}f'''\Delta t^2 \), i.e.,
it is proportional to \( \Delta t^2 \) and not only \( \Delta t \), which means
that the error goes faster to zero as \( \Delta t \) is reduced.
This means that the centered difference formula

$$
\begin{equation}
f'(t_n+\frac{1}{2}\Delta t) \approx \frac{f(t_{n+1}) - f(t_n)}{\Delta t}
\tag{30}
\end{equation}
$$

is more accurate than the forward and backward differences for small
\( \Delta t \).

<h2 id="decay:fd:op">Compact operator notation for finite differences</h2>

<p>
Finite difference formulas can be tedious to write and read,
especially for differential equations with many terms and many
derivatives. To save space and help the reader spot
the nature of the difference approximations, we introduce a
compact notation. For a function \( u(t) \),
a forward difference approximation is denoted
by the \( D_t^+ \) operator and written as

$$
\begin{equation}
[D_t^+u]^n = \frac{u^{n+1} - u^{n}}{\Delta t}
\ \left( \approx \frac{d}{dt} u(t_n)\right) \tag{31}
\tp
\end{equation}
$$

The notation consists of an operator that approximates
differentiation with respect to an independent variable, here \( t \).
The operator is built of the symbol \( D \), with the
independent variable as subscript
and a superscript denoting the type of difference. The superscript \( \,{}^+ \)
indicates a forward difference.
We place square brackets around the operator and the function it operates
on and specify the mesh point, where the operator is acting, by
a superscript after the closing bracket.

<p>
The corresponding operator notation for a centered difference and
a backward difference reads

$$
\begin{equation}
[D_tu]^n = \frac{u^{n+\half} - u^{n-\half}}{\Delta t}
\approx \frac{d}{dt} u(t_n), \tag{32}
\end{equation}
$$

and
$$
\begin{equation}
[D_t^-u]^n = \frac{u^{n} - u^{n-1}}{\Delta t}
\approx \frac{d}{dt} u(t_n) \tag{33}
\tp
\end{equation}
$$

Note that the superscript \( \,{}^- \) denotes the backward
difference, while no superscript implies a central difference.

<p>
An averaging operator is also convenient to have:

$$
\begin{equation}
[\overline{u}^{t}]^n = \half (u^{n-\half} + u^{n+\half} )
\approx u(t_n) \tag{34}
\end{equation}
$$

The superscript \( t \) indicates that the average is taken along the time
coordinate. The common average \( (u^n + u^{n+1})/2 \) can now be
expressed as \( [\overline{u}^{t}]^{n+\half} \). (When also spatial coordinates
enter the problem, we need the explicit specification of the coordinate
after the bar.)

<p>
With our compact notation, the Backward Euler finite difference approximation to \( u^{\prime}=-au \) can be written
as

$$
\begin{equation*}
[D_t^-u]^n = -au^n \tp
\end{equation*}
$$

In difference equations we often place the square brackets around
the whole equation, to indicate at which mesh point the equation applies,
since each term must be approximated at the same point:

$$
\begin{equation}
[D_t^- u  = -au]^n \tp
\end{equation}
$$

Similarly, the Forward Euler scheme takes the form

$$
\begin{equation}
[D_t^+ u  = -au]^n,
\end{equation}
$$

while the Crank-Nicolson scheme is written as

$$
\begin{equation}
[D_t u = -a\overline{u}^t]^{n+\half}\tp
\tag{35}
\end{equation}
$$

<p>
<div class="alert alert-block alert-info alert-text-normal"><b>Question.</b>
By use of <a href="#mjx-eqn-32">(32)</a> and <a href="#mjx-eqn-34">(34)</a>, are you able to
write out the expressions in <a href="#mjx-eqn-35">(35)</a> to verify that
it is indeed the Crank-Nicolson scheme?
</div>


<p>
The \( \theta \)-rule can be specified in operator notation by

$$
\begin{equation}
[\bar D_t u = -a\overline{u}^{t,\theta}]^{n+\theta},\tp
\tag{36}
\end{equation}
$$

We define a new time difference

$$
\begin{equation}
\lbrack\bar D_t u\rbrack^{n+\theta} = \frac{u^{n+1}-u^n}{t^{n+1}-t^n},
\tag{37}
\end{equation}
$$

to be applied at the time point \( t_{n+\theta}\approx\theta t_n + (1-\theta)t_{n+1} \). This weighted average gives rise to the
<em>weighted averaging operator</em>

$$
\begin{equation}
\lbrack\overline{u}^{t,\theta}\rbrack^{n+\theta} = (1-\theta)u^{n} + \theta u^{n+1}
\approx u(t_{n+\theta}),
\tag{38}
\end{equation}
$$

where \( \theta\in [0,1] \) as usual. Note that for \( \theta =\half \) we recover
the standard centered difference and the standard arithmetic mean.
The idea in <a href="#mjx-eqn-36">(36)</a> is to sample the equation at
\( t_{n+\theta} \), use a non-symmetric difference at that
point \( [\bar D_t u]^{n+\theta} \), and a weighted (non-symmetric) mean value.

<p>
An alternative and perhaps clearer notation is

$$ [D_t u]^{n+\half} = \theta [-au]^{n+1} + (1-\theta)[-au]^{n}\tp $$

<p>
Looking at the various examples above and comparing them with the
underlying differential equations, we see immediately which difference
approximations that have been used and at which point they
apply. Therefore, the compact notation effectively communicates the
reasoning behind turning a differential equation into a difference
equation.

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86002.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    
