<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Finite Difference Computing with Exponential Decay Models">
<meta name="keywords" content="decay ODE,exponential decay,mesh,grid,mesh function,finite differences,forward difference,finite differences forward,difference equation,discrete equation,algebraic equation,finite difference scheme,Forward Euler scheme,backward difference,finite differences backward,backward scheme, 1-step,Backward Euler scheme,Crank-Nicolson scheme,centered difference,finite differences centered,averaging arithmetic,weighted average,theta-rule,$\theta$-rule,time step,finite difference operator notation,operator notation, finite differences,directory,folder,doc strings,printf format,format string syntax (Python),plotting curves,visualizing curves,representative (mesh function),array arithmetics,array computing,vectorization,continuous function norms,norm continuous,discrete function norms,mesh function norms,norm discrete (mesh function),error norms,scalar computing,PNG plot,PDF plot,EPS plot,viewing graphics files,cropping images,array arithmetics,array computing,vectorization,stability,amplification factor,A-stable methods,L-stable methods,interactive Python,error amplification factor,error global,consistency,stability,convergence,lambda functions,method of manufactured solutions,MMS (method of manufactured solutions),convergence rate,verification,implicit schemes,explicit schemes,theta-rule,$\theta$-rule,backward scheme, 2-step,BDF2 scheme,Leapfrog scheme,Leapfrog scheme, filtered,Heun's method,Runge-Kutta, 2nd-order method,Taylor-series methods (for ODEs),Adams-Bashforth scheme, 2nd-order,Adams-Bashforth scheme, 3rd order,Runge-Kutta, 4th-order method,RK4,adaptive time stepping,Dormand-Prince Runge-Kutta 4-5 method,population dynamics,logistic model,radioactive decay,chemical reactions irreversible,chemical reactions reversible,Lotka-Volterra model,predator-pray model,terminal velocity,geometric mean,averaging geometric,scaling,Kelvin-Vogt material model,viscoelasticity,refactoring,importing modules,logger,debugging,list comprehension,command-line arguments,option-value pairs (command line),command-line arguments,reading the command line,doctests,software testing doctests,unit testing,software testing nose,software testing pytest,test function,software testing test function,doctest in test function,unit testing,software testing unit testing (class-based),Distutils,GitHub,importing modules,problem class,solver class,wrapper (code),reproducibility,replicability,Unix wildcard notation,wildcard notation (Unix),Word (Microsoft),LibreOffice,OpenOffice,Google Docs,HTML,MathJax,LaTeX,Sphinx (typesetting tool),Markdown,IPython notebooks,Jupyter notebooks,DocOnce,replicability">

<title>Finite Difference Computing with Exponential Decay Models</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [('Preface', 0, 'ch:preface', 'ch:preface'),
              ('Acknowledgments', 3, None, '___sec1'),
              ('Algorithms and implementations', 0, None, '___sec2'),
              ('Finite difference methods',
               1,
               'decay:basics',
               'decay:basics'),
              ('A basic model for exponential decay',
               2,
               'decay:model',
               'decay:model'),
              ('The exact solution', 3, None, '___sec5'),
              ('A complete problem formulation', 3, None, '___sec6'),
              ('The Forward Euler scheme',
               2,
               'decay:schemes:FE',
               'decay:schemes:FE'),
              ('Step 1: Discretizing the domain', 3, None, '___sec8'),
              ('Step 2: Fulfilling the equation at discrete time points',
               3,
               None,
               '___sec9'),
              ('Step 3: Replacing derivatives by finite differences',
               3,
               None,
               '___sec10'),
              ('Step 4: Formulating a recursive algorithm',
               3,
               None,
               '___sec11'),
              ('Interpretation', 3, None, '___sec12'),
              ('Computing with the recursive formula', 3, None, '___sec13'),
              ('The Backward Euler scheme',
               2,
               'decay:schemes:BE',
               'decay:schemes:BE'),
              ('The Crank-Nicolson scheme',
               2,
               'decay:schemes:CN',
               'decay:schemes:CN'),
              ('The unifying $\\theta$-rule',
               2,
               'decay:schemes:theta',
               'decay:schemes:theta'),
              ('Constant time step', 2, None, '___sec17'),
              ('Mathematical derivation of finite difference formulas',
               2,
               'decay:fd:taylor',
               'decay:fd:taylor'),
              ('The forward difference', 3, None, '___sec19'),
              ('The backward difference', 3, None, '___sec20'),
              ('The centered difference', 3, None, '___sec21'),
              ('Compact operator notation for finite differences',
               2,
               'decay:fd:op',
               'decay:fd:op'),
              ('Implementation', 1, 'decay:impl1', 'decay:impl1'),
              ('Computer language: Python', 2, None, '___sec24'),
              ('Making a solver function', 2, 'decay:py1', 'decay:py1'),
              ('Integer division', 2, None, '___sec26'),
              ('Doc strings', 2, None, '___sec27'),
              ('Formatting numbers', 2, None, '___sec28'),
              ('Running the program', 2, None, '___sec29'),
              ('Plotting the solution', 2, None, '___sec30'),
              ('Verifying the implementation', 2, None, '___sec31'),
              ('Running a few algorithmic steps by hand',
               3,
               None,
               '___sec32'),
              ('Computing the numerical error as a mesh function',
               2,
               'decay:computing:error',
               'decay:computing:error'),
              ('Computing the norm of the error mesh function',
               2,
               'decay:computing:error:norm',
               'decay:computing:error:norm'),
              ('Scalar computing', 3, None, '___sec35'),
              ('Experiments with computing and plotting',
               2,
               None,
               '___sec36'),
              ('Combining plot files', 3, None, '___sec37'),
              ('Plotting with SciTools', 3, None, '___sec38'),
              ('Memory-saving implementation', 2, None, '___sec39'),
              ('Exercises', 1, None, '___sec40'),
              ('Exercise 1: Define a mesh function and visualize it',
               2,
               'decay:exer:meshfunc',
               'decay:exer:meshfunc'),
              ('Remarks', 3, None, '___sec42'),
              ('Exercise 2: Differentiate a function',
               2,
               'decay:exer:dudt',
               'decay:exer:dudt'),
              ('Problem 3: Experiment with divisions',
               2,
               'decay:exer:intdiv',
               'decay:exer:intdiv'),
              ('Problem 4: Experiment with wrong computations',
               2,
               'decay:exer:decay1err',
               'decay:exer:decay1err'),
              ('Problem 5: Plot the error function',
               2,
               'decay:exer:plot:error',
               'decay:exer:plot:error'),
              ('Problem 6: Change formatting of numbers and debug',
               2,
               'decay:exer:inexact:output',
               'decay:exer:inexact:output'),
              ('Analysis', 0, 'decay:analysis', 'decay:analysis'),
              ('Experimental investigations', 1, None, '___sec49'),
              ('Discouraging numerical solutions', 2, None, '___sec50'),
              ('Detailed experiments', 2, None, '___sec51'),
              ('Stability', 1, None, '___sec52'),
              ('Exact numerical solution', 2, None, '___sec53'),
              ('Stability properties derived from the amplification factor',
               2,
               None,
               '___sec54'),
              ('Accuracy', 1, None, '___sec55'),
              ('Visual comparison of amplification factors',
               2,
               None,
               '___sec56'),
              ('Series expansion of amplification factors',
               2,
               None,
               '___sec57'),
              ('The ratio of numerical and exact amplification factors',
               2,
               None,
               '___sec58'),
              ('The global error at a point',
               2,
               'decay:analysis:gobal:error',
               'decay:analysis:gobal:error'),
              ('Integrated error',
               2,
               'decay:analysis:gobal:error_int',
               'decay:analysis:gobal:error_int'),
              ('Truncation error',
               2,
               'decay:analysis:trunc',
               'decay:analysis:trunc'),
              ('Consistency, stability, and convergence',
               2,
               None,
               '___sec62'),
              ('Exercises', 1, None, '___sec63'),
              ('Problem 7: Visualize the accuracy of finite differences',
               2,
               'decay:analysis:exer:fd:exp:plot',
               'decay:analysis:exer:fd:exp:plot'),
              ('Problem 8: Explore the $\\theta$-rule for exponential growth',
               2,
               'decay:analysis:exer:growth',
               'decay:analysis:exer:growth'),
              ('Generalizations', 0, None, '___sec66'),
              ('Model extensions', 1, None, '___sec67'),
              ('Generalization: including a variable coefficient',
               2,
               None,
               '___sec68'),
              ('Generalization: including a source term',
               2,
               'decay:source',
               'decay:source'),
              ('Implementation of the generalized model problem',
               2,
               'decay:general',
               'decay:general'),
              ('Deriving the $\\theta$-rule formula', 3, None, '___sec71'),
              ('Python code', 3, None, '___sec72'),
              ('Coding of variable coefficients', 3, None, '___sec73'),
              ('Verifying a constant solution',
               2,
               'decay:verify:trivial',
               'decay:verify:trivial'),
              ('Verification via manufactured solutions',
               2,
               'decay:MMS',
               'decay:MMS'),
              ('Computing convergence rates',
               2,
               'decay:convergence:rate',
               'decay:convergence:rate'),
              ('Estimating $r$', 3, None, '___sec77'),
              ('Implementation', 3, None, '___sec78'),
              ('Extension to systems of ODEs', 2, None, '___sec79'),
              ('General first-order ODEs', 1, None, '___sec80'),
              ('Generic form of first-order ODEs', 2, None, '___sec81'),
              ('The $\\theta$-rule', 2, None, '___sec82'),
              ('An implicit 2-step backward scheme', 2, None, '___sec83'),
              ('Leapfrog schemes', 2, None, '___sec84'),
              ('The ordinary Leapfrog scheme', 3, None, '___sec85'),
              ('The filtered Leapfrog scheme', 3, None, '___sec86'),
              ('The 2nd-order Runge-Kutta method', 2, None, '___sec87'),
              ('A 2nd-order Taylor-series method', 2, None, '___sec88'),
              ('The 2nd- and 3rd-order Adams-Bashforth schemes',
               2,
               None,
               '___sec89'),
              ('The 4th-order Runge-Kutta method',
               2,
               'decay:fd2:RK4',
               'decay:fd2:RK4'),
              ('The Odespy software', 2, None, '___sec91'),
              ('Example: Runge-Kutta methods', 2, None, '___sec92'),
              ('Remark about using the $\\theta$-rule in Odespy',
               3,
               None,
               '___sec93'),
              ('Example: Adaptive Runge-Kutta methods',
               2,
               'decay:fd2:adaptiveRK',
               'decay:fd2:adaptiveRK'),
              ('Exercises', 1, None, '___sec95'),
              ('Exercise 9: Experiment with precision in tests and the size of $u$',
               2,
               'decay:fd2:exer:precision',
               'decay:fd2:exer:precision'),
              ('Exercise 10: Implement the 2-step backward scheme',
               2,
               'decay:fd2:exer:bw2',
               'decay:fd2:exer:bw2'),
              ('Exercise 11: Implement the 2nd-order Adams-Bashforth scheme',
               2,
               'decay:fd2:exer:AB2',
               'decay:fd2:exer:AB2'),
              ('Exercise 12: Implement the 3rd-order Adams-Bashforth scheme',
               2,
               'decay:fd2:exer:AB3',
               'decay:fd2:exer:AB3'),
              ('Exercise 13: Analyze explicit 2nd-order methods',
               2,
               'decay:exer:RK2:Taylor:analysis',
               'decay:exer:RK2:Taylor:analysis'),
              ('Project 14: Implement and investigate the Leapfrog scheme',
               2,
               'decay:fd2:exer:leapfrog1',
               'decay:fd2:exer:leapfrog1'),
              ('Problem 15: Make a unified implementation of many schemes',
               2,
               'decay:fd2:exer:uni',
               'decay:fd2:exer:uni'),
              ('Models', 0, 'decay:app', 'decay:app'),
              ('Scaling', 1, 'decay:app:scaling', 'decay:app:scaling'),
              ('Dimensionless variables', 2, None, '___sec105'),
              ('Dimensionless numbers', 2, None, '___sec106'),
              ('A scaling for vanishing initial condition',
               2,
               None,
               '___sec107'),
              ('Evolution of a population',
               1,
               'decay:app:pop',
               'decay:app:pop'),
              ('Exponential growth',
               2,
               'decay:app:pop:exp',
               'decay:app:pop:exp'),
              ('Logistic growth',
               2,
               'decay:app:pop:log',
               'decay:app:pop:log'),
              ('Compound interest and inflation',
               1,
               'decay:app:interest',
               'decay:app:interest'),
              ("Newton's law of cooling",
               1,
               'decay:app:Newton:cooling',
               'decay:app:Newton:cooling'),
              ('Radioactive decay',
               1,
               'decay:app:nuclear',
               'decay:app:nuclear'),
              ('Deterministic model', 2, None, '___sec114'),
              ('Stochastic model', 2, None, '___sec115'),
              ('Relation between stochastic and deterministic models',
               2,
               None,
               '___sec116'),
              ('Generalization of the radioactive decay modeling',
               2,
               'decay:app:waitingtime',
               'decay:app:waitingtime'),
              ('Chemical kinetics',
               1,
               'decay:app:kinetics',
               'decay:app:kinetics'),
              ('Irreversible reaction of two substances',
               2,
               None,
               '___sec119'),
              ('Reversible reaction of two substances', 2, None, '___sec120'),
              ('Irreversible reaction of two substances into a third',
               2,
               None,
               '___sec121'),
              ('A biochemical reaction', 2, None, '___sec122'),
              ('Spreading of diseases', 1, 'decay:app:SIR', 'decay:app:SIR'),
              ('Predator-pray models in ecology',
               1,
               'decay:app:predpray',
               'decay:app:predpray'),
              ('Decay of atmospheric pressure with altitude',
               1,
               'decay:app:atm',
               'decay:app:atm'),
              ('The general model', 2, None, '___sec126'),
              ('Multiple atmospheric layers', 2, None, '___sec127'),
              ('Simplifications', 2, None, '___sec128'),
              ('Constant layer temperature', 3, None, '___sec129'),
              ('One-layer model', 3, None, '___sec130'),
              ('Compaction of sediments',
               1,
               'decay:app:sediment',
               'decay:app:sediment'),
              ('Vertical motion of a body in a viscous fluid',
               1,
               'decay:app:drag',
               'decay:app:drag'),
              ('Overview of forces', 2, None, '___sec133'),
              ('Equation of motion', 2, None, '___sec134'),
              ('Terminal velocity', 2, None, '___sec135'),
              ('A Crank-Nicolson scheme', 2, None, '___sec136'),
              ('Physical data', 2, None, '___sec137'),
              ('Verification', 2, None, '___sec138'),
              ('Scaling',
               2,
               'decay:app:drag:scaling',
               'decay:app:drag:scaling'),
              ('Viscoelastic materials',
               1,
               'decay:app:viscoelasticity',
               'decay:app:viscoelasticity'),
              ('Decay ODEs from solving a PDE by Fourier expansions',
               1,
               'decay:app:diffusion:Fourier',
               'decay:app:diffusion:Fourier'),
              ('Exercises', 1, None, '___sec142'),
              ('Problem 16: Radioactive decay of Carbon-14',
               2,
               'decay:app:exer:radio:C14',
               'decay:app:exer:radio:C14'),
              ("Exercise 17: Derive schemes for Newton's law of cooling",
               2,
               'decay:app:exer:cooling:schemes',
               'decay:app:exer:cooling:schemes'),
              ("Exercise 18: Implement schemes for Newton's law of cooling",
               2,
               'decay:app:exer:cooling:py',
               'decay:app:exer:cooling:py'),
              ('Bug 1: Wrong time level in the $T_s$ function',
               3,
               None,
               '___sec146'),
              ('Bug 2: Wrong time level in the $T$ function',
               3,
               None,
               '___sec147'),
              ('Bug 3: Missing $\\theta$ in a term', 3, None, '___sec148'),
              ('Bug 4: Missing `k` in the updating formula',
               3,
               None,
               '___sec149'),
              ('Bug 5: Using `1-theta` instead of `theta`',
               3,
               None,
               '___sec150'),
              ('Exercise 19: Find time of murder from body temperature',
               2,
               'decay:app:exer:cooling:murder',
               'decay:app:exer:cooling:murder'),
              ('Exercise 20: Simulate an oscillating cooling process',
               2,
               'decay:app:exer:cooling:osc',
               'decay:app:exer:cooling:osc'),
              ('Exercise 21: Simulate stochastic radioactive decay',
               2,
               'decay:app:exer:stoch:nuclear',
               'decay:app:exer:stoch:nuclear'),
              ('Problem 22: Radioactive decay of two substances',
               2,
               'decay:app:exer:radio:twosubst',
               'decay:app:exer:radio:twosubst'),
              ('Exercise 23: Simulate a simple chemical reaction',
               2,
               'decay:app:exer:kinetics:AB',
               'decay:app:exer:kinetics:AB'),
              ('Exercise 24: Simulate an $n$-th order chemical reaction',
               2,
               'decay:app:exer:kinetics:ABn',
               'decay:app:exer:kinetics:ABn'),
              ('Exercise 25: Simulate a biochemical process',
               2,
               'decay:app:exer:MMK',
               'decay:app:exer:MMK'),
              ('Exercise 26: Simulate spreading of a disease',
               2,
               'decay:app:exer:SIR',
               'decay:app:exer:SIR'),
              ('Exercise 27: Simulate predator-pray interaction',
               2,
               'decay:app:exer:predpray',
               'decay:app:exer:predpray'),
              ('Exercise 28: Simulate the pressure drop in the atmosphere',
               2,
               'decay:app:exer:atm1',
               'decay:app:exer:atm1'),
              ('Exercise 29: Make a program for vertical motion in a fluid',
               2,
               'decay:app:exer:drag:prog',
               'decay:app:exer:drag:prog'),
              ('Project 30: Simulate parachuting',
               2,
               'decay:app:exer:parachute',
               'decay:app:exer:parachute'),
              ('Exercise 31: Formulate vertical motion in the atmosphere',
               2,
               'decay:app:exer:drag:atm1',
               'decay:app:exer:drag:atm1'),
              ('Exercise 32: Simulate vertical motion in the atmosphere',
               2,
               'decay:app:exer:drag:atm2',
               'decay:app:exer:drag:atm2'),
              ('Problem 33: Compute $y=|x|$ by solving an ODE',
               2,
               'decay:app:exer:signum',
               'decay:app:exer:signum'),
              ('Problem 34: Simulate fortune growth with random interest rate',
               2,
               'decay:app:exer:interest',
               'decay:app:exer:interest'),
              ('Exercise 35: Simulate a population in a changing environment',
               2,
               'decay:app:exer:pop:at',
               'decay:app:exer:pop:at'),
              ('Exercise 36: Simulate logistic growth',
               2,
               'decay:app:exer:pop:logistic1',
               'decay:app:exer:pop:logistic1'),
              ('Exercise 37: Rederive the equation for continuous compound interest',
               2,
               'decay:app:exer:interest:derive',
               'decay:app:exer:interest:derive'),
              ('Exercise 38: Simulate the deformation of a viscoelastic material',
               2,
               'decay:app:exer:viscoelasticity1',
               'decay:app:exer:viscoelasticity1'),
              ('Scientific software engineering', 0, 'decay:se', 'decay:se'),
              ('Implementations with functions and modules',
               1,
               'softeng1:basic',
               'softeng1:basic'),
              ('Mathematical problem and solution technique',
               2,
               'softeng1:basic:math',
               'softeng1:basic:math'),
              ('A first, quick implementation',
               2,
               'softeng1:basic:impl1',
               'softeng1:basic:impl1'),
              ('A more decent program',
               2,
               'softeng1:basic:impl2',
               'softeng1:basic:impl2'),
              ('Comments in a program', 3, None, '___sec176'),
              ('Refactoring into functions', 3, None, '___sec177'),
              ('Program file vs IDE vs notebook', 3, None, '___sec178'),
              ('Prefixing imported functions by the module name',
               2,
               'softeng1:basic:modprefix',
               'softeng1:basic:modprefix'),
              ('Implementing the numerical algorithm in a function',
               2,
               'softeng1:basic:func',
               'softeng1:basic:func'),
              ('Do not have several versions of a code',
               2,
               None,
               '___sec181'),
              ('Making a module',
               2,
               'softeng1:basic:module',
               'softeng1:basic:module'),
              ('Example on extending the module code',
               2,
               'softeng1:basic:experiment2',
               'softeng1:basic:experiment2'),
              ('Documenting functions and modules',
               2,
               'softeng1:basic:docstring',
               'softeng1:basic:docstring'),
              ('Logging intermediate results',
               2,
               'softeng1:basic:logging',
               'softeng1:basic:logging'),
              ('Introductory example', 3, None, '___sec186'),
              ('Using a logger in our solver function', 3, None, '___sec187'),
              ('User interfaces',
               1,
               'softeng1:basic:UI',
               'softeng1:basic:UI'),
              ('Command-line arguments', 2, None, '___sec189'),
              ('Positional command-line arguments', 2, None, '___sec190'),
              ('Option-value pairs on the command line',
               2,
               None,
               '___sec191'),
              ('Creating a graphical web user interface',
               2,
               None,
               '___sec192'),
              ('Making a compute function', 3, None, '___sec193'),
              ('Generating the user interface', 3, None, '___sec194'),
              ('Running the web application', 3, None, '___sec195'),
              ('Tests for verifying implementations', 1, None, '___sec196'),
              ('Doctests', 2, None, '___sec197'),
              ('Unit tests and test functions', 2, None, '___sec198'),
              ('Two Python test frameworks: nose and pytest',
               3,
               None,
               '___sec199'),
              ('Test function requirements', 3, None, '___sec200'),
              ('Comparison of real numbers', 3, None, '___sec201'),
              ('Special assert functions from nose', 3, None, '___sec202'),
              ('Locating test functions', 3, None, '___sec203'),
              ('Running tests', 3, None, '___sec204'),
              ('Embedding doctests in a test function', 3, None, '___sec205'),
              ('Installing nose and pytest', 3, None, '___sec206'),
              ('Test function for the solver', 2, None, '___sec207'),
              ('Test function for reading positional command-line arguments',
               2,
               None,
               '___sec208'),
              ('Test function for reading option-value pairs',
               2,
               None,
               '___sec209'),
              ('Classical class-based unit testing',
               2,
               'softeng1:basic:unittest',
               'softeng1:basic:unittest'),
              ('Sharing the software with other users',
               1,
               'softeng1:prog:se:git',
               'softeng1:prog:se:git'),
              ('Organizing the software directory tree',
               2,
               None,
               '___sec212'),
              ('Distributing just a module file', 3, None, '___sec213'),
              ('Distributing a package', 3, None, '___sec214'),
              ('Publishing the software at GitHub', 2, None, '___sec215'),
              ('Downloading and installing the software',
               2,
               None,
               '___sec216'),
              ('Installing just a module file', 3, None, '___sec217'),
              ('Installing a package', 3, None, '___sec218'),
              ('Classes for problem and solution method',
               1,
               'softeng1:prog:se:class',
               'softeng1:prog:se:class'),
              ('The problem class', 2, None, '___sec220'),
              ('The solver class', 2, None, '___sec221'),
              ('Combining the objects', 3, None, '___sec222'),
              ('Improving the problem and solver classes',
               2,
               'softeng1:prog:se:class2',
               'softeng1:prog:se:class2'),
              ('A generic class for parameters', 3, None, '___sec224'),
              ('Automating scientific experiments',
               1,
               'softeng1:experiments',
               'softeng1:experiments'),
              ('Available software', 2, None, '___sec226'),
              ('The results we want to produce', 2, None, '___sec227'),
              ('Combining plot files', 2, None, '___sec228'),
              ('Running a program from Python', 2, None, '___sec229'),
              ('The automating script', 2, None, '___sec230'),
              ('Making a report',
               2,
               'softeng1:exper:report',
               'softeng1:exper:report'),
              ('Word, OpenOffice, GoogleDocs', 3, None, '___sec232'),
              ('HTML with MathJax', 3, None, '___sec233'),
              ('LaTeX', 3, None, '___sec234'),
              ('Sphinx', 3, None, '___sec235'),
              ('Markdown', 3, None, '___sec236'),
              ('IPython/Jupyter notebooks', 3, None, '___sec237'),
              ('Wiki formats', 3, None, '___sec238'),
              ('DocOnce', 3, None, '___sec239'),
              ('Publishing a complete project',
               2,
               'softeng1:exper:github',
               'softeng1:exper:github'),
              ('Exercises', 1, None, '___sec241'),
              ('Problem 39: Make a tool for differentiating curves',
               2,
               'softeng1:exer:derivative',
               'softeng1:exer:derivative'),
              ('Problem 40: Make solid software for the Trapezoidal rule',
               2,
               'softeng1:exer:integral:flat',
               'softeng1:exer:integral:flat'),
              ('Problem 41: Implement classes for the Trapezoidal rule',
               2,
               'softeng1:exer:integral:flat2',
               'softeng1:exer:integral:flat2'),
              ('Problem 42: Write a doctest and a test function',
               2,
               'softeng1:exer:doctest1',
               'softeng1:exer:doctest1'),
              ('Problem 43: Experiment with tolerances in comparisons',
               2,
               'softeng1:exer:tol',
               'softeng1:exer:tol'),
              ('Remarks', 3, None, '___sec247'),
              ('Exercise 44: Make use of a class implementation',
               2,
               'softeng1:exer:class:dts',
               'softeng1:exer:class:dts'),
              ('Problem 45: Make solid software for a difference equation',
               2,
               'softeng1:exer:logistic',
               'softeng1:exer:logistic'),
              ('Summarizing multiple-choice questions', 0, None, '___sec250'),
              ('Quiz', 1, None, '___sec251'),
              ('Exercise 46: Characterize a finite difference',
               2,
               'decay:quiz:fd:FE',
               'decay:quiz:fd:FE'),
              ('Exercise 47: Characterize a finite difference',
               2,
               'decay:quiz:fd:CN',
               'decay:quiz:fd:CN'),
              ('Exercise 48: What is the problem with this program?',
               2,
               'decay:quiz:program',
               'decay:quiz:program'),
              ('Exercise 49: Is the solution correct?',
               2,
               'decay:quiz:stability',
               'decay:quiz:stability'),
              ('Exercise 50: Is this a proper test function?',
               2,
               'decay:quiz:testfunc',
               'decay:quiz:testfunc'),
              ('Exercise 51: Rewrite an expression with array arithmetics',
               2,
               'decay:quiz:arrayarithm',
               'decay:quiz:arrayarithm'),
              ('Exercise 52: What is the truncation error?',
               2,
               'decay:quiz:trunc',
               'decay:quiz:trunc'),
              ('Exercise 53: Recognize a programming language',
               2,
               'decay:quiz:prog:m',
               'decay:quiz:prog:m'),
              ('Exercise 54: Recognize a programming language',
               2,
               'decay:quiz:prog:py',
               'decay:quiz:prog:py'),
              ('Exercise 55: Recognize a programming language',
               2,
               'decay:quiz:prog:f77',
               'decay:quiz:prog:f77'),
              ('Exercise 56: Recognize a programming language',
               2,
               'decay:quiz:prog:c',
               'decay:quiz:prog:c'),
              ('Exercise 57: What is SymPy?',
               2,
               'decay:quiz:sympy1',
               'decay:quiz:sympy1'),
              ('Exercise 58: Testing of code',
               2,
               'decay:quiz:testing1',
               'decay:quiz:testing1'),
              ('Exercise 59: What kind of scheme is this?',
               2,
               'decay:quiz:scheme:CN_error',
               'decay:quiz:scheme:CN_error'),
              ('Exercise 60: What kind of scheme is this?',
               2,
               'decay:quiz:scheme:BE',
               'decay:quiz:scheme:BE'),
              ('Exercise 61: What kind of scheme is this?',
               2,
               'decay:quiz:scheme:leapfrog',
               'decay:quiz:scheme:leapfrog'),
              ('References', 1, None, '___sec268')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\stress}{\boldsymbol{\sigma}}
$$




    
<a name="part0009"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._decay-book-solarized008.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._decay-book-solarized010.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<center><h1 id="decay:se">Scientific software engineering</h1></center> <hr>

<p>
Teaching material on scientific computing has traditionally been very
focused on the mathematics and the applications, while details on how
the computer is programmed to solve the problems have received little attention.
Many end up writing as simple programs as possible, without being
aware of much useful computer science technology that would increase
the fun, efficiency, and reliability of the their scientific computing
activities.

<p>
This chapter demonstrates a series of good practices and tools
from modern computer science, using the simple mathematical problem
\( u^{\prime}=-au \), \( u(0)=I \), such that we minimize the
mathematical details and can go more in depth with implementations.
The goal is to increase the technological
quality of computer programming and make it match the more
well-established quality of the mathematics of scientific computing.

<p>
The conventions and techniques outlined here will save you a lot of time
when you incrementally extend software over time from simpler to more
complicated problems. In particular, you will benefit from
many good habits:

<ul>
 <li> new code is added in a modular fashion to a library (modules),</li>
 <li> programs are run through convenient user interfaces,</li>
 <li> it takes one quick command to let all your code undergo heavy testing,</li>
 <li> tedious manual work with running programs is automated,</li>
 <li> your scientific investigations are reproducible,</li>
 <li> scientific reports with top quality typesetting are produced both
   for paper and electronic devices.</li>
</ul>

<h1 id="softeng1:basic">Implementations with functions and modules</h1>

<p>
All previous examples in this book have implemented numerical
algorithms as Python functions. This is a good style that readers
are expected to adopt. However, this author has experienced that
many students and engineers are inclined to make &quot;flat&quot; programs,
i.e., a sequence of statements without any use of functions, just to
get the problem solved as quickly as possible. Since this programming
style is so widespread, especially among people with MATLAB experience,
we shall look at the weaknesses of flat programs and show how they
can be <em>refactored</em> into more reusable programs based on functions.

<h2 id="softeng1:basic:math">Mathematical problem and solution technique</h2>

<p>
We address the differential equation problem

$$
\begin{align}
u'(t) &= -au(t), \quad t \in (0,T], \tag{194}\\ 
u(0)  &= I,                         \tag{195}
\end{align}
$$

where \( a \), \( I \), and \( T \) are prescribed parameters, and \( u(t) \) is
the unknown function to be estimated. This mathematical model
is relevant for physical phenomena featuring exponential decay
in time, e.g., vertical pressure variation in the atmosphere,
cooling of an object, and radioactive decay.

<p>
As we learned in the chapter <a href="._decay-book-solarized003.html#decay:schemes:FE">The Forward Euler scheme</a>, the
time domain is discretized with points \( 0 = t_0 < t_1 \cdots < t_{N_t}=T \),
here with a constant spacing \( \Delta t \) between the
mesh points: \( \Delta t = t_{n}-t_{n-1} \), \( n=1,\ldots,N_t \). Let
\( u^n \) be the numerical approximation to the exact solution at \( t_n \).
A family of popular numerical methods are provided by the \( \theta \) scheme,

$$
\begin{equation}
u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,
\tag{196}
\end{equation}
$$

for \( n=0,1,\ldots,N_t-1 \). This formula produces
the Forward Euler
scheme when \( \theta=0 \),
the Backward Euler
scheme when \( \theta=1 \),
and the Crank-Nicolson
scheme when \( \theta=1/2 \).

<h2 id="softeng1:basic:impl1">A first, quick implementation</h2>

<p>
Solving <a href="#mjx-eqn-196">(196)</a> in a program is very straightforward:
just make a loop over \( n \) and evaluate the formula. The \( u(t_n \))
values for discrete \( n \) can be stored in an array. This makes it easy
to also plot the solution. It would be natural to also add
the exact
solution curve \( u(t)=Ie^{-at} \) to the plot.

<p>
Many have programming habits that would lead them
to write a simple program like this:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>from numpy import *
from matplotlib.pyplot import *

A = 1
a = 2
T = 4
dt = 0.2
N = int(round(T/dt))
y = zeros(N+1)
t = linspace(0, T, N+1)
theta = 1
y[0] = A
for n in range(0, N):
    y[n+1] = (1 - (1-theta)*a*dt)/(1 + theta*dt*a)*y[n]

y_e = A*exp(-a*t) - y
error = y_e - y
E = sqrt(dt*sum(error**2))
print 'Norm of the error: %.3E' % E
plot(t, y, 'r--o')
t_e = linspace(0, T, 1001)
y_e = A*exp(-a*t_e)
plot(t_e, y_e, 'b-')
legend(['numerical, theta=%g' % theta, 'exact'])
xlabel('t')
ylabel('y')
show()
</code></pre>
<!-- end verbatim block -->

<p>
This program is easy to read, and as long it is correct, many will
claim that it has sufficient quality. Nevertheless, the program suffers
from two serious flaws:

<ol>
<li> The notation in the program does not correspond <em>exactly</em> to
   the notation in the mathematical problem: the solution is called
   <code>y</code> and corresponds to \( u \) in the mathematical description,
   the variable <code>A</code> corresponds to the mathematical parameter \( I \),
   <code>N</code> in the program is called \( N_t \) in the mathematics.</li>
<li> There are no comments in the program.</li>
</ol>

These kind of flaws quickly become crucial if present in code for complicated
mathematical problems and code that is meant to be extended to other problems.

<p>
We also note that the program is <em>flat</em> in the sense that it does
not contain functions. Usually, this is a bad habit, but let us
first correct the two mentioned flaws.

<h2 id="softeng1:basic:impl2">A more decent program</h2>

<p>
A code of better quality arises from
fixing the notation and adding comments:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>from numpy import *
from matplotlib.pyplot import *

I = 1
a = 2
T = 4
dt = 0.2
Nt = int(round(T/dt))     # no of time intervals
u = zeros(Nt+1)           # array of u[n] values
t = linspace(0, T, Nt+1)  # time mesh
theta = 1                 # Backward Euler method

u[0] = I                  # assign initial condition
for n in range(0, Nt):    # n=0,1,...,Nt-1
    u[n+1] = (1 - (1-theta)*a*dt)/(1 + theta*dt*a)*u[n]

# Compute norm of the error
u_e = I*exp(-a*t) - u     # exact u at the mesh points
error = u_e - u
E = sqrt(dt*sum(error**2))
print 'Norm of the error: %.3E' % E

# Compare numerical (u) and exact solution (u_e) in a plot
plot(t, u, 'r--o')
t_e = linspace(0, T, 1001)       # very fine mesh for u_e
u_e = I*exp(-a*t_e)
plot(t_e, u_e, 'b-')
legend(['numerical, theta=%g' % theta, 'exact'])
xlabel('t')
ylabel('u')
show()
</code></pre>
<!-- end verbatim block -->

<h3 id="___sec176">Comments in a program </h3>

<p>
There is obviously not just one way to comment a program, and opinions
may differ as to what code should be accomplished by comments.
The guiding principle is, however, that comments should make the
program easy to understand for human eye. Do not comment obvious
constructions, but focus on ideas and (&quot;what happens in the next
statements?&quot;) and on explaining code that can be interpreted as
complicated.

<h3 id="___sec177">Refactoring into functions </h3>

<p>
At first sight, our updated program seems like
a good starting point for playing around
with the mathematical problem: we can just change parameters and rerun.
Although such edit-and-rerun sessions are good for initial exploration,
one will soon extend the experiments and start developing the code
further. Say we want to compare \( \theta =0,1,0.5 \) in the same
plot. This extension requires changes all over the code and quickly
leads to errors. To do something serious with this program, we have to
break it into smaller pieces and make sure each piece is well tested,
and ensure that the program is sufficiently general and can be reused in
new contexts without changes.  The
next natural step is therefore to isolate the numerical computations
and the visualization in separate Python functions.
Such a rewrite of a code, without essentially changing the functionality,
but just improve the quality of the code, is known as <em>refactoring</em>.
After one has quickly put some code down and tested it, it is a common
step to refactor it so it is better prepared for extensions.

<h3 id="___sec178">Program file vs IDE vs notebook </h3>

<p>
There are basically three different ways of working with Python code:

<ol>
<li> One writes the code in a file, using a text editor (such as
   Emacs or Vim) and runs it in a terminal window.</li>
<li> One applies an <em>Integrated Development Environment</em> (the simplest is IDLE, which comes with standard Python) containing a graphical user interface with an editor and an element where Python code can be run.</li>
<li> One applies the Jupyter Notebook (previously known as IPython Notebook),
   which offers an interactive environment for Python code where
   plots are automatically inserted after the code, see Figure <a href="#softeng1:ipynb">20</a>.</li>
</ol>

It appears that method 1 and 2 are quite equivalent, but the notebook
encourages more experimental code and therefore also flat programs.
Consequently, notebook users will normally need to think more about
refactoring code and increase the use of functions after initial
experimentation.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 20:  Experimental code in a notebook. <div id="softeng1:ipynb"></div> </p></center>
<p><img src="fig-softeng/ipynb_flat.png" align="bottom" width=700></p>
</center>

<h2 id="softeng1:basic:modprefix">Prefixing imported functions by the module name</h2>

<p>
Import statements of the form <code>from module import *</code> import
<em>all</em> functions and variables in <code>module.py</code> into the current file.
This is often referred to as &quot;import star&quot;, and
many find this convenient, but it is not considered as a good
programming style in Python.
For example, when doing

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from numpy import *
from matplotlib.pyplot import *
</code></pre>
<!-- end verbatim block -->
we get mathematical functions like <code>sin</code> and <code>exp</code> as well as
MATLAB-style functions like <code>linspace</code> and <code>plot</code>, which can be called
by these well-known names.  Unfortunately, it sometimes becomes
confusing to know where a particular function comes from, i.e., what
modules you need to import. Is a desired function from <code>numpy</code> or
<code>matplotlib.pyplot</code>? Or is it our own function?  These questions are
easy to answer if functions in modules are prefixed by the module
name. Doing an additional <code>from math import *</code> is really crucial: now
<code>sin</code>, <code>cos</code>, and other mathematical functions are imported and their
names hide those previously imported from <code>numpy</code>.  That is, <code>sin</code> is
now a sine function that accepts a <code>float</code> argument, not an array.

<p>
Doing the import such that module functions must have a prefix
is generally recommended:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import numpy
import matplotlib.pyplot

t = numpy.linspace(0, T, Nt+1)
u_e = I*numpy.exp(-a*t)
matplotlib.pyplot.plot(t, u_e)
</code></pre>
<!-- end verbatim block -->

<p>
The modules <code>numpy</code> and <code>matplotlib.pyplot</code> are frequently used,
and since their full names are quite tedious to write,
two standard abbreviations
have evolved in the Python scientific computing community:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import numpy as np
import matplotlib.pyplot as plt

t = np.linspace(0, T, Nt+1)
u_e = I*np.exp(-a*t)
plt.plot(t, u_e)
</code></pre>
<!-- end verbatim block -->

<p>
The downside of prefixing functions by the module name is that
mathematical expressions like \( e^{-at}\sin(2\pi t) \) get
cluttered with module names,
<!-- begin verbatim block  pycod-->
<pre><code>numpy.exp(-a*t)*numpy.sin(2(numpy.pi*t)
# or
np.exp(-a*t)*np.sin(2*np.pi*t)
</code></pre>
<!-- end verbatim block -->
Such an expression looks like <code>exp(-a*t)*sin(2*pi*t)</code> in most other
programming languages. Similarly, <code>np.linspace</code> and <code>plt.plot</code> look
less familiar to people who are used to MATLAB and who have not
adopted Python's prefix style.  Whether to do <code>from module import *</code>
or <code>import module</code> depends on personal taste and the problem at
hand. In these writings we use <code>from module import *</code> in more basic,
shorter programs where similarity with MATLAB could be an
advantage. However, in reusable modules we prefix calls to module
functions by their function name, <em>or</em> do explicit import of the
needed functions:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from numpy import exp, sum, sqrt

def u_exact(t, I, a):
    return I*exp(-a*t)

error = u_exact(t, I, a) - u
E = sqrt(dt*sum(error**2))
</code></pre>
<!-- end verbatim block -->

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Prefixing module functions or not?</b>
<p>
It can be advantageous to do a combination: mathematical functions
in formulas are imported without prefix, while module functions
in general are called with a prefix. For the <code>numpy</code> package we
can do

<p>
<!-- begin verbatim block -->
<pre><code>import numpy as np
from numpy import exp, sum, sqrt
</code></pre>
<!-- end verbatim block -->
such that mathematical expression can apply <code>exp</code>, <code>sum</code>, and <code>sqrt</code>
and hence look as close to the mathematical formulas as possible
(without a disturbing prefix).
Other calls to <code>numpy</code> function are done with the prefix, as in
<code>np.linspace</code>.
</div>


<h2 id="softeng1:basic:func">Implementing the numerical algorithm in a function</h2>

<p>
The solution formula <a href="#mjx-eqn-196">(196)</a> is completely general and
should be available as a Python function <code>solver</code> with all input data as
function arguments and all output data returned to the calling code.
With this <code>solver</code> function we can solve all types of problems
<a href="#mjx-eqn-194">(194)</a>-<a href="#mjx-eqn-195">(195)</a>
by an easy-to-read one-line statement:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>u, t = solver(I=1, a=2, T=4, dt=0.2, theta=0.5)
</code></pre>
<!-- end verbatim block -->

<p>
Refactoring the numerical method in the previous flat program
in terms of a <code>solver</code> function and prefixing calls to
module functions by the module name leads to this code:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def solver(I, a, T, dt, theta):
    &quot;&quot;&quot;Solve u'=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;
    dt = float(dt)               # avoid integer division
    Nt = int(round(T/dt))        # no of time intervals
    T = Nt*dt                    # adjust T to fit time step dt
    u = np.zeros(Nt+1)           # array of u[n] values
    t = np.linspace(0, T, Nt+1)  # time mesh

    u[0] = I                  # assign initial condition
    for n in range(0, Nt):    # n=0,1,...,Nt-1
        u[n+1] = (1 - (1-theta)*a*dt)/(1 + theta*dt*a)*u[n]
    return u, t
</code></pre>
<!-- end verbatim block -->

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Tip: Always use a doc string to document a function!</b>
<p>
Python has a convention for documenting the purpose and usage of
a function in a <em>doc string</em>: simply place the documentation
in a one- or multi-line triple-quoted string right after the
function header.
</div>


<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Be careful with unintended integer division!</b>
<p>
Note that we in the <code>solver</code> function explicitly covert <code>dt</code> to a
<code>float</code> object. If not, the updating formula for <code>u[n+1]</code> may evaluate
to zero because of integer division when <code>theta</code>, <code>a</code>, and <code>dt</code> are integers!
</div>


<h2 id="___sec181">Do not have several versions of a code </h2>

<p>
One of the most serious flaws in computational work is to have several
slightly different implementations of the same computational algorithms
lying around in various program files. This is very likely to happen,
because busy scientists often want to test a slight variation of a code to see
what happens. A quick copy-and-edit does the task, but such quick hacks tend
to survive. When a real correction is needed in the implementation,
it is difficult to ensure that the correction is done in all relevant files.
In fact, this is a general problem in programming, which has led to
an important principle.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>The DRY principle: Don't repeat yourself!</b>
<p>
When implementing a particular functionality in a computer program, make sure
this functionality and its variations are implemented in just one piece
of code. That is, if you need to revise the implementation, there should be
<em>one and only one</em> place to edit. It follows that you should never
duplicate code (don't repeat yourself!), and code snippets that are
similar should be factored into one piece (function) and parameterized (by
function arguments).
</div>


<p>
The DRY principle means that our <code>solver</code> function should not be
copied to a new file if we need some modifications. Instead, we
should try to extend <code>solver</code> such that the new and old needs are
met by a single function. Sometimes this process requires a new
refactoring, but having a numerical method in one and only one place
is a great advantage.

<h2 id="softeng1:basic:module">Making a module</h2>

<p>
As soon as you start making Python functions in a program, you should
make sure the program file fulfills the requirement of a module.
This means that you can import and reuse your functions in other
programs too. For example, if our <code>solver</code> function resides in a
module file <code>decay.py</code>, another program may reuse of the
function either by

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from decay import solver
u, t = solver(I=1, a=2, T=4, dt=0.2, theta=0.5)
</code></pre>
<!-- end verbatim block -->
or by a slightly different import statement, combined with a subsequent
prefix of the function name by the name of the module:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import decay
u, t = decay.solver(I=1, a=2, T=4, dt=0.2, theta=0.5)
</code></pre>
<!-- end verbatim block -->

<p>
The requirements for a program file to also qualify for a module are simple:

<ol>
<li> The filename without <code>.py</code> must be a valid Python variable name.</li>
<li> The main program must be executed (through statements or
   a function call) in the <em>test block</em>.</li>
</ol>

The <em>test block</em> is normally placed at the end of a module file:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if __name__ == '__main__':
    # Statements
</code></pre>
<!-- end verbatim block -->
When the module file is executed as a stand-alone program, the if test
is true and the indented statements are run. If the module file
is imported, however, <code>__name__</code> equals the module name and the test block
is not executed.

<p>
To demonstrate the difference, consider the trivial module
file <code>hello.py</code> with one function and a call to this function as main program:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>def hello(arg='World!'):
    print 'Hello, ' + arg

if __name__ == '__main__':
    hello()
</code></pre>
<!-- end verbatim block -->
Without the test block, the code reads

<p>
<!-- begin verbatim block  pypro-->
<pre><code>def hello(arg='World!'):
    print 'Hello, ' + arg

hello()
</code></pre>
<!-- end verbatim block -->
With this latter version of the file, any attempt to import <code>hello</code>
will, at the same time, execute the call <code>hello()</code> and hence write
&quot;Hello, World!&quot; to the screen.  Such output is not desired when
importing a module!  To make import and execution of code independent
for another program that wants to use the function <code>hello</code>, the module
<code>hello</code> must be written with a test block. Furthermore, running the
file itself as <code>python hello.py</code> will make the block active and lead
to the desired printing.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>All coming functions are placed in a module!</b>
<p>
The many functions to be explained in the following text are
put in one module file <a href="http://tinyurl.com/ofkw6kc/softeng/decay.py" target="_self"><tt>decay.py</tt></a>.
</div>


<p>
What more than the <code>solver</code> function is needed in our <code>decay</code> module
to do everything we did in the previous, flat program?  We need import
statements for <code>numpy</code> and <code>matplotlib</code> as well as another function
for producing the plot. It can also be convenient to put the exact
solution in a Python function.  Our module <code>decay.py</code> then looks like
this:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import numpy as np
import matplotlib.pyplot as plt

def solver(I, a, T, dt, theta):
    ...

def u_exact(t, I, a):
    return I*np.exp(-a*t)

def experiment_compare_numerical_and_exact():
    I = 1;  a = 2;  T = 4;  dt = 0.4;  theta = 1
    u, t = solver(I, a, T, dt, theta)

    t_e = np.linspace(0, T, 1001)       # very fine mesh for u_e
    u_e = u_exact(t_e, I, a)

    plt.plot(t,   u,   'r--o')       # dashed red line with circles
    plt.plot(t_e, u_e, 'b-')         # blue line for u_e
    plt.legend(['numerical, theta=%g' % theta, 'exact'])
    plt.xlabel('t')
    plt.ylabel('u')
    plotfile = 'tmp'
    plt.savefig(plotfile + '.png');  plt.savefig(plotfile + '.pdf')

    error = u_exact(t, I, a) - u
    E = np.sqrt(dt*np.sum(error**2))
    print 'Error norm:', E

if __name__ == '__main__':
    experiment_compare_numerical_and_exact()
</code></pre>
<!-- end verbatim block -->
We could consider doing <code>from numpy import exp, sqrt, sum</code> to make
the mathematical expressions with these functions closer to the
mathematical formulas, but here we employed the prefix since the
formulas are so simple and easy to read.

<p>
This module file does exactly the same as the previous, flat program,
but now it becomes much easier to extend the code with more functions
that produce other plots, other experiments, etc. Even more important, though,
is that the numerical
algorithm is coded and tested once and for all in the <code>solver</code>
function, and any need to solve the mathematical problem is a matter
of one function call.
<!-- (not copying initialization statements and a loop -->
<!-- to a new program for ad hoc editing!). -->

<h2 id="softeng1:basic:experiment2">Example on extending the module code</h2>

<p>
Let us specifically demonstrate one extension of the flat program in
the section <a href="#softeng1:basic:impl1">A first, quick implementation</a> that would require substantial
editing of the flat code (the section <a href="#softeng1:basic:impl2">A more decent program</a>), while in
a structured module (the section <a href="#softeng1:basic:module">Making a module</a>), we can
simply add a new function without affecting the existing code.

<p>
Our example that illustrates the extension
is to make a comparison between the numerical solutions
for various schemes (\( \theta \) values) and the exact solution:

<p>
<center><p><img src="fig-softeng/compare.png" align="bottom" width=600></p></center>

<p>
<div class="alert alert-block alert-question alert-text-normal">
<b>Wait a minute!</b>
<p>
Look at the flat program in
the section <a href="#softeng1:basic:impl1">A first, quick implementation</a>,
and try to imagine which edits that are required to solve this new problem.
</div>


<p>
With the <code>solver</code> function at hand, we can simply create a function
with a loop over <code>theta</code> values and add the necessary plot statements:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def experiment_compare_schemes():
    &quot;&quot;&quot;Compare theta=0,1,0.5 in the same plot.&quot;&quot;&quot;
    I = 1;  a = 2;  T = 4;  dt = 0.4
    legends = []
    for theta in [0, 1, 0.5]:
        u, t = solver(I, a, T, dt, theta)
        plt.plot(t, u, '--o')
        legends.append('theta=%g' % theta)
    t_e = np.linspace(0, T, 1001)        # very fine mesh for u_e
    u_e = u_exact(t_e, I, a)
    plt.plot(t_e, u_e, 'b-')
    legends.append('exact')
    plt.legend(legends, loc='upper right')
    plotfile = 'tmp'
    plt.savefig(plotfile + '.png');  plt.savefig(plotfile + '.pdf')
</code></pre>
<!-- end verbatim block -->

<p>
A call to this <code>experiment_compare_schemes</code> function must be placed
in the test block, or you can run the program from IPython instead:

<p>
<!-- begin verbatim block  ipy-->
<pre><code>In[1]: from decay import *

In[2]: experiment_compare_schemes()
</code></pre>
<!-- end verbatim block -->

<p>
We do not present how the flat program from
the section <a href="#softeng1:basic:impl2">A more decent program</a> must be refactored to produce the
desired plots, but simply state that the danger of introducing bugs
is significantly larger than when just writing an additional function
in the <code>decay</code> module.

<h2 id="softeng1:basic:docstring">Documenting functions and modules</h2>

<p>
We have already emphasized the importance of documenting functions with
a doc string (see the section <a href="#softeng1:basic:func">Implementing the numerical algorithm in a function</a>). Now it is time
to show how doc strings should be structured in order to take advantage
of the documentation utilities in the <code>numpy</code> module. The idea is
to follow a convention that in itself makes a good pure text doc string
in the terminal window
and at the same time can be translated to beautiful HTML manuals for
the web.

<p>
The conventions for <code>numpy</code> style doc strings are well
<a href="https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt" target="_self">documented</a>, so here we just present a basic example that the reader can adopt.
Input arguments to a function are listed under the heading <code>Parameters</code>,
while returned values are listed under <code>Returns</code>. It is a good idea to
also add an <code>Examples</code> section on the usage of the function.
More complicated software may have additional sections, see <code>pydoc numpy.load</code>
for an example. The markup language available for doc strings is
Sphinx-extended reStructuredText. The example below shows typical
constructs: 1) how inline
mathematics is written with the <code>:math:</code> directive, 2) how arguments
to the functions are referred to using single backticks
(inline monospace font for code applies double backticks), and 3) how
arguments and return values are listed with types and explanation.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def solver(I, a, T, dt, theta):
    &quot;&quot;&quot;
    Solve :math:`u'=-au` with :math:`u(0)=I` for :math:`t \in (0,T]`
    with steps of `dt` and the method implied by `theta`.

    Parameters
    ----------
    I: float
        Initial condition.
    a: float
        Parameter in the differential equation.
    T: float
        Total simulation time.
    theta: float, int
        Parameter in the numerical scheme. 0 gives
        Forward Euler, 1 Backward Euler, and 0.5
        the centered Crank-Nicolson scheme.

    Returns
    -------
    `u`: array
        Solution array.
    `t`: array
        Array with time points corresponding to `u`.

    Examples
    --------
    Solve :math:`u' = -\\frac{1}{2}u, u(0)=1.5`
    with the Crank-Nicolson method:

    &gt;&gt;&gt; u, t = solver(I=1.5, a=0.5, T=9, theta=0.5)
    &gt;&gt;&gt; import matplotlib.pyplot as plt
    &gt;&gt;&gt; plt.plot(t, u)
    &gt;&gt;&gt; plt.show()
    &quot;&quot;&quot;
</code></pre>
<!-- end verbatim block -->
If you follow such doc string conventions in your software, you can
easily produce nice manuals that meet the standard expected within
the Python scientific computing community.

<p>
<a href="http://sphinx-doc.org/" target="_self">Sphinx</a> requires quite a number of manual steps to
prepare a manual, so it is
recommended to use a <a href="http://tinyurl.com/ofkw6kc/softeng/make_sphinx_api.py" target="_self">premade script</a> to automate the steps. (By default,
the script generates documentation for all <code>*.py</code> files in the
current directory.
You need to do a <code>pip install</code> of <code>sphinx</code> and <code>numpydoc</code> to make the
script work.)
Figure <a href="#softeng1:basic:docstring:fig">21</a> provides an example of what
the above doc strings look like when Sphinx has transformed them to HTML.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 21:  Example on Sphinx API manual in HTML. <div id="softeng1:basic:docstring:fig"></div> </p></center>
<p><img src="fig-softeng/selfdoc_numpy.png" align="bottom" width=700></p>
</center>

<h2 id="softeng1:basic:logging">Logging intermediate results</h2>

<p>
Sometimes one may wish that a simulation program could write out
intermediate results for inspection. This could be accomplished by
a (global) <code>verbose</code> variable and code like

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if verbose &gt;= 2:
    print 'u[%d]=%g' % (i, u[i])
</code></pre>
<!-- end verbatim block -->
The professional way to do report intermediate results and problems is,
however, to use a <em>logger</em>. This is an object that writes messages
to a log file. The messages are classified as debug, info, and warning.

<h3 id="___sec186">Introductory example </h3>

<p>
Here is a simple example using defining a logger, using Python's <code>logging</code>
module:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>import logging
import logging
logging.basicConfig(
    filename='myprog.log', filemode='w', level=logging.WARNING,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%m/%d/%Y %I:%M:%S %p')
logging.info('Here is some general info.')
logging.warning('Here is a warning.')
logging.debug('Here is some debugging info.')
logging.critical('Dividing by zero!')
logging.error('Encountered an error.')
</code></pre>
<!-- end verbatim block -->
Running this program gives the following output in the log file <code>myprog.log</code>:

<p>
<!-- begin verbatim block  dat-->
<pre><code>09/26/2015 09:25:10 AM - INFO - Here is some general info.
09/26/2015 09:25:10 AM - WARNING - Here is a warning.
09/26/2015 09:25:10 AM - CRITICAL - Dividing by zero!
09/26/2015 09:25:10 AM - ERROR - Encountered an error.
</code></pre>
<!-- end verbatim block -->
The logger has different <em>levels</em> of messages, ordered as
<em>critical</em>, <em>error</em>, <em>warning</em>, <em>info</em>, and <em>debug</em>.
The <code>level</code> argument to <code>logging.basicConfig</code> sets the level
and thereby determines what the logger will print to the file:
all messages at the specified <em>and lower</em> levels are printed.
For example, in the above example we set the level to be
<em>info</em>, and therefore the critical, error, warning, and info
messages were printed, but not the debug message.
Setting level to debug (<code>logging.DEBUG</code>) prints all messages,
while level <em>critical</em> prints only the critical messages.

<p>
The <code>filemode</code> argument is set to <code>w</code> such that any existing
log file is overwritten (the default is <code>a</code>, which means append
new messages to an existing log file, but this is seldom what
you want in mathematical computations).

<p>
The messages are preceded by the date and time and the level of
the message. This output is governed by the <code>format</code> argument:
<code>asctime</code> is the date and time, <code>levelname</code> is the name of
the message level, and <code>message</code> is the message itself.
Setting <code>format='%(message)s'</code> ensures that just the message and
nothing more is printed on each line. The <code>datefmt</code> string
specifies the formatting of the date and time, using the
rules of the <a href="https://docs.python.org/2/library/time.html#time.strftime" target="_self"><tt>time.strftime</tt></a> function.

<h3 id="___sec187">Using a logger in our solver function </h3>

<p>
Let us let a logger write out intermediate results and some debugging
results in the <code>solver</code> function. Such messages are useful for
monitoring the simulation and for debugging it, respectively.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import logging
logging.basicConfig(
    filename='decay.log', filemode='w', level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y.%m.%d %I:%M:%S %p')

def solver_with_logging(I, a, T, dt, theta):
    &quot;&quot;&quot;Solve u'=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;
    dt = float(dt)               # avoid integer division
    Nt = int(round(T/dt))        # no of time intervals
    T = Nt*dt                    # adjust T to fit time step dt
    u = np.zeros(Nt+1)           # array of u[n] values
    t = np.linspace(0, T, Nt+1)  # time mesh
    logging.debug('solver: dt=%g, Nt=%g, T=%g' % (dt, Nt, T))

    u[0] = I                  # assign initial condition
    for n in range(0, Nt):    # n=0,1,...,Nt-1
        u[n+1] = (1 - (1-theta)*a*dt)/(1 + theta*dt*a)*u[n]

        logging.info('u[%d]=%g' % (n, u[n]))
        logging.debug('1 - (1-theta)*a*dt: %g, %s' %
                      (1-(1-theta)*a*dt,
                       str(type(1-(1-theta)*a*dt))[7:-2]))
        logging.debug('1 + theta*dt*a: %g, %s' %
                      (1 + theta*dt*a,
                       str(type(1 + theta*dt*a))[7:-2]))
    return u, t
</code></pre>
<!-- end verbatim block -->
We can run this new solver function in a shell:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; import decay
&gt;&gt;&gt; u, t = decay.solver_with_logging(I=1, a=0.5, T=10, \ 
           dt=0.5, theta=0.5)
</code></pre>
<!-- end verbatim block -->
During this execution, each logging message is appended to the log file.
Suppose we add some pause (<code>time.sleep(2)</code>) at each time level such that
the execution takes some time. In another terminal window we can then
monitor the evolution of <code>decay.log</code> and the simulation
by the <code>tail -f</code> Unix command:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>Terminal&gt; tail -f decay.log
2015.09.26 05:37:41 AM - INFO - u[0]=1
2015.09.26 05:37:41 AM - INFO - u[1]=0.777778
2015.09.26 05:37:41 AM - INFO - u[2]=0.604938
2015.09.26 05:37:41 AM - INFO - u[3]=0.470508
2015.09.26 05:37:41 AM - INFO - u[4]=0.36595
2015.09.26 05:37:41 AM - INFO - u[5]=0.284628
</code></pre>
<!-- end verbatim block -->
Especially in simulation where each time step demands considerable
CPU time (minutes, hours), it can be handy to monitor such a log file
to see the evolution of the simulation.

<p>
If we want to look more closely into the numerator and denominator of
the formula for \( u^{n+1} \), we can change the logging level to
<code>level=logging.DEBUG</code> and get output in <code>decay.log</code> like

<p>
<!-- begin verbatim block  dat-->
<pre><code>2015.09.26 05:40:01 AM - DEBUG - solver: dt=0.5, Nt=20, T=10
2015.09.26 05:40:01 AM - INFO - u[0]=1
2015.09.26 05:40:01 AM - DEBUG - 1 - (1-theta)*a*dt: 0.875, float
2015.09.26 05:40:01 AM - DEBUG - 1 + theta*dt*a: 1.125, float
2015.09.26 05:40:01 AM - INFO - u[1]=0.777778
2015.09.26 05:40:01 AM - DEBUG - 1 - (1-theta)*a*dt: 0.875, float
2015.09.26 05:40:01 AM - DEBUG - 1 + theta*dt*a: 1.125, float
2015.09.26 05:40:01 AM - INFO - u[2]=0.604938
2015.09.26 05:40:01 AM - DEBUG - 1 - (1-theta)*a*dt: 0.875, float
2015.09.26 05:40:01 AM - DEBUG - 1 + theta*dt*a: 1.125, float
2015.09.26 05:40:01 AM - INFO - u[3]=0.470508
2015.09.26 05:40:01 AM - DEBUG - 1 - (1-theta)*a*dt: 0.875, float
2015.09.26 05:40:01 AM - DEBUG - 1 + theta*dt*a: 1.125, float
2015.09.26 05:40:01 AM - INFO - u[4]=0.36595
2015.09.26 05:40:01 AM - DEBUG - 1 - (1-theta)*a*dt: 0.875, float
2015.09.26 05:40:01 AM - DEBUG - 1 + theta*dt*a: 1.125, float
</code></pre>
<!-- end verbatim block -->

<h1 id="softeng1:basic:UI">User interfaces</h1>

<p>
It is good programming practice to let programs read input from
some <em>user interface</em>, rather than requiring users to <em>edit</em>
parameter values in the source code. With effective user interfaces
it becomes easier and safer to apply the code for scientific investigations and
in particular to automate large-scale investigations by other programs
(see the section <a href="#softeng1:experiments">Automating scientific experiments</a>).

<p>
Reading input data can be done in many ways. We have to decide on the
functionality of the user interface, i.e., how we want to operate the
program when providing input. Thereafter, we use appropriate tools to
implement that particular user interface. There are four basic types
of user interface, listed here according to implementational
complexity, from lowest to highest:

<ol>
<li> Questions and answers in the terminal window</li>
<li> Command-line arguments</li>
<li> Reading data from files</li>
<li> Graphical user interfaces (GUIs)</li>
</ol>

Personal preferences of user interfaces differ substantially, and it is
difficult to present recommendations or pros and cons.
Alternatives 2 and 4 are most popular and will be addressed next.
The goal is to make it easy for the user to
set physical and numerical parameters in
our <code>decay.py</code> program. We use  a little toy program, called
<code>prog.py</code>, as introductory
example:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>delta = 0.5
p = 2
from math import exp
result = delta*exp(-p)
print result
</code></pre>
<!-- end verbatim block -->
The essential content is that <code>prog.py</code> has two input parameters: <code>delta</code>
and <code>p</code>. A user interface will replace the first two assignments to
<code>delta</code> and <code>p</code>.

<h2 id="___sec189">Command-line arguments </h2>

<p>
The command-line arguments are all the words that appear on the
command line after the program name. Running a program <code>prog.py</code>
as <code>python prog.py arg1 arg2</code> means that there are two command-line arguments
(separated by white space): <code>arg1</code> and <code>arg2</code>.
Python stores all command-line arguments in
a special list <code>sys.argv</code>. (The name <code>argv</code> stems from the C language and
stands for &quot;argument values&quot;. In C there is also an integer variable
called <code>argc</code> reflecting the number of arguments, or &quot;argument counter&quot;.
A lot of programming languages have adopted the variable name <code>argv</code> for
the command-line arguments.)
Here is an example on a
program <code>what_is_sys_argv.py</code> that can show us what the command-line arguments
are

<p>
<!-- begin verbatim block  pypro-->
<pre><code>import sys
print sys.argv
</code></pre>
<!-- end verbatim block -->
A sample run goes like

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; python what_is_sys_argv.py 5.0 'two words' -1E+4
['what_is_sys_argv.py', '5.0', 'two words', '-1E+4']
</code></pre>
<!-- end verbatim block -->
We make two observations:

<ul>
 <li> <code>sys.argv[0]</code> is the name of the program,
   and the sublist <code>sys.argv[1:]</code> contains all the command-line arguments.</li>
 <li> Each command-line argument is available as a string. A conversion to
   <code>float</code> is necessary if we want to compute with the numbers 5.0 and
   \( 10^4 \).</li>
</ul>

There are, in principle, two ways of programming with
command-line arguments in Python:

<ul>
 <li> <b>Positional arguments:</b> Decide upon a sequence of parameters
   on the command line and read
   their values directly from the <code>sys.argv[1:]</code> list.</li>
 <li> <b>Option-value pairs:</b>  Use <code>--option value</code> on
   the command line to replace the default value of an input parameter
   <code>option</code> by <code>value</code> (and utilize the <code>argparse.ArgumentParser</code> tool
   for implementation).</li>
</ul>

Suppose we want to run some program <code>prog.py</code> with
specification of two parameters <code>p</code> and <code>delta</code> on the command line.
With positional command-line arguments we write

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; python prog.py 2 0.5
</code></pre>
<!-- end verbatim block -->
and must know that the first argument <code>2</code> represents <code>p</code> and the
next <code>0.5</code> is the value of <code>delta</code>.
With option-value pairs we can run

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; python prog.py --delta 0.5 --p 2
</code></pre>
<!-- end verbatim block -->
Now, both <code>p</code> and <code>delta</code> are supposed to have default values in the program,
so we need to specify only the parameter that is to be changed from
its default value, e.g.,

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; python prog.py --p 2         # p=2, default delta
Terminal&gt; python prog.py --delta 0.7   # delta-0.7, default a
Terminal&gt; python prog.py               # default a and delta
</code></pre>
<!-- end verbatim block -->

<p>
How do we extend the <code>prog.py</code> code for positional arguments
and option-value pairs? Positional arguments require very simple
code:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>import sys
p = float(sys.argv[1])
delta = float(sys.argv[2])

from math import exp
result = delta*exp(-p)
print result
</code></pre>
<!-- end verbatim block -->
If the user forgets to supply two command-line arguments, Python will
raise an <code>IndexError</code> exception and produce a long error message.
To avoid that, we should use a <code>try-except</code> construction:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>import sys
try:
    p = float(sys.argv[1])
    delta = float(sys.argv[2])
except IndexError:
    print 'Usage: %s p delta' % sys.argv[0]
    sys.exit(1)

from math import exp
result = delta*exp(-p)
print result
</code></pre>
<!-- end verbatim block -->
Using <code>sys.exit(1)</code> aborts the program. The value 1 (actually any
value different from 0) notifies the operating system that the
program failed.

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Command-line arguments are strings!</b>
<p>
Note that all elements in <code>sys.argv</code> are string objects.
If the values will enter mathematical computations, we need
to explicitly convert the strings to numbers.
</div>


<p>
Option-value pairs requires more programming and is actually
better explained in a more comprehensive example below.
Minimal code for our <code>prog.py</code> program reads

<p>
<!-- begin verbatim block  pypro-->
<pre><code>import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--p', default=1.0)
parser.add_argument('--delta', default=0.1)

args = parser.parse_args()
p = args.p
delta = args.delta

from math import exp
result = delta*exp(-p)
print result
</code></pre>
<!-- end verbatim block -->
Because the default values of <code>delta</code> and <code>p</code> are float numbers,
the <code>args.delta</code> and <code>args.p</code> variable are automatically of type <code>float</code>.

<p>
Our next task is to use these basic code constructs to equip our
<code>decay.py</code> module with command-line interfaces.

<h2 id="___sec190">Positional command-line arguments </h2>

<p>
For our <code>decay.py</code> module file, we want include functionality such
that we can read \( I \), \( a \), \( T \), \( \theta \), and a range of \( \Delta t \)
values from the command line.  A plot is then to be made, comparing
the different numerical solutions for different \( \Delta t \) values
against the exact solution. The technical details of getting the
command-line information into the program is covered in the next
two sections.

<p>
The simplest way of reading the input parameters is to
decide on their sequence on the command line and just index
the <code>sys.argv</code> list accordingly.
Say the sequence of input data for some functionality in
<code>decay.py</code> is \( I \), \( a \), \( T \), \( \theta \) followed by an
arbitrary number of \( \Delta t \) values. This code extracts
these <em>positional</em> command-line arguments:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def read_command_line_positional():
    if len(sys.argv) &lt; 6:
        print 'Usage: %s I a T on/off BE/FE/CN dt1 dt2 dt3 ...' % \ 
              sys.argv[0]; sys.exit(1)  # abort

    I = float(sys.argv[1])
    a = float(sys.argv[2])
    T = float(sys.argv[3])
    theta = float(sys.argv[4])
    dt_values = [float(arg) for arg in sys.argv[5:]]

    return I, a, T, theta, dt_values
</code></pre>
<!-- end verbatim block -->
Note that we may use a <code>try-except</code> construction instead of the if test.

<p>
A run like

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; python decay.py 1 0.5 4 0.5 1.5 0.75 0.1
</code></pre>
<!-- end verbatim block -->
results in

<p>
<!-- begin verbatim block  pycod-->
<pre><code>sys.argv = ['decay.py', '1', '0.5', '4', '0.5', '1.5', '0.75', '0.1']
</code></pre>
<!-- end verbatim block -->
and consequently the assignments <code>I=1.0</code>, <code>a=0.5</code>, <code>T=4.0</code>, <code>thet=0.5</code>,
and <code>dt_values = [1.5, 0.75, 0.1]</code>.

<p>
Instead of specifying the \( \theta \) value, we could be a bit more
sophisticated and let the user write the name of the scheme:
<code>BE</code> for Backward Euler, <code>FE</code> for Forward Euler, and <code>CN</code>
for Crank-Nicolson. Then we must map this string to the proper
\( \theta \) value, an operation elegantly done by a dictionary:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>scheme = sys.argv[4]
scheme2theta = {'BE': 1, 'CN': 0.5, 'FE': 0}
if scheme in scheme2theta:
    theta = scheme2theta[scheme]
else:
    print 'Invalid scheme name:', scheme; sys.exit(1)
</code></pre>
<!-- end verbatim block -->
Now we can do

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; python decay.py 1 0.5 4 CN 1.5 0.75 0.1
</code></pre>
<!-- end verbatim block -->
and get `theta=0.5`in the code.

<h2 id="___sec191">Option-value pairs on the command line </h2>

<p>
Now we want to specify option-value pairs on the command line,
using <code>--I</code> for <code>I</code> (\( I \)), <code>--a</code> for <code>a</code> (\( a \)), <code>--T</code> for <code>T</code> (\( T \)),
<code>--scheme</code> for the scheme name (<code>BE</code>, <code>FE</code>, <code>CN</code>),
and <code>--dt</code> for the sequence of <code>dt</code> (\( \Delta t \)) values.
Each parameter must have a sensible default value so
that we specify the option on the command line only when the default
value is not suitable. Here is a typical run:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; python decay.py --I 2.5 --dt 0.1 0.2 0.01 --a 0.4
</code></pre>
<!-- end verbatim block -->
Observe the major advantage over positional command-line arguments:
the input is much easier to read and much easier to write.
With positional arguments it is easy to mess up the sequence of
the input parameters and quite challenging to detect errors too,
unless there are just a couple of arguments.

<p>
Python's <code>ArgumentParser</code> tool in the <code>argparse</code> module makes it easy
to create a professional command-line interface to any program. The
documentation of <a href="http://docs.python.org/library/argparse.html" target="_self"><tt>ArgumentParser</tt></a> demonstrates its
versatile applications, so we shall here just list an example
containing the most basic features. It always pays off to use <code>ArgumentParser</code>
rather than trying to manually inspect and interpret option-value pairs
in <code>sys.argv</code>!

<p>
The use of <code>ArgumentParser</code> typically involves three steps:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import argparse
parser = argparse.ArgumentParser()

# Step 1: add arguments
parser.add_argument('--option_name', ...)

# Step 2: interpret the command line
args = parser.parse_args()

# Step 3: extract values
value = args.option_name
</code></pre>
<!-- end verbatim block -->

<p>
A function for setting up all the options is handy:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def define_command_line_options():
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--I', '--initial_condition', type=float,
        default=1.0, help='initial condition, u(0)',
        metavar='I')
    parser.add_argument(
        '--a', type=float, default=1.0,
        help='coefficient in ODE', metavar='a')
    parser.add_argument(
        '--T', '--stop_time', type=float,
        default=1.0, help='end time of simulation',
        metavar='T')
    parser.add_argument(
        '--scheme', type=str, default='CN',
        help='FE, BE, or CN')
    parser.add_argument(
        '--dt', '--time_step_values', type=float,
        default=[1.0], help='time step values',
        metavar='dt', nargs='+', dest='dt_values')
    return parser
</code></pre>
<!-- end verbatim block -->

<p>
Each command-line option is defined through the <code>parser.add_argument</code>
method [<a id="link_footnote_1" href="#def_footnote_1">1</a>]. Alternative options, like the short <code>--I</code> and the more
explaining version <code>--initial_condition</code> can be defined. Other arguments
are <code>type</code> for the Python object type, a default value, and a help
string, which gets printed if the command-line argument <code>-h</code> or <code>--help</code> is
included. The <code>metavar</code> argument specifies the value associated with
the option when the help string is printed. For example, the option for
\( I \) has this help output:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; python decay.py -h
  ...
  --I I, --initial_condition I
                        initial condition, u(0)
  ...
</code></pre>
<!-- end verbatim block -->
The structure of this output is

<p>
<!-- begin verbatim block -->
<pre><code>  --I metavar, --initial_condition metavar
                        help-string
</code></pre>
<!-- end verbatim block -->

<p id="def_footnote_1"><a href="#link_footnote_1"><b>1:</b></a> We use the expression <em>method</em> here, because <code>parser</code>
is a class variable and functions in classes are known as methods in Python
and many other languages.
Readers not familiar with class programming can just substitute
this use of <em>method</em> by <em>function</em>.</p>

<p>
Finally, the <code>--dt</code> option demonstrates how to allow for more than one
value (separated by blanks) through the <code>nargs='+'</code> keyword argument.
After the command line is parsed, we get an object where the values of
the options are stored as attributes. The attribute name is specified
by the <code>dist</code> keyword argument, which for the <code>--dt</code> option is
<code>dt_values</code>. Without the <code>dest</code> argument, the value of an option <code>--opt</code>
is stored as the attribute <code>opt</code>.

<p>
The code below demonstrates how to read the command line and extract
the values for each option:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def read_command_line_argparse():
    parser = define_command_line_options()
    args = parser.parse_args()
    scheme2theta = {'BE': 1, 'CN': 0.5, 'FE': 0}
    data = (args.I, args.a, args.T, scheme2theta[args.scheme],
            args.dt_values)
    return data
</code></pre>
<!-- end verbatim block -->
As seen, the values of the command-line options are available as
attributes in <code>args</code>: <code>args.opt</code> holds the value of option <code>--opt</code>, unless
we used the <code>dest</code> argument (as for <code>--dt_values</code>) for specifying the
attribute name. The <code>args.opt</code> attribute has the object type specified
by <code>type</code> (<code>str</code> by default).

<p>
The making of the plot is not dependent on whether we read data from
the command line as positional arguments or option-value pairs:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def experiment_compare_dt(option_value_pairs=False):
    I, a, T, theta, dt_values = \ 
       read_command_line_argparse() if option_value_pairs else \ 
       read_command_line_positional()

    legends = []
    for dt in dt_values:
        u, t = solver(I, a, T, dt, theta)
        plt.plot(t, u)
        legends.append('dt=%g' % dt)
    t_e = np.linspace(0, T, 1001)       # very fine mesh for u_e
    u_e = u_exact(t_e, I, a)
    plt.plot(t_e, u_e, '--')
    legends.append('exact')
    plt.legend(legends, loc='upper right')
    plt.title('theta=%g' % theta)
    plotfile = 'tmp'
    plt.savefig(plotfile + '.png');  plt.savefig(plotfile + '.pdf')
</code></pre>
<!-- end verbatim block -->

<h2 id="___sec192">Creating a graphical web user interface </h2>

<p>
The Python package <a href="https://github.com/hplgit/parampool" target="_self">Parampool</a>
can be used to automatically generate a web-based <em>graphical user interface</em>
(GUI) for our simulation program. Although the programming technique
dramatically simplifies the efforts to create a GUI, the forthcoming
material on equipping our <code>decay</code> module with a GUI is quite technical
and of significantly less importance than knowing how to make
a command-line interface.

<h3 id="___sec193">Making a compute function </h3>

<p>
The first step is to identify a function
that performs the computations and that takes the necessary input
variables as arguments. This is called the <em>compute function</em> in
Parampool terminology. The purpose of this function is to take
values of \( I \), \( a \), \( T \) together with a sequence of \( \Delta t \) values
and a sequence of \( \theta \) and plot the numerical against the
exact solution for each pair of \( (\theta, \Delta t) \).
The plots can be arranged as a table with the columns being scheme type
(\( \theta \) value) and the rows reflecting the discretization parameter
(\( \Delta t \) value). Figure <a href="#softeng1:fig:GUI">22</a> displays what the
graphical web interface may look like after results are computed
(there are \( 3\times 3 \) plots in the GUI, but only \( 2\times 2 \) are
visible in the figure).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 22:  Automatically generated graphical web interface. <div id="softeng1:fig:GUI"></div> </p></center>
<p><img src="fig-softeng/web_GUI.png" align="bottom" width=800></p>
</center>

<p>
To tell Parampool what type of input data we have,
we assign default values of the right type to all arguments in the
compute function, here called <code>main_GUI</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def main_GUI(I=1.0, a=.2, T=4.0,
             dt_values=[1.25, 0.75, 0.5, 0.1],
             theta_values=[0, 0.5, 1]):
</code></pre>
<!-- end verbatim block -->

<p>
The compute function must return the HTML code we want for displaying
the result in a web page. Here we want to show a
table of plots.
Assume for now that the HTML code for one plot and the value of the
norm of the error can be computed by some other function <code>compute4web</code>.
The <code>main_GUI</code> function can then loop over \( \Delta t \) and \( \theta \)
values and put each plot in an HTML table. Appropriate code goes like

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def main_GUI(I=1.0, a=.2, T=4.0,
             dt_values=[1.25, 0.75, 0.5, 0.1],
             theta_values=[0, 0.5, 1]):
    # Build HTML code for web page. Arrange plots in columns
    # corresponding to the theta values, with dt down the rows
    theta2name = {0: 'FE', 1: 'BE', 0.5: 'CN'}
    html_text = '&lt;table&gt;\n'
    for dt in dt_values:
        html_text += '&lt;tr&gt;\n'
        for theta in theta_values:
            E, html = compute4web(I, a, T, dt, theta)
            html_text += &quot;&quot;&quot;
&lt;td&gt;
&lt;center&gt;&lt;b&gt;%s, dt=%g, error: %.3E&lt;/b&gt;&lt;/center&gt;&lt;br&gt;
%s
&lt;/td&gt;
&quot;&quot;&quot; % (theta2name[theta], dt, E, html)
        html_text += '&lt;/tr&gt;\n'
    html_text += '&lt;/table&gt;\n'
    return html_text
</code></pre>
<!-- end verbatim block -->

<p>
Making one plot is done in <code>compute4web</code>. The statements should be
straightforward from earlier examples, but there is one new feature:
we use a tool in Parampool to embed the PNG code for a plot file
directly in an HTML image tag. The details are hidden from the
programmer, who can just rely on
relevant HTML code in the string <code>html_text</code>. The function looks like

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def compute4web(I, a, T, dt, theta=0.5):
    &quot;&quot;&quot;
    Run a case with the solver, compute error measure,
    and plot the numerical and exact solutions in a PNG
    plot whose data are embedded in an HTML image tag.
    &quot;&quot;&quot;
    u, t = solver(I, a, T, dt, theta)
    u_e = u_exact(t, I, a)
    e = u_e - u
    E = np.sqrt(dt*np.sum(e**2))

    plt.figure()
    t_e = np.linspace(0, T, 1001)    # fine mesh for u_e
    u_e = u_exact(t_e, I, a)
    plt.plot(t,   u,   'r--o')
    plt.plot(t_e, u_e, 'b-')
    plt.legend(['numerical', 'exact'])
    plt.xlabel('t')
    plt.ylabel('u')
    plt.title('theta=%g, dt=%g' % (theta, dt))
    # Save plot to HTML img tag with PNG code as embedded data
    from parampool.utils import save_png_to_str
    html_text = save_png_to_str(plt, plotwidth=400)

    return E, html_text
</code></pre>
<!-- end verbatim block -->

<h3 id="___sec194">Generating the user interface </h3>

<p>
The web GUI is automatically generated by
the following code, placed in the file <a href="http://tinyurl.com/ofkw6kc/softeng/decay_GUI_generate.py" target="_self"><tt>decay_GUI_generate.py</tt></a>.

<p>
<!-- begin verbatim block  pypro-->
<pre><code>from parampool.generator.flask import generate
from decay import main_GUI
generate(main_GUI,
         filename_controller='decay_GUI_controller.py',
         filename_template='decay_GUI_view.py',
         filename_model='decay_GUI_model.py')
</code></pre>
<!-- end verbatim block -->
Running the <code>decay_GUI_generate.py</code> program results in three new
files whose names are specified in the call to <code>generate</code>:

<ol>
 <li> <code>decay_GUI_model.py</code> defines HTML widgets to be used to set
    input data in the web interface,</li>
 <li> <code>templates/decay_GUI_views.py</code> defines the layout of the web page,</li>
 <li> <code>decay_GUI_controller.py</code> runs the web application.</li>
</ol>

We only need to run the last program, and there is no need to look into
these files.

<h3 id="___sec195">Running the web application </h3>

<p>
The web GUI is started by

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; python decay_GUI_controller.py
</code></pre>
<!-- end verbatim block -->
Open a web browser at the location <code>127.0.0.1:5000</code>. Input fields for
<code>I</code>, <code>a</code>, <code>T</code>, <code>dt_values</code>, and <code>theta_values</code> are presented.  Figure
<a href="#softeng1:fig:GUI">22</a> shows a part of the resulting page if we run
with the default values for the input parameters.
With the techniques demonstrated here, one can
easily create a tailored web GUI for a particular type of application
and use it to interactively explore physical and numerical effects.

<h1 id="___sec196">Tests for verifying implementations </h1>

<p>
Any module with functions should have a set of tests that can
check the
correctness of the implementations.
There exists
well-established procedures and corresponding tools for automating
the execution of such tests. These tools allow large test sets to be
run with a one-line command, making it easy to check of the
still software works (as far as the
tests tell!). Here we shall illustrate two important
software testing techniques: <em>doctest</em> and <em>unit testing</em>.
The first one is Python specific, while unit testing is the dominating
test technique in the software industry today.

<h2 id="___sec197">Doctests </h2>

<p>
A doc string, the first string after the function header, is used to
document the purpose of functions and their arguments
(see the section <a href="#softeng1:basic:func">Implementing the numerical algorithm in a function</a>). Very often it
is instructive to include an example in the doc string
on how to use the function.
Interactive examples in the Python shell are most illustrative as
we can see the output resulting from the statements and expressions.
For example,
in the <code>solver</code> function, we can include an example on calling
this function and printing the computed <code>u</code> and <code>t</code> arrays:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def solver(I, a, T, dt, theta):
    &quot;&quot;&quot;
    Solve u'=-a*u, u(0)=I, for t in (0,T] with steps of dt.


    &gt;&gt;&gt; u, t = solver(I=0.8, a=1.2, T=1.5, dt=0.5, theta=0.5)
    &gt;&gt;&gt; for n in range(len(t)):
    ...     print 't=%.1f, u=%.14f' % (t[n], u[n])
    t=0.0, u=0.80000000000000
    t=0.5, u=0.43076923076923
    t=1.0, u=0.23195266272189
    t=1.5, u=0.12489758761948
    &quot;&quot;&quot;
    ...
</code></pre>
<!-- end verbatim block -->

<p>
When such interactive demonstrations are inserted in doc strings,
Python's <a href="http://docs.python.org/library/doctest.html" target="_self"><tt>doctest</tt></a>
module can be used to automate running all commands
in interactive sessions and compare new output with the output
appearing in the doc string.  All we have to do in the current example
is to run the module file <code>decay.py</code> with

<p>
<!-- begin verbatim block  pycod-->
<pre><code>Terminal&gt; python -m doctest decay.py
</code></pre>
<!-- end verbatim block -->
This command imports the <code>doctest</code> module, which runs all
doctests found in the file and reports discrepancies between
expected and computed output.
Alternatively, the test block in a module may run all doctests
by

<p>
<!-- begin verbatim block  pycod-->
<pre><code>if __name__ == '__main__':
    import doctest
    doctest.testmod()
</code></pre>
<!-- end verbatim block -->
Doctests can also be embedded in nose/pytest unit tests
as explained in the next section.

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Doctests prevent command-line arguments!</b>
<p>
No additional command-line argument is allowed when running doctests.
If your program relies on command-line input, make sure the doctests
can be run <em>without</em> such input on the command line.

<p>
However, you can simulate command-line input by filling <code>sys.argv</code>
with values, e.g.,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import sys; sys.argv = '--I 1.0 --a 5'.split()
</code></pre>
<!-- end verbatim block -->
</div>


<p>
The execution command above will report any problem if a test fails.
As an illustration, let us alter the <code>u</code> value at <code>t=1.5</code> in
the output of the doctest by replacing the last digit <code>8</code> by <code>7</code>.
This edit triggers a report:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; python -m doctest decay.py
********************************************************
File &quot;decay.py&quot;, line ...
Failed example:
    for n in range(len(t)):
        print 't=%.1f, u=%.14f' % (t[n], u[n])
Expected:
    t=0.0, u=0.80000000000000
    t=0.5, u=0.43076923076923
    t=1.0, u=0.23195266272189
    t=1.5, u=0.12489758761948
Got:
    t=0.0, u=0.80000000000000
    t=0.5, u=0.43076923076923
    t=1.0, u=0.23195266272189
    t=1.5, u=0.12489758761947
</code></pre>
<!-- end verbatim block -->

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Pay attention to the number of digits in doctest results!</b>
<p>
Note that in the output of <code>t</code> and <code>u</code> we write <code>u</code> with 14 digits.
Writing all 16 digits is not a good idea: if the tests are run on
different hardware, round-off errors might be different, and
the <code>doctest</code> module detects that the numbers are not precisely the same
and reports failures. In the present application, where \( 0 < u(t) \leq 0.8 \),
we expect round-off errors to be of size \( 10^{-16} \), so comparing 15
digits would probably be reliable, but we compare 14 to be on the
safe side. On the other hand, comparing a small number of digits may
hide software errors.
</div>


<p>
Doctests are highly encouraged as they do two things: 1) demonstrate
how a function is used and 2) test that the function works.

<h2 id="___sec198">Unit tests and test functions </h2>

<p>
The unit testing technique consists of identifying smaller units
of code and writing one or more tests for
each unit. One unit can typically be a function.
Each test should, ideally, not depend on the outcome of
other tests. The recommended practice is actually to
design and write the unit tests first and <em>then</em> implement the functions!

<p>
In scientific computing it is not always obvious how to best perform
unit testing. The units are naturally larger than in non-scientific
software. Very often the solution procedure of a mathematical problem
identifies a unit, such as our <code>solver</code> function.

<h3 id="___sec199">Two Python test frameworks: nose and pytest </h3>

<p>
Python offers two very easy-to-use software frameworks for implementing
unit tests: nose and pytest. These work (almost) in the same way,
but our recommendation is to go for pytest.

<h3 id="___sec200">Test function requirements </h3>

<p>
For a test to qualify as a <em>test function</em> in nose or pytest, three
rules must be followed:

<ol>
 <li> The function name must start with <code>test_</code>.</li>
 <li> Function arguments are not allowed.</li>
 <li> An <code>AssertionError</code> exception must be raised if the test fails.</li>
</ol>

A specific example might be illustrative before proceeding.
We have the following function that we want to test:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def double(n):
    return 2*n
</code></pre>
<!-- end verbatim block -->
The corresponding test function could, in principle, have been written
as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_double():
    &quot;&quot;&quot;Test that double(n) works for one specific n.&quot;&quot;&quot;
    n = 4
    expected = 2*4
    computed = double(4)
    if expected != computed:
        raise AssertionError
</code></pre>
<!-- end verbatim block -->
The last two lines, however, are never written like this in test functions.
Instead, Python's <code>assert</code> statement is used: <code>assert success, msg</code>, where
<code>success</code> is a boolean variable, which is <code>False</code> if the test fails, and
<code>msg</code> is <em>an optional</em> message string that is printed when the test fails.
A better version of the test function is therefore

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_double():
    &quot;&quot;&quot;Test that double(n) works for one specific n.&quot;&quot;&quot;
    n = 4
    expected = 2*4
    computed = double(4)
    msg = 'expected %g, computed %g' % (expected, computed)
    success = expected == computed
    assert success, msg
</code></pre>
<!-- end verbatim block -->

<h3 id="___sec201">Comparison of real numbers </h3>

<p>
Because of the finite precision arithmetics on a computer, which gives
rise to round-off errors, the <code>==</code> operator is not suitable for
checking whether two real numbers are equal. Obviously, this principle
also applies to tests in test functions.
We must therefore replace <code>a == b</code> by a comparison
based on a tolerance <code>tol</code>: <code>abs(a-b) &lt; tol</code>. The next example illustrates
the problem and its solution.

<p>
Here is a slightly different function that
we want to test:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def third(x):
    return x/3.
</code></pre>
<!-- end verbatim block -->
We write a test function where the expected result is computed as
\( \frac{1}{3}x \) rather than \( x/3 \):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_third():
    &quot;&quot;&quot;Check that third(x) works for many x values.&quot;&quot;&quot;
    for x in np.linspace(0, 1, 21):
        expected = (1/3.0)*x
        computed = third(x)
        success = expected == computed
        assert success
</code></pre>
<!-- end verbatim block -->
This <code>test_third</code> function executes silently, i.e., no failure,
until <code>x</code> becomes 0.15. Then round-off errors make the <code>==</code> comparison
<code>False</code>. In fact, seven of the <code>x</code> values above face this problem.
The solution is to compare <code>expected</code> and <code>computed</code>
with a small tolerance:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_third():
    &quot;&quot;&quot;Check that third(x) works for many x values.&quot;&quot;&quot;
    for x in np.linspace(0, 1, 21):
        expected = (1/3.)*x
        computed = third(x)
        tol = 1E-15
        success = abs(expected - computed) &lt; tol
        assert success
</code></pre>
<!-- end verbatim block -->

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Always compare real numbers with a tolerance!</b>
<p>
Real numbers should never be compared with the <code>==</code> operator, but always
with the absolute value of the difference and a tolerance.
So, replace <code>a == b</code>, if <code>a</code> and/or <code>b</code> is <code>float</code>, by

<p>
<!-- begin verbatim block  pycod-->
<pre><code>tol = 1E-14
abs(a - b) &lt; tol
</code></pre>
<!-- end verbatim block -->
The suitable size of <code>tol</code> depends on the size of <code>a</code> and <code>b</code>
(see <a href="#softeng1:exer:tol">Problem 43: Experiment with tolerances in comparisons</a>).
</div>


<h3 id="___sec202">Special assert functions from nose </h3>

<p>
Test frameworks often contain more tailored
<em>assert functions</em> that can be called instead of using the <code>assert</code>
statement. For example, comparing two objects within
a tolerance, as in the present
case, can be done by the <code>assert_almost_equal</code> from the nose
framework:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import nose.tools as nt

def test_third():
    x = 0.15
    expected = (1/3.)*x
    computed = third(x)
    nt.assert_almost_equal(
        expected, computed, delta=1E-15,
        msg='diff=%.17E' % (expected - computed))
</code></pre>
<!-- end verbatim block -->

<p>
Whether to use the plain <code>assert</code> statement with a comparison based on
a tolerance or to use the ready-made function <code>assert_almost_equal</code>
depends on the programmer's preference. The examples used in the
documentation of the pytest framework stick to the plain <code>assert</code>
statement.

<h3 id="___sec203">Locating test functions </h3>

<p>
Test functions can reside in a module together with the functions they
are supposed to verify, or the test functions can be collected in
separate files having names starting with <code>test</code>. Actually,
nose and pytest can recursively run all test functions
in all <code>test*.py</code>
files in the current directory, as well as in all subdirectories!

<p>
The <a href="http://tinyurl.com/ofkw6kc/softeng/decay.py" target="_self"><tt>decay.py</tt></a> module file features
test functions in the module, but we could equally well have made
a subdirectory <code>tests</code> and put the test functions in
<a href="http://tinyurl.com/ofkw6kc/softeng/tests/test_decay.py" target="_self"><tt>tests/test_decay.py</tt></a>.

<h3 id="___sec204">Running tests </h3>

<p>
To run all test functions in the file <code>decay.py</code> do

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; nosetests -s -v decay.py
Terminal&gt; py.test -s -v decay.py
</code></pre>
<!-- end verbatim block -->
The <code>-s</code> option ensures that output from the test functions is printed
in the terminal window, while <code>-v</code> prints the outcome of each individual
test function.

<p>
Alternatively, if the test functions are located in some separate
<code>test*.py</code> files,
we can just write

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; py.test -s -v
</code></pre>
<!-- end verbatim block -->
to <em>recursively</em> run <em>all</em> test functions in the current
directory tree. The corresponding

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; nosetests -s -v
</code></pre>
<!-- end verbatim block -->
command does the same, but requires subdirectory names to start
with <code>test</code> or end with <code>_test</code> or <code>_tests</code> (which is a good habit anyway).
An example of a <code>tests</code> directory with a <code>test*.py</code>
file is found in <a href="http://tinyurl.com/ofkw6kc/softeng/tests" target="_self"><tt>src/softeng/tests</tt></a>.

<h3 id="___sec205">Embedding doctests in a test function </h3>

<p>
Doctests can also be executed from nose/pytest unit tests. Here is an
example of a file <a href="http://tinyurl.com/ofkw6kc/softeng/tests/test_decay_doctest.py" target="_self"><tt>test_decay_doctest.py</tt></a> where we in the test
block run all the doctests in the imported module <code>decay</code>, but we also
include a local test function that does the same:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>import sys, os
sys.path.insert(0, os.pardir)
import decay
import doctest

def test_decay_module_with_doctest():
    &quot;&quot;&quot;Doctest embedded in a nose/pytest unit test.&quot;&quot;&quot;
    # Test all functions with doctest in module decay
    failure_count, test_count = doctest.testmod(m=decay)
    assert failure_count == 0

if __name__ == '__main__':
    # Run all functions with doctests in this module
    failure_count, test_count = doctest.testmod(m=decay)
</code></pre>
<!-- end verbatim block -->
Running this file as a program from the command line
triggers the <code>doctest.testmod</code> call
in the test block, while applying <code>py.test</code> or <code>nosetests</code> to the file triggers
an import of the file and execution of the test function
<code>test_decay_modue_with_doctest</code>.

<h3 id="___sec206">Installing nose and pytest </h3>

<p>
With <code>pip</code> available, it is trivial to install nose and/or pytest:
<code>sudo pip install nose</code> and <code>sudo pip install pytest</code>.

<h2 id="___sec207">Test function for the solver </h2>

<p>
Finding good test problems for verifying the implementation of numerical
methods is a topic on its own. The challenge is that we very seldom know
what the numerical errors are. For the present model problem
<a href="#mjx-eqn-194">(194)</a>-<a href="#mjx-eqn-195">(195)</a> solved by
<a href="#mjx-eqn-196">(196)</a> one can, fortunately, derive a formula for
the numerical approximation:

$$ u^n = I\left(
\frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t}
\right)^n\tp$$

Then we know that the implementation should
produce numbers that agree with this formula to machine precision.
The formula for \( u^n \) is known as an <em>exact discrete solution</em> of the
problem and can be coded as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def u_discrete_exact(n, I, a, theta, dt):
    &quot;&quot;&quot;Return exact discrete solution of the numerical schemes.&quot;&quot;&quot;
    dt = float(dt)  # avoid integer division
    A = (1 - (1-theta)*a*dt)/(1 + theta*dt*a)
    return I*A**n
</code></pre>
<!-- end verbatim block -->
A test function can evaluate this solution on a time mesh
and check that the <code>u</code> values produced by the <code>solver</code> function
do not deviate with more than a small tolerance:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_u_discrete_exact():
    &quot;&quot;&quot;Check that solver reproduces the exact discr. sol.&quot;&quot;&quot;
    theta = 0.8; a = 2; I = 0.1; dt = 0.8
    Nt = int(8/dt)  # no of steps
    u, t = solver(I=I, a=a, T=Nt*dt, dt=dt, theta=theta)

    # Evaluate exact discrete solution on the mesh
    u_de = np.array([u_discrete_exact(n, I, a, theta, dt)
                     for n in range(Nt+1)])

    # Find largest deviation
    diff = np.abs(u_de - u).max()
    tol = 1E-14
    success = diff &lt; tol
    assert success
</code></pre>
<!-- end verbatim block -->

<p>
Among important things to consider when constructing test functions
is testing the effect of wrong input to the function being tested.
In our <code>solver</code> function, for example, integer values of \( a \), \( \Delta t \), and
\( \theta \) may cause unintended integer
division. We should therefore add a test to make sure our <code>solver</code>
function does not fall into this potential trap:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_potential_integer_division():
    &quot;&quot;&quot;Choose variables that can trigger integer division.&quot;&quot;&quot;
    theta = 1; a = 1; I = 1; dt = 2
    Nt = 4
    u, t = solver(I=I, a=a, T=Nt*dt, dt=dt, theta=theta)
    u_de = np.array([u_discrete_exact(n, I, a, theta, dt)
                     for n in range(Nt+1)])
    diff = np.abs(u_de - u).max()
    assert diff &lt; 1E-14
</code></pre>
<!-- end verbatim block -->

<p>
In more complicated problems where there is no exact solution of the
numerical problem solved by the software, one must use the method
of manufactured solutions, compute convergence rates for a series
of \( \Delta t \) values, and check that the rates converges to the
expected ones (from theory).
This type of testing is fully explained in
the section <a href="._decay-book-solarized007.html#decay:convergence:rate">Computing convergence rates</a>.

<h2 id="___sec208">Test function for reading positional command-line arguments </h2>

<p>
The function <code>read_command_line_positional</code> extracts numbers from the
command line. To test it, we must decide on a set of values for
the input data, fill <code>sys.argv</code>
accordingly, and check that we get the expected values:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_read_command_line_positional():
    # Decide on a data set of input parameters
    I = 1.6;  a = 1.8;  T = 2.2;  theta = 0.5
    dt_values = [0.1, 0.2, 0.05]
    # Expected return from read_command_line_positional
    expected = [I, a, T, theta, dt_values]
    # Construct corresponding sys.argv array
    sys.argv = [sys.argv[0], str(I), str(a), str(T), 'CN'] + \ 
               [str(dt) for dt in dt_values]
    computed = read_command_line_positional()
    for expected_arg, computed_arg in zip(expected, computed):
        assert expected_arg == computed_arg
</code></pre>
<!-- end verbatim block -->
Note that <code>sys.argv[0]</code> is always the program name and that we have to
copy that string from the original <code>sys.argv</code> array to the new one we
construct in the test function. (Actually, this test function destroys
the original <code>sys.argv</code> that Python fetched from the command line.)

<p>
Any numerical code writer should always be skeptical to the use of the exact
equality operator <code>==</code> in test functions, since round-off errors often
come into play. Here, however, we set some real values, convert them
to strings and convert back again to real numbers (of the same precision).
This string-number conversion does not involve any finite precision
arithmetics effects so we
can safely use <code>==</code> in tests. Note also that the last element in
<code>expected</code> and <code>computed</code> is the list <code>dt_values</code>, and <code>==</code> works
for comparing two lists as well.

<h2 id="___sec209">Test function for reading option-value pairs </h2>

<p>
The function <code>read_command_line_argparse</code> can be verified with a
test function that has the same setup as <code>test_read_command_line_positional</code>
above.
However, the construction of the command line is a bit more complicated.
We find it convenient to construct the line as a string and then
split the line into words to get the desired list <code>sys.argv</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_read_command_line_argparse():
    I = 1.6;  a = 1.8;  T = 2.2;  theta = 0.5
    dt_values = [0.1, 0.2, 0.05]
    # Expected return from read_command_line_argparse
    expected = [I, a, T, theta, dt_values]
    # Construct corresponding sys.argv array
    command_line = '%s --a %s --I %s --T %s --scheme CN --dt ' % \ 
                   (sys.argv[0], a, I, T)
    command_line += ' '.join([str(dt) for dt in dt_values])
    sys.argv = command_line.split()
    computed = read_command_line_argparse()
    for expected_arg, computed_arg in zip(expected, computed):
        assert expected_arg == computed_arg
</code></pre>
<!-- end verbatim block -->
Recall that the Python function <code>zip</code> enables iteration over
several lists, tuples, or arrays at the same time.

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Let silent test functions speak up during development!</b>
<p>
When you develop test functions in a module, it is common to use IPython
for interactive experimentation:

<p>
<!-- begin verbatim block  ipy-->
<pre><code>In[1]: import decay

In[2]: decay.test_read_command_line_argparse()
</code></pre>
<!-- end verbatim block -->

<p>
Note that a working test function is completely silent! Many
find it psychologically annoying to convince themselves that a
completely silent function is doing the right things. It can therefore,
during development of a test function, be convenient to insert
print statements in the function to monitor that the function body
is indeed executed. For example, one can print the expected and
computed values in the terminal window:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_read_command_line_argparse():
    ...
    for expected_arg, computed_arg in zip(expected, computed):
        print expected_arg, computed_arg
        assert expected_arg == computed_arg
</code></pre>
<!-- end verbatim block -->
After performing this edit, we want to run the test again, but
in IPython the module must first be reloaded (reimported):

<p>
<!-- begin verbatim block  ipy-->
<pre><code>In[3]: reload(decay)  # force new import

In[2]: decay.test_read_command_line_argparse()
1.6 1.6
1.8 1.8
2.2 2.2
0.5 0.5
[0.1, 0.2, 0.05] [0.1, 0.2, 0.05]
</code></pre>
<!-- end verbatim block -->
Now we clearly see the objects that are compared.
</div>


<h2 id="softeng1:basic:unittest">Classical class-based unit testing</h2>

<p>
The test functions written for the nose and pytest frameworks are
very straightforward and to the point, with no framework-required boilerplate
code. We just write the statements we need to get the computations and
comparisons done, before applying the required <code>assert</code>.

<p>
The classical way of implementing unit tests (which derives from the
JUnit object-oriented tool in Java) leads to much more comprehensive
implementations with a lot of boilerplate code.  Python comes with a
built-in module <code>unittest</code> for doing this type of classical unit
tests. Although nose or pytest are much more convenient to use than
<code>unittest</code>, class-based unit testing in the style of <code>unittest</code> has a
very strong position in computer science and is so widespread in
the software industry that
even computational scientists should have an idea how such unit test
code is written. A short demo of <code>unittest</code> is therefore included
next. (Readers who are not familiar with object-oriented programming
in Python may find the text hard to understand, but one can safely
jump to the next section.)

<p>
Suppose we have a function <code>double(x)</code> in a module file <code>mymod.py</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def double(x):
    return 2*x
</code></pre>
<!-- end verbatim block -->
Unit testing with the aid of the <code>unittest</code> module
consists of writing a file <code>test_mymod.py</code> for testing the functions
in <code>mymod.py</code>. The individual tests must be methods with names
starting with <code>test_</code> in a class derived from class <code>TestCase</code> in
<code>unittest</code>. With one test method for the function <code>double</code>, the
<code>test_mymod.py</code> file becomes

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import unittest
import mymod

class TestMyCode(unittest.TestCase):
    def test_double(self):
        x = 4
        expected = 2*x
        computed = mymod.double(x)
        self.assertEqual(expected, computed)

if __name__ == '__main__':
    unittest.main()
</code></pre>
<!-- end verbatim block -->
The test is run by executing the test file <code>test_mymod.py</code> as a standard
Python program. There is no support in <code>unittest</code> for automatically
locating and running all tests in all test files in a directory tree.

<p>
We could use the basic <code>assert</code> statement as we did with nose and pytest
functions, but those who write code based on <code>unittest</code> almost
exclusively use the wide range of built-in assert functions such
as <code>assertEqual</code>, <code>assertNotEqual</code>, <code>assertAlmostEqual</code>, to mention
some of them.

<p>
Translation of the test functions from the previous sections
to <code>unittest</code> means making a new file <code>test_decay.py</code> file with a
test class <code>TestDecay</code> where the stand-alone functions for
nose/pytest now become methods in this class.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import unittest
import decay
import numpy as np

def u_discrete_exact(n, I, a, theta, dt):
    ...

class TestDecay(unittest.TestCase):

    def test_exact_discrete_solution(self):
        theta = 0.8; a = 2; I = 0.1; dt = 0.8
        Nt = int(8/dt)  # no of steps
        u, t = decay.solver(I=I, a=a, T=Nt*dt, dt=dt, theta=theta)
        # Evaluate exact discrete solution on the mesh
        u_de = np.array([u_discrete_exact(n, I, a, theta, dt)
                         for n in range(Nt+1)])
        diff = np.abs(u_de - u).max()  # largest deviation
        self.assertAlmostEqual(diff, 0, delta=1E-14)

    def test_potential_integer_division(self):
        ...
        self.assertAlmostEqual(diff, 0, delta=1E-14)

    def test_read_command_line_positional(self):
        ...
        for expected_arg, computed_arg in zip(expected, computed):
            self.assertEqual(expected_arg, computed_arg)

    def test_read_command_line_argparse(self):
        ...

if __name__ == '__main__':
    unittest.main()
</code></pre>
<!-- end verbatim block -->

<h1 id="softeng1:prog:se:git">Sharing the software with other users</h1>

<p>
As soon as you have some working software that you intend to share
with others, you should package your software in a standard way such
that users can easily download your software, install it, improve it,
and ask you to approve their improvements in new versions of the software.
During recent years, the software development community has established
quite firm tools and rules for how all this is done. The following
subsections cover three steps in sharing software:

<ol>
<li> Organizing the software for public distribution.</li>
<li> Uploading the software to a cloud service (here GitHub).</li>
<li> Downloading and installing the software.</li>
</ol>

<h2 id="___sec212">Organizing the software directory tree </h2>

<p>
We start with organizing our software as a directory tree. Our
software consists of one module file, <code>decay.py</code>, and possibly some
unit tests in a separate file located in a directory <code>tests</code>.

<p>
The <code>decay.py</code> can be used as a module or as a program. For distribution
to other users who install the program <code>decay.py</code> in system directories,
we need to insert the following line at the top of the file:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>#!/usr/bin/env python
</code></pre>
<!-- end verbatim block -->
This line makes it possible to write just the filename and get the
file executed by the <code>python</code> program (or more precisely, the first
<code>python</code> program found in the directories in the <code>PATH</code> environment
variable).

<h3 id="___sec213">Distributing just a module file </h3>

<p>
Let us start out with the minimum solution alternative: distributing
just the <code>decay.py</code> file. Then the software is just one file and all
we need is a directory with this file.  Users will also this directory
to contain an installation script <code>setup.py</code> and a <code>README</code> file
telling what the software is about, the author's email address, a URL
for downloading the software, and other useful information.

<p>
The <code>setup.py</code> file can be as short as

<p>
<!-- begin verbatim block  pypro-->
<pre><code>from distutils.core import setup
setup(name='decay',
      version='0.1',
      py_modules=['decay'],
      scripts=['decay.py'],
      )
</code></pre>
<!-- end verbatim block -->
The <code>py_modules</code> argument specifies a list of modules to be installed, while
<code>scripts</code> specifies stand-alone programs. Our <code>decay.py</code> can be used
either as a module or as an executable program, so we want users to
have both possibilities.

<h3 id="___sec214">Distributing a package </h3>

<p>
If the software consists of more files than one or two modules, one
should make a Python <em>package</em> out of it. In our case we make a
package <code>decay</code> containing one module, also called <code>decay</code>.

<p>
To make a package <code>decay</code>, create a directory <code>decay</code> and an empty
file in it with name <code>__init__.py</code>.
A <code>setup.py</code> script must now specify the directory name of the package
and also an executable program (<code>scripts=</code>)
in case we want to run <code>decay.py</code> as a stand-alone application:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>from distutils.core import setup
import os

setup(name='decay',
      version='0.1',
      author='Hans Petter Langtangen',
      author_email='hpl@simula.no',
      url='https://github.com/hplgit/decay-package/',
      packages=['decay'],
      scripts=[os.path.join('decay', 'decay.py')]
     )
</code></pre>
<!-- end verbatim block -->
We have also added some author and download information.
The reader is referred to the <a href="https://docs.python.org/2/distutils/setupscript.html" target="_self">Distutils documentation</a> for more information on how to
write <code>setup.py</code> scripts.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Remark about the executable file.</b>
<p>
The executable program, <code>decay.py</code>, is above taken to be the complete
module file <code>decay.py</code>. It would normally be preferred to instead
write a very short script essentially importing <code>decay</code> and running
the test block in <code>decay.py</code>.  In this way, we distribute a module and
a very short file, say <code>decay-main.py</code>, as an executable program:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>#!/usr/bin/env python
import decay
decay.decay.experiment_compare_dt(True)
decay.decay.plt.show()
</code></pre>
<!-- end verbatim block -->
</div>


<p>
In this package example, we move the unit tests out of the <code>decay.py</code>
module to a separate file, <code>test_decay.py</code>, and place this file in a
directory <code>tests</code>. Then the <code>nosetests</code> and <code>py.test</code> programs will
automatically find and execute the tests.

<p>
The complete directory structure reads

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; /bin/ls -R
.:
decay  README  setup.py

./decay:
decay.py  __init__.py  tests

./decay/tests:
test_decay.py
</code></pre>
<!-- end verbatim block -->

<h2 id="___sec215">Publishing the software at GitHub </h2>

<p>
The leading site today for publishing open source software projects is
GitHub at <a href="http://github.com" target="_self"><tt>http://github.com</tt></a>, provided you want your software to
be open to the world. With a paid GitHub account, you can have private
projects too.

<p>
Sign up for a GitHub account if you do not already have one.
Go to your account settings and provide an SSH key (typically
the file <code>~/.ssh/id_rsa.pub</code>) such that
you can communicate with GitHub without being prompted for your password.
All communication between your computer and GitHub goes via the version
control system Git. This may at first sight look tedious, but
this is the way professionals work with software today. With Git you
have full control of the history of your files, i.e., &quot;who did what when&quot;.
The technology makes Git superior to simpler alternatives
like Dropbox and Google Drive,
especially when you collaborate with others.
There is a reason why Git has gained the position it has,
and there is no reason why you should not adopt this tool.

<p>
To create a new project, click on <em>New repository</em> on the main page and
fill out a project name. Click on the check button <em>Initialize this
repository with a README</em>, and click on <em>Create repository</em>. The next
step is to clone (copy) the GitHub repo (short for repository) to
your own computer(s) and fill it with files. The typical clone command is

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git clone git://github.com:username/projname.git
</code></pre>
<!-- end verbatim block -->
where <code>username</code> is your GitHub username and <code>projname</code> is the
name of the repo (project). The result of <code>git clone</code> is a
directory <code>projname</code>. Go to this directory and add files.
As soon as the repo directory is populated with files, run

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git add .
Terminal&gt; git commit -am 'First registration of project files'
Terminal&gt; git push origin master
</code></pre>
<!-- end verbatim block -->
The above <code>git</code> commands look cryptic, but these commands plus
2-3 more are the essence of what you need in your daily work with
files in small or big
software projects. I strongly encourage you to
learn more about <a href="http://hplgit.github.io/teamods/bitgit/html/" target="_self">version control systems and project hosting
sites</a>
<a href="._decay-book-solarized011.html#Langtangen_bitgit">[11]</a>.

<p>
Your project files are now stored in the cloud at
<a href="https://github.com/username/projname" target="_self"><tt>https://github.com/username/projname</tt></a>. Anyone can
get the software by the listed <code>git clone</code> command you used above,
or by clicking on the links for zip and tar files.

<p>
Every time you update the project files, you need to register
the update at GitHub by

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git commit -am 'Description of the changes you made...'
Terminal&gt; git push origin master
</code></pre>
<!-- end verbatim block -->
The files at GitHub are now synchronized with your local ones.
Similarly, every time you start working on files in this project,
make sure you have the latest version:
<code>git pull origin master</code>.

<p>
You are recommended to read <a href="http://hplgit.github.io/teamods/bitgit/html/" target="_self">a quick intro</a> that makes you
up and going with this style of
professional work. And you should put all your writings and programming
projects in repositories in the cloud!

<h2 id="___sec216">Downloading and installing the software </h2>

<p>
Users of your software go to the Git repo at <code>github.com</code> and
clone the repository. One can use either SSH or HTTP for communication.
Most users will use the latter, typically

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git clone https://github.com/username/projname.git
</code></pre>
<!-- end verbatim block -->
The result is a directory <code>projname</code> with the files in the repo.

<h3 id="___sec217">Installing just a module file </h3>

<p>
The software package is in the case above a directory <code>decay</code> with three files

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; ls decay
README   decay.py   setup.py
</code></pre>
<!-- end verbatim block -->
To install the <code>decay.py</code> file, a user
just runs <code>setup.py</code>:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; sudo python setup.py install
</code></pre>
<!-- end verbatim block -->
This command will install the software in system directories, so the user
needs to run the command as <code>root</code> on Unix systems (therefore the command
starts with <code>sudo</code>).
The user can now import the module by <code>import decay</code> and run
the program by

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; decay.py
</code></pre>
<!-- end verbatim block -->

<p>
A user can easily install the software on her personal account if
a system-wide installation is not desirable. We refer to the
<a href="https://docs.python.org/2/install/index.html#alternate-installation" target="_self">installation documentation</a> for the many arguments that can be given to <code>setup.py</code>.
Note that if the software is installed on a personal account, the
<code>PATH</code> and <code>PYTHONPATH</code> environment variables must contain the
relevant directories.

<p>
Our <code>setup.py</code> file specifies a module <code>decay</code> to be installed as well
as a program <code>decay.py</code>.  Modules are typically installed in some <code>lib</code>
directory on the computer system, e.g.,
<code>/usr/local/lib/python2.7/dist-packages</code>, while executable programs go
to <code>/usr/local/bin</code>.

<h3 id="___sec218">Installing a package </h3>

<p>
When the software is organized as a Python package, the installation is
done by running <code>setup.py</code> exactly as explained above, but the use of a module
<code>decay</code> in a package <code>decay</code> requires the following syntax:

<p>
<!-- begin verbatim block -->
<pre><code>import decay
u, t = decay.decay.solver(...)
</code></pre>
<!-- end verbatim block -->
That is, the call goes like <code>packagename.modulename.functionname</code>.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Package import in <code>__init__.py</code>.</b>
<p>
One can ease the use of packages by providing a somewhat simpler
import like

<p>
<!-- begin verbatim block -->
<pre><code>import decay
u, t = decay.solver(...)

# or
from decay import solver
u, t = solver(...)
</code></pre>
<!-- end verbatim block -->
This is accomplished by putting an import statement in the <code>__init__.py</code>
file, which is always run when doing the package import <code>import decay</code>
or <code>from decay import</code>. The <code>__init__.py</code> file must now contain

<p>
<!-- begin verbatim block  pypro-->
<pre><code>from decay import *
</code></pre>
<!-- end verbatim block -->
Obviously, it is the package developer who decides on such an
<code>__init__.py</code> file or if it should just be empty.
</div>


<h1 id="softeng1:prog:se:class">Classes for problem and solution method</h1>

<p>
The numerical solution procedure was compactly and conveniently implemented in
a Python function <code>solver</code> in the section <a href="#softeng1:basic:math">Mathematical problem and solution technique</a>.
In more complicated problems it might
be beneficial to use classes instead of functions only. Here we shall
describe a class-based software design well suited for scientific problems
where there is a mathematical model of some physical phenomenon and
some numerical methods to solve the equations involved in the model.

<p>
We introduce a class <code>Problem</code> to hold the definition of the physical
problem, and a class <code>Solver</code> to hold the data and methods needed to
numerically solve the problem.  The forthcoming text will explain the
inner workings of these classes and how they represent an alternative
to the <code>solver</code> and <code>experiment_*</code> functions in the <code>decay</code>
module.

<p>
Explaining the details of class programming in Python is considered
far beyond the scope of this text.  Readers who are unfamiliar with Python
class programming should first consult one of the many electronic
Python tutorials or textbooks to come up to speed with concepts and
syntax of Python classes before reading on. The author has a gentle
introduction to class programming for scientific applications
in <a href="._decay-book-solarized011.html#Langtangen_2012">[1]</a>, see <a href="http://hplgit.github.io/primer.html/doc/web/index.html" target="_self">Chapter 7 and 9 and Appendix E</a>.
Other useful resources are

<ul>
 <li> The Python Tutorial: <a href="http://docs.python.org/2/tutorial/classes.html" target="_self"><tt>http://docs.python.org/2/tutorial/classes.html</tt></a></li>
 <li> Wiki book on Python Programming: <a href="http://en.wikibooks.org/wiki/Python_Programming/Classes" target="_self"><tt>http://en.wikibooks.org/wiki/Python_Programming/Classes</tt></a></li>
 <li> <code>tutorialspoint.com</code>: <a href="http://www.tutorialspoint.com/python/python_classes_objects.htm" target="_self"><tt>http://www.tutorialspoint.com/python/python_classes_objects.htm</tt></a></li>
</ul>

<h2 id="___sec220">The problem class </h2>

<p>
The purpose of the problem class is to store all information about
the mathematical model. This usually means the physical parameters
and formulas
in the problem. Looking at our model problem
<a href="#mjx-eqn-194">(194)</a>-<a href="#mjx-eqn-195">(195)</a>, the physical data cover
\( I \), \( a \), and \( T \). Since we have an analytical solution of
the ODE problem, we may add this solution in terms of a Python
function (or method) to the problem class as well.
A possible problem class is therefore

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from numpy import exp

class Problem(object):
    def __init__(self, I=1, a=1, T=10):
        self.T, self.I, self.a = I, float(a), T

    def u_exact(self, t):
        I, a = self.I, self.a
        return I*exp(-a*t)
</code></pre>
<!-- end verbatim block -->
We could in the <code>u_exact</code> method have written
<code>self.I*exp(-self.a*t)</code>, but using local variables <code>I</code> and <code>a</code> allows
the nicer formula <code>I*exp(-a*t)</code>, which looks much closer to the mathematical
expression \( Ie^{-at} \).  This is not an important issue with the
current compact formula, but is beneficial in more complicated
problems with longer formulas to obtain the closest possible
relationship between code and mathematics. The coding style in
this book is to strip
off the <code>self</code> prefix when the code expresses mathematical formulas.

<p>
The class data can be set either as arguments in the constructor or
at any time later, e.g.,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>problem = Problem(T=5)
problem.T = 8
problem.dt = 1.5
</code></pre>
<!-- end verbatim block -->
(Some programmers prefer <code>set</code> and <code>get</code> functions for setting and getting
data in classes, often implemented via <em>properties</em> in Python, but
this author considers that overkill when there are just a few data items
in a class.)

<p>
It would be convenient if class <code>Problem</code> could also initialize
the data from the command line. To this end, we add a method for
defining a set of command-line options and a method that sets the
local attributes equal to what was found on the command line.
The default values associated with the command-line options are taken
as the values provided to the constructor. Class <code>Problem</code> now becomes

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Problem(object):
    def __init__(self, I=1, a=1, T=10):
        self.T, self.I, self.a = I, float(a), T

    def define_command_line_options(self, parser=None):
        &quot;&quot;&quot;Return updated (parser) or new ArgumentParser object.&quot;&quot;&quot;
        if parser is None:
            import argparse
            parser = argparse.ArgumentParser()

        parser.add_argument(
            '--I', '--initial_condition', type=float,
            default=1.0, help='initial condition, u(0)',
            metavar='I')
        parser.add_argument(
            '--a', type=float, default=1.0,
            help='coefficient in ODE', metavar='a')
        parser.add_argument(
            '--T', '--stop_time', type=float,
            default=1.0, help='end time of simulation',
            metavar='T')
        return parser

    def init_from_command_line(self, args):
        &quot;&quot;&quot;Load attributes from ArgumentParser into instance.&quot;&quot;&quot;
        self.I, self.a, self.T = args.I, args.a, args.T

    def u_exact(self, t):
        &quot;&quot;&quot;Return the exact solution u(t)=I*exp(-a*t).&quot;&quot;&quot;
        I, a = self.I, self.a
        return I*exp(-a*t)
</code></pre>
<!-- end verbatim block -->
Observe that if the user already has an <code>ArgumentParser</code> object it can be
supplied, but if she does not have any, class <code>Problem</code> makes one.
Python's <code>None</code> object is used to indicate that a variable is not
initialized with a proper value.

<h2 id="___sec221">The solver class </h2>

<p>
The solver class stores parameters related to the numerical solution method
and provides a function <code>solve</code> for solving the problem.
For convenience, a problem object is given to the constructor
in a solver object such that the object gets access to the
physical data. In the present example,
the numerical solution method involves the parameters \( \Delta t \)
and \( \theta \), which then constitute the data part of the solver class.
We include, as in the problem class, functionality for
reading \( \Delta t \) and \( \theta \) from the command line:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Solver(object):
    def __init__(self, problem, dt=0.1, theta=0.5):
        self.problem = problem
        self.dt, self.theta = float(dt), theta

    def define_command_line_options(self, parser):
        &quot;&quot;&quot;Return updated (parser) or new ArgumentParser object.&quot;&quot;&quot;
        parser.add_argument(
            '--scheme', type=str, default='CN',
            help='FE, BE, or CN')
        parser.add_argument(
            '--dt', '--time_step_values', type=float,
            default=[1.0], help='time step values',
            metavar='dt', nargs='+', dest='dt_values')
        return parser

    def init_from_command_line(self, args):
        &quot;&quot;&quot;Load attributes from ArgumentParser into instance.&quot;&quot;&quot;
        self.dt, self.theta = args.dt, args.theta

    def solve(self):
        self.u, self.t = solver(
            self.problem.I, self.problem.a, self.problem.T,
            self.dt, self.theta)

    def error(self):
        &quot;&quot;&quot;Return norm of error at the mesh points.&quot;&quot;&quot;
        u_e = self.problem.u_exact(self.t)
        e = u_e - self.u
        E = np.sqrt(self.dt*np.sum(e**2))
        return E
</code></pre>
<!-- end verbatim block -->
Note that we see no need to repeat the body of the previously
developed and tested <code>solver</code> function. We just call that function from
the <code>solve</code> method.  In this way, class <code>Solver</code> is merely a class wrapper
of the stand-alone <code>solver</code> function. With a single object of class <code>Solver</code>
we have all the physical and numerical data bundled together with the numerical
solution method.

<h3 id="___sec222">Combining the objects </h3>

<p>
Eventually we need to show how the classes <code>Problem</code> and <code>Solver</code>
play together. We read parameters from the command line and make a
plot with the numerical and exact solution:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def experiment_classes():
    problem = Problem()
    solver = Solver(problem)

    # Read input from the command line
    parser = problem.define_command_line_options()
    parser = solver. define_command_line_options(parser)
    args = parser.parse_args()
    problem.init_from_command_line(args)
    solver. init_from_command_line(args)

    # Solve and plot
    solver.solve()
    import matplotlib.pyplot as plt
    t_e = np.linspace(0, T, 1001)    # very fine mesh for u_e
    u_e = problem.u_exact(t_e)
    print 'Error:', solver.error()

    plt.plot(t,   u,   'r--o')
    plt.plot(t_e, u_e, 'b-')
    plt.legend(['numerical, theta=%g' % theta, 'exact'])
    plt.xlabel('t')
    plt.ylabel('u')
    plotfile = 'tmp'
    plt.savefig(plotfile + '.png');  plt.savefig(plotfile + '.pdf')
    plt.show()
</code></pre>
<!-- end verbatim block -->

<h2 id="softeng1:prog:se:class2">Improving the problem and solver classes</h2>

<p>
The previous <code>Problem</code> and <code>Solver</code> classes containing parameters
soon get much repetitive code when the number of parameters increases.
Much of this code can be parameterized and be made more compact.
For this purpose, we decide to collect all parameters in a dictionary,
<code>self.prm</code>, with two associated dictionaries <code>self.type</code> and
<code>self.help</code> for holding associated object types and help strings.
The reason is that processing dictionaries is easier than processing
a set of individual attributes.
For the specific ODE example we deal with, the three dictionaries in
the problem class are typically

<p>
<!-- begin verbatim block  pycod-->
<pre><code>self.prm  = dict(I=1, a=1, T=10)
self.type = dict(I=float, a=float, T=float)
self.help = dict(I='initial condition, u(0)',
                 a='coefficient in ODE',
                 T='end time of simulation')
</code></pre>
<!-- end verbatim block -->
Provided a problem or solver class defines these three
dictionaries in the constructor,
we can create a super class <code>Parameters</code> with general code
for defining command-line options and reading them as well as
methods for setting and getting each parameter. A <code>Problem</code> or <code>Solver</code> for
a particular mathematical problem can then
inherit most of the needed functionality and code
from the <code>Parameters</code> class. For example,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Problem(Parameters):
    def __init__(self):
        self.prm  = dict(I=1, a=1, T=10)
        self.type = dict(I=float, a=float, T=float)
        self.help = dict(I='initial condition, u(0)',
                         a='coefficient in ODE',
                         T='end time of simulation')

    def u_exact(self, t):
        I, a = self['I a'.split()]
        return I*np.exp(-a*t)

class Solver(Parameters):
    def __init__(self, problem):
        self.problem = problem   # class Problem object
        self.prm  = dict(dt=0.5, theta=0.5)
        self.type = dict(dt=float, theta=float)
        self.help = dict(dt='time step value',
                         theta='time discretization parameter')

    def solve(self):
        from decay import solver
        I, a, T = self.problem['I a T'.split()]
        dt, theta = self['dt theta'.split()]
        self.u, self.t = solver(I, a, T, dt, theta)
</code></pre>
<!-- end verbatim block -->
By inheritance, these classes can automatically do a lot more when it comes to
reading and assigning parameter values:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>problem = Problem()
solver = Solver(problem)

# Read input from the command line
parser = problem.define_command_line_options()
parser = solver. define_command_line_options(parser)
args = parser.parse_args()
problem.init_from_command_line(args)
solver. init_from_command_line(args)

# Other syntax for setting/getting parameter values
problem['T'] = 6
print 'Time step:', solver['dt']

solver.solve()
u, t = solver.u, solver.t
</code></pre>
<!-- end verbatim block -->

<h3 id="___sec224">A generic class for parameters </h3>

<p>
A simplified version of the parameter class looks as follows:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class Parameters(object):
    def __getitem__(self, name):
        &quot;&quot;&quot;obj[name] syntax for getting parameters.&quot;&quot;&quot;
        if isinstance(name, (list,tuple)):         # get many?
            return [self.prm[n] for n in name]
        else:
            return self.prm[name]

    def __setitem__(self, name, value):
        &quot;&quot;&quot;obj[name] = value syntax for setting a parameter.&quot;&quot;&quot;
        self.prm[name] = value

    def define_command_line_options(self, parser=None):
        &quot;&quot;&quot;Automatic registering of options.&quot;&quot;&quot;
        if parser is None:
            import argparse
            parser = argparse.ArgumentParser()

        for name in self.prm:
            tp = self.type[name] if name in self.type else str
            help = self.help[name] if name in self.help else None
            parser.add_argument(
                '--' + name, default=self.get(name), metavar=name,
                type=tp, help=help)

        return parser

    def init_from_command_line(self, args):
        for name in self.prm:
            self.prm[name] = getattr(args, name)
</code></pre>
<!-- end verbatim block -->
The file <a href="http://tinyurl.com/ofkw6kc/softeng/decay_oo.py" target="_self"><tt>decay_oo.py</tt></a> contains
a slightly more advanced version of class <code>Parameters</code> where we
in the functions for getting and setting parameters
test for valid parameter names and
raise exceptions with informative messages if any name is not registered.

<p>
We have already sketched the <code>Problem</code> and <code>Solver</code> classes that build
on inheritance from <code>Parameters</code>. We have also shown how they are
used. The only remaining code is to make the plot, but this code is
identical to previous versions when the numerical solution is
available in an object <code>t</code> and the exact one in <code>u_e</code>.

<p>
The advantage with the <code>Parameters</code> class is that it scales to problems
with a large number of physical and numerical parameters:
as long as the parameters are defined once via a dictionary,
the compact code in class <code>Parameters</code> can handle any collection of
parameters of any size.

<h1 id="softeng1:experiments">Automating scientific experiments</h1>

<p>
Empirical scientific investigations based on running computer programs
require careful design of the experiments and accurate reporting of results.
Although there is a strong tradition to do such investigations manually,
the extreme requirements to scientific accuracy make a program much
better suited to conduct the experiments. We shall in this section outline
how we can write such programs, often called <em>scripts</em>, for running other
programs and archiving the results.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Scientific investigation.</b>
<p>
The purpose of the investigations is to explore the quality of numerical
solutions to an ordinary differential equation. More specifically, we
solve the initial-value problem

$$
\begin{equation}
u^\prime(t) = -au(t),\quad u(0)=I,\quad t\in (0,T],
\tag{197}
\end{equation}
$$

by the \( \theta \)-rule:

$$
\begin{equation}
u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,
\quad u^0=I\tp
\tag{198}
\end{equation}
$$

This scheme corresponds to well-known methods: \( \theta=0 \) gives the
Forward Euler (FE) scheme, \( \theta=1 \) gives the Backward Euler (BE) scheme,
and \( \theta=\frac{1}{2} \) gives the Crank-Nicolson
(CN) or midpoint/centered scheme.

<p>
For chosen constants \( I \), \( a \), and \( T \), we run the three schemes for various
values of \( \Delta t \), and present the following results in a report:

<ol>
<li> visual comparison of the numerical and exact solution in a plot for
   each \( \Delta t \) and \( \theta=0,1,\frac{1}{2} \),</li>
<li> a table and a plot of the norm of the numerical error versus \( \Delta t \)
   for \( \theta=0,1,\frac{1}{2} \).</li>
</ol>

The report will also document the mathematical details of the problem under
investigation.
</div>


<h2 id="___sec226">Available software </h2>

<p>
Appropriate software for implementing <a href="#mjx-eqn-198">(198)</a>
is available in a program <a href="http://tinyurl.com/nc4upel/doconce_src/model.py" target="_self"><tt>model.py</tt></a>, which is run as

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; python model.py --I 1.5 --a 0.25 --T 6 --dt 1.25 0.75 0.5
</code></pre>
<!-- end verbatim block -->
The command-line input corresponds to setting \( I=1.5 \), \( a=0.25 \), \( T=6 \),
and run three values of \( \Delta t \): 1.25, 0.75, ad 0.5.

<p>
The results of running this <code>model.py</code> command are text in the
terminal window and a set of plot files.
The plot files have names <code>M_D.E</code>, where <code>M</code> denotes the method
(<code>FE</code>, <code>BE</code>, <code>CN</code> for \( \theta=0,1,\frac{1}{2} \), respectively), <code>D</code>
the time step length (here <code>1.25</code>, <code>0.75</code>, or <code>0.5</code>), and <code>E</code>
is the plot file extension <code>png</code> or <code>pdf</code>.
The text output in the terminal window looks like

<p>
<!-- begin verbatim block -->
<pre><code>0.0   1.25:    5.998E-01
0.0   0.75:    1.926E-01
0.0   0.50:    1.123E-01
0.0   0.10:    1.558E-02
0.5   1.25:    6.231E-02
0.5   0.75:    1.543E-02
0.5   0.50:    7.237E-03
0.5   0.10:    2.469E-04
1.0   1.25:    1.766E-01
1.0   0.75:    8.579E-02
1.0   0.50:    6.884E-02
1.0   0.10:    1.411E-02
</code></pre>
<!-- end verbatim block -->
The first column is the \( \theta \) value, the next the \( \Delta t \) value,
and the final column represents the numerical error \( E \) (the
norm of discrete error function on the mesh).

<h2 id="___sec227">The results we want to produce </h2>

<p>
The results we need for our investigations are slightly different than
what is directly produced by <code>model.py</code>:

<ol>
<li> We need to collect all the plots for one
   numerical method (FE, BE, CN) in a single plot.
   For example, if 4 \( \Delta t \) values are run, the summarizing plot
   for the BE method has \( 2\times 2 \) subplots, with the subplot corresponding
   to the largest \( \Delta t \) in the upper left corner and the smallest
   in the bottom right corner.</li>
<li> We need to create a table containing
   \( \Delta t \) values in the first column and the numerical error
   \( E \) for \( \theta=0,0.5,1 \)
   in the next three columns. This table should be available as a
   standard CSV file.</li>
<li> We need to plot the numerical error \( E \) versus \( \Delta t \)
   in a log-log plot.</li>
</ol>

Consequently, we must write a script that can run <code>model.py</code> as described and
produce the results 1-3 above. This requires combining multiple plot files into
one file and interpreting the output from <code>model.py</code> as data for plotting and
file storage.

<p>
If the script's name is <code>exper1.py</code>, we run it with the desired \( \Delta t \)
values as positional command-line arguments:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; python exper1.py 0.5 0.25 0.1 0.05
</code></pre>
<!-- end verbatim block -->
This run will then generate eight plot files: <code>FE.png</code> and <code>FE.pdf</code> summarizing
the plots with the FE method, <code>BE.png</code> and <code>BE.pdf</code> with
the BE method, <code>CN.png</code> and <code>CN.pdf</code> with the CN method, and <code>error.png</code>
and <code>error.pdf</code> with the log-log plot of the numerical error versus \( \Delta t \).
In addition, the table with numerical errors is written to a
file <code>error.csv</code>.

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Reproducible and replicable science.</b>
<p>
A script that automates running our computer experiments
will ensure
that the experiments can easily be rerun by anyone in
the future, either to confirm the same results or redo the experiments with
other input data.
Also, whatever we did to produce the results is
documented in every detail in the script.

<p>
A project where anyone can easily repeat the experiments with the same data
is referred to as being <em>replicable</em>, and replicability
should be a fundamental requirement in scientific computing work.
Of more scientific interest is <em>reproducibilty</em>, which means that we can
also run alternative experiments to arrive at the same conclusions.
This requires more than an automating script.
</div>


<h2 id="___sec228">Combining plot files </h2>

<p>
The script for running experiments needs to combine multiple image
files into one. The
<a href="http://www.imagemagick.org/script/montage.php" target="_self"><tt>montage</tt></a>
and
<a href="http://www.imagemagick.org/script/convert.php" target="_self"><tt>convert</tt></a> programs in
the ImageMagick software suite
can be used to combine image files.
However, these programs are best suited for
PNG files. For vector plots in PDF format one needs other tools
to preserve the quality: <code>pdftk</code>, <code>pdfnup</code>, and <code>pdfcrop</code>.

<p>
Suppose you have four files <code>f1.png</code>, <code>f2.png</code>, <code>f3.png</code>, and <code>f4.png</code>
and want to combine them into a \( 2\times 2 \) table of subplots in a new
file <code>f.png</code>, see
Figure <a href="#softeng1:experiments:fig:BE4a">23</a> for an example.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 23:  Illustration of the Backward Euler method for four time step values. <div id="softeng1:experiments:fig:BE4a"></div> </p></center>
<p><img src="fig-softeng/BE4a.png" align="bottom" width=600></p>
</center>

<p>
The appropriate ImageMagick commands are

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; montage -background white -geometry 100% -tile 2x \ 
          f1.png f2.png f3.png f4.png f.png
Terminal&gt; convert -trim f.png f.png
Terminal&gt; convert f.png -transparent white f.png
</code></pre>
<!-- end verbatim block -->
The first command mounts the four files in one, the next <code>convert</code> command
removes unnecessary surrounding white space, and the final <code>convert</code> command
makes the white background transparent.

<p>
High-quality montage of PDF files <code>f1.pdf</code>,
<code>f2.pdf</code>, <code>f3.pdf</code>, and <code>f4.pdf</code> into <code>f.pdf</code> goes like

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; pdftk f1.pdf f2.pdf f3.pdf f4.pdf output tmp.pdf
Terminal&gt; pdfnup --nup 2x2 --outfile tmp.pdf tmp.pdf
Terminal&gt; pdfcrop tmp.pdf f.pdf
Terminal&gt; rm -f tmp.pdf
</code></pre>
<!-- end verbatim block -->

<h2 id="___sec229">Running a program from Python </h2>

<p>
The script for automating experiments needs to run the <code>model.py</code> program
with appropriate command-line options. Python has several tools for
executing an arbitrary command in the operating systems.
Let <code>cmd</code> be a string containing the desired command.
In the present case study, <code>cmd</code> could be <code>'python model.py --I 1 --dt 0.5 0.2'</code>.
The following code
executes <code>cmd</code> and loads the text output into a string <code>output</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from subprocess import Popen, PIPE, STDOUT
p = Popen(cmd, shell=True, stdout=PIPE, stderr=STDOUT)
output, _ = p.communicate()

# Check if the execution was successful
failure = p.returncode
if failure:
    print 'Command failed:', cmd; sys.exit(1)
</code></pre>
<!-- end verbatim block -->
Unsuccessful execution usually makes it meaningless to continue
the program, and therefore we abort the program with <code>sys.exit(1)</code>.
Any argument different from 0 signifies to the computer's operating system
that our program stopped with a failure.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Programming tip: use <code>_</code> for dummy variable.</b>
<p>
Sometimes we need to unpack tuples or lists in separate variables,
but we are not interested in all the variables. One example is

<p>
<!-- begin verbatim block  pycod-->
<pre><code>output, error = p.communicate()
</code></pre>
<!-- end verbatim block -->
but <code>error</code> is of no interest.
One can then use underscore <code>_</code> as variable name for the dummy
(uninteresting) variable(s):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>output, _ = p.communicate()
</code></pre>
<!-- end verbatim block -->
Here is another example where we iterate over a list of three-tuples,
but the interest is limited to the second element in each three-tuple:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for _, value, _ in list_of_three_tuples:
    # work with value
</code></pre>
<!-- end verbatim block -->
</div>


<p>
We need to interpret the contents of the string
<code>output</code> and store
the data in an appropriate data structure for further processing.
Since the content is basically a table and will be transformed to
a spread sheet format, we let the columns in the table be represented
by lists in the program,
and we collect these columns in a dictionary whose keys are natural
column names: <code>dt</code> and the three values of \( \theta \).
The following code translates the output of <code>cmd</code> (<code>output</code>)
to such a dictionary of lists (<code>errors</code>):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>errors = {'dt': dt_values, 1: [], 0: [], 0.5: []}
for line in output.splitlines():
    words = line.split()
    if words[0] in ('0.0', '0.5', '1.0'):  # line with E?
        # typical line: 0.0   1.25:    7.463E+00
        theta = float(words[0])
        E = float(words[2])
        errors[theta].append(E)
</code></pre>
<!-- end verbatim block -->

<h2 id="___sec230">The automating script </h2>

<p>
We have now all the core elements in place to write the complete
script where we run
<code>model.py</code> for a set of \( \Delta t \) values (given as positional
command-line arguments), make the error plot,
write the CSV file, and combine plot files as described above.
The complete code is listed below, followed by some explaining comments.

<p>
<!-- begin verbatim block  pypro-->
<pre><code>import os, sys, glob
import matplotlib.pyplot as plt

def run_experiments(I=1, a=2, T=5):
    # The command line must contain dt values
    if len(sys.argv) &gt; 1:
        dt_values = [float(arg) for arg in sys.argv[1:]]
    else:
        print 'Usage: %s dt1 dt2 dt3 ...' %  sys.argv[0]
        sys.exit(1)  # abort

    # Run module file and grab output
    cmd = 'python model.py --I %g --a %g --T %g' % (I, a, T)
    dt_values_str = ' '.join([str(v) for v in dt_values])
    cmd += ' --dt %s' % dt_values_str
    print cmd
    from subprocess import Popen, PIPE, STDOUT
    p = Popen(cmd, shell=True, stdout=PIPE, stderr=STDOUT)
    output, _ = p.communicate()
    failure = p.returncode
    if failure:
        print 'Command failed:', cmd; sys.exit(1)

    errors = {'dt': dt_values, 1: [], 0: [], 0.5: []}
    for line in output.splitlines():
        words = line.split()
        if words[0] in ('0.0', '0.5', '1.0'):  # line with E?
            # typical line: 0.0   1.25:    7.463E+00
            theta = float(words[0])
            E = float(words[2])
            errors[theta].append(E)

    # Find min/max for the axis
    E_min = 1E+20; E_max = -E_min
    for theta in 0, 0.5, 1:
        E_min = min(E_min, min(errors[theta]))
        E_max = max(E_max, max(errors[theta]))

    plt.loglog(errors['dt'], errors[0], 'ro-')
    plt.loglog(errors['dt'], errors[0.5], 'b+-')
    plt.loglog(errors['dt'], errors[1], 'gx-')
    plt.legend(['FE', 'CN', 'BE'], loc='upper left')
    plt.xlabel('log(time step)')
    plt.ylabel('log(error)')
    plt.axis([min(dt_values), max(dt_values), E_min, E_max])
    plt.title('Error vs time step')
    plt.savefig('error.png');  plt.savefig('error.pdf')

    # Write out a table in CSV format
    f = open('error.csv', 'w')
    f.write(r'$\Delta t$,$\theta=0$,$\theta=0.5$,$\theta=1$' + '\n')
    for _dt, _fe, _cn, _be in zip(
        errors['dt'], errors[0], errors[0.5], errors[1]):
        f.write('%.2f,%.4f,%.4f,%.4f\n' % (_dt, _fe, _cn, _be))
    f.close()

    # Combine images into rows with 2 plots in each row
    image_commands = []
    for method in 'BE', 'CN', 'FE':
        pdf_files = ' '.join(['%s_%g.pdf' % (method, dt)
                              for dt in dt_values])
        png_files = ' '.join(['%s_%g.png' % (method, dt)
                              for dt in dt_values])
        image_commands.append(
            'montage -background white -geometry 100%' +
            ' -tile 2x %s %s.png' % (png_files, method))
        image_commands.append(
            'convert -trim %s.png %s.png' % (method, method))
        image_commands.append(
            'convert %s.png -transparent white %s.png' %
            (method, method))
        image_commands.append(
            'pdftk %s output tmp.pdf' % pdf_files)
        num_rows = int(round(len(dt_values)/2.0))
        image_commands.append(
            'pdfnup --nup 2x%d --outfile tmp.pdf tmp.pdf' % num_rows)
        image_commands.append(
            'pdfcrop tmp.pdf %s.pdf' % method)

    for cmd in image_commands:
        print cmd
        failure = os.system(cmd)
        if failure:
            print 'Command failed:', cmd; sys.exit(1)

    # Remove the files generated above and by model.py
    from glob import glob
    filenames = glob('*_*.png') + glob('*_*.pdf') + glob('tmp*.pdf')
    for filename in filenames:
        os.remove(filename)

if __name__ == '__main__':
    run_experiments(I=1, a=2, T=5)
    plt.show()
</code></pre>
<!-- end verbatim block -->

<p>
We may comment upon many useful constructs in this script:

<ul>
 <li> <code>[float(arg) for arg in sys.argv[1:]]</code> builds a list of real numbers
   from all the command-line arguments.</li>
 <li> <code>['%s_%s.png' % (method, dt) for dt in dt_values]</code> builds a list of
   filenames from a list of numbers (<code>dt_values</code>).</li>
 <li> All <code>montage</code>, <code>convert</code>, <code>pdftk</code>, <code>pdfnup</code>, and <code>pdfcrop</code>
   commands for creating
   composite figures are stored in a
   list and later executed in a loop.</li>
 <li> <code>glob('*_*.png')</code> returns a list of the names of all files in the
   current directory where the filename matches the <a href="http://en.wikipedia.org/wiki/Glob_(programming)" target="_self">Unix wildcard notation</a>
   <code>*_*.png</code> (meaning any text, underscore, any text, and then <code>.png</code>).</li>
 <li> <code>os.remove(filename)</code> removes the file with name <code>filename</code>.</li>
 <li> <code>failure = os.system(cmd)</code> runs an operating system command with
   simpler syntax than what is required by <code>subprocess</code> (but the output
   of <code>cmd</code> cannot be captured).</li>
</ul>

<h2 id="softeng1:exper:report">Making a report</h2>

<p>
The results of running computer experiments are best documented in a
little report containing the problem to be solved, key code segments,
and the plots from a series of experiments. At least the part of the
report containing the plots should be automatically generated by the
script that performs the set of experiments, because in the script we
know exactly which input data that were used to generate a specific
plot, thereby ensuring that each figure is connected to the
right data. Take a look at <a href="http://tinyurl.com/nc4upel/_static/sphinx-cloud/" target="_self">a sample report</a>  to see what we have in
mind.

<h3 id="___sec232">Word, OpenOffice, GoogleDocs </h3>

<p>
Microsoft Word, its open source counterparts OpenOffice and
LibreOffice, along with GoogleDocs and similar online services are the
dominating tools for writing reports today. Nevertheless, scientific
reports often need mathematical equations and nicely typeset computer
code in monospace font. The support for mathematics and computer code
in the mentioned tools is in this author's view not on par with the
technologies based on <em>markup languages</em> and which are addressed
below. Also, with markup languages one has a readable, pure text file
as source for the report, and changes in this text can easily be
tracked by version control systems like Git. The result is a very
strong tool for monitoring &quot;who did what when&quot; with the files,
resulting in increased reliability of the writing process. For
collaborative writing, the merge functionality in Git leads to safer
simultaneously editing that what is offered even by collaborative
tools like GoogleDocs.

<h3 id="___sec233">HTML with MathJax </h3>

<p>
HTML is the markup language used for web pages.  Nicely typeset computer
code is straightforward in HTML, and high-quality mathematical
typesetting is available using an extension to HTML called <a href="http://www.mathjax.org/" target="_self">MathJax</a>, which allows formulas and equations to be
typeset with LaTeX syntax and nicely rendered in web browsers, see
Figure <a href="#softeng1:exper:report:fig:mathjax">24</a>.  A relatively small
subset of LaTeX environments for mathematics is supported, but the
syntax for formulas is quite rich. Inline formulas look like <code>\(
u'=-au \)</code> while equations are surrounded by <code>$$</code> signs.  Inside such
signs, one can use <code>\[ u'=-au \]</code> for unnumbered equations, or
<code>\begin{equation}</code> and <code>\end{equation}</code> for
numbered equations, or <code>\begin{align}</code> and <code>\end{align}</code> for multiple
numbered aligned equations.  You need to be familiar with <a href="http://en.wikibooks.org/wiki/LaTeX/Mathematics" target="_self">mathematical
typesetting in LaTeX</a> to write MathJax
code.

<p>
The file <a href="http://tinyurl.com/p96acy2/report_generation/exper1_html.py" target="_self"><tt>exper1_mathjax.py</tt></a>
calls a script
<a href="http://tinyurl.com/p96acy2/exper1.py" target="_self"><tt>exper1.py</tt></a>
to perform the numerical experiments and then runs Python
statements for creating an <a href="http://tinyurl.com/nc4upel/_static/report_mathjax.html.html" target="_self">HTML file</a> with the source code for <a href="http://tinyurl.com/nc4upel/_static/report_mathjax.html" target="_self">the scientific report</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 24:  Report in HTML format with MathJax. <div id="softeng1:exper:report:fig:mathjax"></div> </p></center>
<p><img src="fig-softeng/report_mathjax.png" align="bottom" width=600></p>
</center>

<h3 id="___sec234">LaTeX </h3>

<p>
<!-- "http://en.wikibooks.org/wiki/LaTeX" -->

<p>
The <em>de facto</em> language for mathematical typesetting and scientific
report writing is <a href="http://en.wikipedia.org/wiki/LaTeX" target="_self">LaTeX</a>. A
number of very sophisticated packages have been added to the language
over a period of three decades, allowing very fine-tuned layout and
typesetting. For output in the <a href="http://tinyurl.com/nc4upel/_static/report.pdf" target="_self">PDF format</a>, see Figure
<a href="#softeng1:exper:report:fig:latex">25</a> for an example, LaTeX is the
definite choice when it comes to <em>typesetting quality</em>.
The LaTeX language used to
write the reports has typically a lot of commands involving
<a href="http://tinyurl.com/nc4upel/_static/report.tex.html" target="_self">backslashes and braces</a>, and many claim that
LaTeX syntax is not particularly readable.  For output on the web via
HTML code (i.e., not only showing the PDF in the browser window), LaTeX
struggles with delivering high quality typesetting. Other tools,
especially Sphinx, give better results and can also produce
nice-looking PDFs.  The file <a href="http://tinyurl.com/p96acy2/report_generation/exper1_latex.py" target="_self"><tt>exper1_latex.py</tt></a> shows how to
generate the LaTeX source from a program.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 25:  Report in PDF format generated from LaTeX source. <div id="softeng1:exper:report:fig:latex"></div> </p></center>
<p><img src="fig-softeng/report_latexpdf.png" align="bottom" width=600></p>
</center>

<h3 id="___sec235">Sphinx </h3>

<p>
<!-- give pointers to source pages -->

<p>
<a href="http://sphinx.pocoo.org/" target="_self">Sphinx</a> is a typesetting language with
similarities to HTML and LaTeX, but with much less tagging. It has
recently become very popular for software documentation and
mathematical reports. Sphinx can utilize LaTeX for mathematical
formulas and equations. Unfortunately, the
subset of LaTeX mathematics supported is less than in full MathJax (in
particular, numbering of multiple equations in an <code>align</code> type
environment is not supported).  The <a href="http://tinyurl.com/nc4upel/_static/report_sphinx.rst.html" target="_self">Sphinx syntax</a> is an extension of
the reStructuredText language. An attractive feature of Sphinx is its
rich support for <a href="http://tinyurl.com/nc4upel/_static/sphinx-cloud/index.html" target="_self">fancy layout of web pages</a>. In particular,
Sphinx can easily be combined with various layout <em>themes</em> that give a
certain look and feel to the web site and that offers table of
contents, navigation, and search facilities, see Figure
<a href="#softeng1:exper:report:fig:sphinx">26</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 26:  Report in HTML format generated from Sphinx source. <div id="softeng1:exper:report:fig:sphinx"></div> </p></center>
<p><img src="fig-softeng/report_sphinx.png" align="bottom" width=600></p>
</center>

<h3 id="___sec236">Markdown </h3>

<p>
A recent, very popular format for easy writing of web pages is
<a href="http://daringfireball.net/projects/markdown/" target="_self">Markdown</a>.
Text is written very much like one would do in email, using
spacing and special characters to naturally format the code
instead of heavily tagging the text as in LaTeX and HTML.
With the tool <a href="http://johnmacfarlane.net/pandoc/" target="_self">Pandoc</a> one
can go from Markdown to a variety of formats.
HTML is a common output format, but LaTeX, epub, XML,
OpenOffice/LibreOffice, MediaWiki, and Microsoft Word are some other
possibilities. A Markdown version of our scientific
report demo is available as an IPython/Jupyter notebook (described next).

<h3 id="___sec237">IPython/Jupyter notebooks </h3>

<p>
The <a href="http://ipython.org/notebook.html" target="_self">IPython Notebook</a> is
a web-based tool where one can write scientific reports with live computer
code and graphics. Or the other way around: software can be equipped
with documentation in the style of scientific reports.
A slightly extended version of Markdown is used for writing text and
mathematics, and the <a href="http://tinyurl.com/nc4upel/_static/report.ipynb.html" target="_self">source code of a notebook</a> is in json format.
The interest in the notebook has grown amazingly fast
over just a few years, and further development now takes place
in the <a href="https://jupyter.org/" target="_self">Jupyter project</a>, which
supports a lot of programming languages for interactive notebook computing.
Jupyter notebooks are primarily live electronic documents, but they can be
printed out as PDF reports too.
A notebook version of our scientific report can be <a href="http://tinyurl.com/p96acy2/_static/report.ipynb" target="_self">downloaded</a> and experimented with
or <a href="http://nbviewer.ipython.org/url/hplgit.github.com/teamods/writing_reports/_static/report.ipynb" target="_self">just statically viewed</a> in a browser.

<h3 id="___sec238">Wiki formats </h3>

<p>
A range of wiki formats are popular for creating notes on the web,
especially documents which allow groups of people to edit and add
content. Apart from <a href="http://www.mediawiki.org/wiki/MediaWiki" target="_self">MediaWiki</a> (the wiki format used for
Wikipedia), wiki formats have no support for mathematical typesetting
and also limited tools for displaying computer code in nice ways.
Wiki formats are therefore less suitable for scientific reports compared
to the other formats mentioned here.

<h3 id="___sec239">DocOnce </h3>

<p>
Since it is difficult to choose the right tool or format for writing a
scientific report, it is advantageous to write the content in a format
that easily translates to LaTeX, HTML, Sphinx, Markdown,
IPython/Jupyter notebooks, and various wikis. <a href="https://github.com/hplgit/doconce" target="_self">DocOnce</a> is such a tool. It is similar to
Pandoc, but offers some special convenient features for writing about
mathematics and programming.  The <a href="http://tinyurl.com/nc4upel/_static/report.do.txt.html" target="_self">tagging is modest</a>, somewhere between
LaTeX and Markdown.  The program <a href="http://tinyurl.com/p96acy2/exper1_do.py" target="_self"><tt>exper1_do.py</tt></a> demonstrates how
to generate DocOnce code for a scientific report.
There is also a corresponding rich demo of the <a href="http://tinyurl.com/nc4upel/index.html" target="_self">resulting reports</a> that can be made from
this DocOnce code.

<p>
<!-- project with exploring instability (help with matplotlib contour plots, and maybe show such a plot) -->

<h2 id="softeng1:exper:github">Publishing a complete project</h2>

<p>
To assist the important principle of <em>replicable</em> science,
a report documenting scientific investigations should be accompanied by
all the software and data used for the investigations so that others
have a possibility to redo the work and assess the qualify of the results.

<p>
One way of documenting a complete project is to make a directory tree
with all relevant files. Preferably, the tree is published at
some project hosting site like <a href="http://hplgit.github.com/teamods/bitgit/html/" target="_self">Bitbucket or GitHub</a> so that others can download it
as a tarfile, zipfile, or clone the files directly using the Git version control
system.
For the investigations outlined in the section <a href="#softeng1:exper:report">Making a report</a>,
we can create a directory tree with files
<!-- begin verbatim block -->
<pre><code>setup.py
./src:
   model.py
./doc:
   ./src:
      exper1_mathjax.py
      make_report.sh
      run.sh
   ./pub:
      report.html
</code></pre>
<!-- end verbatim block -->
The <code>src</code> directory holds source code (modules) to be reused in other projects,
the <code>setup.py</code> script builds and installs such software,
the <code>doc</code> directory contains the documentation, with <code>src</code> for the
source of the documentation (usually written in a markup language)
and <code>pub</code> for published (compiled) documentation.
The <code>run.sh</code> file is a simple Bash script listing the <code>python</code> commands
we used to run <code>exper1_mathjax.py</code> to generate the experiments and
the <code>report.html</code> file.

<p>
<!-- Point to DocOnce version -->

<h1 id="___sec241">Exercises </h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="softeng1:exer:derivative">Problem 39: Make a tool for differentiating curves</h2>

<p>
Suppose we have a curve specified through a set
of discrete coordinates \( (x_i,y_i) \), \( i=0,\ldots,n \), where the \( x_i \)
values are uniformly distributed with spacing \( \Delta x \): \( x_i=\Delta x \).
The derivative of this curve, defined as a new curve with points
\( (x_i, d_i) \), can be computed via finite differences:

$$
\begin{align}
d_0 &= \frac{y_1-y_0}{\Delta x},
\tag{199}\\ 
d_i &= \frac{y_{i+1}-y_{i-1}}{2\Delta x},\quad i=1,\ldots,n-1,
\tag{200}\\ 
d_n &= \frac{y_n-y_{n-1}}{\Delta x}\tp
\tag{201}
\end{align}
$$

<p>
<b>a)</b>
Write a function
<code>differentiate(x, y)</code> for differentiating a curve
with coordinates in the arrays <code>x</code> and <code>y</code>, using the
formulas above. The function should return the coordinate arrays
of the resulting differentiated curve.

<p>
<b>b)</b>
Since the formulas for differentiation used here are only approximate,
with unknown approximation errors, it is challenging to construct
test cases. Here are three approaches, which should be implemented
in three separate test functions.

<ol>
<li> Consider a curve with three points and compute \( d_i \), \( i=0,1,2 \),
   by hand. Make a test that compares the hand-calculated results with those
   from the function in a).</li>
<li> The formulas for \( d_i \) are exact for points on
   a straight line, as all the \( d_i \) values are then the same, equal to
   the slope of the line. A test can check this property.</li>
<li> For point lying on a parabola, the values for \( d_i \), \( i=1,\ldots,n-1 \),
   should equal the exact derivative of the parabola. Make a test based on
   this property.</li>
</ol>

<b>c)</b>
Start with a curve corresponding to \( y=\sin(\pi x) \) and \( n+1 \)
points in \( [0,1] \). Apply <code>differentiate</code> four times and plot the
resulting curve and the exact \( y=\sin\pi x \) for \( n=6, 11, 21, 41 \).

<p>
<!-- Using a 2nd-order backward formula at x=1 does not improve the -->
<!-- results much, one gets large errors at the end points. -->

<p>
Filename: <code>curvediff</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="softeng1:exer:integral:flat">Problem 40: Make solid software for the Trapezoidal rule</h2>

<p>
An integral

$$ \int_a^b f(x)dx $$

can be numerically approximated by the Trapezoidal rule,

$$ \int_a^b f(x)dx \approx \frac{h}{2}(f(a) + f(b)) + h\sum_{i=1}^{n-1} f(x_i),
$$

where \( x_i \) is a set of uniformly spaced points in \( [a,b] \):

$$ h = \frac{b-a}{n},\quad x_i=a + ih,\ i=1,\ldots,n-1\tp $$

<p>
Somebody has used this rule to compute the integral \( \int_0^\pi \sin^2x\, dx \):

<p>
<!-- begin verbatim block  pypro-->
<pre><code>from math import pi, sin
np = 20
h = pi/np
I = 0
for k in range(1, np):
    I += sin(k*h)**2
print I
</code></pre>
<!-- end verbatim block -->

<p>
<b>a)</b>
The &quot;flat&quot; implementation above suffers from serious flaws:

<ol>
<li> A general numerical algorithm (the Trapezoidal rule) is implemented
   in a specialized form where the formula for \( f \) is inserted directly
   into the code for the general integration formula.</li>
<li> A general numerical algorithm is not encapsulated as a general
   function, with appropriate parameters, which can be reused
   across a wide range of applications.</li>
<li> The lazy programmer dropped the first terms in the general formula
   since \( \sin(0)=\sin(\pi)=0 \).</li>
<li> The sloppy programmer used <code>np</code> (number of points?) as variable for
   <code>n</code> in the formula and a counter <code>k</code> instead of <code>i</code>. Such small
   deviations from the mathematical notation are completely unnecessary.
   The closer the code and the mathematics can get, the easier it is
   to spot errors in formulas.</li>
</ol>

Write a function <code>trapezoidal</code> that fixes these flaws.
Place the function in a module <code>trapezoidal</code>.

<p>
<b>b)</b>
Write a test function <code>test_trapezoidal</code>. Call the test function
explicitly to check that it works. Remove the call and run pytest
on the module:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; py.test -s -v trapezoidal
</code></pre>
<!-- end verbatim block -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Note that even if you know the value of the integral, you do not know
the error in the approximation produced by the Trapezoidal rule.
However, the Trapezoidal rule will integrate linear functions
exactly (i.e., to machine precision). Base a test function
on a linear \( f(x) \).

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>c)</b>
Add functionality such that we can compute \( \int_a^b f(x)dx \) by providing
\( f \), \( a \), \( b \), and \( n \) as positional command-line arguments to the
module file:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; python trapezoidal.py 'sin(x)**2' 0 pi 20
</code></pre>
<!-- end verbatim block -->
Here, \( a=0 \), \( b=\pi \), and \( n=20 \).

<p>
Note that the <code>trapezoidal.py</code> file must still be a valid module file, so the
interpretation of command-line data and computation of the integral
must be performed from calls in a test block.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
To translate a string formula on the command line, like <code>sin(x)**2</code>,
into a Python function, you can wrap a function declaration around
the formula and run <code>exec</code> on the string to turn it into live Python code:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import math, sys
formula = sys.argv[1]
f_code = &quot;&quot;&quot;
def f(x):
    return %s
&quot;&quot;&quot; % formula
exec(code, math.__dict__)
</code></pre>
<!-- end verbatim block -->
The result is the same as if we had hardcoded

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from math import *

def f(x):
    return sin(x)**2
</code></pre>
<!-- end verbatim block -->
in the program. Note that <code>exec</code> needs the namespace
<code>math.__dict__</code>, i.e., all names in the <code>math</code> module, such that
it understands <code>sin</code> and other mathematical functions.
Similarly, to allow \( a \) and \( b \) to be <code>math</code> expressions like <code>pi/4</code>
and <code>exp(4)</code>, do

<p>
<!-- begin verbatim block  sys-->
<pre><code>a = eval(sys.argv[2], math.__dict__)
b = eval(sys.argv[2], math.__dict__)
</code></pre>
<!-- end verbatim block -->

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>d)</b>
Write a test function for verifying the implementation of
data reading from the command line.

<p>
Filename: <code>trapezoidal</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="softeng1:exer:integral:flat2">Problem 41: Implement classes for the Trapezoidal rule</h2>

<p>
We consider the same problem setting as in <a href="#softeng1:exer:integral:flat">Problem 40: Make solid software for the Trapezoidal rule</a>. Make a module with a class <code>Problem</code>
representing the mathematical problem to be solved and a class
<code>Solver</code> representing the solution method.  The rest of the
functionality of the module, including test functions and reading data
from the command line, should be as in <a href="#softeng1:exer:integral:flat">Problem 40: Make solid software for the Trapezoidal rule</a>.
Filename: <code>trapezoidal_class</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="softeng1:exer:doctest1">Problem 42: Write a doctest and a test function</h2>

<p>
Type in the following program:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>import sys
# This sqrt(x) returns real if x&gt;0 and complex if x&lt;0
from numpy.lib.scimath import sqrt

def roots(a, b, c):
    &quot;&quot;&quot;
    Return the roots of the quadratic polynomial
    p(x) = a*x**2 + b*x + c.

    The roots are real or complex objects.
    &quot;&quot;&quot;
    q = b**2 - 4*a*c
    r1 = (-b + sqrt(q))/(2*a)
    r2 = (-b - sqrt(q))/(2*a)
    return r1, r2

a, b, c = [float(arg) for arg in sys.argv[1:]]
print roots(a, b, c)
</code></pre>
<!-- end verbatim block -->

<p>
<b>a)</b>
Equip the <code>roots</code> function with a doctest.
Make sure to test both real and complex roots.
Write out numbers in the doctest with 14 digits or less.

<p>
<b>b)</b>
Make a test function for the <code>roots</code> function. Perform the
same mathematical tests as in a), but with different
programming technology.

<p>
Filename: <code>test_roots</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="softeng1:exer:tol">Problem 43: Experiment with tolerances in comparisons</h2>

<p>
When we replace a comparison <code>a == b</code>, where <code>a</code> and/or <code>b</code> are
<code>float</code> objects, by a comparison with tolerance, <code>abs(a-b) &lt; tol</code>,
the appropriate size of <code>tol</code> depends on the size <code>a</code> and <code>b</code>.
Investigate how the size of <code>abs(a-b)</code> varies when <code>b</code> takes on
values \( 10^k \), \( k=-5,-9,\ldots,20 \) and <code>a=1.0/49*b*49</code>.
Filename: <code>tolerance</code>.

<p>
<!-- Closing remarks for this Problem -->

<h3 id="___sec247">Remarks </h3>

<p>
You will experience that if <code>a</code> and <code>b</code> are large, as they can be
in geophysical applications where lengths measured in meters can be of size
\( 10^6 \) m, <code>tol</code> must be about \( 10^{-9} \), while <code>a</code> and <code>b</code> around unity can
have <code>tol</code> of size \( 10^{-15} \).

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="softeng1:exer:class:dts">Exercise 44: Make use of a class implementation</h2>

<p>
Implement the <code>experiment_compare_dt</code> function from <code>decay.py</code>
using class <code>Problem</code> and class <code>Solver</code> from
the section <a href="#softeng1:prog:se:class">Classes for problem and solution method</a>.
The parameters <code>I</code>, <code>a</code>, <code>T</code>, the scheme name, and a series of
<code>dt</code> values should be read from the command line.
Filename: <code>experiment_compare_dt_class</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="softeng1:exer:logistic">Problem 45: Make solid software for a difference equation</h2>

<p>
We have the following evolutionary difference equation for the number
of individuals \( u^n \) of a certain specie at time \( n\Delta t \):

$$
\begin{equation}
u^{n+1} = u^n + \Delta t r u^n\left(1 - \frac{u^n}{M^n}\right),
\quad u^0=U_0\tp
\tag{202}
\end{equation}
$$

Here, \( n \) is a counter in time, \( \Delta t \) is time between time levels
\( n \) and \( n+1 \) (assumed constant), \( r \) is a net reproduction rate
for the specie,
and \( M^n \) is the upper limit of the population that the environment can
sustain at time level \( n \).
Filename: <code>logistic</code>.

<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._decay-book-solarized008.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._decay-book-solarized010.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    
