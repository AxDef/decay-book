<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Finite Difference Computing with Exponential Decay Models">
<meta name="keywords" content="decay ODE,exponential decay,mesh,grid,mesh function,finite differences,forward difference,finite differences forward,difference equation,discrete equation,algebraic equation,finite difference scheme,Forward Euler scheme,backward difference,finite differences backward,backward scheme, 1-step,Backward Euler scheme,Crank-Nicolson scheme,centered difference,finite differences centered,averaging arithmetic,weighted average,theta-rule,$\theta$-rule,time step,finite difference operator notation,operator notation, finite differences,directory,folder,doc strings,printf format,format string syntax (Python),plotting curves,visualizing curves,representative (mesh function),array arithmetics,array computing,vectorization,continuous function norms,norm continuous,discrete function norms,mesh function norms,norm discrete (mesh function),error norms,scalar computing,PNG plot,PDF plot,EPS plot,viewing graphics files,cropping images,array arithmetics,array computing,vectorization,stability,amplification factor,A-stable methods,L-stable methods,interactive Python,error amplification factor,error global,consistency,stability,convergence,Monte Carlo simulation,uncertainty quantification,lambda functions,method of manufactured solutions,MMS (method of manufactured solutions),convergence rate,verification,implicit schemes,explicit schemes,theta-rule,$\theta$-rule,backward scheme, 2-step,BDF2 scheme,Leapfrog scheme,Leapfrog scheme, filtered,Heun's method,Runge-Kutta, 2nd-order method,Taylor-series methods (for ODEs),Adams-Bashforth scheme, 2nd-order,Adams-Bashforth scheme, 3rd order,Runge-Kutta, 4th-order method,RK4,adaptive time stepping,Dormand-Prince Runge-Kutta 4-5 method,population dynamics,logistic model,radioactive decay,chemical reactions irreversible,chemical reactions reversible,Lotka-Volterra model,predator-prey model,terminal velocity,geometric mean,averaging geometric,scaling,Kelvin-Voigt material model,viscoelasticity,refactoring,importing modules,logger,debugging,list comprehension,command-line arguments,option-value pairs (command line),command-line arguments,reading the command line,doctests,software testing doctests,unit testing,software testing nose,software testing pytest,test function,software testing test function,relative differences,doctest in test function,unit testing,software testing unit testing (class-based),Distutils,GitHub,importing modules,problem class,solver class,wrapper (code),reproducibility,replicability,Unix wildcard notation,wildcard notation (Unix),Word (Microsoft),LibreOffice,OpenOffice,Google Docs,HTML,MathJax,LaTeX,Sphinx (typesetting tool),Markdown,IPython notebooks,Jupyter notebooks,DocOnce,replicability,relative differences">

<title>Finite Difference Computing with Exponential Decay Models</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [('Preface', 0, 'ch:preface', 'ch:preface'),
              ('Algorithms and implementations', 0, None, '___sec1'),
              ('Finite difference methods',
               1,
               'decay:basics',
               'decay:basics'),
              ('A basic model for exponential decay',
               2,
               'decay:model',
               'decay:model'),
              ('The exact solution', 3, None, '___sec4'),
              ('A complete problem formulation', 3, None, '___sec5'),
              ('The Forward Euler scheme',
               2,
               'decay:schemes:FE',
               'decay:schemes:FE'),
              ('Step 1: Discretizing the domain', 3, None, '___sec7'),
              ('Step 2: Fulfilling the equation at discrete time points',
               3,
               None,
               '___sec8'),
              ('Step 3: Replacing derivatives by finite differences',
               3,
               None,
               '___sec9'),
              ('Step 4: Formulating a recursive algorithm',
               3,
               None,
               '___sec10'),
              ('Interpretation', 3, None, '___sec11'),
              ('Computing with the recursive formula', 3, None, '___sec12'),
              ('The Backward Euler scheme',
               2,
               'decay:schemes:BE',
               'decay:schemes:BE'),
              ('The Crank-Nicolson scheme',
               2,
               'decay:schemes:CN',
               'decay:schemes:CN'),
              ('The unifying $\\theta$-rule',
               2,
               'decay:schemes:theta',
               'decay:schemes:theta'),
              ('Constant time step', 2, None, '___sec16'),
              ('Mathematical derivation of finite difference formulas',
               2,
               'decay:fd:taylor',
               'decay:fd:taylor'),
              ('The forward difference', 3, None, '___sec18'),
              ('The backward difference', 3, None, '___sec19'),
              ('The centered difference', 3, None, '___sec20'),
              ('Compact operator notation for finite differences',
               2,
               'decay:fd:op',
               'decay:fd:op'),
              ('Implementation', 1, 'decay:impl1', 'decay:impl1'),
              ('Computer language: Python', 2, None, '___sec23'),
              ('Making a solver function', 2, 'decay:py1', 'decay:py1'),
              ('Integer division', 2, 'decay:py2', 'decay:py2'),
              ('Doc strings', 2, None, '___sec26'),
              ('Formatting numbers', 2, None, '___sec27'),
              ('Running the program', 2, None, '___sec28'),
              ('Plotting the solution', 2, None, '___sec29'),
              ('Verifying the implementation', 2, None, '___sec30'),
              ('Running a few algorithmic steps by hand',
               3,
               None,
               '___sec31'),
              ('Computing the numerical error as a mesh function',
               2,
               'decay:computing:error',
               'decay:computing:error'),
              ('Computing the norm of the error mesh function',
               2,
               'decay:computing:error:norm',
               'decay:computing:error:norm'),
              ('Scalar computing', 3, None, '___sec34'),
              ('Experiments with computing and plotting',
               2,
               None,
               '___sec35'),
              ('Combining plot files', 3, None, '___sec36'),
              ('Plotting with SciTools', 3, None, '___sec37'),
              ('Memory-saving implementation', 2, None, '___sec38'),
              ('Exercises', 1, None, '___sec39'),
              ('Exercise 2.1: Define a mesh function and visualize it',
               2,
               'decay:exer:meshfunc',
               'decay:exer:meshfunc'),
              ('Remarks', 3, None, '___sec41'),
              ('Problem 2.2: Differentiate a function',
               2,
               'decay:exer:dudt',
               'decay:exer:dudt'),
              ('Problem 2.3: Experiment with divisions',
               2,
               'decay:exer:intdiv',
               'decay:exer:intdiv'),
              ('Problem 2.4: Experiment with wrong computations',
               2,
               'decay:exer:decay1err',
               'decay:exer:decay1err'),
              ('Problem 2.5: Plot the error function',
               2,
               'decay:exer:plot:error',
               'decay:exer:plot:error'),
              ('Problem 2.6: Change formatting of numbers and debug',
               2,
               'decay:exer:inexact:output',
               'decay:exer:inexact:output'),
              ('Analysis', 0, 'decay:analysis', 'decay:analysis'),
              ('Experimental investigations', 1, None, '___sec48'),
              ('Discouraging numerical solutions', 2, None, '___sec49'),
              ('Detailed experiments', 2, None, '___sec50'),
              ('Stability', 1, None, '___sec51'),
              ('Exact numerical solution', 2, None, '___sec52'),
              ('Stability properties derived from the amplification factor',
               2,
               None,
               '___sec53'),
              ('Accuracy', 1, None, '___sec54'),
              ('Visual comparison of amplification factors',
               2,
               None,
               '___sec55'),
              ('Series expansion of amplification factors',
               2,
               None,
               '___sec56'),
              ('The ratio of numerical and exact amplification factors',
               2,
               None,
               '___sec57'),
              ('The global error at a point',
               2,
               'decay:analysis:gobal:error',
               'decay:analysis:gobal:error'),
              ('Integrated error',
               2,
               'decay:analysis:gobal:error_int',
               'decay:analysis:gobal:error_int'),
              ('Truncation error',
               2,
               'decay:analysis:trunc',
               'decay:analysis:trunc'),
              ('Consistency, stability, and convergence',
               2,
               None,
               '___sec61'),
              ('Various types of errors in a differential equation model',
               1,
               None,
               '___sec62'),
              ('Model errors', 2, None, '___sec63'),
              ('Data errors', 2, None, '___sec64'),
              ('Discretization errors', 2, None, '___sec65'),
              ('Rounding errors', 2, None, '___sec66'),
              ('Discussion of the size of various errors',
               2,
               None,
               '___sec67'),
              ('Exercises', 1, None, '___sec68'),
              ('Problem 3.1: Visualize the accuracy of finite differences',
               2,
               'decay:analysis:exer:fd:exp:plot',
               'decay:analysis:exer:fd:exp:plot'),
              ('Problem 3.2: Explore the $\\theta$-rule for exponential growth',
               2,
               'decay:analysis:exer:growth',
               'decay:analysis:exer:growth'),
              ('Problem 3.3: Explore rounding errors in numerical calculus',
               2,
               'decay:analysis:exer:rounding',
               'decay:analysis:exer:rounding'),
              ('Generalizations', 0, None, '___sec72'),
              ('Model extensions', 1, None, '___sec73'),
              ('Generalization: including a variable coefficient',
               2,
               None,
               '___sec74'),
              ('Generalization: including a source term',
               2,
               'decay:source',
               'decay:source'),
              ('Implementation of the generalized model problem',
               2,
               'decay:general',
               'decay:general'),
              ('Deriving the $\\theta$-rule formula', 3, None, '___sec77'),
              ('Python code', 3, None, '___sec78'),
              ('Coding of variable coefficients', 3, None, '___sec79'),
              ('Verifying a constant solution',
               2,
               'decay:verify:trivial',
               'decay:verify:trivial'),
              ('Verification via manufactured solutions',
               2,
               'decay:MMS',
               'decay:MMS'),
              ('Computing convergence rates',
               2,
               'decay:convergence:rate',
               'decay:convergence:rate'),
              ('Estimating $r$', 3, None, '___sec83'),
              ('Implementation', 3, None, '___sec84'),
              ('Extension to systems of ODEs', 2, None, '___sec85'),
              ('General first-order ODEs', 1, None, '___sec86'),
              ('Generic form of first-order ODEs', 2, None, '___sec87'),
              ('The $\\theta$-rule', 2, None, '___sec88'),
              ('An implicit 2-step backward scheme', 2, None, '___sec89'),
              ('Leapfrog schemes', 2, None, '___sec90'),
              ('The ordinary Leapfrog scheme', 3, None, '___sec91'),
              ('The filtered Leapfrog scheme', 3, None, '___sec92'),
              ('The 2nd-order Runge-Kutta method', 2, None, '___sec93'),
              ('A 2nd-order Taylor-series method', 2, None, '___sec94'),
              ('The 2nd- and 3rd-order Adams-Bashforth schemes',
               2,
               None,
               '___sec95'),
              ('The 4th-order Runge-Kutta method',
               2,
               'decay:fd2:RK4',
               'decay:fd2:RK4'),
              ('The Odespy software', 2, None, '___sec97'),
              ('Example: Runge-Kutta methods', 2, None, '___sec98'),
              ('Remark about using the $\\theta$-rule in Odespy',
               3,
               None,
               '___sec99'),
              ('Example: Adaptive Runge-Kutta methods',
               2,
               'decay:fd2:adaptiveRK',
               'decay:fd2:adaptiveRK'),
              ('Exercises', 1, None, '___sec101'),
              ('Exercise 4.1: Experiment with precision in tests and the size of $u$',
               2,
               'decay:fd2:exer:precision',
               'decay:fd2:exer:precision'),
              ('Exercise 4.2: Implement the 2-step backward scheme',
               2,
               'decay:fd2:exer:bw2',
               'decay:fd2:exer:bw2'),
              ('Exercise 4.3: Implement the 2nd-order Adams-Bashforth scheme',
               2,
               'decay:fd2:exer:AB2',
               'decay:fd2:exer:AB2'),
              ('Exercise 4.4: Implement the 3rd-order Adams-Bashforth scheme',
               2,
               'decay:fd2:exer:AB3',
               'decay:fd2:exer:AB3'),
              ('Exercise 4.5: Analyze explicit 2nd-order methods',
               2,
               'decay:exer:RK2:Taylor:analysis',
               'decay:exer:RK2:Taylor:analysis'),
              ('Project 4.6: Implement and investigate the Leapfrog scheme',
               2,
               'decay:fd2:exer:leapfrog1',
               'decay:fd2:exer:leapfrog1'),
              ('Problem 4.7: Make a unified implementation of many schemes',
               2,
               'decay:fd2:exer:uni',
               'decay:fd2:exer:uni'),
              ('Models', 0, 'decay:app', 'decay:app'),
              ('Scaling', 1, 'decay:app:scaling', 'decay:app:scaling'),
              ('Dimensionless variables', 2, None, '___sec111'),
              ('Dimensionless numbers', 2, None, '___sec112'),
              ('A scaling for vanishing initial condition',
               2,
               None,
               '___sec113'),
              ('Evolution of a population',
               1,
               'decay:app:pop',
               'decay:app:pop'),
              ('Exponential growth',
               2,
               'decay:app:pop:exp',
               'decay:app:pop:exp'),
              ('Logistic growth',
               2,
               'decay:app:pop:log',
               'decay:app:pop:log'),
              ('Compound interest and inflation',
               1,
               'decay:app:interest',
               'decay:app:interest'),
              ("Newton's law of cooling",
               1,
               'decay:app:Newton:cooling',
               'decay:app:Newton:cooling'),
              ('Radioactive decay',
               1,
               'decay:app:nuclear',
               'decay:app:nuclear'),
              ('Deterministic model', 2, None, '___sec120'),
              ('Stochastic model', 2, None, '___sec121'),
              ('Relation between stochastic and deterministic models',
               2,
               None,
               '___sec122'),
              ('Generalization of the radioactive decay modeling',
               2,
               'decay:app:waitingtime',
               'decay:app:waitingtime'),
              ('Chemical kinetics',
               1,
               'decay:app:kinetics',
               'decay:app:kinetics'),
              ('Irreversible reaction of two substances',
               2,
               None,
               '___sec125'),
              ('Reversible reaction of two substances', 2, None, '___sec126'),
              ('Irreversible reaction of two substances into a third',
               2,
               None,
               '___sec127'),
              ('A biochemical reaction', 2, None, '___sec128'),
              ('Spreading of diseases', 1, 'decay:app:SIR', 'decay:app:SIR'),
              ('Predator-prey models in ecology',
               1,
               'decay:app:predprey',
               'decay:app:predprey'),
              ('Decay of atmospheric pressure with altitude',
               1,
               'decay:app:atm',
               'decay:app:atm'),
              ('The general model', 2, None, '___sec132'),
              ('Multiple atmospheric layers', 2, None, '___sec133'),
              ('Simplifications', 2, None, '___sec134'),
              ('Constant layer temperature', 3, None, '___sec135'),
              ('One-layer model', 3, None, '___sec136'),
              ('Compaction of sediments',
               1,
               'decay:app:sediment',
               'decay:app:sediment'),
              ('Vertical motion of a body in a viscous fluid',
               1,
               'decay:app:drag',
               'decay:app:drag'),
              ('Overview of forces', 2, None, '___sec139'),
              ('Equation of motion', 2, None, '___sec140'),
              ('Terminal velocity', 2, None, '___sec141'),
              ('A Crank-Nicolson scheme', 2, None, '___sec142'),
              ('Physical data', 2, None, '___sec143'),
              ('Verification', 2, None, '___sec144'),
              ('Scaling',
               2,
               'decay:app:drag:scaling',
               'decay:app:drag:scaling'),
              ('Viscoelastic materials',
               1,
               'decay:app:viscoelasticity',
               'decay:app:viscoelasticity'),
              ('Decay ODEs from solving a PDE by Fourier expansions',
               1,
               'decay:app:diffusion:Fourier',
               'decay:app:diffusion:Fourier'),
              ('Exercises', 1, None, '___sec148'),
              ('Problem 5.1: Radioactive decay of Carbon-14',
               2,
               'decay:app:exer:radio:C14',
               'decay:app:exer:radio:C14'),
              ("Exercise 5.2: Derive schemes for Newton's law of cooling",
               2,
               'decay:app:exer:cooling:schemes',
               'decay:app:exer:cooling:schemes'),
              ("Exercise 5.3: Implement schemes for Newton's law of cooling",
               2,
               'decay:app:exer:cooling:py',
               'decay:app:exer:cooling:py'),
              ('Exercise 5.4: Find time of murder from body temperature',
               2,
               'decay:app:exer:cooling:murder',
               'decay:app:exer:cooling:murder'),
              ('Exercise 5.5: Simulate an oscillating cooling process',
               2,
               'decay:app:exer:cooling:osc',
               'decay:app:exer:cooling:osc'),
              ('Exercise 5.6: Simulate stochastic radioactive decay',
               2,
               'decay:app:exer:stoch:nuclear',
               'decay:app:exer:stoch:nuclear'),
              ('Problem 5.7: Radioactive decay of two substances',
               2,
               'decay:app:exer:radio:twosubst',
               'decay:app:exer:radio:twosubst'),
              ('Exercise 5.8: Simulate a simple chemical reaction',
               2,
               'decay:app:exer:kinetics:AB',
               'decay:app:exer:kinetics:AB'),
              ('Exercise 5.9: Simulate an $n$-th order chemical reaction',
               2,
               'decay:app:exer:kinetics:ABn',
               'decay:app:exer:kinetics:ABn'),
              ('Exercise 5.10: Simulate a biochemical process',
               2,
               'decay:app:exer:MMK',
               'decay:app:exer:MMK'),
              ('Exercise 5.11: Simulate spreading of a disease',
               2,
               'decay:app:exer:SIR',
               'decay:app:exer:SIR'),
              ('Exercise 5.12: Simulate predator-prey interaction',
               2,
               'decay:app:exer:predprey',
               'decay:app:exer:predprey'),
              ('Exercise 5.13: Simulate the pressure drop in the atmosphere',
               2,
               'decay:app:exer:atm1',
               'decay:app:exer:atm1'),
              ('Exercise 5.14: Make a program for vertical motion in a fluid',
               2,
               'decay:app:exer:drag:prog',
               'decay:app:exer:drag:prog'),
              ('Project 5.15: Simulate parachuting',
               2,
               'decay:app:exer:parachute',
               'decay:app:exer:parachute'),
              ('Exercise 5.16: Formulate vertical motion in the atmosphere',
               2,
               'decay:app:exer:drag:atm1',
               'decay:app:exer:drag:atm1'),
              ('Exercise 5.17: Simulate vertical motion in the atmosphere',
               2,
               'decay:app:exer:drag:atm2',
               'decay:app:exer:drag:atm2'),
              ('Problem 5.18: Compute $y=|x|$ by solving an ODE',
               2,
               'decay:app:exer:signum',
               'decay:app:exer:signum'),
              ('Problem 5.19: Simulate fortune growth with random interest rate',
               2,
               'decay:app:exer:interest',
               'decay:app:exer:interest'),
              ('Exercise 5.20: Simulate a population in a changing environment',
               2,
               'decay:app:exer:pop:at',
               'decay:app:exer:pop:at'),
              ('Exercise 5.21: Simulate logistic growth',
               2,
               'decay:app:exer:pop:logistic1',
               'decay:app:exer:pop:logistic1'),
              ('Exercise 5.22: Rederive the equation for continuous compound interest',
               2,
               'decay:app:exer:interest:derive',
               'decay:app:exer:interest:derive'),
              ('Exercise 5.23: Simulate the deformation of a viscoelastic material',
               2,
               'decay:app:exer:viscoelasticity1',
               'decay:app:exer:viscoelasticity1'),
              ('Scientific software engineering', 0, 'decay:se', 'decay:se'),
              ('Implementations with functions and modules',
               1,
               'softeng1:basic',
               'softeng1:basic'),
              ('Mathematical problem and solution technique',
               2,
               'softeng1:basic:math',
               'softeng1:basic:math'),
              ('A first, quick implementation',
               2,
               'softeng1:basic:impl1',
               'softeng1:basic:impl1'),
              ('A more decent program',
               2,
               'softeng1:basic:impl2',
               'softeng1:basic:impl2'),
              ('Comments in a program', 3, None, '___sec177'),
              ('Refactoring into functions', 3, None, '___sec178'),
              ('Program file vs IDE vs notebook', 3, None, '___sec179'),
              ('Prefixing imported functions by the module name',
               2,
               'softeng1:basic:modprefix',
               'softeng1:basic:modprefix'),
              ('Implementing the numerical algorithm in a function',
               2,
               'softeng1:basic:func',
               'softeng1:basic:func'),
              ('Do not have several versions of a code',
               2,
               None,
               '___sec182'),
              ('Making a module',
               2,
               'softeng1:basic:module',
               'softeng1:basic:module'),
              ('Example on extending the module code',
               2,
               'softeng1:basic:experiment2',
               'softeng1:basic:experiment2'),
              ('Documenting functions and modules',
               2,
               'softeng1:basic:docstring',
               'softeng1:basic:docstring'),
              ('Logging intermediate results',
               2,
               'softeng1:basic:logging',
               'softeng1:basic:logging'),
              ('Introductory example', 3, None, '___sec187'),
              ('Using a logger in our solver function', 3, None, '___sec188'),
              ('User interfaces',
               1,
               'softeng1:basic:UI',
               'softeng1:basic:UI'),
              ('Command-line arguments',
               2,
               'softeng1:basic:UI:cmlargs',
               'softeng1:basic:UI:cmlargs'),
              ('Positional command-line arguments',
               2,
               'softeng1:basic:UI:pos_cml',
               'softeng1:basic:UI:pos_cml'),
              ('Option-value pairs on the command line',
               2,
               'softeng1:basic:UI:options_cml',
               'softeng1:basic:UI:options_cml'),
              ('Creating a graphical web user interface',
               2,
               None,
               '___sec193'),
              ('Making a compute function', 3, None, '___sec194'),
              ('Generating the user interface', 3, None, '___sec195'),
              ('Running the web application', 3, None, '___sec196'),
              ('Tests for verifying implementations',
               1,
               'softeng1:verify',
               'softeng1:verify'),
              ('Doctests',
               2,
               'softeng1:verify:doctests',
               'softeng1:verify:doctests'),
              ('Unit tests and test functions',
               2,
               'softeng1:verify:pytest',
               'softeng1:verify:pytest'),
              ('Two Python test frameworks: nose and pytest',
               3,
               None,
               '___sec200'),
              ('Test function requirements', 3, None, '___sec201'),
              ('Comparison of real numbers', 3, None, '___sec202'),
              ('Special assert functions from nose', 3, None, '___sec203'),
              ('Locating test functions', 3, None, '___sec204'),
              ('Running tests', 3, None, '___sec205'),
              ('Embedding doctests in a test function', 3, None, '___sec206'),
              ('Installing nose and pytest', 3, None, '___sec207'),
              ('Test function for the solver', 2, None, '___sec208'),
              ('Test function for reading positional command-line arguments',
               2,
               None,
               '___sec209'),
              ('Test function for reading option-value pairs',
               2,
               None,
               '___sec210'),
              ('Classical class-based unit testing',
               2,
               'softeng1:basic:unittest',
               'softeng1:basic:unittest'),
              ('Sharing the software with other users',
               1,
               'softeng1:prog:se:git',
               'softeng1:prog:se:git'),
              ('Organizing the software directory tree',
               2,
               None,
               '___sec213'),
              ('Distributing just a module file', 3, None, '___sec214'),
              ('Distributing a package', 3, None, '___sec215'),
              ('Publishing the software at GitHub', 2, None, '___sec216'),
              ('Downloading and installing the software',
               2,
               None,
               '___sec217'),
              ('Installing just a module file', 3, None, '___sec218'),
              ('Installing a package', 3, None, '___sec219'),
              ('Classes for problem and solution method',
               1,
               'softeng1:prog:se:class',
               'softeng1:prog:se:class'),
              ('The problem class', 2, None, '___sec221'),
              ('The solver class', 2, None, '___sec222'),
              ('Combining the objects', 3, None, '___sec223'),
              ('Improving the problem and solver classes',
               2,
               'softeng1:prog:se:class2',
               'softeng1:prog:se:class2'),
              ('A generic class for parameters', 3, None, '___sec225'),
              ('Automating scientific experiments',
               1,
               'softeng1:experiments',
               'softeng1:experiments'),
              ('Available software', 2, None, '___sec227'),
              ('The results we want to produce', 2, None, '___sec228'),
              ('Combining plot files', 2, None, '___sec229'),
              ('Running a program from Python', 2, None, '___sec230'),
              ('The automating script', 2, None, '___sec231'),
              ('Making a report',
               2,
               'softeng1:exper:report',
               'softeng1:exper:report'),
              ('Word, OpenOffice, GoogleDocs', 3, None, '___sec233'),
              ('HTML with MathJax', 3, None, '___sec234'),
              ('LaTeX', 3, None, '___sec235'),
              ('Sphinx', 3, None, '___sec236'),
              ('Markdown', 3, None, '___sec237'),
              ('IPython/Jupyter notebooks', 3, None, '___sec238'),
              ('Wiki formats', 3, None, '___sec239'),
              ('DocOnce', 3, None, '___sec240'),
              ('Publishing a complete project',
               2,
               'softeng1:exper:github',
               'softeng1:exper:github'),
              ('Exercises', 1, None, '___sec242'),
              ('Problem 6.1: Make a tool for differentiating curves',
               2,
               'softeng1:exer:derivative',
               'softeng1:exer:derivative'),
              ('Problem 6.2: Make solid software for the Trapezoidal rule',
               2,
               'softeng1:exer:integral:flat',
               'softeng1:exer:integral:flat'),
              ('Problem 6.3: Implement classes for the Trapezoidal rule',
               2,
               'softeng1:exer:integral:flat2',
               'softeng1:exer:integral:flat2'),
              ('Problem 6.4: Write a doctest and a test function',
               2,
               'softeng1:exer:doctest1',
               'softeng1:exer:doctest1'),
              ('Problem 6.5: Investigate the size of tolerances in comparisons',
               2,
               'softeng1:exer:tol',
               'softeng1:exer:tol'),
              ('Remarks', 3, None, '___sec248'),
              ('Exercise 6.6: Make use of a class implementation',
               2,
               'softeng1:exer:class:dts',
               'softeng1:exer:class:dts'),
              ('Problem 6.7: Make solid software for a difference equation',
               2,
               'softeng1:exer:logistic',
               'softeng1:exer:logistic'),
              ('Summarizing multiple-choice questions', 0, None, '___sec251'),
              ('Quiz', 1, None, '___sec252'),
              ('Exercise 7.1: Characterize a finite difference',
               2,
               'decay:quiz:fd:FE',
               'decay:quiz:fd:FE'),
              ('Exercise 7.2: Characterize a finite difference',
               2,
               'decay:quiz:fd:CN',
               'decay:quiz:fd:CN'),
              ('Exercise 7.3: What is the problem with this program?',
               2,
               'decay:quiz:program',
               'decay:quiz:program'),
              ('Exercise 7.4: Is the solution correct?',
               2,
               'decay:quiz:stability',
               'decay:quiz:stability'),
              ('Exercise 7.5: Is this a proper test function?',
               2,
               'decay:quiz:testfunc',
               'decay:quiz:testfunc'),
              ('Exercise 7.6: Rewrite an expression with array arithmetics',
               2,
               'decay:quiz:arrayarithm',
               'decay:quiz:arrayarithm'),
              ('Exercise 7.7: What is the truncation error?',
               2,
               'decay:quiz:trunc',
               'decay:quiz:trunc'),
              ('Exercise 7.8: Recognize a programming language',
               2,
               'decay:quiz:prog:m',
               'decay:quiz:prog:m'),
              ('Exercise 7.9: Recognize a programming language',
               2,
               'decay:quiz:prog:py',
               'decay:quiz:prog:py'),
              ('Exercise 7.10: Recognize a programming language',
               2,
               'decay:quiz:prog:f77',
               'decay:quiz:prog:f77'),
              ('Exercise 7.11: Recognize a programming language',
               2,
               'decay:quiz:prog:c',
               'decay:quiz:prog:c'),
              ('Exercise 7.12: What is SymPy?',
               2,
               'decay:quiz:sympy1',
               'decay:quiz:sympy1'),
              ('Exercise 7.13: Testing of code',
               2,
               'decay:quiz:testing1',
               'decay:quiz:testing1'),
              ('Exercise 7.14: What kind of scheme is this?',
               2,
               'decay:quiz:scheme:CN_error',
               'decay:quiz:scheme:CN_error'),
              ('Exercise 7.15: What kind of scheme is this?',
               2,
               'decay:quiz:scheme:BE',
               'decay:quiz:scheme:BE'),
              ('Exercise 7.16: What kind of scheme is this?',
               2,
               'decay:quiz:scheme:leapfrog',
               'decay:quiz:scheme:leapfrog'),
              ('References', 1, None, '___sec269')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\stress}{\boldsymbol{\sigma}}
$$




    
<a name="part0007"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._decay-book-solarized006.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._decay-book-solarized008.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<center><h1 id="___sec72">Generalizations </h1></center> <hr>

<p>
It is time to consider generalizations of the simple decay model
\( u^{\prime}=-au \) and also to look at additional numerical solution
methods.  We consider first variable coefficients, \( u^{\prime}=a(t)u +
b(t) \), and later a completely general scalar ODE \( u^{\prime}=f(u,t) \)
and its generalization to a system of such general ODEs.  Among
numerical methods, we treat implicit multi-step methods, and several
families of explicit methods: Leapfrog schemes, Runge-Kutta methods,
and Adams-Bashforth formulas.

<h1 id="___sec73">Model extensions </h1>

<p>
This section looks at the generalizations to \( u^{\prime}=-a(t)u \)
and \( u^{\prime}=-a(t)u + b(t) \). We sketch the corresponding
implementations of the \( \theta \)-rule for such variable-coefficient ODEs.
Verification can no longer make use of an exact solution of the
numerical problem so we make use of manufactured solutions,
for deriving an exact solution of the ODE problem, and then we can
compute empirical convergence rates for the method and see if these
coincide with the expected rates from theory.
Finally, we see how our numerical methods can be applied to systems
of ODEs.

<p>
The example programs associated with this chapter are found in
the directory <a href="http://tinyurl.com/ofkw6kc/genz" target="_self"><tt>src/genz</tt></a>.

<h2 id="___sec74">Generalization: including a variable coefficient </h2>

<p>
In the ODE for decay, \( u^{\prime}=-au \), we now consider the case where \( a \)
depends on time:

$$
\begin{equation}
u^{\prime}(t) = -a(t)u(t),\quad t\in (0,T],\quad u(0)=I \tp
\tag{74}
\end{equation}
$$

<p>
A Forward Euler scheme consists of evaluating <a href="#mjx-eqn-74">(74)</a>
at \( t=t_n \) and approximating the derivative with a forward
difference \( [D^+_t u]^n \):

$$
\begin{equation}
\frac{u^{n+1} - u^n}{\Delta t} = -a(t_n)u^n
\tp
\tag{75}
\end{equation}
$$

The Backward Euler scheme becomes
$$
\begin{equation}
\frac{u^{n} - u^{n-1}}{\Delta t} = -a(t_n)u^n
\tp
\tag{76}
\end{equation}
$$

The Crank-Nicolson method builds on sampling the ODE at
\( t_{n+\half} \). We can evaluate \( a \) at \( t_{n+\half} \)
and use an average for \( u \) at
times \( t_n \) and \( t_{n+1} \):
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -a(t_{n+\half})\half(u^n + u^{n+1})
\tp
\tag{77}
\end{equation}
$$

Alternatively, we can use an average for the product \( au \):

$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -\half(a(t_n)u^n + a(t_{n+1})u^{n+1})
\tp
\tag{78}
\end{equation}
$$

The \( \theta \)-rule unifies the three mentioned schemes. One version is to
have \( a \) evaluated at the weighted time point \( (1-\theta)t_n + \theta t_{n+1} \),

$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -a((1-\theta)t_n + \theta t_{n+1})((1-\theta) u^n + \theta u^{n+1})
\tp
\tag{79}
\end{equation}
$$

Another possibility is to apply a weighted average for the product \( au \),
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -(1-\theta) a(t_n)u^n - \theta
a(t_{n+1})u^{n+1}
\tp
\tag{80}
\end{equation}
$$

<p>
With the finite difference operator notation the Forward Euler and Backward
Euler schemes can be summarized as

$$
\begin{align}
\lbrack D^+_t u &= -au\rbrack^n,
\tag{81}\\ 
\lbrack D^-_t u &= -au\rbrack^n
\tp
\tag{82}
\end{align}
$$

The Crank-Nicolson and \( \theta \) schemes depend on whether we evaluate
\( a \) at the sample point for the ODE or if we use an average. The
various versions are written as

$$
\begin{align}
\lbrack D_t u &= -a\overline{u}^t\rbrack^{n+\half},
\tag{83}\\ 
\lbrack D_t u &= -\overline{au}^t\rbrack^{n+\half},
\tag{84}\\ 
\lbrack D_t u &= -a\overline{u}^{t,\theta}\rbrack^{n+\theta},
\tag{85}\\ 
\lbrack D_t u &= -\overline{au}^{t,\theta}\rbrack^{n+\theta}
\tp
\tag{86}
\end{align}
$$

<h2 id="decay:source">Generalization: including a source term</h2>

<p>
A further extension of the model ODE is to include a source term \( b(t) \):

$$
\begin{equation}
u^{\prime}(t) = -a(t)u(t) + b(t),\quad t\in (0,T],\quad u(0)=I
\tp
\tag{87}
\end{equation}
$$

<p>
The time point where we sample the ODE determines where \( b(t) \) is
evaluated. For the Crank-Nicolson scheme and the \( \theta \)-rule we
have a choice of whether to evaluate \( a(t) \) and \( b(t) \) at the
correct point or use an average. The chosen strategy becomes
particularly clear if we write up the schemes in the operator notation:

$$
\begin{align}
\lbrack D^+_t u &= -au + b\rbrack^n,
\tag{88}\\ 
\lbrack D^-_t u &= -au + b\rbrack^n,
\tag{89}\\ 
\lbrack D_t u   &= -a\overline{u}^t + b\rbrack^{n+\half},
\tag{90}\\ 
\lbrack D_t u   &= \overline{-au+b}^t\rbrack^{n+\half},
\tag{91}\\ 
\lbrack D_t u   &= -a\overline{u}^{t,\theta} + b\rbrack^{n+\theta},
\tag{92}\\ 
\lbrack D_t u   &= \overline{-au+b}^{t,\theta}\rbrack^{n+\theta}
\tag{93}
\tp
\end{align}
$$

<h2 id="decay:general">Implementation of the generalized model problem</h2>

<h3 id="___sec77">Deriving the \( \theta \)-rule formula </h3>

<p>
Writing out the \( \theta \)-rule in <a href="#mjx-eqn-93">(93)</a>,
using <a href="._decay-book-solarized003.html#mjx-eqn-44">(44)</a>
and <a href="._decay-book-solarized003.html#mjx-eqn-45">(45)</a>, we get
$$
\begin{equation}
\frac{u^{n+1}-u^n}{\Delta t} = \theta(-a^{n+1}u^{n+1} + b^{n+1}))
+ (1-\theta)(-a^nu^{n} + b^n)),
\tag{94}
\end{equation}
$$

where \( a^n \) means evaluating \( a \) at \( t=t_n \) and similar for
\( a^{n+1} \), \( b^n \), and \( b^{n+1} \).
We solve for \( u^{n+1} \):
$$
\begin{equation}
u^{n+1} = ((1 - \Delta t(1-\theta)a^n)u^n
+ \Delta t(\theta b^{n+1} + (1-\theta)b^n))(1 + \Delta t\theta a^{n+1})^{-1}
\tp
\tag{95}
\end{equation}
$$

<h3 id="___sec78">Python code </h3>

<p>
Here is a suitable implementation of <a href="#mjx-eqn-94">(94)</a>
where \( a(t) \) and \( b(t) \) are given as
Python functions:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def solver(I, a, b, T, dt, theta):
    &quot;&quot;&quot;
    Solve u'=-a(t)*u + b(t), u(0)=I,
    for t in (0,T] with steps of dt.
    a and b are Python functions of t.
    &quot;&quot;&quot;
    dt = float(dt)            # avoid integer division
    Nt = int(round(T/dt))     # no of time intervals
    T = Nt*dt                 # adjust T to fit time step dt
    u = zeros(Nt+1)           # array of u[n] values
    t = linspace(0, T, Nt+1)  # time mesh

    u[0] = I                  # assign initial condition
    for n in range(0, Nt):    # n=0,1,...,Nt-1
        u[n+1] = ((1 - dt*(1-theta)*a(t[n]))*u[n] + \ 
                  dt*(theta*b(t[n+1]) + (1-theta)*b(t[n])))/\ 
                  (1 + dt*theta*a(t[n+1]))
    return u, t
</code></pre>
<!-- end verbatim block -->
This function is found in the file <a href="http://tinyurl.com/ofkw6kc/genz/decay_vc.py" target="_self"><tt>decay_vc.py</tt></a> (<code>vc</code> stands for &quot;variable coefficients&quot;).

<h3 id="___sec79">Coding of variable coefficients </h3>

<p>
The <code>solver</code> function shown above demands the arguments <code>a</code> and <code>b</code> to
be Python functions of time <code>t</code>, say

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def a(t):
    return a_0 if t &lt; tp else k*a_0

def b(t):
    return 1
</code></pre>
<!-- end verbatim block -->
Here, <code>a(t)</code> has three parameters <code>a0</code>, <code>tp</code>, and <code>k</code>,
which must be global variables.

<p>
A better implementation, which avoids global variables,
is to represent <code>a</code> by a class where the
parameters are attributes and where a <em>special method</em> <code>__call__</code>
evaluates \( a(t) \):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>class A:
    def __init__(self, a0=1, k=2):
        self.a0, self.k = a0, k

    def __call__(self, t):
        return self.a0 if t &lt; self.tp else self.k*self.a0

a = A(a0=2, k=1)  # a behaves as a function a(t)
</code></pre>
<!-- end verbatim block -->

<p>
For quick tests it is cumbersome to write a complete function or a class.
The <em>lambda function</em> construction in Python is then convenient. For example,
<!-- begin verbatim block  pycod-->
<pre><code>a = lambda t: a_0 if t &lt; tp else k*a_0
</code></pre>
<!-- end verbatim block -->
is equivalent to the <code>def a(t)</code> definition above. In general,
<!-- begin verbatim block  pycod-->
<pre><code>f = lambda arg1, arg2, ...: expression
</code></pre>
<!-- end verbatim block -->
is equivalent to
<!-- begin verbatim block  pycod-->
<pre><code>def f(arg1, arg2, ...):
    return expression
</code></pre>
<!-- end verbatim block -->
One can use lambda functions directly in calls. Say we want to
solve \( u^{\prime}=-u+1 \), \( u(0)=2 \):
<!-- begin verbatim block  pycod-->
<pre><code>u, t = solver(2, lambda t: 1, lambda t: 1, T, dt, theta)
</code></pre>
<!-- end verbatim block -->

<p>
Whether to use a plain function, a class, or a lambda function depends
on the programmer's taste. Lazy programmers prefer the lambda construct, while
very safe programmers go for the class solution.

<h2 id="decay:verify:trivial">Verifying a constant solution</h2>

<p>
An extremely useful partial verification method is to construct a test
problem with a very simple solution, usually \( u=\hbox{const} \).
Especially the initial debugging of a program code can benefit greatly
from such tests, because 1) all relevant numerical methods will
exactly reproduce a constant solution, 2) many of the intermediate
calculations are easy to control by hand for a constant \( u \), and 3) even a
constant \( u \) can uncover many bugs in an implementation.

<p>
The only constant solution for the problem \( u^{\prime}=-au \) is \( u=0 \), but too
many bugs can escape from that trivial solution.  It is much better to
search for a problem where \( u=C=\hbox{const}\neq 0 \).  Then \( u^{\prime}=-a(t)u
+ b(t) \) is more appropriate: with \( u=C \) we can choose any \( a(t) \) and
set \( b=a(t)C \) and \( I=C \). An appropriate test function is

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_constant_solution():
    &quot;&quot;&quot;
    Test problem where u=u_const is the exact solution, to be
    reproduced (to machine precision) by any relevant method.
    &quot;&quot;&quot;
    def u_exact(t):
        return u_const

    def a(t):
        return 2.5*(1+t**3)  # can be arbitrary

    def b(t):
        return a(t)*u_const

    u_const = 2.15
    theta = 0.4; I = u_const; dt = 4
    Nt = 4  # enough with a few steps
    u, t = solver(I=I, a=a, b=b, T=Nt*dt, dt=dt, theta=theta)
    print u
    u_e = u_exact(t)
    difference = abs(u_e - u).max()  # max deviation
    tol = 1E-14
    assert difference &lt; tol
</code></pre>
<!-- end verbatim block -->

<p>
An interesting question is what type of bugs that will make the
computed \( u^n \) deviate from the exact solution \( C \).
Fortunately, the updating formula and the initial condition must
be absolutely correct for the test to pass! Any attempt to make
a wrong indexing in terms like <code>a(t[n])</code> or any attempt to
introduce an erroneous factor in the formula creates a solution
that is different from \( C \).

<h2 id="decay:MMS">Verification via manufactured solutions</h2>

<p>
Following the idea of the previous section, we can choose any formula
as the exact solution, insert the formula in the ODE problem and fit
the data \( a(t) \), \( b(t) \), and \( I \) to make the chosen
formula fulfill the equation. This
powerful technique for generating exact solutions is very useful for
verification purposes and known as the <em>method of manufactured
solutions</em>, often abbreviated MMS.

<p>
One common choice of solution is a linear function in the independent
variable(s). The rationale behind such a simple variation is that
almost any relevant numerical solution method for differential
equation problems is able to reproduce a linear function exactly to
machine precision (if \( u \) is about unity in size; precision is lost if
\( u \) takes on large values, see <a href="#decay:fd2:exer:precision">Exercise 4.1: Experiment with precision in tests and the size of \( u \)</a>).
The linear solution also makes some stronger demands to the
numerical method and the implementation than the constant solution
used in the section <a href="#decay:verify:trivial">Verifying a constant solution</a>, at least in more
complicated applications. Still, the constant solution is often
ideal for initial debugging before proceeding with a linear solution.

<p>
We choose a linear solution \( u(t) = ct + d \). From the initial condition it
follows that \( d=I \).
Inserting this \( u \) in the left-hand side of <a href="#mjx-eqn-87">(87)</a>, i.e.,
the ODE, we get
$$ c = -a(t)u + b(t) \tp  $$

Any function \( u=ct+I \) is then a correct solution if we choose
$$ b(t) = c + a(t)(ct + I) \tp  $$

With this \( b(t) \) there are no restrictions on \( a(t) \) and \( c \).

<p>
Let us prove that such a linear solution obeys the numerical
schemes. To this end, we must check that \( u^n = ca(t_n)(ct_n+I) \)
fulfills the discrete equations. For these calculations, and
later calculations involving linear solutions inserted in
finite difference schemes, it is convenient to
compute the action of a difference operator on a linear function \( t \):

$$
\begin{align}
\lbrack D_t^+ t\rbrack^n &= \frac{t_{n+1}-t_n}{\Delta t}=1,
\tag{96}\\ 
\lbrack D_t^- t\rbrack^n &= \frac{t_{n}-t_{n-1}}{\Delta t}=1,
\tag{97}\\ 
\lbrack D_t t\rbrack^n &= \frac{t_{n+\half}-t_{n-\half}}{\Delta t}=\frac{(n+\half)\Delta t - (n-\half)\Delta t}{\Delta t}=1
\tag{98}
\tp
\end{align}
$$

Clearly, all three finite difference approximations to the derivative are
exact for \( u(t)=t \) or its mesh function counterpart \( u^n = t_n \).

<p>
The difference equation for the Forward Euler scheme

$$ [D^+_t u = -au + b]^n, $$

with \( a^n=a(t_n) \), \( b^n=c + a(t_n)(ct_n + I) \), and \( u^n=ct_n + I \)
then results in

$$ c = -a(t_n)(ct_n+I) + c + a(t_n)(ct_n + I) = c $$

which is always fulfilled. Similar calculations can be done for the
Backward Euler and Crank-Nicolson schemes, or the \( \theta \)-rule for
that matter. In all cases, \( u^n=ct_n +I \) is an exact solution of
the discrete equations. That is why we should expect that
\( u^n - \uex(t_n) =0 \) mathematically and \( |u^n - \uex(t_n)| \) less
than a small number about the machine precision for \( n=0,\ldots,N_t \).

<p>
The following function offers an implementation of this verification
test based on a linear exact solution:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_linear_solution():
    &quot;&quot;&quot;
    Test problem where u=c*t+I is the exact solution, to be
    reproduced (to machine precision) by any relevant method.
    &quot;&quot;&quot;
    def u_exact(t):
        return c*t + I

    def a(t):
        return t**0.5  # can be arbitrary

    def b(t):
        return c + a(t)*u_exact(t)

    theta = 0.4; I = 0.1; dt = 0.1; c = -0.5
    T = 4
    Nt = int(T/dt)  # no of steps
    u, t = solver(I=I, a=a, b=b, T=Nt*dt, dt=dt, theta=theta)
    u_e = u_exact(t)
    difference = abs(u_e - u).max()  # max deviation
    print difference
    tol = 1E-14  # depends on c!
    assert difference &lt; tol
</code></pre>
<!-- end verbatim block -->
Any error in the updating formula makes this test fail!

<p>
Choosing more complicated formulas as the exact solution, say
\( \cos(t) \), will not make the numerical and exact solution
coincide to machine precision, because finite differencing of
\( \cos(t) \) does not exactly yield the exact derivative \( -\sin(t) \).
In such cases, the verification procedure
must be based on measuring the convergence rates as exemplified in
the section <a href="#decay:convergence:rate">Computing convergence rates</a>. Convergence rates can be
computed as long as one has
an exact solution of a problem that the solver can be tested on, but
this can always be obtained by the method of manufactured solutions.

<h2 id="decay:convergence:rate">Computing convergence rates</h2>

<p>
We expect that the error \( E \) in the numerical solution is
reduced if the mesh size \( \Delta t \) is decreased. More specifically,
many numerical methods obey a power-law relation between \( E \) and
\( \Delta t \):

$$
\begin{equation}
E = C\Delta t^r,
\tag{99}
\end{equation}
$$

where \( C \) and \( r \) are (usually unknown) constants independent of \( \Delta t \).
The formula <a href="#mjx-eqn-99">(99)</a> is viewed as an asymptotic model valid for
sufficiently small \( \Delta t \). How small is normally hard to estimate
without doing numerical estimations of \( r \).

<p>
The parameter \( r \) is known as the <em>convergence rate</em>. For example,
if the convergence rate is 2, halving \( \Delta t \) reduces the error by
a factor of 4. Diminishing \( \Delta t \) then has a greater impact on
the error compared with methods that have \( r=1 \). For a given value of \( r \),
we refer to the method as of \( r \)-th order. First- and second-order
methods are most common in scientific computing.

<h3 id="___sec83">Estimating \( r \) </h3>

<p>
There are two alternative ways of estimating \( C \) and \( r \) based on a set of
\( m \) simulations with corresponding pairs \( (\Delta t_i, E_i) \), \( i=0,\ldots,m-1 \),
and \( \Delta t_{i} < \Delta t_{i-1} \) (i.e., decreasing cell size).

<ol>
 <li> Take the logarithm of <a href="#mjx-eqn-99">(99)</a>, \( \ln E = r\ln \Delta t + \ln C \),
    and fit a straight line to the data points \( (\Delta t_i, E_i) \),
    \( i=0,\ldots,m-1 \).</li>
 <li> Consider two consecutive experiments, \( (\Delta t_i, E_i) \) and
    \( (\Delta t_{i-1}, E_{i-1}) \). Dividing the equation
    \( E_{i-1}=C\Delta t_{i-1}^r \) by \( E_{i}=C\Delta t_{i}^r \) and solving
    for \( r \) yields</li>
</ol>

$$
\begin{equation}
r_{i-1} = \frac{\ln (E_{i-1}/E_i)}{\ln (\Delta t_{i-1}/\Delta t_i)}
\tag{100}
\end{equation}
$$

for \( i=1,\ldots,m-1 \). Note that we have introduced a subindex \( i-1 \)
on \( r \) in <a href="#mjx-eqn-100">(100)</a> because \( r \) estimated from
a pair of experiments must be expected to change with \( i \).

<p>
The disadvantage of method 1 is that <a href="#mjx-eqn-99">(99)</a> might not be valid
for the coarsest meshes (largest \( \Delta t \) values). Fitting a line
to all the data points is then misleading.  Method 2 computes
convergence rates for pairs of experiments and allows us to see
if the sequence \( r_i \) converges to some value as \( i\rightarrow m-2 \).
The final \( r_{m-2} \) can then be taken as the convergence rate.
If the coarsest meshes have a differing rate, the corresponding
time steps are probably too large for <a href="#mjx-eqn-99">(99)</a> to be valid.
That is, those time steps lie outside the asymptotic range of
\( \Delta t \) values where the error behaves like <a href="#mjx-eqn-99">(99)</a>.

<h3 id="___sec84">Implementation </h3>

<p>
We can compute \( r_0, r_1, \ldots, r_{m-2} \) from \( E_i \) and \( \Delta t_i \)
by the following function

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def compute_rates(dt_values, E_values):
    m = len(dt_values)
    r = [log(E_values[i-1]/E_values[i])/
         log(dt_values[i-1]/dt_values[i])
         for i in range(1, m, 1)]
    # Round to two decimals
    r = [round(r_, 2) for r_ in r]
    return r
</code></pre>
<!-- end verbatim block -->

<p>
Experiments with a series of time step values and \( \theta=0,1,0.5 \)
can be set up as follows, here embedded in a real test function:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_convergence_rates():
    # Create a manufactured solution
    # define u_exact(t), a(t), b(t)

    dt_values = [0.1*2**(-i) for i in range(7)]
    I = u_exact(0)

    for theta in (0, 1, 0.5):
        E_values = []
        for dt in dt_values:
            u, t = solver(I=I, a=a, b=b, T=6, dt=dt, theta=theta)
            u_e = u_exact(t)
            e = u_e - u
            E = sqrt(dt*sum(e**2))
            E_values.append(E)
        r = compute_rates(dt_values, E_values)
        print 'theta=%g, r: %s' % (theta, r)
        expected_rate = 2 if theta == 0.5 else 1
        tol = 0.1
        diff = abs(expected_rate - r[-1])
        assert diff &lt; tol
</code></pre>
<!-- end verbatim block -->

<p>
The manufactured solution is conveniently computed by <code>sympy</code>.
Let us choose \( \uex(t) = \sin(t)e^{-2t} \) and \( a(t)=t^2 \).
This implies that we must fit \( b \) as \( b(t)=u'(t)-a(t) \).
We first compute with <code>sympy</code> expressions and then we convert
the exact solution, \( a \), and \( b \) to Python functions that we
can use in the subsequent numerical computing:

<p>
<!-- begin verbatim block  pycod-->
<pre><code># Create a manufactured solution with sympy
import sympy as sym
t = sym.symbols('t')
u_e = sym.sin(t)*sym.exp(-2*t)
a = t**2
b = sym.diff(u_e, t) + a*u_exact

# Turn sympy expressions into Python function
u_exact = sym.lambdify([t], u_e, modules='numpy')
a = sym.lambdify([t], a, modules='numpy')
b = sym.lambdify([t], b, modules='numpy')
</code></pre>
<!-- end verbatim block -->
The complete code is found in the function <code>test_convergence_rates</code>
in the file <a href="http://tinyurl.com/ofkw6kc/genz/decay_vc.py" target="_self"><tt>decay_vc.py</tt></a>.

<p>
Running this code gives the output

<p>
<!-- begin verbatim block  sys-->
<pre><code>theta=0, r: [1.06, 1.03, 1.01, 1.01, 1.0, 1.0]
theta=1, r: [0.94, 0.97, 0.99, 0.99, 1.0, 1.0]
theta=0.5, r: [2.0, 2.0, 2.0, 2.0, 2.0, 2.0]
</code></pre>
<!-- end verbatim block -->
We clearly see how the convergence rates approach the expected values.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Why convergence rates are important.</b>
<p>
The strong practical application of computing convergence rates is for
verification: wrong convergence rates point to errors in the code, and
correct convergence rates bring strong support for a correct implementation.
Experience shows that bugs in the code easily destroy the
expected convergence rate.
</div>


<h2 id="___sec85">Extension to systems of ODEs </h2>

<p>
Many ODE models involve more than one unknown function and more
than one equation. Here is an example of two unknown functions \( u(t) \)
and \( v(t) \):

$$
\begin{align}
u^{\prime} &= a u + bv,
\tag{101}\\ 
v^{\prime} &= cu +  dv,
\tag{102}
\end{align}
$$

for constants \( a,b,c,d \).
Applying the Forward Euler method to each equation results in a simple
updating formula:

$$
\begin{align}
u^{n+1} &= u^n + \Delta t (a u^n + b v^n),
\tag{103}\\ 
v^{n+1} &= u^n + \Delta t (cu^n + dv^n)
\tp
\tag{104}
\end{align}
$$

On the other hand, the Crank-Nicolson or Backward Euler schemes result in a
\( 2\times 2 \) linear system for the new unknowns. The latter scheme becomes

$$
\begin{align}
u^{n+1} &= u^n + \Delta t (a u^{n+1} + b v^{n+1}),
\tag{105}\\ 
v^{n+1} &= v^n + \Delta t (c u^{n+1} + d v^{n+1})\tp
\tag{106}
\end{align}
$$

Collecting \( u^{n+1} \) as well as \( v^{n+1} \) on the left-hand side results
in
$$
\begin{align}
(1 - \Delta t a)u^{n+1} + bv^{n+1} &= u^n ,
\tag{107}\\ 
c u^{n+1} + (1 - \Delta t d) v^{n+1} &= v^n ,
\tag{108}
\end{align}
$$

which is a system of two coupled, linear, algebraic equations in two
unknowns. These equations can be solved by hand (using standard
techniques for two algebraic equations with two unknowns \( x \) and \( y \)),
resulting in explicit formulas for \( u^{n+1} \) and \( v^{n+1} \) that can be
directly implemented. For systems of ODEs with many equations and unknowns, one
will express the coupled equations at each time level in matrix form
and call software for numerical solution of linear systems of equations.

<h1 id="___sec86">General first-order ODEs </h1>

<p>
We now turn the attention to general, nonlinear ODEs and systems of
such ODEs.  Our focus is on numerical methods that can be readily
reused for time-discretization of PDEs, and diffusion PDEs in particular.
The methods are just briefly listed, and we refer to the rich literature
for more detailed descriptions and analysis - the books
<a href="._decay-book-solarized011.html#Petzold_Ascher_1998">[6]</a> <a href="._decay-book-solarized011.html#Griffiths_et_al_2010">[7]</a> <a href="._decay-book-solarized011.html#Hairer_Wanner_Norsett_bookI">[8]</a> <a href="._decay-book-solarized011.html#Hairer_Wanner_bookII">[9]</a> are all excellent resources on numerical methods for ODEs.
We also demonstrate the Odespy Python interface to a range
of different software for general first-order ODE systems.

<h2 id="___sec87">Generic form of first-order ODEs </h2>

<p>
ODEs are commonly written in the generic form

$$
\begin{equation}
u^{\prime} = f(u,t),\quad u(0)=I,
\tag{109}
\end{equation}
$$

where \( f(u,t) \)  is some prescribed function.
As an example, our most
general exponential decay model <a href="#mjx-eqn-87">(87)</a> has
\( f(u,t)=-a(t)u(t) + b(t) \).

<p>
The unknown \( u \) in <a href="#mjx-eqn-109">(109)</a> may either be
a scalar function of time \( t \), or a vector valued function of \( t \) in
case of a <em>system of ODEs</em> with \( m \) unknown components:
$$ u(t) = (u^{(0)}(t),u^{(1)}(t),\ldots,u^{(m-1)}(t)) \tp  $$

In that case, the right-hand side is a vector-valued function with \( m \)
components,
$$
\begin{align*}
f(u, t) = ( & f^{(0)}(u^{(0)}(t),\ldots,u^{(m-1)}(t)),\\ 
            & f^{(1)}(u^{(0)}(t),\ldots,u^{(m-1)}(t)),\\ 
            & \vdots\\ 
            & f^{(m-1)}(u^{(0)}(t),\ldots,u^{(m-1)}(t)))
\tp
\end{align*}
$$

<p>
Actually, any system of ODEs can
be written in the form <a href="#mjx-eqn-109">(109)</a>, but higher-order
ODEs then need auxiliary unknown functions to enable conversion to
a first-order system.

<p>
Next we list some well-known methods for \( u^{\prime}=f(u,t) \), valid both for
a single ODE (scalar \( u \)) and systems of ODEs (vector \( u \)).

<h2 id="___sec88">The \( \theta \)-rule </h2>

<p>
The \( \theta \)-rule scheme applied to \( u^{\prime}=f(u,t) \) becomes

$$
\begin{equation}
\frac{u^{n+1}-u^n}{\Delta t} = \theta f(u^{n+1},t_{n+1}) +
(1-\theta)f(u^n, t_n)\tp
\tag{110}
\end{equation}
$$

Bringing the unknown \( u^{n+1} \) to the left-hand side and the known terms
on the right-hand side gives

$$
\begin{equation}
u^{n+1} - \Delta t \theta f(u^{n+1},t_{n+1}) =
u^n + \Delta t(1-\theta)f(u^n, t_n)\tp
\tag{111}
\end{equation}
$$

For a general \( f \) (not linear in \( u \)), this equation is <em>nonlinear</em> in
the unknown \( u^{n+1} \) unless \( \theta = 0 \). For a scalar ODE (\( m=1 \)),
we have to solve a single nonlinear algebraic equation for \( u^{n+1} \),
while for a system of ODEs, we get a system of coupled, nonlinear
algebraic equations. Newton's method is a popular solution approach
in both cases. Note that with the Forward Euler scheme (\( \theta =0 \))
we do not have to deal with nonlinear equations, because in that
case we have an explicit updating formula for \( u^{n+1} \). This is known
as an <em>explicit</em> scheme. With \( \theta\neq 1 \) we have to solve
(systems of) algebraic equations, and the scheme is said to be <em>implicit</em>.

<h2 id="___sec89">An implicit 2-step backward scheme </h2>

<p>
The implicit backward method with 2 steps applies a
three-level backward difference as approximation to \( u^{\prime}(t) \),
$$ u^{\prime}(t_{n+1}) \approx \frac{3u^{n+1} - 4u^{n} + u^{n-1}}{2\Delta t},$$

which is an approximation of order \( \Delta t^2 \) to the first derivative.
The resulting scheme for \( u^{\prime}=f(u,t) \) reads
$$
\begin{equation}
u^{n+1} = \frac{4}{3}u^n - \frac{1}{3}u^{n-1} +
\frac{2}{3}\Delta t f(u^{n+1}, t_{n+1})
\tp
\tag{112}
\end{equation}
$$

Higher-order versions of the scheme <a href="#mjx-eqn-112">(112)</a> can
be constructed by including more time levels. These schemes are known
as the Backward Differentiation Formulas (BDF), and the particular
version <a href="#mjx-eqn-112">(112)</a> is often referred to as BDF2.

<p>
Note that the scheme <a href="#mjx-eqn-112">(112)</a> is implicit and requires
solution of nonlinear equations when \( f \) is nonlinear in \( u \).  The
standard 1st-order Backward Euler method or the Crank-Nicolson scheme
can be used for the first step.

<h2 id="___sec90">Leapfrog schemes </h2>

<h3 id="___sec91">The ordinary Leapfrog scheme </h3>

<p>
The derivative of \( u \) at some point \( t_n \) can be approximated by
a central difference over two time steps,

$$
\begin{equation}
u^{\prime}(t_n)\approx \frac{u^{n+1}-u^{n-1}}{2\Delta t} = [D_{2t}u]^n
\tag{113}
\end{equation}
$$

which is an approximation of second order in \( \Delta t \). The scheme
can then be written as

$$ [D_{2t}u=f(u,t)]^n, $$

in operator notation. Solving for \( u^{n+1} \) gives

$$
\begin{equation}
u^{n+1} = u^{n-1} + 2\Delta t f(u^n, t_n)
\tp
\tag{114}
\end{equation}
$$

Observe that <a href="#mjx-eqn-114">(114)</a> is an explicit scheme, and that
a nonlinear \( f \) (in \( u \)) is trivial to handle since it only involves
the known \( u^n \) value.
Some other scheme must be used as starter to compute \( u^1 \), preferably
the Forward Euler scheme since it is also explicit.

<h3 id="___sec92">The filtered Leapfrog scheme </h3>

<p>
Unfortunately, the Leapfrog scheme <a href="#mjx-eqn-114">(114)</a>
will develop growing oscillations with time (see <a href="#decay:fd2:exer:leapfrog1">Project 4.6: Implement and investigate the Leapfrog scheme</a>). A remedy for such undesired oscillations
is to introduce a <em>filtering technique</em>. First, a standard Leapfrog
step is taken, according to <a href="#mjx-eqn-114">(114)</a>, and then
the previous \( u^n \) value is adjusted according to
$$
\begin{equation}
u^n\ \leftarrow\ u^n + \gamma (u^{n-1} - 2u^n + u^{n+1})
\tag{115}
\tp
\end{equation}
$$

The \( \gamma \)-terms will effectively damp oscillations in the solution,
especially those with short wavelength (like point-to-point oscillations).
A common choice of \( \gamma \) is 0.6 (a value used in the
famous NCAR Climate Model).

<p>
<!-- Need to elaborate more on this: -->
<!-- The difference in th \( \gamma \) term in <a href="#mjx-eqn-115">(115)</a> -->
<!-- can be recognized as a finite difference approximation to -->
<!-- \( \Delta t^2 u^{\prime\prime}(t_n) \). -->

<h2 id="___sec93">The 2nd-order Runge-Kutta method </h2>

<p>
The two-step scheme

$$
\begin{align}
u^* &= u^n + \Delta t f(u^n, t_n),
\tag{116}\\ 
u^{n+1} &= u^n + \Delta t \half \left( f(u^n, t_n) + f(u^*, t_{n+1})
\right),
\tag{117}
\end{align}
$$

essentially applies a Crank-Nicolson method <a href="#mjx-eqn-117">(117)</a>
to the ODE, but replaces
the term \( f(u^{n+1}, t_{n+1}) \) by a prediction
\( f(u^{*}, t_{n+1}) \) based on a Forward Euler step <a href="#mjx-eqn-116">(116)</a>.
The scheme <a href="#mjx-eqn-116">(116)</a>-<a href="#mjx-eqn-117">(117)</a> is
known as Huen's method, but is also a 2nd-order Runge-Kutta method.
The scheme is explicit, and the error is expected to behave as \( \Delta t^2 \).

<h2 id="___sec94">A 2nd-order Taylor-series method </h2>

<p>
One way to compute \( u^{n+1} \) given \( u^n \) is to use a Taylor polynomial.
We may write up a polynomial of 2nd degree:
$$
u^{n+1} = u^n + u^{\prime}(t_n)\Delta t + {\half}u^{\prime\prime}(t_n)\Delta t^2
\tp
$$

From the equation \( u^{\prime}=f(u,t) \) it follows that the derivatives of \( u \)
can be expressed in terms of \( f \) and its derivatives:
$$
\begin{align*}
u^{\prime}(t_n) &=f(u^n,t_n),\\ 
u^{\prime\prime}(t_n) &=
\frac{\partial f}{\partial u}(u^n,t_n) u^{\prime}(t_n) + \frac{\partial f}{\partial t}\\ 
&=  f(u^n,t_n)\frac{\partial f}{\partial u}(u^n,t_n)  +
\frac{\partial f}{\partial t},
\end{align*}
$$

resulting in the scheme
$$
\begin{equation}
u^{n+1} = u^n + f(u^n,t_n)\Delta t + \half\left(
f(u^n,t_n)\frac{\partial f}{\partial u}(u^n,t_n)  +
\frac{\partial f}{\partial t}\right)\Delta t^2
\tp
\tag{118}
\end{equation}
$$

More terms in the series could be included in the Taylor polynomial to
obtain methods of higher order than 2.

<h2 id="___sec95">The 2nd- and 3rd-order Adams-Bashforth schemes </h2>

<p>
The following method is known as the 2nd-order Adams-Bashforth scheme:

$$
\begin{equation}
u^{n+1} = u^n + \half\Delta t\left( 3f(u^n, t_n) - f(u^{n-1}, t_{n-1})
\right)
\tp
\tag{119}
\end{equation}
$$

The scheme is explicit and requires another one-step scheme to compute
\( u^1 \) (the Forward Euler scheme or Heun's method, for instance).
As the name implies, the error behaves like \( \Delta t^2 \).

<p>
Another explicit scheme, involving four time levels, is the
3rd-order Adams-Bashforth scheme

$$
\begin{equation}
u^{n+1} = u^n + \frac{1}{12}\left( 23f(u^n, t_n) - 16 f(u^{n-1},t_{n-1})
+ 5f(u^{n-2}, t_{n-2})\right)
\tp
\tag{120}
\end{equation}
$$

The numerical error is of order \( \Delta t^3 \), and the scheme needs
some method for computing \( u^1 \) and \( u^2 \).

<p>
More general, higher-order Adams-Bashforth schemes (also called
<em>explicit Adams methods</em>) compute \( u^{n+1} \) as a linear combination
of \( f \) at \( k+1 \) previous time steps:

$$ u^{n+1} = u^n + \sum_{j=0}^k \beta_jf(u^{n-j},t_{n-j}),$$

where \( \beta_j \) are known coefficients.

<h2 id="decay:fd2:RK4">The 4th-order Runge-Kutta method</h2>

<p>
The perhaps most widely used method to solve ODEs is the 4th-order
Runge-Kutta method, often called RK4.
Its derivation is a nice illustration of common
numerical approximation strategies, so let us go through the
steps in detail to learn about algorithmic development.

<p>
The starting point is to integrate the ODE
\( u^{\prime}=f(u,t) \) from \( t_n \) to \( t_{n+1} \):

$$ u(t_{n+1}) - u(t_n) = \int\limits_{t_{n}}^{t_{n+1}} f(u(t),t)dt\tp $$

We want to compute \( u(t_{n+1}) \) and regard \( u(t_n) \) as known.
The task is to find good approximations for the integral, since the
integrand involves the unknown \( u \) between \( t_n \) and \( t_{n+1} \).

<p>
The integral can be approximated by the famous
<a href="http://en.wikipedia.org/wiki/Simpson's_rule" target="_self">Simpson's rule</a>:

$$ \int\limits_{t_{n}}^{t_{n+1}} f(u(t),t)dt
\approx \frac{\Delta t}{6}\left( f^n + 4f^{n+\half} + f^{n+1}\right)\tp$$

The problem now is that we do not know \( f^{n+\half}=f(u^{n+\half},t_{n+\half}) \)
and \( f^{n+1}=(u^{n+1},t_{n+1}) \) as we know only \( u^n \) and hence \( f^n \).
The idea is to use various approximations for \( f^{n+\half} \) and
\( f^{n+1} \) based on well-known schemes for the ODE in the
intervals \( [t_n,t_{n+\half}] \) and \( [t_n, t_{n+1}] \).
We split the integral approximation into four terms:

$$ \int\limits_{t_{n}}^{t_{n+1}} f(u(t),t)dt
\approx \frac{\Delta t}{6}\left( f^n + 2\hat{f}^{n+\half}
+ 2\tilde{f}^{n+\half} + \bar{f}^{n+1}\right),$$

where \( \hat{f}^{n+\half} \), \( \tilde{f}^{n+\half} \), and \( \bar{f}^{n+1} \)
are approximations to \( f^{n+\half} \) and
\( f^{n+1} \), respectively, that can be based on already computed quantities.
For \( \hat{f}^{n+\half} \) we can apply
an approximation to \( u^{n+\half} \) using the Forward Euler
method with step \( \half\Delta t \):

$$
\begin{equation}
\hat{f}^{n+\half} = f(u^n + \half{\Delta t} f^n, t_{n+\half})
\tag{121}
\end{equation}
$$

Since this gives us a prediction of \( f^{n+\half} \), we can for
\( \tilde{f}^{n+\half} \) try a Backward Euler method to approximate \( u^{n+\half} \):

$$
\begin{equation}
\tilde{f}^{n+\half} = f(u^n + \half\Delta t\hat{f}^{n+\half}, t_{n+\half})\tp
\tag{122}
\end{equation}
$$

With \( \tilde{f}^{n+\half} \) as a hopefully good approximation to
\( f^{n+\half} \), we can for the final term \( \bar{f}^{n+1} \) use
a Crank-Nicolson method on \( [t_n, t_{n+1}] \) to approximate \( u^{n+1} \):

$$
\begin{equation}
\bar{f}^{n+1} = f(u^n + \Delta t \hat{f}^{n+\half}, t_{n+1})\tp
\tag{123}
\end{equation}
$$

We have now used the Forward and Backward Euler methods as well as the
Crank-Nicolson method in the context of Simpson's rule. The hope is
that the combination of these methods yields an overall time-stepping
scheme from \( t_n \) to \( t_n{+1} \) that is much more accurate than the
\( \Oof{\Delta t} \) and \( \Oof{\Delta t^2} \) of the individual steps.
This is indeed true: the overall accuracy is \( \Oof{\Delta t^4} \)!

<p>
To summarize, the 4th-order Runge-Kutta method becomes

$$
\begin{equation}
u^{n+1} = u^n +
\frac{\Delta t}{6}\left( f^n + 2\hat{f}^{n+\half}
+ 2\tilde{f}^{n+\half} + \bar{f}^{n+1}\right),
\tag{124}
\end{equation}
$$

where the quantities on the right-hand side are computed from
<a href="#mjx-eqn-121">(121)</a>-<a href="#mjx-eqn-123">(123)</a>. Note that
the scheme is fully explicit so there is never any need to solve linear or
nonlinear algebraic
equations. However, the stability is conditional and depends on \( f \).
There is a whole range of <em>implicit</em> Runge-Kutta methods that
are unconditionally stable, but require solution of algebraic
equations involving \( f \) at each time step.

<p>
The simplest way to explore more sophisticated methods for ODEs is to
apply one of the many high-quality software packages that exist, as the
next section explains.

<h2 id="___sec97">The Odespy software </h2>

<p>
A wide range of methods and software exist for solving <a href="#mjx-eqn-109">(109)</a>.
Many of the methods are accessible through a unified Python interface offered
by the <a href="https://github.com/hplgit/odespy" target="_self">Odespy</a> <a href="._decay-book-solarized011.html#odespy">[10]</a> package.
Odespy features simple Python implementations of the most fundamental
schemes as well as Python interfaces to several famous packages for
solving ODEs: <a href="https://computation.llnl.gov/casc/odepack/odepack_home.html" target="_self">ODEPACK</a>, <a href="https://computation.llnl.gov/casc/odepack/odepack_home.html" target="_self">Vode</a>,
<a href="http://www.netlib.org/ode/rkc.f" target="_self">rkc.f</a>, <a href="http://www.netlib.org/ode/rkf45.f" target="_self">rkf45.f</a>, as well
as the ODE solvers in <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.html" target="_self">SciPy</a>, <a href="http://docs.sympy.org/dev/modules/mpmath/calculus/odes.html" target="_self">SymPy</a>, and <a href="http://olivierverdier.github.com/odelab/" target="_self">odelab</a>.

<p>
The code below illustrates the usage of Odespy the solving \( u^{\prime}=-au \),
\( u(0)=I \), \( t\in (0,T] \),
by the famous 4th-order Runge-Kutta method, using \( \Delta t=1 \)
and \( N_t=6 \) steps:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>def f(u, t):
    return -a*u

import odespy
import numpy as np

I = 1; a = 0.5; Nt = 6; dt = 1
solver = odespy.RK4(f)
solver.set_initial_condition(I)
t_mesh = np.linspace(0, Nt*dt, Nt+1)
u, t = solver.solve(t_mesh)
</code></pre>
<!-- end verbatim block -->

<p>
The previously listed methods for ODEs are all accessible in
Odespy:

<ul>
 <li> the \( \theta \)-rule: <code>ThetaRule</code></li>
 <li> special cases of the \( \theta \)-rule: <code>ForwardEuler</code>, <code>BackwardEuler</code>,
   <code>CrankNicolson</code></li>
 <li> the 2nd- and 4th-order Runge-Kutta methods: <code>RK2</code> and <code>RK4</code></li>
 <li> The BDF methods and the Adam-Bashforth methods:
   <code>Vode</code>, <code>Lsode</code>, <code>Lsoda</code>, <code>lsoda_scipy</code></li>
 <li> The Leapfrog schemes: <code>Leapfrog</code> and <code>LeapfrogFiltered</code></li>
</ul>

<h2 id="___sec98">Example: Runge-Kutta methods  </h2>

<p>
Since all solvers have the same interface in Odespy, except for a
potentially different set of
parameters in the solvers' constructors, one can easily make a list of
solver objects and run a loop for comparing a lot of solvers. The
code below, found in complete form in <a href="http://tinyurl.com/ofkw6kc/genz/decay_odespy.py" target="_self"><tt>decay_odespy.py</tt></a>,
compares the famous Runge-Kutta methods of orders 2, 3, and 4
with the exact solution of the decay equation
\( u^{\prime}=-au \).
Since we have quite long time steps, we have included the only
relevant \( \theta \)-rule for large time steps, the Backward Euler scheme
(\( \theta=1 \)), as well.
Figure <a href="#decay:odespy:fig1">21</a> shows the results.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import numpy as np
import matplotlib.pyplot as plt
import sys

def f(u, t):
    return -a*u

I = 1; a = 2; T = 6
dt = float(sys.argv[1]) if len(sys.argv) &gt;= 2 else 0.75
Nt = int(round(T/dt))
t = np.linspace(0, Nt*dt, Nt+1)

solvers = [odespy.RK2(f),
           odespy.RK3(f),
           odespy.RK4(f),]

# BackwardEuler must use Newton solver to converge
# (Picard is default and leads to divergence)
solvers.append(
    odespy.BackwardEuler(f, nonlinear_solver='Newton'))
# Or tell BackwardEuler that it is a linear problem
solvers[-1] = odespy.BackwardEuler(f, f_is_linear=True,
                                   jac=lambda u, t: -a)]
legends = []
for solver in solvers:
    solver.set_initial_condition(I)
    u, t = solver.solve(t)

    plt.plot(t, u)
    plt.hold('on')
    legends.append(solver.__class__.__name__)

# Compare with exact solution plotted on a very fine mesh
t_fine = np.linspace(0, T, 10001)
u_e = I*np.exp(-a*t_fine)
plt.plot(t_fine, u_e, '-') # avoid markers by specifying line type
legends.append('exact')

plt.legend(legends)
plt.title('Time step: %g' % dt)
plt.show()
</code></pre>
<!-- end verbatim block -->
With the <code>odespy.BackwardEuler</code> method we must either tell that
the problem is linear and provide the Jacobian of \( f(u,t) \), i.e.,
\( \partial f/\partial u \), as the <code>jac</code> argument, or we have to assume
that \( f \) is nonlinear, but then specify Newton's method as solver
for the nonlinear equations (since the equations are linear, Newton's
method will converge in one iteration). By default,
<code>odespy.BackwardEuler</code> assumes a nonlinear problem to be solved by
Picard iteration, but that leads to divergence in the present problem.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Visualization tip.</b>
<p>
We use Matplotlib for
plotting here, but one could alternatively import <code>scitools.std</code> as <code>plt</code> instead. Plain use of Matplotlib as done here results in
curves with different colors, which may be hard to distinguish on
black-and-white paper. Using <code>scitools.std</code>, curves are
automatically given colors <em>and</em> markers, thus making curves easy
to distinguish on screen with colors and on black-and-white paper.
The automatic adding of markers is normally a bad idea for a
very fine mesh since all the markers get cluttered, but <code>scitools.std</code> limits
the number of markers in such cases.
For the exact solution we use a very fine mesh, but in the code
above we specify the line type as a solid line (<code>-</code>), which means
no markers and just a color to be automatically determined by
the backend used for plotting (Matplotlib by default, but
<code>scitools.std</code> gives the opportunity to use other backends
to produce the plot, e.g., Gnuplot or Grace).

<p>
Also note the that the legends
are based on the class names of the solvers, and in Python the name of
the class type (as a string) of an object <code>obj</code> is obtained by
<code>obj.__class__.__name__</code>.
</div>


<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 21:  Behavior of different schemes for the decay equation. <div id="decay:odespy:fig1"></div> </p></center>
<p><img src="fig-genz/decay_odespy1_png.png" align="bottom" width=600></p>
</center>

<p>
The runs in Figure <a href="#decay:odespy:fig1">21</a>
and other experiments reveal that the 2nd-order Runge-Kutta
method (<code>RK2</code>) is unstable for \( \Delta t>1 \) and decays slower than the
Backward Euler scheme for large and moderate \( \Delta t \) (see <a href="#decay:exer:RK2:Taylor:analysis">Exercise 4.5: Analyze explicit 2nd-order methods</a> for an analysis).  However, for
fine \( \Delta t = 0.25 \) the 2nd-order Runge-Kutta method approaches
the exact solution faster than the Backward Euler scheme.  That is,
the latter scheme does a better job for larger \( \Delta t \), while the
higher order scheme is superior for smaller \( \Delta t \). This is a
typical trend also for most schemes for ordinary and partial
differential equations.

<p>
The 3rd-order Runge-Kutta method (<code>RK3</code>) also has artifacts in the form
of oscillatory behavior for the larger \( \Delta t \) values, much
like that of the Crank-Nicolson scheme. For finer \( \Delta t \),
the 3rd-order Runge-Kutta method converges quickly to the exact
solution.

<p>
The 4th-order Runge-Kutta method (<code>RK4</code>) is slightly inferior
to the Backward Euler scheme on the coarsest mesh, but is then
clearly superior to all the other schemes. It is definitely the
method of choice for all the tested schemes.

<h3 id="___sec99">Remark about using the \( \theta \)-rule in Odespy </h3>

<p>
The Odespy package assumes that the ODE is written as \( u^{\prime}=f(u,t) \) with
an \( f \) that is possibly nonlinear in \( u \). The \( \theta \)-rule for
\( u^{\prime}=f(u,t) \) leads to
$$ u^{n+1} = u^{n} + \Delta t\left(\theta f(u^{n+1}, t_{n+1})
+ (1-\theta) f(u^{n}, t_{n})\right),$$

which is a <em>nonlinear equation</em> in \( u^{n+1} \). Odespy's implementation
of the \( \theta \)-rule (<code>ThetaRule</code>) and the specialized Backward Euler
(<code>BackwardEuler</code>) and Crank-Nicolson (<code>CrankNicolson</code>) schemes
must invoke iterative methods for
solving the nonlinear equation in \( u^{n+1} \). This is done even when
\( f \) is linear in \( u \), as in the model problem \( u^{\prime}=-au \), where we can
easily solve for \( u^{n+1} \) by hand.  Therefore, we need to specify
use of Newton's method to solve the equations.
(Odespy allows other methods than Newton's to be used, for instance
Picard iteration, but that method is not suitable. The reason is that it
applies the Forward Euler scheme to generate a start value for
the iterations. Forward Euler may give very wrong solutions
for large \( \Delta t \) values. Newton's method, on the other hand,
is insensitive to the start value in <em>linear problems</em>.)

<h2 id="decay:fd2:adaptiveRK">Example: Adaptive Runge-Kutta methods</h2>

<p>
Odespy also offers solution methods that can adapt the size of \( \Delta t \)
with time to match a desired accuracy in the solution. Intuitively,
small time steps will be chosen in areas where the solution is changing
rapidly, while larger time steps can be used where the solution
is slowly varying. Some kind of <em>error estimator</em> is used to
adjust the next time step at each time level.

<p>
A very popular adaptive method for solving ODEs is the Dormand-Prince
Runge-Kutta method of order 4 and 5. The 5th-order method is used as a
reference solution and the difference between the 4th- and 5th-order
methods is used as an indicator of the error in the numerical
solution.  The Dormand-Prince method is the default choice in MATLAB's
widely used <code>ode45</code> routine.

<p>
We can easily set up Odespy to use the Dormand-Prince method and
see how it selects the optimal time steps. To this end, we request
only one time step from \( t=0 \) to \( t=T \) and ask the method to
compute the necessary non-uniform time mesh to meet a certain
error tolerance. The code goes like

<p>
<!-- begin verbatim block  pypro-->
<pre><code>import odespy
import numpy as np
import decay_mod
import sys
#import matplotlib.pyplot as plt
import scitools.std as plt

def f(u, t):
    return -a*u

def u_exact(t):
    return I*np.exp(-a*t)

I = 1; a = 2; T = 5
tol = float(sys.argv[1])
solver = odespy.DormandPrince(f, atol=tol, rtol=0.1*tol)

Nt = 1  # just one step - let the scheme find its intermediate points
t_mesh = np.linspace(0, T, Nt+1)
t_fine = np.linspace(0, T, 10001)

solver.set_initial_condition(I)
u, t = solver.solve(t_mesh)

# u and t will only consist of [I, u^Nt] and [0,T]
# solver.u_all and solver.t_all contains all computed points
plt.plot(solver.t_all, solver.u_all, 'ko')
plt.hold('on')
plt.plot(t_fine, u_exact(t_fine), 'b-')
plt.legend(['tol=%.0E' % tol, 'exact'])
plt.savefig('tmp_odespy_adaptive.png')
plt.show()
</code></pre>
<!-- end verbatim block -->

<p>
Running four cases with tolerances \( 10^{-1} \), \( 10^{-3} \), \( 10^{-5} \),
and \( 10^{-7} \), gives the results in Figure <a href="#decay:odespy:fig2">22</a>.
Intuitively, one would expect denser points in the beginning of
the decay and larger time steps when the solution flattens out.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 22:  Choice of adaptive time mesh by the Dormand-Prince method for different tolerances. <div id="decay:odespy:fig2"></div> </p></center>
<p><img src="fig-genz/decay_DormandPrince_adaptivity.png" align="bottom" width=800></p>
</center>

<h1 id="___sec101">Exercises </h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:fd2:exer:precision">Exercise 4.1: Experiment with precision in tests and the size of \( u \)</h2>

<p>
It is claimed in the section <a href="#decay:MMS">Verification via manufactured solutions</a> that most numerical methods will
reproduce a linear exact solution to machine precision. Test this
assertion using the test function <code>test_linear_solution</code> in the
<a href="http://tinyurl.com/ofkw6kc/genz/decay_vc.py" target="_self"><tt>decay_vc.py</tt></a> program.
Vary the parameter <code>c</code> from very small, via <code>c=1</code> to many larger values,
and print out the maximum difference between the numerical solution
and the exact solution. What is the relevant value of the tolerance
in the float comparison in each case?

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>test_precision</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:fd2:exer:bw2">Exercise 4.2: Implement the 2-step backward scheme</h2>

<p>
Implement the 2-step backward method <a href="#mjx-eqn-112">(112)</a> for the
model \( u^{\prime}(t) = -a(t)u(t) + b(t) \), \( u(0)=I \).  Allow the first step to
be computed by either the Backward Euler scheme or the Crank-Nicolson
scheme. Verify the implementation by choosing \( a(t) \) and \( b(t) \) such
that the exact solution is linear in \( t \) (see the section <a href="#decay:MMS">Verification via manufactured solutions</a>). Show mathematically that a linear solution is indeed a
solution of the discrete equations.

<p>
Compute convergence rates (see the section <a href="#decay:convergence:rate">Computing convergence rates</a>) in
a test case using \( a=\hbox{const} \) and \( b=0 \), where we easily have an exact
solution, and determine if the choice of a first-order scheme
(Backward Euler) for the first step has any impact on the overall
accuracy of this scheme. The expected error goes like \( \Oof{\Delta t^2} \).
Filename: <code>decay_backward2step</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:fd2:exer:AB2">Exercise 4.3: Implement the 2nd-order Adams-Bashforth scheme</h2>

<p>
Implement the 2nd-order Adams-Bashforth method <a href="#mjx-eqn-119">(119)</a>
for the decay problem \( u^{\prime}=-a(t)u + b(t) \), \( u(0)=I \), \( t\in (0, T] \).
Use the Forward Euler method for the first step such that the overall
scheme is explicit. Verify the implementation using an exact
solution that is linear in time.
Analyze the scheme by searching for solutions \( u^n=A^n \) when \( a=\hbox{const} \)
and \( b=0 \). Compare this second-order scheme to the Crank-Nicolson scheme.
Filename: <code>decay_AdamsBashforth2</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:fd2:exer:AB3">Exercise 4.4: Implement the 3rd-order Adams-Bashforth scheme</h2>

<p>
Implement the 3rd-order Adams-Bashforth method <a href="#mjx-eqn-120">(120)</a>
for the decay problem \( u^{\prime}=-a(t)u + b(t) \), \( u(0)=I \), \( t\in (0, T] \).
Since the scheme is explicit, allow it to be started by two steps with
the Forward Euler method.  Investigate experimentally the case where
\( b=0 \) and \( a \) is a constant: Can we have oscillatory solutions for
large \( \Delta t \)?
Filename: <code>decay_AdamsBashforth3</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:exer:RK2:Taylor:analysis">Exercise 4.5: Analyze explicit 2nd-order methods</h2>

<p>
Show that the schemes <a href="#mjx-eqn-117">(117)</a> and
<a href="#mjx-eqn-118">(118)</a> are identical in the case \( f(u,t)=-a \), where
\( a>0 \) is a constant. Assume that the numerical solution reads
\( u^n=A^n \) for some unknown amplification factor \( A \) to be determined.
Find \( A \) and derive stability criteria. Can the scheme produce
oscillatory solutions of \( u^{\prime}=-au \)? Plot the numerical and exact
amplification factor.
Filename: <code>decay_RK2_Taylor2</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:fd2:exer:leapfrog1">Project 4.6: Implement and investigate the Leapfrog scheme</h2>

<p>
A Leapfrog scheme
for the ODE \( u^{\prime}(t) = -a(t)u(t) + b(t) \) is defined by

$$
\begin{equation}
\lbrack D_{2t}u = -au+b\rbrack^n\tp
\tag{125}
\end{equation}
$$

A separate method is needed to compute \( u^1 \). The Forward Euler
scheme is a possible candidate.

<p>
<b>a)</b>
Implement the Leapfrog scheme for the model equation.
Plot the solution in the case \( a=1 \), \( b=0 \), \( I=1 \),
\( \Delta t = 0.01 \), \( t\in [0,4] \). Compare with the exact
solution \( \uex(t)=e^{-t} \).

<p>
<b>b)</b>
Show mathematically that a linear solution in \( t \) fulfills the
Forward Euler scheme for the first step and the Leapfrog scheme
for the subsequent steps. Use this linear solution to verify
the implementation, and automate the verification through a test
function.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
It can be wise to automate the calculations such that it is easy to
redo the calculations for other types of solutions. Here is
a possible <code>sympy</code> function that takes a symbolic expression <code>u</code>
(implemented as a Python function of <code>t</code>), fits the <code>b</code> term, and
checks if <code>u</code> fulfills the discrete equations:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import sympy as sym

def analyze(u):
    t, dt, a = sym.symbols('t dt a')

    print 'Analyzing u_e(t)=%s' % u(t)
    print 'u(0)=%s' % u(t).subs(t, 0)

    # Fit source term to the given u(t)
    b = sym.diff(u(t), t) + a*u(t)
    b = sym.simplify(b)
    print 'Source term b:', b

    # Residual in discrete equations; Forward Euler step
    R_step1 = (u(t+dt) - u(t))/dt + a*u(t) - b
    R_step1 = sym.simplify(R_step1)
    print 'Residual Forward Euler step:', R_step1

    # Residual in discrete equations; Leapfrog steps
    R = (u(t+dt) - u(t-dt))/(2*dt) + a*u(t) - b
    R = sym.simplify(R)
    print 'Residual Leapfrog steps:', R

def u_e(t):
    return c*t + I

analyze(u_e)
# or short form: analyze(lambda t: c*t + I)
</code></pre>
<!-- end verbatim block -->

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>c)</b>
Show that a second-order polynomial in \( t \) cannot be a solution of the discrete
equations. However, if a Crank-Nicolson scheme is used for the first
step, a second-order polynomial solves the equations exactly.

<p>
<b>d)</b>
Create a manufactured solution \( u(t)=\sin(t) \) for the ODE
\( u^{\prime}=-au+b \).
Compute the convergence rate of the Leapfrog scheme using this
manufactured solution. The expected convergence rate of the
Leapfrog scheme is \( \Oof{\Delta t^2} \). Does the use of a
1st-order method for the first step impact the convergence rate?

<p>
<!-- A possible test case is -->
<!-- \( u^{\prime}=-au + b \), \( u(0)=0 \), where \( \uex(t)=b/a + (I - b/a)e^{-at} \) if -->
<!-- \( a \) and \( b \) are constants. -->

<p>
<b>e)</b>
Set up a set of experiments to demonstrate that the Leapfrog scheme
<a href="#mjx-eqn-125">(125)</a> is associated with numerical artifacts
(instabilities). Document the main results from this investigation.

<p>
<b>f)</b>
Analyze and explain the
instabilities of the Leapfrog scheme <a href="#mjx-eqn-125">(125)</a>:

<ol>
<li> Choose \( a=\mbox{const} \) and \( b=0 \). Assume that an exact solution
   of the discrete equations has
   the form \( u^n=A^n \), where \( A \) is an amplification factor to
   be determined. Derive an equation for \( A \) by inserting \( u^n=A^n \)
   in the Leapfrog scheme.</li>
<li> Compute \( A \) either by hand and/or with the aid of <code>sympy</code>.
   The polynomial for \( A \) has two roots, \( A_1 \) and \( A_2 \). Let
   \( u^n \) be a linear combination \( u^n=C_1A_1^n + C_2A_2^n \).</li>
<li> Show that one of the roots is the reason for instability.</li>
<li> Compare \( A \) with the exact expression, using a Taylor series approximation.</li>
<li> How can \( C_1 \) and \( C_2 \) be determined?</li>
</ol>

<b>g)</b>
Since the original Leapfrog scheme is unconditionally unstable as time
grows, it demands some stabilization.  This can be done by filtering,
where we first find \( u^{n+1} \) from the original Leapfrog scheme and
then replace \( u^{n} \) by \( u^n + \gamma (u^{n-1} - 2u^n +
u^{n+1}) \), where \( \gamma \) can be taken as 0.6.  Implement the filtered
Leapfrog scheme and check that it can handle tests where the original
Leapfrog scheme is unstable.

<p>
Filename: <code>decay_leapfrog</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:fd2:exer:uni">Problem 4.7: Make a unified implementation of many schemes</h2>

<p>
Consider the linear ODE problem \( u^{\prime}(t)=-a(t)u(t) + b(t) \), \( u(0)=I \).
Explicit schemes for this problem can be written in the general form
$$
\begin{equation}
u^{n+1} = \sum_{j=0}^m c_ju^{n-j},
\tag{126}
\end{equation}
$$

for some choice of \( c_0,\ldots,c_m \).
Find expressions for the \( c_j \) coefficients in case of the
\( \theta \)-rule, the three-level backward scheme,
the Leapfrog scheme, the 2nd-order Runge-Kutta method,
and the 3rd-order Adams-Bashforth scheme.

<p>
Make a class <code>ExpDecay</code> that implements the
general updating formula <a href="#mjx-eqn-126">(126)</a>.
The formula cannot be applied for \( n < m \), and for those \( n \) values, other
schemes must be used. Assume for simplicity that we just
repeat Crank-Nicolson steps until <a href="#mjx-eqn-126">(126)</a> can be used.
Use a subclass
to specify the list \( c_0,\ldots,c_m \) for a particular method, and
implement subclasses for all the mentioned schemes.
Verify the implementation by testing with a linear solution, which should
be exactly reproduced by all methods.
Filename: <code>decay_schemes_unified</code>.

<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._decay-book-solarized006.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._decay-book-solarized008.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    
