
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Generalizations</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Finite Difference Computing with Exponential Decay Models" href="index.html" />
    <link rel="next" title="Models" href="._book007.html" />
    <link rel="prev" title="Analysis" href="._book005.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book007.html" title="Models"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book005.html" title="Analysis"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with Exponential Decay Models</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="generalizations">
<h1>Generalizations<a class="headerlink" href="#generalizations" title="Permalink to this headline">¶</a></h1>
<p>It is time to consider generalizations of the simple decay model
<span class="math">\(u^{\prime}=-au\)</span> and also to look at additional numerical solution methods.
We consider first variable coefficients, <span class="math">\(u^{\prime}=a(t)u + b(t)\)</span>,
and later a completely general scalar ODE <span class="math">\(u^{\prime}=f(u,t)\)</span> and its
generalization to a system of such general ODEs.
Among numerical methods, we treat implicit multi-step methods,
and several families of explicit methods: Leapfrog
schemes, Runge-Kutta methods, and Adams-Bashforth formulas.</p>
<div class="section" id="model-extensions">
<h2>Model extensions<a class="headerlink" href="#model-extensions" title="Permalink to this headline">¶</a></h2>
<p>This section looks at the generalizations to <span class="math">\(u^{\prime}=-a(t)u\)</span>
and <span class="math">\(u^{\prime}=-a(t)u + b(t)\)</span>. We sketch the corresponding
implementations of the <span class="math">\(\theta\)</span>-rule for such variable-coeffients ODEs.
Verification can no longer make use of an exact solution of the
numerical problem so we make use of manufactured solutions,
for deriving an exact solution of the ODE problem, and then we can
compute empirical convergence rates for the method and see if these
coincide with the expected rates from theory.
Finally, we see how our numerical methods can be applied to systems
of ODEs.</p>
<p>The example programs associated with this chapter are found in
the directory <a class="reference external" href="http://tinyurl.com/ofkw6kc/genz">src/genz</a>.</p>
<div class="section" id="generalization-including-a-variable-coefficient">
<h3>Generalization: including a variable coefficient<a class="headerlink" href="#generalization-including-a-variable-coefficient" title="Permalink to this headline">¶</a></h3>
<p>In the ODE for decay, <span class="math">\(u^{\prime}=-au\)</span>, we now consider the case where <span class="math">\(a\)</span>
depends on time:</p>
<div class="math" id="equation-decay:problem:a">
<span id="eq-decay-problem-a"></span><span class="eqno">(1)</span>\[     u^{\prime}(t) = -a(t)u(t),\quad t\in (0,T],\quad u(0)=I {\thinspace .}\]</div>
<p>A Forward Euler scheme consist of evaluating <a href="#equation-decay:problem:a">(1)</a>
at <span class="math">\(t=t_n\)</span> and approximating the derivative with a forward
difference <span class="math">\([D^+_t u]^n\)</span>:</p>
<div class="math">
\[\frac{u^{n+1} - u^n}{\Delta t} = -a(t_n)u^n
{\thinspace .}\]</div>
<p>The Backward Euler scheme becomes</p>
<div class="math">
\[\frac{u^{n} - u^{n-1}}{\Delta t} = -a(t_n)u^n
{\thinspace .}\]</div>
<p>The Crank-Nicolson method builds on sampling the ODE at
<span class="math">\(t_{n+\frac{1}{2}}\)</span>. We can evaluate <span class="math">\(a\)</span> at <span class="math">\(t_{n+\frac{1}{2}}\)</span>
and use an average for <span class="math">\(u\)</span> at
times <span class="math">\(t_n\)</span> and <span class="math">\(t_{n+1}\)</span>:</p>
<div class="math">
\[\frac{u^{n+1} - u^{n}}{\Delta t} = -a(t_{n+\frac{1}{2}})\frac{1}{2}(u^n + u^{n+1})
{\thinspace .}\]</div>
<p>Alternatively, we can use an average for the product <span class="math">\(au\)</span>:</p>
<div class="math">
\[\frac{u^{n+1} - u^{n}}{\Delta t} = -\frac{1}{2}(a(t_n)u^n + a(t_{n+1})u^{n+1})
{\thinspace .}\]</div>
<p>The <span class="math">\(\theta\)</span>-rule unifies the three mentioned schemes. One version is to
have <span class="math">\(a\)</span> evaluated at the weighted time point <span class="math">\((1-\theta)t_n + \theta t_{n+1}\)</span>,</p>
<div class="math">
\[\frac{u^{n+1} - u^{n}}{\Delta t} = -a((1-\theta)t_n + \theta t_{n+1})((1-\theta) u^n + \theta u^{n+1})
{\thinspace .}\]</div>
<p>Another possibility is to apply a weighted average for the product <span class="math">\(au\)</span>,</p>
<div class="math">
\[\frac{u^{n+1} - u^{n}}{\Delta t} = -(1-\theta) a(t_n)u^n - \theta
a(t_{n+1})u^{n+1}
{\thinspace .}\]</div>
<p>With the finite difference operator notation the Forward Euler and Backward
Euler schemes can be summarized as</p>
<div class="math">
\[\lbrack D^+_t u = -au\rbrack^n,\]</div>
<div class="math">
\[\lbrack D^-_t u = -au\rbrack^n
{\thinspace .}\]</div>
<p>The Crank-Nicolson and <span class="math">\(\theta\)</span> schemes depend on whether we evaluate
<span class="math">\(a\)</span> at the sample point for the ODE or if we use an average. The
various versions are written as</p>
<div class="math">
\[\lbrack D_t u = -a\overline{u}^t\rbrack^{n+\frac{1}{2}},\]</div>
<div class="math">
\[\lbrack D_t u = -\overline{au}^t\rbrack^{n+\frac{1}{2}},\]</div>
<div class="math">
\[\lbrack D_t u = -a\overline{u}^{t,\theta}\rbrack^{n+\theta},\]</div>
<div class="math">
\[\lbrack D_t u = -\overline{au}^{t,\theta}\rbrack^{n+\theta}
{\thinspace .}\]</div>
</div>
<div class="section" id="generalization-including-a-source-term">
<span id="decay-source"></span><h3>Generalization: including a source term<a class="headerlink" href="#generalization-including-a-source-term" title="Permalink to this headline">¶</a></h3>
<p>A further extension of the model ODE is to include a source term <span class="math">\(b(t)\)</span>:</p>
<div class="math" id="equation-decay:problem:ab">
<span id="eq-decay-problem-ab"></span><span class="eqno">(2)</span>\[     u^{\prime}(t) = -a(t)u(t) + b(t),\quad t\in (0,T],\quad u(0)=I
     {\thinspace .}\]</div>
<p>The time point where we sample the ODE determines where <span class="math">\(b(t)\)</span> is
evaluated. For the Crank-Nicolson scheme and the <span class="math">\(\theta\)</span>-rule we
have a choice of whether to evaluate <span class="math">\(a(t)\)</span> and <span class="math">\(b(t)\)</span> at the
correct point or use an average. The chosen strategy becomes
particularly clear if we write up the schemes in the operator notation:</p>
<div class="math">
\[\lbrack D^+_t u = -au + b\rbrack^n,\]</div>
<div class="math">
\[\lbrack D^-_t u = -au + b\rbrack^n,\]</div>
<div class="math">
\[\lbrack D_t u   = -a\overline{u}^t + b\rbrack^{n+\frac{1}{2}},\]</div>
<div class="math">
\[\lbrack D_t u   = \overline{-au+b}^t\rbrack^{n+\frac{1}{2}},\]</div>
<div class="math">
\[\lbrack D_t u   = -a\overline{u}^{t,\theta} + b\rbrack^{n+\theta},\]</div>
<div class="math" id="equation-decay:problem:ab:theta:avg:all:op">
<span id="eq-decay-problem-ab-theta-avg-all-op"></span><span class="eqno">(3)</span>\[     \lbrack D_t u   = \overline{-au+b}^{t,\theta}\rbrack^{n+\theta}\]\[     {\thinspace .}\]</div>
</div>
<div class="section" id="implementation-of-the-generalized-model-problem">
<span id="decay-general"></span><h3>Implementation of the generalized model problem<a class="headerlink" href="#implementation-of-the-generalized-model-problem" title="Permalink to this headline">¶</a></h3>
<div class="section" id="deriving-the-rule-formula">
<h4>Deriving the <span class="math">\(\theta\)</span>-rule formula<a class="headerlink" href="#deriving-the-rule-formula" title="Permalink to this headline">¶</a></h4>
<p>Writing out the <span class="math">\(\theta\)</span>-rule in <a href="#equation-decay:problem:ab:theta:avg:all:op">(3)</a>,
using <a class="reference internal" href="._book002.html#eq-decay-fd1-du-theta"><span class="std std-ref">(3.37)</span></a>
and <a class="reference internal" href="._book002.html#eq-decay-fd1-wmean-a"><span class="std std-ref">(3.38)</span></a>, we get</p>
<div class="math" id="equation-decay:problem:ab:theta:avg:all">
<span id="eq-decay-problem-ab-theta-avg-all"></span><span class="eqno">(4)</span>\[     \frac{u^{n+1}-u^n}{\Delta t} = \theta(-a^{n+1}u^{n+1} + b^{n+1}))
     + (1-\theta)(-a^nu^{n} + b^n)),\]</div>
<p>where <span class="math">\(a^n\)</span> means evaluating <span class="math">\(a\)</span> at <span class="math">\(t=t_n\)</span> and similar for
<span class="math">\(a^{n+1}\)</span>, <span class="math">\(b^n\)</span>, and <span class="math">\(b^{n+1}\)</span>.
We solve for <span class="math">\(u^{n+1}\)</span>:</p>
<div class="math">
\[u^{n+1} = ((1 - \Delta t(1-\theta)a^n)u^n
+ \Delta t(\theta b^{n+1} + (1-\theta)b^n))(1 + \Delta t\theta a^{n+1})^{-1}
{\thinspace .}\]</div>
</div>
<div class="section" id="python-code">
<h4>Python code<a class="headerlink" href="#python-code" title="Permalink to this headline">¶</a></h4>
<p>Here is a suitable implementation of <a href="#equation-decay:problem:ab:theta:avg:all">(4)</a>
where <span class="math">\(a(t)\)</span> and <span class="math">\(b(t)\)</span> are given as
Python functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=-a(t)*u + b(t), u(0)=I,</span>
<span class="sd">    for t in (0,T] with steps of dt.</span>
<span class="sd">    a and b are Python functions of t.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>            <span class="c"># avoid integer division</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>     <span class="c"># no of time intervals</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span>                 <span class="c"># adjust T to fit time step dt</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c"># array of u[n] values</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># time mesh</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>                  <span class="c"># assign initial condition</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>    <span class="c"># n=0,1,...,Nt-1</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> \
                  <span class="n">dt</span><span class="o">*</span><span class="p">(</span><span class="n">theta</span><span class="o">*</span><span class="n">b</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">b</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])))</span><span class="o">/</span>\
                  <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">theta</span><span class="o">*</span><span class="n">a</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>This function is found in the file <a class="reference external" href="http://tinyurl.com/ofkw6kc/genz/decay_vc.py">decay_vc.py</a> (<code class="docutils literal"><span class="pre">vc</span></code> stands for &#8220;variable coefficients&#8221;).</p>
</div>
<div class="section" id="coding-of-variable-coefficients">
<h4>Coding of variable coefficients<a class="headerlink" href="#coding-of-variable-coefficients" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">solver</span></code> function shown above demands the arguments <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> to
be Python functions of time <code class="docutils literal"><span class="pre">t</span></code>, say</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a_0</span> <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">tp</span> <span class="k">else</span> <span class="n">k</span><span class="o">*</span><span class="n">a_0</span>

<span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">a(t)</span></code> has three parameters <code class="docutils literal"><span class="pre">a0</span></code>, <code class="docutils literal"><span class="pre">tp</span></code>, and <code class="docutils literal"><span class="pre">k</span></code>,
which must be global variables.</p>
<p>A better implementation, which avoids global variables,
is to represent <code class="docutils literal"><span class="pre">a</span></code> by a class where the
parameters are attributes and where a <em>special method</em> <code class="docutils literal"><span class="pre">__call__</span></code>
evaluates <span class="math">\(a(t)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">a0</span><span class="p">,</span> <span class="n">k</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a0</span> <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tp</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">a0</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">a0</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># a behaves as a function a(t)</span>
</pre></div>
</div>
<p id="index-0">For quick tests it is cumbersome to write a complete function or a class.
The <em>lambda function</em> construction in Python is then convenient. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">a_0</span> <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">tp</span> <span class="k">else</span> <span class="n">k</span><span class="o">*</span><span class="n">a_0</span>
</pre></div>
</div>
<p>is equivalent to the <code class="docutils literal"><span class="pre">def</span> <span class="pre">a(t)</span></code> definition above. In general,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">:</span> <span class="n">expression</span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">expression</span>
</pre></div>
</div>
<p>One can use lambda functions directly in calls. Say we want to
solve <span class="math">\(u^{\prime}=-u+1\)</span>, <span class="math">\(u(0)=2\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
</pre></div>
</div>
<p>Whether to use a plain function, a class, or a lambda function depends
on the programmer&#8217;s taste. Lazy programmers prefer the lambda construct, while
very safe programmers go for the class solution.</p>
</div>
</div>
<div class="section" id="verifying-a-constant-solution">
<span id="decay-verify-trivial"></span><h3>Verifying a constant solution<a class="headerlink" href="#verifying-a-constant-solution" title="Permalink to this headline">¶</a></h3>
<p>An extremely useful partial verification method is to construct a test
problem with a very simple solution, usually <span class="math">\(u=\hbox{const}\)</span>.
Especially the initial debugging of a program code can benefit greatly
from such tests, because 1) all relevant numerical methods will
exactly reproduce a constant solution, 2) many of the intermediate
calculations are easy to control by hand for a constant <span class="math">\(u\)</span>, and 3) even a
constant <span class="math">\(u\)</span> can uncover many bugs in an implementation.</p>
<p>The only constant solution for the problem <span class="math">\(u^{\prime}=-au\)</span> is <span class="math">\(u=0\)</span>, but too
many bugs can escape from that trivial solution.  It is much better to
search for a problem where <span class="math">\(u=C=\hbox{const}\neq 0\)</span>.  Then <span class="math">\(u^{\prime}=-a(t)u
+ b(t)\)</span> is more appropriate: with <span class="math">\(u=C\)</span> we can choose any <span class="math">\(a(t)\)</span> and
set <span class="math">\(b=a(t)C\)</span> and <span class="math">\(I=C\)</span>. An appropriate test function is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_constant_solution</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test problem where u=u_const is the exact solution, to be</span>
<span class="sd">    reproduced (to machine precision) by any relevant method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">u_const</span>

    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">2.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>  <span class="c"># can be arbitrary</span>

    <span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">u_const</span>

    <span class="n">u_const</span> <span class="o">=</span> <span class="mf">2.15</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="n">u_const</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c"># enough with a few steps</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">u</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">difference</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  <span class="c"># max deviation</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">difference</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>An interesting question is what type of bugs that will make the
computed <span class="math">\(u^n\)</span> deviate from the exact solution <span class="math">\(C\)</span>.
Fortunately, the updating formula and the initial condition must
be absolutely correct for the test to pass! Any attempt to make
a wrong indexing in terms like <code class="docutils literal"><span class="pre">a(t[n])</span></code> or any attempt to
introduce an erroneous factor in the formula creates a solution
that is different from <span class="math">\(C\)</span>.</p>
</div>
<div class="section" id="verification-via-manufactured-solutions">
<span id="decay-mms"></span><h3>Verification via manufactured solutions<a class="headerlink" href="#verification-via-manufactured-solutions" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-1"></span><p id="index-2">Following the idea of the previous section, we can choose any formula
as the exact solution, insert the formula in the ODE problem and fit
the data <span class="math">\(a(t)\)</span>, <span class="math">\(b(t)\)</span>, and <span class="math">\(I\)</span> to make the chosen
formula fulfill the equation. This
powerful technique for generating exact solutions is very useful for
verification purposes and known as the <em>method of manufactured
solutions</em>, often abbreviated MMS.</p>
<p>One common choice of solution is a linear function in the independent
variable(s). The rationale behind such a simple variation is that
almost any relevant numerical solution method for differential
equation problems is able to reproduce a linear function exactly to
machine precision (if <span class="math">\(u\)</span> is about unity in size; precision is lost if
<span class="math">\(u\)</span> takes on large values, see <a class="reference internal" href="#decay-fd2-exer-precision"><span class="std std-ref">Exercise 9: Experiment with precision in tests and the size of </span></a>).
The linear solution also makes some stronger demands to the
numerical method and the implementation than the constant solution
used in the section <a class="reference internal" href="#decay-verify-trivial"><span class="std std-ref">Verifying a constant solution</span></a>, at least in more
complicated applications. Still, the constant solution is often
ideal for initial debugging before proceeding with a linear solution.</p>
<p>We choose a linear solution <span class="math">\(u(t) = ct + d\)</span>. From the initial condition it
follows that <span class="math">\(d=I\)</span>.
Inserting this <span class="math">\(u\)</span> in the left-hand side of <a href="#equation-decay:problem:ab">(2)</a>, i.e.,
the ODE, we get</p>
<div class="math">
\[c = -a(t)u + b(t) {\thinspace .}\]</div>
<p>Any function <span class="math">\(u=ct+I\)</span> is then a correct solution if we choose</p>
<div class="math">
\[b(t) = c + a(t)(ct + I) {\thinspace .}\]</div>
<p>With this <span class="math">\(b(t)\)</span> there are no restrictions on <span class="math">\(a(t)\)</span> and <span class="math">\(c\)</span>.</p>
<p>Let us prove that such a linear solution obeys the numerical
schemes. To this end, we must check that <span class="math">\(u^n = ca(t_n)(ct_n+I)\)</span>
fulfills the discrete equations. For these calculations, and
later calculations involving linear solutions inserted in
finite difference schemes, it is convenient to
compute the action of a difference operator on a linear function <span class="math">\(t\)</span>:</p>
<div class="math" id="equation-decay:fd2:Dop:tn:fw">
<span id="eq-decay-fd2-dop-tn-fw"></span><span class="eqno">(5)</span>\[     \lbrack D_t^+ t\rbrack^n = \frac{t_{n+1}-t_n}{\Delta t}=1,\]</div>
<div class="math" id="equation-decay:fd2:Dop:tn:bw">
<span id="eq-decay-fd2-dop-tn-bw"></span><span class="eqno">(6)</span>\[     \lbrack D_t^- t\rbrack^n = \frac{t_{n}-t_{n-1}}{\Delta t}=1,\]</div>
<div class="math" id="equation-decay:fd2:Dop:tn:cn">
<span id="eq-decay-fd2-dop-tn-cn"></span><span class="eqno">(7)</span>\[     \lbrack D_t t\rbrack^n = \frac{t_{n+\frac{1}{2}}-t_{n-\frac{1}{2}}}{\Delta t}=\frac{(n+\frac{1}{2})\Delta t - (n-\frac{1}{2})\Delta t}{\Delta t}=1\]\[     {\thinspace .}\]</div>
<p>Clearly, all three finite difference approximations to the derivative are
exact for <span class="math">\(u(t)=t\)</span> or its mesh function counterpart <span class="math">\(u^n = t_n\)</span>.</p>
<p>The difference equation for the Forward Euler scheme</p>
<div class="math">
\[[D^+_t u = -au + b]^n,\]</div>
<p>with <span class="math">\(a^n=a(t_n)\)</span>, <span class="math">\(b^n=c + a(t_n)(ct_n + I)\)</span>, and <span class="math">\(u^n=ct_n + I\)</span>
then results in</p>
<div class="math">
\[c = -a(t_n)(ct_n+I) + c + a(t_n)(ct_n + I) = c\]</div>
<p>which is always fulfilled. Similar calculations can be done for the
Backward Euler and Crank-Nicolson schemes, or the <span class="math">\(\theta\)</span>-rule for
that matter. In all cases, <span class="math">\(u^n=ct_n +I\)</span> is an exact solution of
the discrete equations. That is why we should expect that
<span class="math">\(u^n - {u_{\small\mbox{e}}}(t_n) =0\)</span> mathematically and <span class="math">\(|u^n - {u_{\small\mbox{e}}}(t_n)|\)</span> less
than a small number about the machine precision for <span class="math">\(n=0,\ldots,N_t\)</span>.</p>
<p>The following function offers an implementation of this verification
test based on a linear exact solution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_linear_solution</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test problem where u=c*t+I is the exact solution, to be</span>
<span class="sd">    reproduced (to machine precision) by any relevant method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span>

    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">**</span><span class="mf">0.5</span>  <span class="c"># can be arbitrary</span>

    <span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">c</span> <span class="o">+</span> <span class="n">a</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>  <span class="c"># no of steps</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">difference</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  <span class="c"># max deviation</span>
    <span class="k">print</span> <span class="n">difference</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>  <span class="c"># depends on c!</span>
    <span class="k">assert</span> <span class="n">difference</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="k">def</span> <span class="nf">test_convergence_rates</span><span class="p">():</span>
    <span class="c"># Create a manufactured solution with sympy</span>
    <span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">t</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u_exact</span>

    <span class="c"># Turn sympy expressions into Python function</span>
    <span class="n">u_exact</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">t</span><span class="p">],</span> <span class="n">u_e</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">t</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">t</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_rates</span><span class="p">(</span><span class="n">dt_values</span><span class="p">,</span> <span class="n">E_values</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt_values</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">log</span><span class="p">(</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span>
             <span class="n">log</span><span class="p">(</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="c"># Round to two decimals</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">r_</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">r_</span> <span class="ow">in</span> <span class="n">r</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="n">dt_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="o">*</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">):</span>
        <span class="n">E_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">E_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">compute_rates</span><span class="p">(</span><span class="n">dt_values</span><span class="p">,</span> <span class="n">E_values</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;theta=</span><span class="si">%g</span><span class="s">, r: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="n">expected_rate</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">theta</span> <span class="o">==</span> <span class="mf">0.5</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">expected_rate</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>Any error in the updating formula makes this test fail!</p>
<p>Choosing more complicated formulas as the exact solution, say
<span class="math">\(\cos(t)\)</span>, will not make the numerical and exact solution
coincide to machine precision, because finite differencing of
<span class="math">\(\cos(t)\)</span> does not exactly yield the exact derivative <span class="math">\(-\sin(t)\)</span>.
In such cases, the verification procedure
must be based on measuring the convergence rates as exemplified in
the section <a class="reference internal" href="#decay-convergence-rate"><span class="std std-ref">Computing convergence rates</span></a>. Convergence rates can be
computed as long as one has
an exact solution of a problem that the solver can be tested on, but
this can always be obtained by the method of manufactured solutions.</p>
</div>
<div class="section" id="computing-convergence-rates">
<span id="decay-convergence-rate"></span><h3>Computing convergence rates<a class="headerlink" href="#computing-convergence-rates" title="Permalink to this headline">¶</a></h3>
<p id="index-3">We expect that the error <span class="math">\(E\)</span> in the numerical solution is
reduced if the mesh size <span class="math">\(\Delta t\)</span> is decreased. More specifically,
many numerical methods obey a power-law relation between <span class="math">\(E\)</span> and
<span class="math">\(\Delta t\)</span>:</p>
<div class="math" id="equation-decay:E:dt">
<span id="eq-decay-e-dt"></span><span class="eqno">(8)</span>\[     E = C\Delta t^r,\]</div>
<p>where <span class="math">\(C\)</span> and <span class="math">\(r\)</span> are (usually unknown) constants independent of <span class="math">\(\Delta t\)</span>.
The formula <a href="#equation-decay:E:dt">(8)</a> is viewed as an asymptotic model valid for
sufficiently small <span class="math">\(\Delta t\)</span>. How small is normally hard to estimate
without doing numerical estimations of <span class="math">\(r\)</span>.</p>
<p>The parameter <span class="math">\(r\)</span> is known as the <em>convergence rate</em>. For example,
if the convergence rate is 2, halving <span class="math">\(\Delta t\)</span> reduces the error by
a factor of 4. Diminishing <span class="math">\(\Delta t\)</span> then has a greater impact on
the error compared with methods that have <span class="math">\(r=1\)</span>. For a given value of <span class="math">\(r\)</span>,
we refer to the method as of <span class="math">\(r\)</span>-th order. First- and second-order
methods are most common in scientific computing.</p>
<div class="section" id="estimating">
<h4>Estimating <span class="math">\(r\)</span><a class="headerlink" href="#estimating" title="Permalink to this headline">¶</a></h4>
<p>There are two alternative ways of estimating <span class="math">\(C\)</span> and <span class="math">\(r\)</span> based on a set of
<span class="math">\(m\)</span> simulations with corresponding pairs <span class="math">\((\Delta t_i, E_i)\)</span>, <span class="math">\(i=0,\ldots,m-1\)</span>,
and <span class="math">\(\Delta t_{i} &lt; \Delta t_{i-1}\)</span> (i.e., decreasing cell size).</p>
<blockquote>
<div><ol class="arabic simple">
<li>Take the logarithm of <a href="#equation-decay:E:dt">(8)</a>, <span class="math">\(\ln E = r\ln \Delta t + \ln C\)</span>,
and fit a straight line to the data points <span class="math">\((\Delta t_i, E_i)\)</span>,
<span class="math">\(i=0,\ldots,m-1\)</span>.</li>
<li>Consider two consecutive experiments, <span class="math">\((\Delta t_i, E_i)\)</span> and
<span class="math">\((\Delta t_{i-1}, E_{i-1})\)</span>. Dividing the equation
<span class="math">\(E_{i-1}=C\Delta t_{i-1}^r\)</span> by <span class="math">\(E_{i}=C\Delta t_{i}^r\)</span> and solving
for <span class="math">\(r\)</span> yields</li>
</ol>
</div></blockquote>
<div class="math" id="equation-decay:conv:rate">
<span id="eq-decay-conv-rate"></span><span class="eqno">(9)</span>\[     r_{i-1} = \frac{\ln (E_{i-1}/E_i)}{\ln (\Delta t_{i-1}/\Delta t_i)}\]</div>
<p>for <span class="math">\(i=1,\ldots,m-1\)</span>. Note that we have introduced a subindex <span class="math">\(i-1\)</span>
on <span class="math">\(r\)</span> in <a href="#equation-decay:conv:rate">(9)</a> because <span class="math">\(r\)</span> estimated from
a pair of experiments must be expected to change with <span class="math">\(i\)</span>.</p>
<p>The disadvantage of method 1 is that <a href="#equation-decay:E:dt">(8)</a> might not be valid
for the coarsest meshes (largest <span class="math">\(\Delta t\)</span> values). Fitting a line
to all the data points is then misleading.  Method 2 computes
convergence rates for pairs of experiments and allows us to see
if the sequence <span class="math">\(r_i\)</span> converges to some value as <span class="math">\(i\rightarrow m-2\)</span>.
The final <span class="math">\(r_{m-2}\)</span> can then be taken as the convergence rate.
If the coarsest meshes have a differing rate, the corresponding
time steps are probably too large for <a href="#equation-decay:E:dt">(8)</a> to be valid.
That is, those time steps lie outside the asymptotic range of
<span class="math">\(\Delta t\)</span> values where the error behaves like <a href="#equation-decay:E:dt">(8)</a>.</p>
</div>
<div class="section" id="implementation-2">
<h4>Implementation  (2)<a class="headerlink" href="#implementation-2" title="Permalink to this headline">¶</a></h4>
<p>We can compute <span class="math">\(r_0, r_1, \ldots, r_{m-2}\)</span> from <span class="math">\(E_i\)</span> and <span class="math">\(\Delta t_i\)</span>
by the following functionL</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">compute_rates</span><span class="p">(</span><span class="n">dt_values</span><span class="p">,</span> <span class="n">E_values</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt_values</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">log</span><span class="p">(</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span>
         <span class="n">log</span><span class="p">(</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="c"># Round to two decimals</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">r_</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">r_</span> <span class="ow">in</span> <span class="n">r</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>Experiments with a series of time step values and <span class="math">\(\theta=0,1,0.5\)</span>
can be set up as follows, here embedded in a real test function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_convergence_rates</span><span class="p">():</span>
    <span class="c"># Create a manufactured solution</span>
    <span class="c"># define u_exact(t), a(t), b(t)</span>

    <span class="n">dt_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="o">*</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">):</span>
        <span class="n">E_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">E_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">compute_rates</span><span class="p">(</span><span class="n">dt_values</span><span class="p">,</span> <span class="n">E_values</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;theta=</span><span class="si">%g</span><span class="s">, r: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="n">expected_rate</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">theta</span> <span class="o">==</span> <span class="mf">0.5</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">expected_rate</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>The manufactured solution is conveniently computed by <code class="docutils literal"><span class="pre">sympy</span></code>.
Let us choose <span class="math">\({u_{\small\mbox{e}}}(t) = \sin(t)e^{-2t}\)</span> and <span class="math">\(a(t)=t^2\)</span>.
This implies that we must fit <span class="math">\(b\)</span> as <span class="math">\(b(t)=u'(t)-a(t)\)</span>.
We first compute with <code class="docutils literal"><span class="pre">sympy</span></code> expressions and then we convert
the exact solution, <span class="math">\(a\)</span>, and <span class="math">\(b\)</span> to Python functions that we
can use in the subsequent numerical computing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Create a manufactured solution with sympy</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">t</span><span class="o">**</span><span class="mi">2</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u_exact</span>

<span class="c"># Turn sympy expressions into Python function</span>
<span class="n">u_exact</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">t</span><span class="p">],</span> <span class="n">u_e</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">t</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">t</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The complete code is found in the function <code class="docutils literal"><span class="pre">test_convergence_rates</span></code>
in the file <a class="reference external" href="http://tinyurl.com/ofkw6kc/genz/decay_vc.py">decay_vc.py</a>.</p>
<p>Running this code gives the output</p>
<div class="highlight-text"><div class="highlight"><pre>theta=0, r: [1.06, 1.03, 1.01, 1.01, 1.0, 1.0]
theta=1, r: [0.94, 0.97, 0.99, 0.99, 1.0, 1.0]
theta=0.5, r: [2.0, 2.0, 2.0, 2.0, 2.0, 2.0]
</pre></div>
</div>
<p>We clearly see how the convergence rates goes to the expected values.</p>
<div class="admonition-why-convergence-rates-are-important admonition" id="index-4">
<p class="first admonition-title">Why convergence rates are important</p>
<p class="last">The strong practical application of computing convergence rates is for
verification: wrong convergence rates point to errors in the code, and
correct convergence rates bring strong support for a correct implementation.
Experience shows that bugs in the code easily destroy the
expected convergence rate.</p>
</div>
</div>
</div>
<div class="section" id="extension-to-systems-of-odes">
<h3>Extension to systems of ODEs<a class="headerlink" href="#extension-to-systems-of-odes" title="Permalink to this headline">¶</a></h3>
<p>Many ODE models involve more than one unknown function and more
than one equation. Here is an example of two unknown functions <span class="math">\(u(t)\)</span>
and <span class="math">\(v(t)\)</span>:</p>
<div class="math">
\[u^{\prime} = a u + bv,\]</div>
<div class="math">
\[v^{\prime} = cu +  dv,\]</div>
<p>for constants <span class="math">\(a,b,c,d\)</span>.
Applying the Forward Euler method to each equation results in a simple
updating formula:</p>
<div class="math">
\[u^{n+1} = u^n + \Delta t (a u^n + b v^n),\]</div>
<div class="math">
\[v^{n+1} = u^n + \Delta t (cu^n + dv^n)
{\thinspace .}\]</div>
<p>On the other hand, the Crank-Nicolson or Backward Euler schemes result in a
<span class="math">\(2\times 2\)</span> linear system for the new unknowns. The latter scheme becomes</p>
<div class="math">
\[u^{n+1} = u^n + \Delta t (a u^{n+1} + b v^{n+1}),\]</div>
<div class="math">
\[v^{n+1} = v^n + \Delta t (c u^{n+1} + d v^{n+1}){\thinspace .}\]</div>
<p>Collecting <span class="math">\(u^{n+1}\)</span> as well as <span class="math">\(v^{n+1}\)</span> on the left-hand side results
in</p>
<div class="math">
\[(1 - \Delta t a)u^{n+1} + bv^{n+1} = u^n ,\]</div>
<div class="math">
\[c u^{n+1} + (1 - \Delta t d) v^{n+1} = v^n ,\]</div>
<p>which is a system of two coupled, linear, algebraic equations in two
unknowns. These equations can be solved by hand (using standard
techniques for two algebraic equations with two unknowns <span class="math">\(x\)</span> and <span class="math">\(y\)</span>),
resulting in explicit formulas for <span class="math">\(u^{n+1}\)</span> and <span class="math">\(v^{n+1}\)</span> that can be
directly implemented. For systems of ODEs with many equations and unknowns, one
will express the coupled equations at each time level in matrix form
and call software for numerical solution of linear systems of equations.</p>
</div>
</div>
<div class="section" id="general-first-order-odes">
<h2>General first-order ODEs<a class="headerlink" href="#general-first-order-odes" title="Permalink to this headline">¶</a></h2>
<p>We now turn the attention to general, nonlinear ODEs and systems of
such ODEs.  Our focus is on numerical methods that can be readily
reused for time-discretization of PDEs, and diffusion PDEs in particular.
The methods are just briefly listed, and we refer to the rich literature
for more detailed descriptions and analysis - the books
<a class="reference internal" href="._book009.html#ref04" id="id1">[Ref04]</a> <a class="reference internal" href="._book009.html#ref05" id="id2">[Ref05]</a> <a class="reference internal" href="._book009.html#ref06" id="id3">[Ref06]</a> <a class="reference internal" href="._book009.html#ref07" id="id4">[Ref07]</a> are all excellent resources on numerical methods for ODEs.
We also demonstrate the Odespy Python interface to a range
of different software for general first-order ODE systems.</p>
<div class="section" id="generic-form-of-first-order-odes">
<h3>Generic form of first-order ODEs<a class="headerlink" href="#generic-form-of-first-order-odes" title="Permalink to this headline">¶</a></h3>
<p>ODEs are commonly written in the generic form</p>
<div class="math" id="equation-decay:ode:general">
<span id="eq-decay-ode-general"></span><span class="eqno">(10)</span>\[     u^{\prime} = f(u,t),\quad u(0)=I,\]</div>
<p>where <span class="math">\(f(u,t)\)</span>  is some prescribed function.
As an example, our most
general exponential decay model <a href="#equation-decay:problem:ab">(2)</a> has
<span class="math">\(f(u,t)=-a(t)u(t) + b(t)\)</span>.</p>
<p>The unknown <span class="math">\(u\)</span> in <a href="#equation-decay:ode:general">(10)</a> may either be
a scalar function of time <span class="math">\(t\)</span>, or a vector valued function of <span class="math">\(t\)</span> in
case of a <em>system of ODEs</em> with <span class="math">\(m\)</span> unknown components:</p>
<div class="math">
\[u(t) = (u^{(0)}(t),u^{(1)}(t),\ldots,u^{(m-1)}(t)) {\thinspace .}\]</div>
<p>In that case, the right-hand side is vector-valued function with <span class="math">\(m\)</span>
components,</p>
<div class="math">
\[\begin{split}f(u, t) = ( &amp; f^{(0)}(u^{(0)}(t),\ldots,u^{(m-1)}(t)),\\
            &amp; f^{(1)}(u^{(0)}(t),\ldots,u^{(m-1)}(t)),\\
            &amp; \vdots,\\
            &amp; f^{(m-1)}(u^{(0)}(t),\ldots,u^{(m-1)}(t)))
{\thinspace .}\end{split}\]</div>
<p>Actually, any system of ODEs can
be written in the form <a href="#equation-decay:ode:general">(10)</a>, but higher-order
ODEs then need auxiliary unknown functions to enable conversion to
a first-order system.</p>
<p>Next we list some well-known methods for <span class="math">\(u^{\prime}=f(u,t)\)</span>, valid both for
a single ODE (scalar <span class="math">\(u\)</span>) and systems of ODEs (vector <span class="math">\(u\)</span>).</p>
</div>
<div class="section" id="the-rule">
<h3>The <span class="math">\(\theta\)</span>-rule<a class="headerlink" href="#the-rule" title="Permalink to this headline">¶</a></h3>
<p>The <span class="math">\(\theta\)</span>-rule scheme applied to <span class="math">\(u^{\prime}=f(u,t)\)</span> becomes</p>
<div class="math" id="equation-decay:fd2:theta">
<span id="eq-decay-fd2-theta"></span><span class="eqno">(11)</span>\[     \frac{u^{n+1}-u^n}{\Delta t} = \theta f(u^{n+1},t_{n+1}) +
     (1-\theta)f(u^n, t_n){\thinspace .}\]</div>
<p>Bringing the unknown <span class="math">\(u^{n+1}\)</span> to the left-hand side and the known terms
on the right-hand side gives</p>
<span class="target" id="index-5"></span><span class="target" id="index-6"></span><span class="target" id="index-7"></span><div class="math" id="index-8">
\[u^{n+1} - \Delta t \theta f(u^{n+1},t_{n+1}) =
u^n + \Delta t(1-\theta)f(u^n, t_n){\thinspace .}\]</div>
<p>For a general <span class="math">\(f\)</span> (not linear in <span class="math">\(u\)</span>), this equation is <em>nonlinear</em> in
the unknown <span class="math">\(u^{n+1}\)</span> unless <span class="math">\(\theta = 0\)</span>. For a scalar ODE (<span class="math">\(m=1\)</span>),
we have to solve a single nonlinear algebraic equation for <span class="math">\(u^{n+1}\)</span>,
while for a system of ODEs, we get a system of coupled, nonlinear
algebraic equations. Newton&#8217;s method is a popular solution approach
in both cases. Note that with the Forward Euler scheme (<span class="math">\(\theta =0\)</span>)
we do not have to deal with nonlinear equations, because in that
case we have an explicit updating formula for <span class="math">\(u^{n+1}\)</span>. This is known
as an <em>explicit</em> scheme. With <span class="math">\(\theta\neq 1\)</span> we have to solve
(systems of) algebraic equations, and the scheme is said to be <em>implicit</em>.</p>
</div>
<div class="section" id="an-implicit-2-step-backward-scheme">
<h3>An implicit 2-step backward scheme<a class="headerlink" href="#an-implicit-2-step-backward-scheme" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-9"></span><p id="index-10">The implicit backward method with 2 steps applies a
three-level backward difference as approximation to <span class="math">\(u^{\prime}(t)\)</span>,</p>
<div class="math">
\[u^{\prime}(t_{n+1}) \approx \frac{3u^{n+1} - 4u^{n} + u^{n-1}}{2\Delta t},\]</div>
<p>which is an approximation of order <span class="math">\(\Delta t^2\)</span> to the first derivative.
The resulting scheme for <span class="math">\(u^{\prime}=f(u,t)\)</span> reads</p>
<div class="math" id="equation-decay:fd2:bw:2step">
<span id="eq-decay-fd2-bw-2step"></span><span class="eqno">(12)</span>\[     u^{n+1} = \frac{4}{3}u^n - \frac{1}{3}u^{n-1} +
     \frac{2}{3}\Delta t f(u^{n+1}, t_{n+1})
     {\thinspace .}\]</div>
<p>Higher-order versions of the scheme <a href="#equation-decay:fd2:bw:2step">(12)</a> can
be constructed by including more time levels. These schemes are known
as the Backward Differentiation Formulas (BDF), and the particular
version <a href="#equation-decay:fd2:bw:2step">(12)</a> is often referred to as BDF2.</p>
<p>Note that the scheme <a href="#equation-decay:fd2:bw:2step">(12)</a> is implicit and requires
solution of nonlinear equations when <span class="math">\(f\)</span> is nonlinear in <span class="math">\(u\)</span>.  The
standard 1st-order Backward Euler method or the Crank-Nicolson scheme
can be used for the first step.</p>
</div>
<div class="section" id="leapfrog-schemes">
<h3>Leapfrog schemes<a class="headerlink" href="#leapfrog-schemes" title="Permalink to this headline">¶</a></h3>
<div class="section" id="the-ordinary-leapfrog-scheme">
<span id="index-11"></span><h4>The ordinary Leapfrog scheme<a class="headerlink" href="#the-ordinary-leapfrog-scheme" title="Permalink to this headline">¶</a></h4>
<p>The derivative of <span class="math">\(u\)</span> at some point <span class="math">\(t_n\)</span> can be approximated by
a central difference over two time steps,</p>
<div class="math">
\[u^{\prime}(t_n)\approx \frac{u^{n+1}-u^{n-1}}{2\Delta t} = [D_{2t}u]^n\]</div>
<p>which is an approximation of second order in <span class="math">\(\Delta t\)</span>. The scheme
can then be written as</p>
<div class="math">
\[[D_{2t}u=f(u,t)]^n,\]</div>
<p>in operator notation. Solving for <span class="math">\(u^{n+1}\)</span> gives</p>
<div class="math" id="equation-decay:fd2:leapfrog">
<span id="eq-decay-fd2-leapfrog"></span><span class="eqno">(13)</span>\[     u^{n+1} = u^{n-1} + 2\Delta t f(u^n, t_n)
     {\thinspace .}\]</div>
<p>Observe that <a href="#equation-decay:fd2:leapfrog">(13)</a> is an explicit scheme, and that
a nonlinear <span class="math">\(f\)</span> (in <span class="math">\(u\)</span>) is trivial to handle since it only involves
the known <span class="math">\(u^n\)</span> value.
Some other scheme must be used as starter to compute <span class="math">\(u^1\)</span>, preferably
the Forward Euler scheme since it is also explicit.</p>
</div>
<div class="section" id="the-filtered-leapfrog-scheme">
<span id="index-12"></span><h4>The filtered Leapfrog scheme<a class="headerlink" href="#the-filtered-leapfrog-scheme" title="Permalink to this headline">¶</a></h4>
<p>Unfortunately, the Leapfrog scheme <a href="#equation-decay:fd2:leapfrog">(13)</a>
will develop growing oscillations with time (see <a class="reference internal" href="#decay-fd2-exer-leapfrog1"><span class="std std-ref">Project 14: Implement and investigate the Leapfrog scheme</span></a>). A remedy for such undesired oscillations
is to introduce a <em>filtering technique</em>. First, a standard Leapfrog
step is taken, according to <a href="#equation-decay:fd2:leapfrog">(13)</a>, and then
the previous <span class="math">\(u^n\)</span> value is adjusted according to</p>
<div class="math" id="equation-decay:fd2:leapfrog:filtered">
<span id="eq-decay-fd2-leapfrog-filtered"></span><span class="eqno">(14)</span>\[     u^n\ \leftarrow\ u^n + \gamma (u^{n-1} - 2u^n + u^{n+1})\]\[     {\thinspace .}\]</div>
<p>The <span class="math">\(\gamma\)</span>-terms will effectively damp oscillations in the solution,
especially those with short wavelength (like point-to-point oscillations).
A common choice of <span class="math">\(\gamma\)</span> is 0.6 (a value used in the
famous NCAR Climate Model).</p>
</div>
</div>
<div class="section" id="the-2nd-order-runge-kutta-method">
<h3>The 2nd-order Runge-Kutta method<a class="headerlink" href="#the-2nd-order-runge-kutta-method" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-13"></span><p id="index-14">The two-step scheme</p>
<div class="math" id="equation-decay:fd2:RK2:s1">
<span id="eq-decay-fd2-rk2-s1"></span><span class="eqno">(15)</span>\[     u^* = u^n + \Delta t f(u^n, t_n),\]</div>
<div class="math" id="equation-decay:fd2:RK2:s2">
<span id="eq-decay-fd2-rk2-s2"></span><span class="eqno">(16)</span>\[     u^{n+1} = u^n + \Delta t \frac{1}{2} \left( f(u^n, t_n) + f(u^*, t_{n+1})
     \right),\]</div>
<p>essentially applies a Crank-Nicolson method <a href="#equation-decay:fd2:RK2:s2">(16)</a>
to the ODE, but replaces
the term <span class="math">\(f(u^{n+1}, t_{n+1})\)</span> by a prediction
<span class="math">\(f(u^{*}, t_{n+1})\)</span> based on a Forward Euler step <a href="#equation-decay:fd2:RK2:s1">(15)</a>.
The scheme <a href="#equation-decay:fd2:RK2:s1">(15)</a>-<a href="#equation-decay:fd2:RK2:s2">(16)</a> is
known as Huen&#8217;s method, but is also a 2nd-order Runge-Kutta method.
The scheme is explicit, and the error is expected to behave as <span class="math">\(\Delta t^2\)</span>.</p>
</div>
<div class="section" id="a-2nd-order-taylor-series-method">
<h3>A 2nd-order Taylor-series method<a class="headerlink" href="#a-2nd-order-taylor-series-method" title="Permalink to this headline">¶</a></h3>
<p id="index-15">One way to compute <span class="math">\(u^{n+1}\)</span> given <span class="math">\(u^n\)</span> is to use a Taylor polynomial.
We may write up a polynomial of 2nd degree:</p>
<div class="math">
\[u^{n+1} = u^n + u^{\prime}(t_n)\Delta t + {\frac{1}{2}}u^{\prime\prime}(t_n)\Delta t^2
{\thinspace .}\]</div>
<p>From the equation <span class="math">\(u^{\prime}=f(u,t)\)</span> it follows that the derivatives of <span class="math">\(u\)</span>
can be expressed in terms of <span class="math">\(f\)</span> and its derivatives:</p>
<div class="math">
\[\begin{split}u^{\prime}(t_n) &amp;=f(u^n,t_n),\\
u^{\prime\prime}(t_n) &amp;=
\frac{\partial f}{\partial u}(u^n,t_n) u^{\prime}(t_n) + \frac{\partial f}{\partial t}\\
&amp;=  f(u^n,t_n)\frac{\partial f}{\partial u}(u^n,t_n)  +
\frac{\partial f}{\partial t},\end{split}\]</div>
<p>resulting in the scheme</p>
<div class="math" id="equation-decay:fd2:Taylor2">
<span id="eq-decay-fd2-taylor2"></span><span class="eqno">(17)</span>\[     u^{n+1} = u^n + f(u^n,t_n)\Delta t + \frac{1}{2}\left(
     f(u^n,t_n)\frac{\partial f}{\partial u}(u^n,t_n)  +
     \frac{\partial f}{\partial t}\right)\Delta t^2
     {\thinspace .}\]</div>
<p>More terms in the series could be included in the Taylor polynomial to
obtain methods of higher order than 2.</p>
</div>
<div class="section" id="the-2nd-and-3rd-order-adams-bashforth-schemes">
<h3>The 2nd- and 3rd-order Adams-Bashforth schemes<a class="headerlink" href="#the-2nd-and-3rd-order-adams-bashforth-schemes" title="Permalink to this headline">¶</a></h3>
<p id="index-16">The following method is known as the 2nd-order Adams-Bashforth scheme:</p>
<div class="math" id="equation-decay:fd2:AB2">
<span id="eq-decay-fd2-ab2"></span><span class="eqno">(18)</span>\[     u^{n+1} = u^n + \frac{1}{2}\Delta t\left( 3f(u^n, t_n) - f(u^{n-1}, t_{n-1})
     \right)
     {\thinspace .}\]</div>
<p>The scheme is explicit and requires another one-step scheme to compute
<span class="math">\(u^1\)</span> (the Forward Euler scheme or Heun&#8217;s method, for instance).
As the name implies, the error behaves like <span class="math">\(\Delta t^2\)</span>.</p>
<p id="index-17">Another explicit scheme, involving four time levels, is the
3rd-order Adams-Bashforth scheme</p>
<div class="math" id="equation-decay:fd2:AB3">
<span id="eq-decay-fd2-ab3"></span><span class="eqno">(19)</span>\[     u^{n+1} = u^n + \frac{1}{12}\left( 23f(u^n, t_n) - 16 f(u^{n-1},t_{n-1})
     + 5f(u^{n-2}, t_{n-2})\right)
     {\thinspace .}\]</div>
<p>The numerical error is of order <span class="math">\(\Delta t^3\)</span>, and the scheme needs
some method for computing <span class="math">\(u^1\)</span> and <span class="math">\(u^2\)</span>.</p>
<p>More general, higher-order Adams-Bashforth schemes (also called
<em>explicit Adams methods</em>) compute <span class="math">\(u^{n+1}\)</span> as a linear combination
of <span class="math">\(f\)</span> at <span class="math">\(k+1\)</span> previous time steps:</p>
<div class="math">
\[u^{n+1} = u^n + \sum_{j=0}^k \beta_jf(u^{n-j},t_{n-j}),\]</div>
<p>where <span class="math">\(\beta_j\)</span> are known coefficients.</p>
</div>
<div class="section" id="the-4th-order-runge-kutta-method">
<span id="decay-fd2-rk4"></span><h3>The 4th-order Runge-Kutta method<a class="headerlink" href="#the-4th-order-runge-kutta-method" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-18"></span><p id="index-19">The perhaps most widely used method to solve ODEs is the 4th-order
Runge-Kutta method, often called RK4.
Its derivation is a nice illustration of common
numerical approximation strategies, so let us go through the
steps in detail to learn about algorithmic development.</p>
<p>The starting point is to integrate the ODE
<span class="math">\(u^{\prime}=f(u,t)\)</span> from <span class="math">\(t_n\)</span> to <span class="math">\(t_{n+1}\)</span>:</p>
<div class="math">
\[u(t_{n+1}) - u(t_n) = \int\limits_{t_{n}}^{t_{n+1}} f(u(t),t)dt{\thinspace .}\]</div>
<p>We want to compute <span class="math">\(u(t_{n+1})\)</span> and regard <span class="math">\(u(t_n)\)</span> as known.
The task is to find good approximations for the integral, since the
integrand involves the unknown <span class="math">\(u\)</span> between <span class="math">\(t_n\)</span> and <span class="math">\(t_{n+1}\)</span>.</p>
<p>The integral can be approximated by the famous
<a class="reference external" href="http://en.wikipedia.org/wiki/Simpson's_rule">Simpson&#8217;s rule</a>:</p>
<div class="math">
\[\int\limits_{t_{n}}^{t_{n+1}} f(u(t),t)dt
\approx \frac{\Delta t}{6}\left( f^n + 4f^{n+\frac{1}{2}} + f^{n+1}\right){\thinspace .}\]</div>
<p>The problem now is that we do not know <span class="math">\(f^{n+\frac{1}{2}}=f(u^{n+\frac{1}{2}},t_{n+\frac{1}{2}})\)</span>
and <span class="math">\(f^{n+1}=(u^{n+1},t_{n+1})\)</span> as we know only <span class="math">\(u^n\)</span> and hence <span class="math">\(f^n\)</span>.
The idea is to use various approximations for <span class="math">\(f^{n+\frac{1}{2}}\)</span> and
<span class="math">\(f^{n+1}\)</span> based on well-known schemes for the ODE in the
intervals <span class="math">\([t_n,t_{n+\frac{1}{2}}]\)</span> and <span class="math">\([t_n, t_{n+1}]\)</span>.
We split the integral approximation into four terms:</p>
<div class="math">
\[\int\limits_{t_{n}}^{t_{n+1}} f(u(t),t)dt
\approx \frac{\Delta t}{6}\left( f^n + 2\hat{f}^{n+\frac{1}{2}}
+ 2\tilde{f}^{n+\frac{1}{2}} + \bar{f}^{n+1}\right),\]</div>
<p>where <span class="math">\(\hat{f}^{n+\frac{1}{2}}\)</span>, <span class="math">\(\tilde{f}^{n+\frac{1}{2}}\)</span>, and <span class="math">\(\bar{f}^{n+1}\)</span>
are approximations to <span class="math">\(f^{n+\frac{1}{2}}\)</span> and
<span class="math">\(f^{n+1}\)</span>, respectively, that can be based on already computed quantities.
For <span class="math">\(\hat{f}^{n+\frac{1}{2}}\)</span> we can apply
an approximation to <span class="math">\(u^{n+\frac{1}{2}}\)</span> using the Forward Euler
method with step <span class="math">\(\frac{1}{2}\Delta t\)</span>:</p>
<div class="math" id="equation-decay:fd2:RK4:hatf">
<span id="eq-decay-fd2-rk4-hatf"></span><span class="eqno">(20)</span>\[     \hat{f}^{n+\frac{1}{2}} = f(u^n + \frac{1}{2}{\Delta t} f^n, t_{n+\frac{1}{2}})\]</div>
<p>Since this gives us a prediction of <span class="math">\(f^{n+\frac{1}{2}}\)</span>, we can for
<span class="math">\(\tilde{f}^{n+\frac{1}{2}}\)</span> try a Backward Euler method to approximate <span class="math">\(u^{n+\frac{1}{2}}\)</span>:</p>
<div class="math" id="equation-decay:fd2:RK4:tildef">
<span id="eq-decay-fd2-rk4-tildef"></span><span class="eqno">(21)</span>\[     \tilde{f}^{n+\frac{1}{2}} = f(u^n + \frac{1}{2}\Delta t\hat{f}^{n+\frac{1}{2}}, t_{n+\frac{1}{2}}){\thinspace .}\]</div>
<p>With <span class="math">\(\tilde{f}^{n+\frac{1}{2}}\)</span> as a hopefully good approximation to
<span class="math">\(f^{n+\frac{1}{2}}\)</span>, we can for the final term <span class="math">\(\bar{f}^{n+1}\)</span> use
a Crank-Nicolson method to approximate <span class="math">\(u^{n+1}\)</span>:</p>
<div class="math" id="equation-decay:fd2:RK4:barf">
<span id="eq-decay-fd2-rk4-barf"></span><span class="eqno">(22)</span>\[     \bar{f}^{n+1} = f(u^n + \Delta t \hat{f}^{n+\frac{1}{2}}, t_{n+1}){\thinspace .}\]</div>
<p>We have now used the Forward and Backward Euler methods as well as the
Crank-Nicolson method in the context of Simpson&#8217;s rule. The hope is
that the combination of these methods yields an overall time-stepping
scheme from <span class="math">\(t_n\)</span> to <span class="math">\(t_n{+1}\)</span> that is much more accurate than the
<span class="math">\({\mathcal{O}(\Delta t)}\)</span> and <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span> of the individual steps.
This is indeed true: the overall accuracy is <span class="math">\({\mathcal{O}(\Delta t^4)}\)</span>!</p>
<p>To summarize, the 4th-order Runge-Kutta method becomes</p>
<div class="math">
\[u^{n+1} = u^n +
\frac{\Delta t}{6}\left( f^n + 2\hat{f}^{n+\frac{1}{2}}
+ 2\tilde{f}^{n+\frac{1}{2}} + \bar{f}^{n+1}\right),\]</div>
<p>where the quantities on the right-hand side are computed from
<a href="#equation-decay:fd2:RK4:hatf">(20)</a>-<a href="#equation-decay:fd2:RK4:barf">(22)</a>. Note that
the scheme is fully explicit so there is never any need to solve linear or
nonlinear algebraic
equations. However, the stability is conditional and depends on <span class="math">\(f\)</span>.
There is a whole range of <em>implicit</em> Runge-Kutta methods that
are unconditionally stable, but require solution of algebraic
equations involving <span class="math">\(f\)</span> at each time step.</p>
<p>The simplest way to explore more sophisticated methods for ODEs is to
apply one of the many high-quality software packages that exist, as the
next section explains.</p>
</div>
<div class="section" id="the-odespy-software">
<h3>The Odespy software<a class="headerlink" href="#the-odespy-software" title="Permalink to this headline">¶</a></h3>
<p>A wide range of methods and software exist for solving <a href="#equation-decay:ode:general">(10)</a>.
Many of the methods are accessible through a unified Python interface offered
by the <a class="reference external" href="https://github.com/hplgit/odespy">Odespy</a> <a class="reference internal" href="._book009.html#ref08" id="id5">[Ref08]</a> package.
Odespy features simple Python implementations of the most fundamental
schemes as well as Python interfaces to several famous packages for
solving ODEs: <a class="reference external" href="https://computation.llnl.gov/casc/odepack/odepack_home.html">ODEPACK</a>, <a class="reference external" href="https://computation.llnl.gov/casc/odepack/odepack_home.html">Vode</a>,
<a class="reference external" href="http://www.netlib.org/ode/rkc.f">rkc.f</a>, <a class="reference external" href="http://www.netlib.org/ode/rkf45.f">rkf45.f</a>, as well
as the ODE solvers in <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.html">SciPy</a>, <a class="reference external" href="http://docs.sympy.org/dev/modules/mpmath/calculus/odes.html">SymPy</a>, and <a class="reference external" href="http://olivierverdier.github.com/odelab/">odelab</a>.</p>
<p>The usage of Odespy follows this setup for the ODE <span class="math">\(u^{\prime}=-au\)</span>,
<span class="math">\(u(0)=I\)</span>, <span class="math">\(t\in (0,T]\)</span>, here solved
by the famous 4th-order Runge-Kutta method with <span class="math">\(\Delta t=1\)</span>
and <span class="math">\(N_t=6\)</span> steps:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">u</span>

<span class="kn">import</span> <span class="nn">odespy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span> <span class="n">Nt</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">RK4</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="n">t_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t_mesh</span><span class="p">)</span>
</pre></div>
</div>
<p>The previously listed methods for ODEs are all accessible in
Odespy:</p>
<blockquote>
<div><ul class="simple">
<li>the <span class="math">\(\theta\)</span>-rule: <code class="docutils literal"><span class="pre">ThetaRule</span></code></li>
<li>special cases of the <span class="math">\(\theta\)</span>-rule: <code class="docutils literal"><span class="pre">ForwardEuler</span></code>, <code class="docutils literal"><span class="pre">BackwardEuler</span></code>,
<code class="docutils literal"><span class="pre">CrankNicolson</span></code></li>
<li>the 2nd- and 4th-order Runge-Kutta methods: <code class="docutils literal"><span class="pre">RK2</span></code> and <code class="docutils literal"><span class="pre">RK4</span></code></li>
<li>The BDF methods and the Adam-Bashforth methods:
<code class="docutils literal"><span class="pre">Vode</span></code>, <code class="docutils literal"><span class="pre">Lsode</span></code>, <code class="docutils literal"><span class="pre">Lsoda</span></code>, <code class="docutils literal"><span class="pre">lsoda_scipy</span></code></li>
<li>The Leapfrog schemes: <code class="docutils literal"><span class="pre">Leapfrog</span></code> and <code class="docutils literal"><span class="pre">LeapfrogFiltered</span></code></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="example-runge-kutta-methods">
<h3>Example: Runge-Kutta methods<a class="headerlink" href="#example-runge-kutta-methods" title="Permalink to this headline">¶</a></h3>
<p>Since all solvers have the same interface in Odespy, except for a
potentially different set of
parameters in the solvers&#8217; constructors, one can easily make a list of
solver objects and run a loop for comparing a lot of solvers. The
code below, found in complete form in <a class="reference external" href="http://tinyurl.com/ofkw6kc/genz/decay_odespy.py">decay_odespy.py</a>,
compares the famous Runge-Kutta methods of orders 2, 3, and 4
with the exact solution of the decay equation
<span class="math">\(u^{\prime}=-au\)</span>.
Since we have quite long time steps, we have included the only
relevant <span class="math">\(\theta\)</span>-rule for large time steps, the Backward Euler scheme
(<span class="math">\(\theta=1\)</span>), as well.
Figure <a class="reference internal" href="#decay-odespy-fig1"><span class="std std-ref">Behavior of different schemes for the decay equation</span></a> shows the results.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">u</span>

<span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">T</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="k">else</span> <span class="mf">0.75</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="n">solvers</span> <span class="o">=</span> <span class="p">[</span><span class="n">odespy</span><span class="o">.</span><span class="n">RK2</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
           <span class="n">odespy</span><span class="o">.</span><span class="n">RK3</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
           <span class="n">odespy</span><span class="o">.</span><span class="n">RK4</span><span class="p">(</span><span class="n">f</span><span class="p">),]</span>

<span class="c"># BackwardEuler must use Newton solver to converge</span>
<span class="c"># (Picard is default and leads to divergence)</span>
<span class="n">solvers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
    <span class="n">odespy</span><span class="o">.</span><span class="n">BackwardEuler</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nonlinear_solver</span><span class="o">=</span><span class="s">&#39;Newton&#39;</span><span class="p">))</span>
<span class="c"># Or tell BackwardEuler that it is a linear problem</span>
<span class="n">solvers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">BackwardEuler</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f_is_linear</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                   <span class="n">jac</span><span class="o">=</span><span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="o">-</span><span class="n">a</span><span class="p">)]</span>
<span class="n">legends</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">solver</span> <span class="ow">in</span> <span class="n">solvers</span><span class="p">:</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
    <span class="n">legends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

<span class="c"># Compare with exact solution plotted on a very fine mesh</span>
<span class="n">t_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">10001</span><span class="p">)</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t_fine</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;-&#39;</span><span class="p">)</span> <span class="c"># avoid markers by specifying line type</span>
<span class="n">legends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;exact&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legends</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Time step: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">dt</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>With the <code class="docutils literal"><span class="pre">odespy.BackwardEuler</span></code> method we must either tell that
the problem is linear and provide the Jacobian of <span class="math">\(f(u,t)\)</span>, i.e.,
<span class="math">\(\partial f/\partial u\)</span>, as the <code class="docutils literal"><span class="pre">jac</span></code> argument, or we have to assume
that <span class="math">\(f\)</span> is nonlinear, but then specify Newton&#8217;s method as solver
for the nonlinear equations (since the equations are linear, Newton&#8217;s
method will converge in one iteration). By default,
<code class="docutils literal"><span class="pre">odespy.BackwardEuler</span></code> assumes a nonlinear problem to be solved by
Picard iteration, but that leads to divergence in the present problem.</p>
<div class="admonition-visualization-tip admonition">
<p class="first admonition-title">Visualization tip</p>
<p>We use Matplotlib for
plotting here, but one could alternatively import <code class="docutils literal"><span class="pre">scitools.std</span></code> as <code class="docutils literal"><span class="pre">plt</span></code> instead. Plain use of Matplotlib as done here results in
curves with different colors, which may be hard to distinguish on
black-and-white paper. Using <code class="docutils literal"><span class="pre">scitools.std</span></code>, curves are
automatically given colors <em>and</em> markers, thus making curves easy
to distinguish on screen with colors and on black-and-white paper.
The automatic adding of markers is normally a bad idea for a
very fine mesh since all the markers get cluttered, but <code class="docutils literal"><span class="pre">scitools.std</span></code> limits
the number of markers in such cases.
For the exact solution we use a very fine mesh, but in the code
above we specify the line type as a solid line (<code class="docutils literal"><span class="pre">-</span></code>), which means
no markers and just a color to be automatically determined by
the backend used for plotting (Matplotlib by default, but
<code class="docutils literal"><span class="pre">scitools.std</span></code> gives the opportunity to use other backends
to produce the plot, e.g., Gnuplot or Grace).</p>
<p class="last">Also note the that the legends
are based on the class names of the solvers, and in Python the name of
the class type (as a string) of an object <code class="docutils literal"><span class="pre">obj</span></code> is obtained by
<code class="docutils literal"><span class="pre">obj.__class__.__name__</span></code>.</p>
</div>
<div class="figure" id="id6">
<span id="decay-odespy-fig1"></span><a class="reference internal image-reference" href="_images/decay_odespy1_png.png"><img alt="_images/decay_odespy1_png.png" src="_images/decay_odespy1_png.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Behavior of different schemes for the decay equation</em></span></p>
</div>
<p>The runs in Figure <a class="reference internal" href="#decay-odespy-fig1"><span class="std std-ref">Behavior of different schemes for the decay equation</span></a>
and other experiments reveal that the 2nd-order Runge-Kutta
method (<code class="docutils literal"><span class="pre">RK2</span></code>) is unstable for <span class="math">\(\Delta t&gt;1\)</span> and decays slower than the
Backward Euler scheme for large and moderate <span class="math">\(\Delta t\)</span> (see <a class="reference internal" href="#decay-exer-rk2-taylor-analysis"><span class="std std-ref">Exercise 13: Analyze explicit 2nd-order methods</span></a> for an analysis).  However, for
fine <span class="math">\(\Delta t = 0.25\)</span> the 2nd-order Runge-Kutta method approaches
the exact solution faster than the Backward Euler scheme.  That is,
the latter scheme does a better job for larger <span class="math">\(\Delta t\)</span>, while the
higher order scheme is superior for smaller <span class="math">\(\Delta t\)</span>. This is a
typical trend also for most schemes for ordinary and partial
differential equations.</p>
<p>The 3rd-order Runge-Kutta method (<code class="docutils literal"><span class="pre">RK3</span></code>) also has artifacts in the form
of oscillatory behavior for the larger <span class="math">\(\Delta t\)</span> values, much
like that of the Crank-Nicolson scheme. For finer <span class="math">\(\Delta t\)</span>,
the 3rd-order Runge-Kutta method converges quickly to the exact
solution.</p>
<p>The 4th-order Runge-Kutta method (<code class="docutils literal"><span class="pre">RK4</span></code>) is slightly inferior
to the Backward Euler scheme on the coarsest mesh, but is then
clearly superior to all the other schemes. It is definitely the
method of choice for all the tested schemes.</p>
<div class="section" id="remark-about-using-the-rule-in-odespy">
<h4>Remark about using the <span class="math">\(\theta\)</span>-rule in Odespy<a class="headerlink" href="#remark-about-using-the-rule-in-odespy" title="Permalink to this headline">¶</a></h4>
<p>The Odespy package assumes that the ODE is written as <span class="math">\(u^{\prime}=f(u,t)\)</span> with
an <span class="math">\(f\)</span> that is possibly nonlinear in <span class="math">\(u\)</span>. The <span class="math">\(\theta\)</span>-rule for
<span class="math">\(u^{\prime}=f(u,t)\)</span> leads to</p>
<div class="math">
\[u^{n+1} = u^{n} + \Delta t\left(\theta f(u^{n+1}, t_{n+1})
+ (1-\theta) f(u^{n}, t_{n})\right),\]</div>
<p>which is a <em>nonlinear equation</em> in <span class="math">\(u^{n+1}\)</span>. Odespy&#8217;s implementation
of the <span class="math">\(\theta\)</span>-rule (<code class="docutils literal"><span class="pre">ThetaRule</span></code>) and the specialized Backward Euler
(<code class="docutils literal"><span class="pre">BackwardEuler</span></code>) and Crank-Nicolson (<code class="docutils literal"><span class="pre">CrankNicolson</span></code>) schemes
must invoke iterative methods for
solving the nonlinear equation in <span class="math">\(u^{n+1}\)</span>. This is done even when
<span class="math">\(f\)</span> is linear in <span class="math">\(u\)</span>, as in the model problem <span class="math">\(u^{\prime}=-au\)</span>, where we can
easily solve for <span class="math">\(u^{n+1}\)</span> by hand.  Therefore, we need to specify
use of Newton&#8217;s method to solve the equations.
(Odespy allows other methods than Newton&#8217;s to be used, for instance
Picard iteration, but that method is not suitable. The reason is that it
applies the Forward Euler scheme to generate a start value for
the iterations. Forward Euler may give very wrong solutions
for large <span class="math">\(\Delta t\)</span> values. Newton&#8217;s method, on the other hand,
is insensitive to the start value in <em>linear problems</em>.)</p>
</div>
</div>
<div class="section" id="example-adaptive-runge-kutta-methods">
<span id="decay-fd2-adaptiverk"></span><h3>Example: Adaptive Runge-Kutta methods<a class="headerlink" href="#example-adaptive-runge-kutta-methods" title="Permalink to this headline">¶</a></h3>
<p id="index-20">Odespy also offers solution methods that can adapt the size of <span class="math">\(\Delta t\)</span>
with time to match a desired accuracy in the solution. Intuitively,
small time steps will be chosen in areas where the solution is changing
rapidly, while larger time steps can be used where the solution
is slowly varying. Some kind of <em>error estimator</em> is used to
adjust the next time step at each time level.</p>
<span class="target" id="index-21"></span><p id="index-22">A very popular adaptive method for solving ODEs is the Dormand-Prince
Runge-Kutta method of order 4 and 5. The 5th-order method is used as a
reference solution and the difference between the 4th- and 5th-order
methods is used as an indicator of the error in the numerical
solution.  The Dormand-Prince method is the default choice in MATLAB&#8217;s
widely used <code class="docutils literal"><span class="pre">ode45</span></code> routine.</p>
<p>We can easily set up Odespy to use the Dormand-Prince method and
see how it selects the optimal time steps. To this end, we request
only one time step from <span class="math">\(t=0\)</span> to <span class="math">\(t=T\)</span> and ask the method to
compute the necessary non-uniform time mesh to meet a certain
error tolerance. The code goes like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">odespy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">decay_mod</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="c">#import matplotlib.pyplot as plt</span>
<span class="kn">import</span> <span class="nn">scitools.std</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">u</span>

<span class="k">def</span> <span class="nf">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">T</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">tol</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">DormandPrince</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">0.1</span><span class="o">*</span><span class="n">tol</span><span class="p">)</span>

<span class="n">Nt</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># just one step - let the scheme find its intermediate points</span>
<span class="n">t_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">10001</span><span class="p">)</span>

<span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t_mesh</span><span class="p">)</span>

<span class="c"># u and t will only consist of [I, u^Nt] and [0,T]</span>
<span class="c"># solver.u_all and solver.t_all contains all computed points</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">t_all</span><span class="p">,</span> <span class="n">solver</span><span class="o">.</span><span class="n">u_all</span><span class="p">,</span> <span class="s">&#39;ko&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t_fine</span><span class="p">),</span> <span class="s">&#39;b-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;tol=</span><span class="si">%.0E</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">tol</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp_odespy_adaptive.png&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Running four cases with tolerances <span class="math">\(10^{-1}\)</span>, <span class="math">\(10^{-3}\)</span>, <span class="math">\(10^{-5}\)</span>,
and <span class="math">\(10^{-7}\)</span>, gives the results in Figure <a class="reference internal" href="#decay-odespy-fig2"><span class="std std-ref">Choice of adaptive time mesh by the Dormand-Prince method for different tolerances</span></a>.
Intuitively, one would expect denser points in the beginning of
the decay and larger time steps when the solution flattens out.</p>
<div class="figure" id="id7">
<span id="decay-odespy-fig2"></span><a class="reference internal image-reference" href="_images/decay_DormandPrince_adaptivity.png"><img alt="_images/decay_DormandPrince_adaptivity.png" src="_images/decay_DormandPrince_adaptivity.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Choice of adaptive time mesh by the Dormand-Prince method for different tolerances</em></span></p>
</div>
</div>
</div>
<div class="section" id="exercises-3">
<h2>Exercises  (3)<a class="headerlink" href="#exercises-3" title="Permalink to this headline">¶</a></h2>
<div class="section" id="exercise-9-experiment-with-precision-in-tests-and-the-size-of">
<span id="decay-fd2-exer-precision"></span><h3>Exercise 9: Experiment with precision in tests and the size of <span class="math">\(u\)</span><a class="headerlink" href="#exercise-9-experiment-with-precision-in-tests-and-the-size-of" title="Permalink to this headline">¶</a></h3>
<p>It is claimed in the section <a class="reference internal" href="#decay-mms"><span class="std std-ref">Verification via manufactured solutions</span></a> that most numerical methods will
reproduce a linear exact solution to machine precision. Test this
assertion using the test function <code class="docutils literal"><span class="pre">test_linear_solution</span></code> in the
<a class="reference external" href="http://tinyurl.com/ofkw6kc/genz/decay_vc.py">decay_vc.py</a> program.
Vary the parameter <code class="docutils literal"><span class="pre">c</span></code> from very small, via <code class="docutils literal"><span class="pre">c=1</span></code> to many larger values,
and print out the maximum difference between the numerical solution
and the exact solution. What is the relevant value of the tolerance
in the float comparison in each case?</p>
<p>Filename: <code class="docutils literal"><span class="pre">test_precision</span></code>.</p>
</div>
<div class="section" id="exercise-10-implement-the-2-step-backward-scheme">
<span id="decay-fd2-exer-bw2"></span><h3>Exercise 10: Implement the 2-step backward scheme<a class="headerlink" href="#exercise-10-implement-the-2-step-backward-scheme" title="Permalink to this headline">¶</a></h3>
<p>Implement the 2-step backward method <a href="#equation-decay:fd2:bw:2step">(12)</a> for the
model <span class="math">\(u^{\prime}(t) = -a(t)u(t) + b(t)\)</span>, <span class="math">\(u(0)=I\)</span>.  Allow the first step to
be computed by either the Backward Euler scheme or the Crank-Nicolson
scheme. Verify the implementation by choosing <span class="math">\(a(t)\)</span> and <span class="math">\(b(t)\)</span> such
that the exact solution is linear in <span class="math">\(t\)</span> (see the section <a class="reference internal" href="#decay-mms"><span class="std std-ref">Verification via manufactured solutions</span></a>). Show mathematically that a linear solution is indeed a
solution of the discrete equations.</p>
<p>Compute convergence rates (see the section <a class="reference internal" href="#decay-convergence-rate"><span class="std std-ref">Computing convergence rates</span></a>) in
a test case using <span class="math">\(a=\hbox{const}\)</span> and <span class="math">\(b=0\)</span>, where we easily have an exact
solution, and determine if the choice of a first-order scheme
(Backward Euler) for the first step has any impact on the overall
accuracy of this scheme. The expected error goes like <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>.
Filename: <code class="docutils literal"><span class="pre">decay_backward2step</span></code>.</p>
</div>
<div class="section" id="exercise-11-implement-the-2nd-order-adams-bashforth-scheme">
<span id="decay-fd2-exer-ab2"></span><h3>Exercise 11: Implement the 2nd-order Adams-Bashforth scheme<a class="headerlink" href="#exercise-11-implement-the-2nd-order-adams-bashforth-scheme" title="Permalink to this headline">¶</a></h3>
<p>Implement the 2nd-order Adams-Bashforth method <a href="#equation-decay:fd2:AB2">(18)</a>
for the decay problem <span class="math">\(u^{\prime}=-a(t)u + b(t)\)</span>, <span class="math">\(u(0)=I\)</span>, <span class="math">\(t\in (0, T]\)</span>.
Use the Forward Euler method for the first step such that the overall
scheme is explicit. Verify the implementation using an exact
solution that is linear in time.
Analyze the scheme by searching for solutions <span class="math">\(u^n=A^n\)</span> when <span class="math">\(a=\hbox{const}\)</span>
and <span class="math">\(b=0\)</span>. Compare this second-order scheme to the Crank-Nicolson scheme.
Filename: <code class="docutils literal"><span class="pre">decay_AdamsBashforth2</span></code>.</p>
</div>
<div class="section" id="exercise-12-implement-the-3rd-order-adams-bashforth-scheme">
<span id="decay-fd2-exer-ab3"></span><h3>Exercise 12: Implement the 3rd-order Adams-Bashforth scheme<a class="headerlink" href="#exercise-12-implement-the-3rd-order-adams-bashforth-scheme" title="Permalink to this headline">¶</a></h3>
<p>Implement the 3rd-order Adams-Bashforth method <a href="#equation-decay:fd2:AB3">(19)</a>
for the decay problem <span class="math">\(u^{\prime}=-a(t)u + b(t)\)</span>, <span class="math">\(u(0)=I\)</span>, <span class="math">\(t\in (0, T]\)</span>.
Since the scheme is explicit, allow it to be started by two steps with
the Forward Euler method.  Investigate experimentally the case where
<span class="math">\(b=0\)</span> and <span class="math">\(a\)</span> is a constant: Can we have oscillatory solutions for
large <span class="math">\(\Delta t\)</span>?
Filename: <code class="docutils literal"><span class="pre">decay_AdamsBashforth3</span></code>.</p>
</div>
<div class="section" id="exercise-13-analyze-explicit-2nd-order-methods">
<span id="decay-exer-rk2-taylor-analysis"></span><h3>Exercise 13: Analyze explicit 2nd-order methods<a class="headerlink" href="#exercise-13-analyze-explicit-2nd-order-methods" title="Permalink to this headline">¶</a></h3>
<p>Show that the schemes <a href="#equation-decay:fd2:RK2:s2">(16)</a> and
<a href="#equation-decay:fd2:Taylor2">(17)</a> are identical in the case <span class="math">\(f(u,t)=-a\)</span>, where
<span class="math">\(a&gt;0\)</span> is a constant. Assume that the numerical solution reads
<span class="math">\(u^n=A^n\)</span> for some unknown amplification factor <span class="math">\(A\)</span> to be determined.
Find <span class="math">\(A\)</span> and derive stability criteria. Can the scheme produce
oscillatory solutions of <span class="math">\(u^{\prime}=-au\)</span>? Plot the numerical and exact
amplification factor.
Filename: <code class="docutils literal"><span class="pre">decay_RK2_Taylor2</span></code>.</p>
</div>
<div class="section" id="project-14-implement-and-investigate-the-leapfrog-scheme">
<span id="decay-fd2-exer-leapfrog1"></span><h3>Project 14: Implement and investigate the Leapfrog scheme<a class="headerlink" href="#project-14-implement-and-investigate-the-leapfrog-scheme" title="Permalink to this headline">¶</a></h3>
<p>A Leapfrog scheme
for the ODE <span class="math">\(u^{\prime}(t) = -a(t)u(t) + b(t)\)</span> is defined by</p>
<div class="math">
\[\lbrack D_{2t}u = -au+b\rbrack^n{\thinspace .}\]</div>
<p>A separate method is needed to compute <span class="math">\(u^1\)</span>. The Forward Euler
scheme is a possible candidate.</p>
<p><strong>a)</strong>
Implement the Leapfrog scheme for the model equation.
Plot the solution in the case <span class="math">\(a=1\)</span>, <span class="math">\(b=0\)</span>, <span class="math">\(I=1\)</span>,
<span class="math">\(\Delta t = 0.01\)</span>, <span class="math">\(t\in [0,4]\)</span>. Compare with the exact
solution <span class="math">\({u_{\small\mbox{e}}}(t)=e^{-t}\)</span>.</p>
<p><strong>b)</strong>
Show mathematically that a linear solution in <span class="math">\(t\)</span> fulfills the
Forward Euler scheme for the first step and the Leapfrog scheme
for the subsequent steps. Use this linear solution to verify
the implementation, and automate the verification through a test
function.</p>
<p><strong>Hint.</strong>
It can be wise to automate the calculations such that it is easy to
redo the calculations for other types of solutions. Here is
a possible <code class="docutils literal"><span class="pre">sympy</span></code> function that takes a symbolic expression <code class="docutils literal"><span class="pre">u</span></code>
(implemented as a Python function of <code class="docutils literal"><span class="pre">t</span></code>), fits the <code class="docutils literal"><span class="pre">b</span></code> term, and
checks if <code class="docutils literal"><span class="pre">u</span></code> fulfills the discrete equations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>

<span class="k">def</span> <span class="nf">analyze</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;t dt a&#39;</span><span class="p">)</span>

    <span class="k">print</span> <span class="s">&#39;Analyzing u_e(t)=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;u(0)=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c"># Fit source term to the given u(t)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;Source term b:&#39;</span><span class="p">,</span> <span class="n">b</span>

    <span class="c"># Residual in discrete equations; Forward Euler step</span>
    <span class="n">R_step1</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="o">/</span><span class="n">dt</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">b</span>
    <span class="n">R_step1</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R_step1</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;Residual Forward Euler step:&#39;</span><span class="p">,</span> <span class="n">R_step1</span>

    <span class="c"># Residual in discrete equations; Leapfrog steps</span>
    <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">dt</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">b</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;Residual Leapfrog steps:&#39;</span><span class="p">,</span> <span class="n">R</span>

<span class="k">def</span> <span class="nf">u_e</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">c</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span>

<span class="n">analyze</span><span class="p">(</span><span class="n">u_e</span><span class="p">)</span>
<span class="c"># or short form: analyze(lambda t: c*t + I)</span>
</pre></div>
</div>
<p><strong>c)</strong>
Show that a second-order polynomial in <span class="math">\(t\)</span> cannot be a solution of the discrete
equations. However, if a Crank-Nicolson scheme is used for the first
step, a second-order polynomial solves the equations exactly.</p>
<p><strong>d)</strong>
Create a manufactured solution <span class="math">\(u(t)=\sin(t)\)</span> for the ODE
<span class="math">\(u^{\prime}=-au+b\)</span>.
Compute the convergence rate of the Leapfrog scheme using this
manufactured solution. The expected convergence rate of the
Leapfrog scheme is <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>. Does the use of a
1st-order method for the first step impact the convergence rate?</p>
<p><strong>e)</strong>
Set up a set of experiments to demonstrate that the Leapfrog scheme
<a href="#equation-decay:fd2:leapfrog">(13)</a> is associated with numerical artifacts
(instabilities). Document the main results from this investigation.</p>
<p><strong>f)</strong>
Analyze and explain the
instabilities of the Leapfrog scheme <a href="#equation-decay:fd2:leapfrog">(13)</a>:</p>
<ol class="arabic simple">
<li>Choose <span class="math">\(a=\mbox{const}\)</span> and <span class="math">\(b=0\)</span>. Assume that an exact solution
of the discrete equations has
the form <span class="math">\(u^n=A^n\)</span>, where <span class="math">\(A\)</span> is an amplification factor to
be determined. Derive an equation for <span class="math">\(A\)</span> by inserting <span class="math">\(u^n=A^n\)</span>
in the Leapfrog scheme.</li>
<li>Compute <span class="math">\(A\)</span> either by hand and/or with the aid of <code class="docutils literal"><span class="pre">sympy</span></code>.
The polynomial for <span class="math">\(A\)</span> has two roots, <span class="math">\(A_1\)</span> and <span class="math">\(A_2\)</span>. Let
<span class="math">\(u^n\)</span> be a linear combination <span class="math">\(u^n=C_1A_1^n + C_2A_2^n\)</span>.</li>
<li>Show that one of the roots is the reason for instability.</li>
<li>Compare <span class="math">\(A\)</span> with the exact expression, using a Taylor series approximation.</li>
<li>How can <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> be determined?</li>
</ol>
<p><strong>g)</strong>
Since the original Leapfrog scheme is unconditionally unstable as time
grows, it demands some stabilization.  This can be done by filtering,
where we first find <span class="math">\(u^{n+1}\)</span> from the original Leapfrog scheme and
then replace <span class="math">\(u^{n}\)</span> by <span class="math">\(u^n + \gamma (u^{n-1} - 2u^n +
u^{n+1})\)</span>, where <span class="math">\(\gamma\)</span> can be taken as 0.6.  Implement the filtered
Leapfrog scheme and check that it can handle tests where the original
Leapfrog scheme is unstable.</p>
<p>Filename: <code class="docutils literal"><span class="pre">decay_leapfrog</span></code>.</p>
</div>
<div class="section" id="problem-15-make-a-unified-implementation-of-many-schemes">
<span id="decay-fd2-exer-uni"></span><h3>Problem 15: Make a unified implementation of many schemes<a class="headerlink" href="#problem-15-make-a-unified-implementation-of-many-schemes" title="Permalink to this headline">¶</a></h3>
<p>Consider the linear ODE problem <span class="math">\(u^{\prime}(t)=-a(t)u(t) + b(t)\)</span>, <span class="math">\(u(0)=I\)</span>.
Explicit schemes for this problem can be written in the general form</p>
<div class="math" id="equation-decay:analysis:exer:sumcj">
<span id="eq-decay-analysis-exer-sumcj"></span><span class="eqno">(23)</span>\[     u^{n+1} = \sum_{j=0}^m c_ju^{n-j},\]</div>
<p>for some choice of <span class="math">\(c_0,\ldots,c_m\)</span>.
Find expressions for the <span class="math">\(c_j\)</span> coefficients in case of the
<span class="math">\(\theta\)</span>-rule, the three-level backward scheme,
the Leapfrog scheme, the 2nd-order Runge-Kutta method,
and the 3rd-order Adams-Bashforth scheme.</p>
<p>Make a class <code class="docutils literal"><span class="pre">ExpDecay</span></code> that implements the
general updating formula <a href="#equation-decay:analysis:exer:sumcj">(23)</a>.
The formula cannot be applied for <span class="math">\(n &lt; m\)</span>, and for those <span class="math">\(n\)</span> values, other
schemes must be used. Assume for simplicity that we just
repeat Crank-Nicolson steps until <a href="#equation-decay:analysis:exer:sumcj">(23)</a> can be used.
Use a subclass
to specify the list <span class="math">\(c_0,\ldots,c_m\)</span> for a particular method, and
implement subclasses for all the mentioned schemes.
Verify the implementation by testing with a linear solution, which should
be exactly reproduced by all methods.
Filename: <code class="docutils literal"><span class="pre">decay_schemes_unified</span></code>.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Generalizations</a><ul>
<li><a class="reference internal" href="#model-extensions">Model extensions</a><ul>
<li><a class="reference internal" href="#generalization-including-a-variable-coefficient">Generalization: including a variable coefficient</a></li>
<li><a class="reference internal" href="#generalization-including-a-source-term">Generalization: including a source term</a></li>
<li><a class="reference internal" href="#implementation-of-the-generalized-model-problem">Implementation of the generalized model problem</a><ul>
<li><a class="reference internal" href="#deriving-the-rule-formula">Deriving the <span class="math">\(\theta\)</span>-rule formula</a></li>
<li><a class="reference internal" href="#python-code">Python code</a></li>
<li><a class="reference internal" href="#coding-of-variable-coefficients">Coding of variable coefficients</a></li>
</ul>
</li>
<li><a class="reference internal" href="#verifying-a-constant-solution">Verifying a constant solution</a></li>
<li><a class="reference internal" href="#verification-via-manufactured-solutions">Verification via manufactured solutions</a></li>
<li><a class="reference internal" href="#computing-convergence-rates">Computing convergence rates</a><ul>
<li><a class="reference internal" href="#estimating">Estimating <span class="math">\(r\)</span></a></li>
<li><a class="reference internal" href="#implementation-2">Implementation  (2)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#extension-to-systems-of-odes">Extension to systems of ODEs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#general-first-order-odes">General first-order ODEs</a><ul>
<li><a class="reference internal" href="#generic-form-of-first-order-odes">Generic form of first-order ODEs</a></li>
<li><a class="reference internal" href="#the-rule">The <span class="math">\(\theta\)</span>-rule</a></li>
<li><a class="reference internal" href="#an-implicit-2-step-backward-scheme">An implicit 2-step backward scheme</a></li>
<li><a class="reference internal" href="#leapfrog-schemes">Leapfrog schemes</a><ul>
<li><a class="reference internal" href="#the-ordinary-leapfrog-scheme">The ordinary Leapfrog scheme</a></li>
<li><a class="reference internal" href="#the-filtered-leapfrog-scheme">The filtered Leapfrog scheme</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-2nd-order-runge-kutta-method">The 2nd-order Runge-Kutta method</a></li>
<li><a class="reference internal" href="#a-2nd-order-taylor-series-method">A 2nd-order Taylor-series method</a></li>
<li><a class="reference internal" href="#the-2nd-and-3rd-order-adams-bashforth-schemes">The 2nd- and 3rd-order Adams-Bashforth schemes</a></li>
<li><a class="reference internal" href="#the-4th-order-runge-kutta-method">The 4th-order Runge-Kutta method</a></li>
<li><a class="reference internal" href="#the-odespy-software">The Odespy software</a></li>
<li><a class="reference internal" href="#example-runge-kutta-methods">Example: Runge-Kutta methods</a><ul>
<li><a class="reference internal" href="#remark-about-using-the-rule-in-odespy">Remark about using the <span class="math">\(\theta\)</span>-rule in Odespy</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-adaptive-runge-kutta-methods">Example: Adaptive Runge-Kutta methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-3">Exercises  (3)</a><ul>
<li><a class="reference internal" href="#exercise-9-experiment-with-precision-in-tests-and-the-size-of">Exercise 9: Experiment with precision in tests and the size of <span class="math">\(u\)</span></a></li>
<li><a class="reference internal" href="#exercise-10-implement-the-2-step-backward-scheme">Exercise 10: Implement the 2-step backward scheme</a></li>
<li><a class="reference internal" href="#exercise-11-implement-the-2nd-order-adams-bashforth-scheme">Exercise 11: Implement the 2nd-order Adams-Bashforth scheme</a></li>
<li><a class="reference internal" href="#exercise-12-implement-the-3rd-order-adams-bashforth-scheme">Exercise 12: Implement the 3rd-order Adams-Bashforth scheme</a></li>
<li><a class="reference internal" href="#exercise-13-analyze-explicit-2nd-order-methods">Exercise 13: Analyze explicit 2nd-order methods</a></li>
<li><a class="reference internal" href="#project-14-implement-and-investigate-the-leapfrog-scheme">Project 14: Implement and investigate the Leapfrog scheme</a></li>
<li><a class="reference internal" href="#problem-15-make-a-unified-implementation-of-many-schemes">Problem 15: Make a unified implementation of many schemes</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book005.html"
                        title="previous chapter">Analysis</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book007.html"
                        title="next chapter">Models</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book006.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book007.html" title="Models"
             >next</a> |</li>
        <li class="right" >
          <a href="._book005.html" title="Analysis"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with Exponential Decay Models</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2015, Hans Petter Langtangen.
  </div>
</div>

  </body>
</html>