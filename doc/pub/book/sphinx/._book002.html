
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Vibration ODEs</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Finite Difference Computing with Partial Differential Equations" href="index.html" />
    <link rel="next" title="Wave equations" href="._book003.html" />
    <link rel="prev" title="Preface" href="._book001.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book003.html" title="Wave equations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book001.html" title="Preface"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with Partial Differential Equations</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="vibration-odes">
<h1>Vibration ODEs<a class="headerlink" href="#vibration-odes" title="Permalink to this headline">¶</a></h1>
<p>Vibration problems lead to differential equations with solutions that
oscillate in time, typically in a damped or undamped sinusoidal
fashion.  Such solutions put certain demands on the numerical methods
compared to other phenomena whose solutions are monotone or very smooth.
Both the frequency and amplitude of the oscillations need to be
accurately handled by the numerical schemes. Most of the reasoning and
specific building blocks introduced in the forthcoming text can be
reused to construct sound methods for partial differential equations
of wave nature in multiple spatial dimensions.</p>
<p>[<strong>hpl 1</strong>: Need to discuss errors also for the damped and nonlinear models. At least the frequency errors must be illustrated here as well and investigated numerically, either in text or exercises.]</p>
<div class="section" id="finite-difference-discretization">
<span id="vib-model1"></span><h2>Finite difference discretization<a class="headerlink" href="#finite-difference-discretization" title="Permalink to this headline">¶</a></h2>
<p>Many of the numerical challenges faced when computing oscillatory
solutions to ODEs and PDEs can be captured by the very simple ODE
<span class="math">\(u^{\prime\prime} + u =0\)</span>. This ODE is thus chosen as our starting
point for method development, implementation, and analysis.</p>
<div class="section" id="a-basic-model-for-vibrations">
<h3>A basic model for vibrations<a class="headerlink" href="#a-basic-model-for-vibrations" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><p id="index-2">A system that vibrates without damping and external forcing
can be described by the ODE problem</p>
<div class="math" id="eq-vib-ode1">
\[\tag{1}
u^{\prime\prime} + \omega^2u = 0,\quad u(0)=I,\ u^{\prime}(0)=0,\ t\in (0,T]
    \tp\]</div>
<p>Here, <span class="math">\(\omega\)</span> and <span class="math">\(I\)</span> are given constants.
The exact solution of <a class="reference internal" href="#eq-vib-ode1"><span class="std std-ref">(1)</span></a> is</p>
<span class="target" id="index-3"></span><span class="target" id="index-4"></span><div class="math" id="eq-vib-ode1-uex">
<span id="index-5"></span>\[\tag{2}
u(t) = I\cos (\omega t)
    \tp\]</div>
<p>That is, <span class="math">\(u\)</span> oscillates with constant amplitude <span class="math">\(I\)</span> and
angular frequency <span class="math">\(\omega\)</span>.
The corresponding period of oscillations (i.e., the time between two
neighboring peaks in the cosine function) is <span class="math">\(P=2\pi/\omega\)</span>.
The number of periods per second
is <span class="math">\(f=\omega/(2\pi)\)</span> and measured in the unit Hz.
Both <span class="math">\(f\)</span> and <span class="math">\(\omega\)</span> are referred to as frequency, but <span class="math">\(\omega\)</span>
is more precisely named <em>angular frequency</em>, measured in rad/s.</p>
<p>In vibrating mechanical systems modeled by <a class="reference internal" href="#eq-vib-ode1"><span class="std std-ref">(1)</span></a>, <span class="math">\(u(t)\)</span>
very often represents a position or a displacement of a particular
point in the system. The derivative <span class="math">\(u^{\prime}(t)\)</span> then has the
interpretation of velocity, and <span class="math">\(u^{\prime\prime}(t)\)</span> is the associated
acceleration.  The model <a class="reference internal" href="#eq-vib-ode1"><span class="std std-ref">(1)</span></a> is not only
applicable to vibrating mechanical systems, but also to oscillations
in electrical circuits.</p>
</div>
<div class="section" id="a-centered-finite-difference-scheme">
<span id="vib-ode1-fdm"></span><h3>A centered finite difference scheme<a class="headerlink" href="#a-centered-finite-difference-scheme" title="Permalink to this headline">¶</a></h3>
<p>To formulate a finite difference method for the model
problem  <a class="reference internal" href="#eq-vib-ode1"><span class="std std-ref">(1)</span></a> we follow the <a class="reference external" href="http://tinyurl.com/opdfafk/pub/sphinx-decay/main_decay.html#the-forward-euler-scheme">four steps</a> explained in <a class="reference internal" href="._book017.html#ref2" id="id1">[Ref2]</a>.</p>
<span class="target" id="index-6"></span><div class="section" id="step-1-discretizing-the-domain">
<span id="index-7"></span><h4>Step 1: Discretizing the domain<a class="headerlink" href="#step-1-discretizing-the-domain" title="Permalink to this headline">¶</a></h4>
<p>The domain is discretized by
introducing a uniformly partitioned time mesh.
The points in the mesh are <span class="math">\(t_n=n\Delta t\)</span>, <span class="math">\(n=0,1,\ldots,N_t\)</span>,
where <span class="math">\(\Delta t = T/N_t\)</span> is the constant length of the time steps.
We introduce a mesh function <span class="math">\(u^n\)</span> for <span class="math">\(n=0,1,\ldots,N_t\)</span>, which
approximates the exact solution at the mesh points. The mesh
function will be computed from algebraic equations derived from
the differential equation problem.</p>
</div>
<div class="section" id="step-2-fulfilling-the-equation-at-discrete-time-points">
<h4>Step 2: Fulfilling the equation at discrete time points<a class="headerlink" href="#step-2-fulfilling-the-equation-at-discrete-time-points" title="Permalink to this headline">¶</a></h4>
<p>The ODE is to be satisfied at each mesh point:</p>
<div class="math" id="eq-vib-ode1-step2">
\[\tag{3}
u^{\prime\prime}(t_n) + \omega^2u(t_n) = 0,\quad n=1,\ldots,N_t
    \tp\]</div>
<span class="target" id="index-8"></span></div>
<div class="section" id="step-3-replacing-derivatives-by-finite-differences">
<span id="index-9"></span><h4>Step 3: Replacing derivatives by finite differences<a class="headerlink" href="#step-3-replacing-derivatives-by-finite-differences" title="Permalink to this headline">¶</a></h4>
<p>The derivative <span class="math">\(u^{\prime\prime}(t_n)\)</span> is to be replaced by a finite
difference approximation. A common second-order accurate approximation
to the second-order derivative is</p>
<div class="math" id="eq-vib-ode1-step3">
\[\tag{4}
u^{\prime\prime}(t_n) \approx \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
    \tp\]</div>
<p>Inserting <a class="reference internal" href="#eq-vib-ode1-step3"><span class="std std-ref">(4)</span></a> in <a class="reference internal" href="#eq-vib-ode1-step2"><span class="std std-ref">(3)</span></a>
yields</p>
<div class="math" id="eq-vib-ode1-step3b">
\[\tag{5}
\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2} = -\omega^2 u^n
    \tp\]</div>
<p>We also need to replace the derivative in the initial condition by
a finite difference. Here we choose a centered difference, whose
accuracy is similar to the centered difference we used for <span class="math">\(u^{\prime\prime}\)</span>:</p>
<div class="math" id="eq-vib-ode1-step3c">
\[\tag{6}
\frac{u^1-u^{-1}}{2\Delta t} = 0\]\[    \tp\]</div>
</div>
<div class="section" id="step-4-formulating-a-recursive-algorithm">
<h4>Step 4: Formulating a recursive algorithm<a class="headerlink" href="#step-4-formulating-a-recursive-algorithm" title="Permalink to this headline">¶</a></h4>
<p>To formulate the computational algorithm, we assume that we
have already computed <span class="math">\(u^{n-1}\)</span> and <span class="math">\(u^n\)</span> such that <span class="math">\(u^{n+1}\)</span> is the
unknown value, which we can readily solve for:</p>
<div class="math" id="eq-vib-ode1-step4">
\[\tag{7}
u^{n+1} = 2u^n - u^{n-1} - \Delta t^2\omega^2 u^n
    \tp\]</div>
<p>The computational algorithm is simply to apply <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a>
successively for <span class="math">\(n=1,2,\ldots,N_t-1\)</span>. This numerical scheme sometimes
goes under the name
Stormer&#8217;s
method or <a class="reference external" href="http://en.wikipedia.org/wiki/Verlet_integration">Verlet integration</a>.</p>
</div>
<div class="section" id="computing-the-first-step">
<h4>Computing the first step<a class="headerlink" href="#computing-the-first-step" title="Permalink to this headline">¶</a></h4>
<p>We observe that <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a> cannot be used for <span class="math">\(n=0\)</span> since
the computation of <span class="math">\(u^1\)</span> then involves the undefined value <span class="math">\(u^{-1}\)</span>
at <span class="math">\(t=-\Delta t\)</span>. The discretization of the initial condition
then comes to our rescue: <a class="reference internal" href="#eq-vib-ode1-step3c"><span class="std std-ref">(6)</span></a> implies <span class="math">\(u^{-1} = u^1\)</span>
and this relation can be combined with <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a>
for <span class="math">\(n=1\)</span> to yield a value for <span class="math">\(u^1\)</span>:</p>
<div class="math">
\[u^1 = 2u^0 - u^{1} - \Delta t^2 \omega^2 u^0,\]</div>
<p>which reduces to</p>
<div class="math" id="eq-vib-ode1-step4b">
\[\tag{8}
u^1 = u^0 - \half \Delta t^2 \omega^2 u^0
    \tp\]</div>
<p><a class="reference internal" href="#vib-exer-step4b-alt"><span class="std std-ref">Exercise 5: Use a Taylor polynomial to compute </span></a> asks you to perform an alternative derivation
and also to generalize the initial condition to <span class="math">\(u^{\prime}(0)=V\neq 0\)</span>.</p>
</div>
<div class="section" id="the-computational-algorithm">
<h4>The computational algorithm<a class="headerlink" href="#the-computational-algorithm" title="Permalink to this headline">¶</a></h4>
<p>The steps for solving <a class="reference internal" href="#eq-vib-ode1"><span class="std std-ref">(1)</span></a> becomes</p>
<blockquote>
<div><ol class="arabic simple">
<li><span class="math">\(u^0=I\)</span></li>
<li>compute <span class="math">\(u^1\)</span> from <a class="reference internal" href="#eq-vib-ode1-step4b"><span class="std std-ref">(8)</span></a></li>
<li>for <span class="math">\(n=1,2,\ldots,N_t-1\)</span>:</li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li>compute <span class="math">\(u^{n+1}\)</span> from <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a></li>
</ol>
</div></blockquote>
</div></blockquote>
<p>The algorithm is more precisely expressed directly in Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># mesh points in time</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>          <span class="c"># constant time step</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c"># solution</span>

<span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
<span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition-remark-on-using-w-for-math-omega admonition">
<p class="first admonition-title">Remark on using <code class="docutils literal"><span class="pre">w</span></code> for <span class="math">\(\omega\)</span></p>
<p class="last">In the code, we use <code class="docutils literal"><span class="pre">w</span></code> as the symbol for <span class="math">\(\omega\)</span>.
The reason is that this author prefers <code class="docutils literal"><span class="pre">w</span></code> for readability
and comparison with the mathematical <span class="math">\(\omega\)</span> instead of
the full word <code class="docutils literal"><span class="pre">omega</span></code> as variable name.</p>
</div>
</div>
<div class="section" id="operator-notation">
<h4>Operator notation<a class="headerlink" href="#operator-notation" title="Permalink to this headline">¶</a></h4>
<p>We may write the scheme using a compact difference notation
listed in Appendix <a class="reference internal" href="._book010.html#sec-form-fdop"><span class="std std-ref">Finite difference operator notation</span></a>
(see also
<a class="reference external" href="http://tinyurl.com/opdfafk/pub/sphinx-decay/main_decay.html#compact-operator-notation-for-finite-differences">examples</a> in <a class="reference internal" href="._book017.html#ref2" id="id2">[Ref2]</a>).
The difference <a class="reference internal" href="#eq-vib-ode1-step3"><span class="std std-ref">(4)</span></a> has the operator
notation <span class="math">\([D_tD_t u]^n\)</span> such that we can write:</p>
<div class="math" id="eq-vib-ode1-step4-op">
\[\tag{9}
[D_tD_t u  + \omega^2 u = 0]^n
    \tp\]</div>
<p>Note that <span class="math">\([D_tD_t u]^n\)</span> means applying a central difference with step <span class="math">\(\Delta t/2\)</span> twice:</p>
<div class="math">
\[[D_t(D_t u)]^n = \frac{[D_t u]^{n+\half} - [D_t u]^{n-\half}}{\Delta t}\]</div>
<p>which is written out as</p>
<div class="math">
\[\frac{1}{\Delta t}\left(\frac{u^{n+1}-u^n}{\Delta t} - \frac{u^{n}-u^{n-1}}{\Delta t}\right) = \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
\tp\]</div>
<p>The discretization of initial conditions can in the operator notation
be expressed as</p>
<div class="math" id="eq-auto1">
\[\tag{10}
[u = I]^0,\quad [D_{2t} u = 0]^0,\]</div>
<p>where the operator <span class="math">\([D_{2t} u]^n\)</span> is defined as</p>
<div class="math" id="eq-auto2">
\[\tag{11}
[D_{2t} u]^n = \frac{u^{n+1} - u^{n-1}}{2\Delta t}
    \tp\]</div>
</div>
</div>
</div>
<div class="section" id="implementation-1">
<span id="vib-impl1"></span><h2>Implementation<a class="headerlink" href="#implementation-1" title="Permalink to this headline">¶</a></h2>
<div class="section" id="making-a-solver-function">
<span id="vib-impl1-solver"></span><h3>Making a solver function<a class="headerlink" href="#making-a-solver-function" title="Permalink to this headline">¶</a></h3>
<p>The algorithm from the previous section is readily translated to
a complete Python function for computing and returning
<span class="math">\(u^0,u^1,\ldots,u^{N_t}\)</span> and <span class="math">\(t_0,t_1,\ldots,t_{N_t}\)</span>, given the
input <span class="math">\(I\)</span>, <span class="math">\(\omega\)</span>, <span class="math">\(\Delta t\)</span>, and <span class="math">\(T\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;&#39; + w**2*u = 0 for t in (0,T], u(0)=I and u&#39;(0)=0,</span>
<span class="sd">    by a central finite difference method with time step dt.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>We do a simple <code class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> to make the code as close as
possible to MATLAB, although good programming habits would prefix
the <code class="docutils literal"><span class="pre">numpy</span></code> and <code class="docutils literal"><span class="pre">matplotlib</span></code> calls by (abbreviations of) the module
name.</p>
<p>[<strong>hpl 2</strong>: Refer to right section in decay book for prefix discussion.]</p>
<p>A function for plotting the numerical and the exact solution is also
convenient to have:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">visualize</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;r--o&#39;</span><span class="p">)</span>
    <span class="n">t_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1001</span><span class="p">)</span>  <span class="c"># very fine mesh for u_e</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;upper left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;dt=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">umin</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">();</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp1.png&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp1.pdf&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>A corresponding main program calling these functions for a simulation
of a given number of periods (<code class="docutils literal"><span class="pre">num_periods</span></code>) may take the form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">I</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">num_periods</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>    <span class="c">#  one period</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">num_periods</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
<span class="n">visualize</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>Adjusting some of the input parameters via the command line can be
handy. Here is a code segment using the <code class="docutils literal"><span class="pre">ArgumentParser</span></code> tool in
the <code class="docutils literal"><span class="pre">argparse</span></code> module to define option value (<code class="docutils literal"><span class="pre">--option</span> <span class="pre">value</span></code>)
pairs on the command line:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">argparse</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--I&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--w&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--dt&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--num_periods&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
<span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">num_periods</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">num_periods</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Such parsing of the command line is explained in more detailed in</dt>
<dd>the</dd>
</dl>
<p>&#8220;section on user interfaces&#8221;: &#8221;...&#8221; in <a class="reference internal" href="._book017.html#ref2" id="id3">[Ref2]</a>.</p>
<p>[<strong>hpl 3</strong>: Fix reference to web document.]</p>
<p>A typical execution goes like</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python vib_undamped.py --num_periods 20 --dt 0.1
</pre></div>
</div>
<div class="section" id="computing">
<h4>Computing <span class="math">\(u^{\prime}\)</span><a class="headerlink" href="#computing" title="Permalink to this headline">¶</a></h4>
<p>In mechanical vibration applications one is often interested in
computing the velocity <span class="math">\(v(t)=u^{\prime}(t)\)</span> after <span class="math">\(u(t)\)</span> has been computed.
This can be done by a central difference,</p>
<div class="math" id="eq-auto3">
\[\tag{12}
v(t_n)=u^{\prime}(t_n) \approx v^n = \frac{u^{n+1}-u^{n-1}}{2\Delta t} = [D_{2t}u]^n
    \tp\]</div>
<p>This formula applies for all inner mesh points, <span class="math">\(n=1,\ldots,N_t-1\)</span>.
For <span class="math">\(n=0\)</span>, <span class="math">\(v(0)\)</span> is given by the initial condition on <span class="math">\(u^{\prime}(0)\)</span>,
and for <span class="math">\(n=N_t\)</span> we can use a one-sided, backward difference:</p>
<div class="math">
\[v^n=[D_t^-u]^n = \frac{u^{n} - u^{n-1}}{\Delta t}\tp\]</div>
<p>Typical (scalar) code is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>  <span class="c"># or v = np.zeros(len(u))</span>
<span class="c"># Use central difference for internal points</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="c"># Use initial condition for u&#39;(0) when i=0</span>
<span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c"># Use backward difference at the final mesh point</span>
<span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">dt</span>
</pre></div>
</div>
<p>We can get rid of the loop, which is slow for large <span class="math">\(N_t\)</span>, by
vectorizing the central difference. The above code segment
goes as follows in its vectorized version:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>  <span class="c"># central difference</span>
<span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>                           <span class="c"># boundary condition u&#39;(0)</span>
<span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">dt</span>         <span class="c"># backward difference</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="verification-1">
<span id="vib-ode1-verify"></span><h3>Verification<a class="headerlink" href="#verification-1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="manual-calculation">
<h4>Manual calculation<a class="headerlink" href="#manual-calculation" title="Permalink to this headline">¶</a></h4>
<p>The simplest type of verification, which is also instructive for understanding
the algorithm, is to compute <span class="math">\(u^1\)</span>, <span class="math">\(u^2\)</span>, and <span class="math">\(u^3\)</span>
with the aid of a calculator
and make a function for comparing these results with those from the <code class="docutils literal"><span class="pre">solver</span></code>
function. The <code class="docutils literal"><span class="pre">test_three_steps</span></code> function in
the file <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib_undamped.py">vib_undamped.py</a>
shows the details how we use the hand calculations to test the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_three_steps</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">;</span>  <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>  <span class="n">T</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">u_by_hand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.000000000000000</span><span class="p">,</span>
                          <span class="mf">0.802607911978213</span><span class="p">,</span>
                          <span class="mf">0.288358920740053</span><span class="p">])</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_by_hand</span> <span class="o">-</span> <span class="n">u</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
</div>
<div class="section" id="testing-very-simple-solutions">
<h4>Testing very simple solutions<a class="headerlink" href="#testing-very-simple-solutions" title="Permalink to this headline">¶</a></h4>
<p>Constructing test problems where the exact solution is constant or
linear helps initial debugging and verification as one expects any
reasonable numerical method to reproduce such solutions to machine
precision.  Second-order accurate methods will often also reproduce a
quadratic solution.  Here <span class="math">\([D_tD_tt^2]^n=2\)</span>, which is the exact
result. A solution <span class="math">\(u=t^2\)</span> leads to <span class="math">\(u^{\prime\prime}+\omega^2 u=2 + (\omega
t)^2\neq 0\)</span>.  We must therefore add a source in the equation: <span class="math">\(u^{\prime\prime} +
\omega^2 u = f\)</span> to allow a solution <span class="math">\(u=t^2\)</span> for <span class="math">\(f=(\omega t)^2\)</span>.  By
simple insertion we can show that the mesh function <span class="math">\(u^n = t_n^2\)</span> is
also a solution of the discrete equations.  <a class="reference internal" href="#vib-exer-undamped-verify-linquad"><span class="std std-ref">Problem 1: Use linear/quadratic functions for verification</span></a> asks you to carry out all
details to show that linear and quadratic solutions are solutions
of the discrete equations. Such results are very useful for debugging
and verification. You are strongly encouraged to do this problem now!</p>
</div>
<div class="section" id="checking-convergence-rates">
<h4>Checking convergence rates<a class="headerlink" href="#checking-convergence-rates" title="Permalink to this headline">¶</a></h4>
<p>Empirical computation of convergence rates
yields a good method for verification. The method and its computational
are explained in detail for a simple ODE model in the section on <a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/sphinx/._book006.html#computing-convergence-rates">computing convergence rates</a>
in <a class="reference internal" href="._book017.html#ref2" id="id4">[Ref2]</a>. Readers not familiar with the concept should
look up this reference before proceeding.</p>
<p>In the present problem, computing convergence rates means that we must</p>
<blockquote>
<div><ul class="simple">
<li>perform <span class="math">\(m\)</span> simulations with halved time steps: <span class="math">\(\Delta t_i=2^{-i}\Delta t_0\)</span>, <span class="math">\(i=0,\ldots,m-1\)</span>,</li>
<li>compute the <span class="math">\(L^2\)</span> norm of the error,
<span class="math">\(E_i=\sqrt{\Delta t_i\sum_{n=0}^{N_t-1}(u^n-\uex(t_n))^2}\)</span> in each case,</li>
<li>estimate the convergence rates <span class="math">\(r_i\)</span> based on two consecutive
experiments <span class="math">\((\Delta t_{i-1}, E_{i-1})\)</span> and <span class="math">\((\Delta t_{i}, E_{i})\)</span>,
assuming <span class="math">\(E_i=C(\Delta t_i)^{r}\)</span> and <span class="math">\(E_{i-1}=C(\Delta t_{i-1})^{r}\)</span>.
From these equations it follows that
<span class="math">\(r = \ln (E_{i-1}/E_i)/\ln (\Delta t_{i-1}/\Delta t_i)\)</span>. Since this <span class="math">\(r\)</span>
will vary with <span class="math">\(i\)</span>, we equip it with an index and call it <span class="math">\(r_{i-1}\)</span>,
where <span class="math">\(i\)</span> runs from <span class="math">\(1\)</span> to <span class="math">\(m-1\)</span>.</li>
</ul>
</div></blockquote>
<p>The computed rates <span class="math">\(r_0,r_1,\ldots,r_{m-2}\)</span> hopefully converges to a
number, which hopefully is 2, the right one, in the present
problem. The convergence of the rates demands that the time steps
<span class="math">\(\Delta t_i\)</span> are sufficiently small for the error model <span class="math">\(E_i=(\Delta t_i)^r\)</span>
to be valid.</p>
<p>All the implementational details of computing the sequence
<span class="math">\(r_0,r_1,\ldots,r_{m-2}\)</span> appear below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">convergence_rates</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">solver_function</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return m-1 empirical estimates of the convergence rate</span>
<span class="sd">    based on m simulations, where the time step is halved</span>
<span class="sd">    for each simulation.</span>
<span class="sd">    solver_function(I, w, dt, T) solves each problem, where T</span>
<span class="sd">    is based on simulation for num_periods periods.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mf">0.35</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.3</span>       <span class="c"># just chosen values</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>              <span class="c"># period</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="mi">30</span>               <span class="c"># 30 time step per period 2*pi/w</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">num_periods</span>

    <span class="n">dt_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">E_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver_function</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">u_e</span><span class="o">-</span><span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">dt_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">E_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span>

    <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span>
         <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>The expected convergence rate is 2, because we have used
a second-order finite
difference approximations <span class="math">\([D_tD_tu]^n\)</span> to the ODE and a
second-order finite difference formula for the initial condition for
<span class="math">\(u^{\prime}\)</span>. Other theoretical error measures also points to
<span class="math">\(r=2\)</span>.</p>
<p>In the present problem, when <span class="math">\(\Delta t_0\)</span> corresponds to 30 time steps
per period, the returned <code class="docutils literal"><span class="pre">r</span></code> list has all its values equal to 2.00
(if rounded to two decimals). This amazing result means that all
<span class="math">\(\Delta t_i\)</span> values are well into the asymptotic regime where the
error model <span class="math">\(E_i = C(\Delta t_i)^r\)</span> is valid.</p>
<p>We can now construct a test function that computes convergence rates
and checks that the final (and usually the best) estimate is sufficiently
close to 2. Here, a rough tolerance of 0.1 is enough. This unit test
goes like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_convergence_rates</span><span class="p">():</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">solver_function</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="c"># Accept rate to 1 decimal place</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>The complete code appears in the file <code class="docutils literal"><span class="pre">vib_undamped.py</span></code>.</p>
</div>
</div>
<div class="section" id="scaled-model">
<h3>Scaled model<a class="headerlink" href="#scaled-model" title="Permalink to this headline">¶</a></h3>
<p>[<strong>hpl 4</strong>: Need reference to scaling book and maybe also decay book.]</p>
<p>It is advantageous to use dimensionless variables in simulations, because
fewer parameters need to be set. The present problem is made dimensionless
by introducing dimensionless variables <span class="math">\(\bar t = t/t_c\)</span> and <span class="math">\(\bar u = u/u_c\)</span>,
where <span class="math">\(t_c\)</span> and <span class="math">\(u_c\)</span> are characteristic scales for <span class="math">\(t\)</span> and <span class="math">\(u\)</span>,
respectively. The scaled ODE problem reads</p>
<div class="math">
\[\frac{u_c}{t_c^2}\frac{d^2\bar u}{d\bar t^2} + u_c\bar u = 0,\quad
u_c\bar u(0) = I,\ \frac{u_c}{t_c}\frac{d\bar u}{d\bar t}(0)=0\tp\]</div>
<p>A common choice is to take <span class="math">\(t_c\)</span> as one period of
the oscillations, <span class="math">\(t_c = 2\pi/w\)</span>, and <span class="math">\(u_c=I\)</span>.
This gives the dimensionless model</p>
<div class="math" id="eq-vib-ode1-model-scaled">
\[\tag{13}
\frac{d^2\bar u}{\bar t^2} + 4\pi^2 \bar u = 0,\quad \bar u(0)=1,\
    \bar u^{\prime}(0)=0\tp\]</div>
<p>Observe that there are no physical parameters in <a class="reference internal" href="#eq-vib-ode1-model-scaled"><span class="std std-ref">(13)</span></a>!
We can therefore perform
a single numerical simulation <span class="math">\(\bar u(\bar t)\)</span> and afterwards
recover any <span class="math">\(u(t; \omega, I)\)</span> by</p>
<div class="math">
\[u(t;\omega, I) = u_c\bar u(t/t_c) = I\bar u(omega t/(2\pi))\tp\]</div>
<p>We can easily check this assertion: the solution of the scaled problem
is <span class="math">\(\bar u(\bar t) = \cos(2\pi\bar t)\)</span>. The formula for <span class="math">\(u\)</span> in terms
of <span class="math">\(\bar u\)</span> gives <span class="math">\(u = I\cos(\omega t)\)</span>, which is nothing but the solution
of the original problem with dimensions.</p>
<p>The scaled model can by run by calling <code class="docutils literal"><span class="pre">solver(I=1,</span> <span class="pre">w=2*pi,</span> <span class="pre">dt,</span> <span class="pre">T)</span></code>.
Each period is now 1 and <code class="docutils literal"><span class="pre">T</span></code> simply counts the number of periods.
Choosing <code class="docutils literal"><span class="pre">dt</span></code> as <code class="docutils literal"><span class="pre">1./M</span></code> gives <code class="docutils literal"><span class="pre">M</span></code> time steps per period.</p>
</div>
</div>
<div class="section" id="long-time-simulations">
<span id="vib-ode1-longseries"></span><h2>Long time simulations<a class="headerlink" href="#long-time-simulations" title="Permalink to this headline">¶</a></h2>
<p>Figure <a class="reference internal" href="#vib-ode1-2dt"><span class="std std-ref">Effect of halving the time step</span></a> shows a comparison of the exact and numerical
solution for the scaled model <a class="reference internal" href="#eq-vib-ode1-model-scaled"><span class="std std-ref">(13)</span></a> with
<span class="math">\(\Delta t=0.1, 0.05\)</span>.
From the plot we make the following observations:</p>
<blockquote>
<div><ul class="simple">
<li>The numerical solution seems to have correct amplitude.</li>
<li>There is a angular frequency error which is reduced by reducing the time step.</li>
<li>The total angular frequency error grows with time.</li>
</ul>
</div></blockquote>
<p>By angular frequency error we mean that the numerical angular frequency differs
from the exact <span class="math">\(\omega\)</span>. This is evident by looking
at the peaks of the numerical solution: these have incorrect
positions compared with the peaks of the exact cosine solution. The
effect can be mathematical expressed by writing the numerical solution
as <span class="math">\(I\cos\tilde\omega t\)</span>, where <span class="math">\(\tilde\omega\)</span> is not exactly
equal to <span class="math">\(\omega\)</span>. Later, we shall mathematically
quantify this numerical angular frequency <span class="math">\(\tilde\omega\)</span>.</p>
<div class="figure" id="id7">
<span id="vib-ode1-2dt"></span><a class="reference internal image-reference" href="_images/vib_freq_err1.png"><img alt="_images/vib_freq_err1.png" src="_images/vib_freq_err1.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Effect of halving the time step</em></span></p>
</div>
<div class="section" id="using-a-moving-plot-window">
<h3>Using a moving plot window<a class="headerlink" href="#using-a-moving-plot-window" title="Permalink to this headline">¶</a></h3>
<p>In vibration problems it is often of interest to investigate the system&#8217;s
behavior over long time intervals. Errors in the angular frequency accumulate
and become more visible as time grows. We can investigate long
time series by introducing a moving plot window that can move along with
the <span class="math">\(p\)</span> most recently computed periods of the solution. The
<a class="reference external" href="https://github.com/hplgit/scitools">SciTools</a> package contains
a convenient tool for this: <code class="docutils literal"><span class="pre">MovingPlotWindow</span></code>. Typing
<code class="docutils literal"><span class="pre">pydoc</span> <span class="pre">scitools.MovingPlotWindow</span></code> shows a demo and a description of its use.
The function below utilizes the moving plot window and is in fact
called by the <code class="docutils literal"><span class="pre">main</span></code> function the <code class="docutils literal"><span class="pre">vib_undamped</span></code> module
if the number of periods in the simulation exceeds 10.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">visualize_front</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">skip_frames</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Visualize u and the exact solution vs t, using a</span>
<span class="sd">    moving plot window and continuous drawing of the</span>
<span class="sd">    curves as they evolve in time.</span>
<span class="sd">    Makes it easy to plot very long time series.</span>
<span class="sd">    Plots are saved to files if savefig is True.</span>
<span class="sd">    Only each skip_frames-th plot is saved (e.g., if</span>
<span class="sd">    skip_frame=10, only each 10th plot is saved to file;</span>
<span class="sd">    this is convenient if plot files corresponding to</span>
<span class="sd">    different time steps are to be compared).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">scitools.std</span> <span class="kn">as</span> <span class="nn">st</span>
    <span class="kn">from</span> <span class="nn">scitools.MovingPlotWindow</span> <span class="kn">import</span> <span class="n">MovingPlotWindow</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>

    <span class="c"># Remove all old plot files tmp_*.png</span>
    <span class="kn">import</span> <span class="nn">glob</span><span class="o">,</span> <span class="nn">os</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s">&#39;tmp_*.png&#39;</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>  <span class="c"># one period</span>
    <span class="n">umin</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">();</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">plot_manager</span> <span class="o">=</span> <span class="n">MovingPlotWindow</span><span class="p">(</span>
        <span class="n">window_width</span><span class="o">=</span><span class="mi">8</span><span class="o">*</span><span class="n">P</span><span class="p">,</span>
        <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span>
        <span class="n">yaxis</span><span class="o">=</span><span class="p">[</span><span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">],</span>
        <span class="n">mode</span><span class="o">=</span><span class="s">&#39;continuous drawing&#39;</span><span class="p">)</span>
    <span class="n">frame_counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">plot_manager</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">plot_manager</span><span class="o">.</span><span class="n">first_index_in_plot</span>
            <span class="n">st</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#39;r-1&#39;</span><span class="p">,</span>
                    <span class="n">t</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">I</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#39;b-1&#39;</span><span class="p">,</span>
                    <span class="n">title</span><span class="o">=</span><span class="s">&#39;t=</span><span class="si">%6.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">plot_manager</span><span class="o">.</span><span class="n">axis</span><span class="p">(),</span>
                    <span class="n">show</span><span class="o">=</span><span class="ow">not</span> <span class="n">savefig</span><span class="p">)</span> <span class="c"># drop window if savefig</span>
            <span class="k">if</span> <span class="n">savefig</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">%</span> <span class="n">skip_frames</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s">&#39;tmp_</span><span class="si">%04d</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="n">frame_counter</span>
                <span class="n">st</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                <span class="k">print</span> <span class="s">&#39;making plot file&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="s">&#39;at t=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="n">frame_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">plot_manager</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>We run the scaled problem (the default values for the command-line arguments
<code class="docutils literal"><span class="pre">--I</span></code> and <code class="docutils literal"><span class="pre">--w</span></code> correspond to the scaled problem) for 40 periods with 20
time steps per period:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python vib_undamped.py --dt 0.05 --num_periods 40
</pre></div>
</div>
<p>The moving plot window is invoked, and we can follow the numerical and exact
solutions as time progresses. From this demo we see that
the angular frequency error is small in the beginning, but it becomes more
prominent with time. A new run with <span class="math">\(\Delta t=0.1\)</span> (i.e., only 10 time steps per period)
clearly shows that the phase errors become significant even earlier
in the time series, deteriorating the solution further.</p>
</div>
<div class="section" id="making-animations">
<span id="vib-ode1-anim"></span><h3>Making animations<a class="headerlink" href="#making-animations" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-10"></span><span class="target" id="index-11"></span><span class="target" id="index-12"></span><span class="target" id="index-13"></span><span class="target" id="index-14"></span><span class="target" id="index-15"></span><div class="section" id="producing-standard-video-formats">
<span id="index-16"></span><h4>Producing standard video formats<a class="headerlink" href="#producing-standard-video-formats" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">visualize_front</span></code> function stores all the plots in
files whose names are numbered:
<code class="docutils literal"><span class="pre">tmp_0000.png</span></code>, <code class="docutils literal"><span class="pre">tmp_0001.png</span></code>, <code class="docutils literal"><span class="pre">tmp_0002.png</span></code>,
and so on. From these files we may make a movie. The Flash
format is popular,</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; ffmpeg -r 12 -i tmp_%04d.png -c:v flv movie.flv
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">ffmpeg</span></code> program can be replaced by the <code class="docutils literal"><span class="pre">avconv</span></code> program in
the above command if desired (but at the time of this writing it seems
to be more momentum in the <code class="docutils literal"><span class="pre">ffmpeg</span></code> project).
The <code class="docutils literal"><span class="pre">-r</span></code> option should come first and
describes the number of frames per second in the movie. The
<code class="docutils literal"><span class="pre">-i</span></code> option describes the name of the plot files.
Other formats can be generated by changing the video codec
and equipping the video file with the right extension:</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Codec and filename</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Flash</td>
<td><code class="docutils literal"><span class="pre">-c:v</span> <span class="pre">flv</span> <span class="pre">movie.flv</span></code></td>
</tr>
<tr class="row-odd"><td>MP4</td>
<td><code class="docutils literal"><span class="pre">-c:v</span> <span class="pre">libx264</span> <span class="pre">movie.mp4</span></code></td>
</tr>
<tr class="row-even"><td>WebM</td>
<td><code class="docutils literal"><span class="pre">-c:v</span> <span class="pre">libvpx</span> <span class="pre">movie.webm</span></code></td>
</tr>
<tr class="row-odd"><td>Ogg</td>
<td><code class="docutils literal"><span class="pre">-c:v</span> <span class="pre">libtheora</span> <span class="pre">movie.ogg</span></code></td>
</tr>
</tbody>
</table>
<p id="index-17">The video file can be played by some video player like <code class="docutils literal"><span class="pre">vlc</span></code>, <code class="docutils literal"><span class="pre">mplayer</span></code>,
<code class="docutils literal"><span class="pre">gxine</span></code>, or <code class="docutils literal"><span class="pre">totem</span></code>, e.g.,</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; vlc movie.webm
</pre></div>
</div>
<p>A web page can also be used to play the movie. Today&#8217;s standard is
to use the HTML5 <code class="docutils literal"><span class="pre">video</span></code> tag:</p>
<div class="highlight-html"><div class="highlight"><pre><span class="nt">&lt;video</span> <span class="na">autoplay</span> <span class="na">loop</span> <span class="na">controls</span>
       <span class="na">width=</span><span class="s">&#39;640&#39;</span> <span class="na">height=</span><span class="s">&#39;365&#39;</span> <span class="na">preload=</span><span class="s">&#39;none&#39;</span><span class="nt">&gt;</span>
<span class="nt">&lt;source</span> <span class="na">src=</span><span class="s">&#39;movie.webm&#39;</span>  <span class="na">type=</span><span class="s">&#39;video/webm; codecs=&quot;vp8, vorbis&quot;&#39;</span><span class="nt">&gt;</span>
<span class="nt">&lt;/video&gt;</span>
</pre></div>
</div>
<p>Modern browsers do not support all of the video formats.
MP4 is needed to successfully play the videos on Apple devices
that use the Safari browser.
WebM is the preferred format for Chrome, Opera, Firefox, and Internet
Explorer v9+. Flash was a popular format, but older browsers that
required Flash can play MP4. All browsers that work with Ogg can also
work with WebM. This means that to have a video work in all browsers,
the video should be available in the MP4 and WebM formats.
The proper HTML code reads</p>
<div class="highlight-html"><div class="highlight"><pre><span class="nt">&lt;video</span> <span class="na">autoplay</span> <span class="na">loop</span> <span class="na">controls</span>
       <span class="na">width=</span><span class="s">&#39;640&#39;</span> <span class="na">height=</span><span class="s">&#39;365&#39;</span> <span class="na">preload=</span><span class="s">&#39;none&#39;</span><span class="nt">&gt;</span>
<span class="nt">&lt;source</span> <span class="na">src=</span><span class="s">&#39;movie.mp4&#39;</span>   <span class="na">type=</span><span class="s">&#39;video/mp4;</span>
<span class="s"> codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&#39;</span><span class="nt">&gt;</span>
<span class="nt">&lt;source</span> <span class="na">src=</span><span class="s">&#39;movie.webm&#39;</span>  <span class="na">type=</span><span class="s">&#39;video/webm;</span>
<span class="s"> codecs=&quot;vp8, vorbis&quot;&#39;</span><span class="nt">&gt;</span>
<span class="nt">&lt;/video&gt;</span>
</pre></div>
</div>
<p>The MP4 format should appear first to ensure that Apple devices will
load the video correctly.</p>
<div class="admonition-caution-number-the-plot-files-correctly admonition">
<p class="first admonition-title">Caution: number the plot files correctly</p>
<p class="last">To ensure that the individual plot frames are shown in correct order,
it is important to number the files with zero-padded numbers
(0000, 0001, 0002, etc.). The printf format <code class="docutils literal"><span class="pre">%04d</span></code> specifies an
integer in a field of width 4, padded with zeros from the left.
A simple Unix wildcard file specification like <code class="docutils literal"><span class="pre">tmp_*.png</span></code>
will then list the frames in the right order. If the numbers in the
filenames were not zero-padded, the frame <code class="docutils literal"><span class="pre">tmp_11.png</span></code> would appear
before <code class="docutils literal"><span class="pre">tmp_2.png</span></code> in the movie.</p>
</div>
</div>
<div class="section" id="paying-png-files-in-a-web-browser">
<h4>Paying PNG files in a web browser<a class="headerlink" href="#paying-png-files-in-a-web-browser" title="Permalink to this headline">¶</a></h4>
<p id="index-18">The <code class="docutils literal"><span class="pre">scitools</span> <span class="pre">movie</span></code> command can create a movie player for a set
of PNG files such that a web browser can be used to watch the movie.
This interface has the advantage that the speed of the movie can
easily be controlled, a feature that scientists often appreciate.
The command for creating an HTML with a player for a set of
PNG files <code class="docutils literal"><span class="pre">tmp_*.png</span></code> goes like</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; scitools movie output_file=vib.html fps=4 tmp_*.png
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">fps</span></code> argument controls the speed of the movie (&#8220;frames per second&#8221;).</p>
<p>To watch the movie, load the video file <code class="docutils literal"><span class="pre">vib.html</span></code> into some browser, e.g.,</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; google-chrome vib.html  # invoke web page
</pre></div>
</div>
<p>Clicking on <code class="docutils literal"><span class="pre">Start</span> <span class="pre">movie</span></code> to see the result. Moving this movie to
some other place requires moving <code class="docutils literal"><span class="pre">vib.html</span></code> <em>and all the PNG files</em>
<code class="docutils literal"><span class="pre">tmp_*.png</span></code>:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; mkdir vib_dt0.1
Terminal&gt; mv tmp_*.png vib_dt0.1
Terminal&gt; mv vib.html vib_dt0.1/index.html
</pre></div>
</div>
</div>
<div class="section" id="making-animated-gif-files">
<h4>Making animated GIF files<a class="headerlink" href="#making-animated-gif-files" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">convert</span></code> program from the ImageMagick software suite can be
used to produce animated GIF files from a set of PNG files:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; convert -delay 25 tmp_vib*.png tmp_vib.gif
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">-delay</span></code> option needs an argument of the delay between each frame,
measured in 1/100 s, so 4 frames/s here gives 25/100 s delay.
Note, however, that in this particular example
with <span class="math">\(\Delta t=0.05\)</span> and 40 periods,
making an animated GIF file out of
the large number of PNG files is a very heavy process and not
considered feasible. Animated GIFs are best suited for animations with
not so many frames and where you want to see each frame and play them
slowly.</p>
<p>[<strong>hpl 5</strong>: Combine two simulations side by side!]</p>
</div>
</div>
<div class="section" id="using-bokeh-to-compare-graphs">
<h3>Using Bokeh to compare graphs<a class="headerlink" href="#using-bokeh-to-compare-graphs" title="Permalink to this headline">¶</a></h3>
<p>Instead of a moving plot frame, one can use tools that allows panning
by the mouse. For example, we can show four periods of a signal in
a plot and then scroll with the mouse through the rest of the
simulation. The <a class="reference external" href="http://bokeh.pydata.org/en/latest/docs/quickstart.html">Bokeh</a> plotting library offers such tools, but the plot must be displayed in
a web browser. The documentation of Bokeh is excellent, so here we just
show how the library can be used to compare a set of <span class="math">\(u\)</span> curves corresponding
to long time simulations.</p>
<p>Imagine we have performed experiments for a set of <span class="math">\(\Delta t\)</span> values.
We want each curve, together with the exact solution, to appear in
a plot, and then arrange all plots in a grid-like fashion:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/bokeh_gridplot1.png"><img alt="_images/bokeh_gridplot1.png" src="_images/bokeh_gridplot1.png" style="width: 800px;" /></a>
</div>
<p>Furthermore, we want the axis to couple such that if we move into
the future in one plot, all the other plots follows (note the
displaced <span class="math">\(t\)</span> axes!):</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/bokeh_gridplot2.png"><img alt="_images/bokeh_gridplot2.png" src="_images/bokeh_gridplot2.png" style="width: 800px;" /></a>
</div>
<p>A function for creating a Bokeh plot, given a list of <code class="docutils literal"><span class="pre">u</span></code> arrays
and corresponding <code class="docutils literal"><span class="pre">t</span></code> arrays, from different simulations, described
compactly in a list of strings <code class="docutils literal"><span class="pre">legends</span></code>, takes the following form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">bokeh_plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">legends</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">t_range</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make plots for u vs t using the Bokeh library.</span>
<span class="sd">    u and t are lists (several experiments can be compared).</span>
<span class="sd">    legens contain legend strings for the various u,t pairs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="p">]</span>  <span class="c"># wrap in list</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>  <span class="c"># wrap in list</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">legends</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">legends</span> <span class="o">=</span> <span class="p">[</span><span class="n">legends</span><span class="p">]</span>  <span class="c"># wrap in list</span>

    <span class="kn">import</span> <span class="nn">bokeh.plotting</span> <span class="kn">as</span> <span class="nn">plt</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">output_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;cdn&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Comparison&#39;</span><span class="p">)</span>
    <span class="c"># Assume that all t arrays have the same range</span>
    <span class="n">t_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1001</span><span class="p">)</span>  <span class="c"># fine mesh for u_e</span>
    <span class="n">tools</span> <span class="o">=</span> <span class="s">&#39;pan,wheel_zoom,box_zoom,reset,&#39;</span>\
            <span class="s">&#39;save,box_select,lasso_select&#39;</span>
    <span class="n">u_range</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.2</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">I</span><span class="p">]</span>
    <span class="n">font_size</span> <span class="o">=</span> <span class="s">&#39;8pt&#39;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># list of plot objects</span>
    <span class="c"># Make the first figure</span>
    <span class="n">p_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span>
        <span class="n">width</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">plot_height</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">legends</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">x_axis_label</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">,</span> <span class="n">y_axis_label</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">,</span>
        <span class="n">x_range</span><span class="o">=</span><span class="n">t_range</span><span class="p">,</span> <span class="n">y_range</span><span class="o">=</span><span class="n">u_range</span><span class="p">,</span> <span class="n">tools</span><span class="o">=</span><span class="n">tools</span><span class="p">,</span>
        <span class="n">title_text_font_size</span><span class="o">=</span><span class="n">font_size</span><span class="p">)</span>
    <span class="n">p_</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label_text_font_size</span><span class="o">=</span><span class="n">font_size</span>
    <span class="n">p_</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label_text_font_size</span><span class="o">=</span><span class="n">font_size</span>
    <span class="n">p_</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line_color</span><span class="o">=</span><span class="s">&#39;blue&#39;</span><span class="p">)</span>
    <span class="c"># Add exact solution</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">p_</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="n">line_color</span><span class="o">=</span><span class="s">&#39;red&#39;</span><span class="p">,</span> <span class="n">line_dash</span><span class="o">=</span><span class="s">&#39;4 4&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_</span><span class="p">)</span>
    <span class="c"># Make the rest of the figures and attach their axes to</span>
    <span class="c"># the first figure&#39;s axes</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
        <span class="n">p_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span>
            <span class="n">width</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">plot_height</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">legends</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="n">x_axis_label</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">,</span> <span class="n">y_axis_label</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">,</span>
            <span class="n">x_range</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x_range</span><span class="p">,</span> <span class="n">y_range</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y_range</span><span class="p">,</span> <span class="n">tools</span><span class="o">=</span><span class="n">tools</span><span class="p">,</span>
            <span class="n">title_text_font_size</span><span class="o">=</span><span class="n">font_size</span><span class="p">)</span>
        <span class="n">p_</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label_text_font_size</span> <span class="o">=</span> <span class="n">font_size</span>
        <span class="n">p_</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label_text_font_size</span> <span class="o">=</span> <span class="n">font_size</span>
        <span class="n">p_</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">line_color</span><span class="o">=</span><span class="s">&#39;blue&#39;</span><span class="p">)</span>
        <span class="n">p_</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="n">line_color</span><span class="o">=</span><span class="s">&#39;red&#39;</span><span class="p">,</span> <span class="n">line_dash</span><span class="o">=</span><span class="s">&#39;4 4&#39;</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_</span><span class="p">)</span>

    <span class="c"># Arrange all plots in a grid with 3 plots per row</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="p">[[]]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="n">grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># New row</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gridplot</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">toolbar_location</span><span class="o">=</span><span class="s">&#39;left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">plot</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">plot</span><span class="p">)</span>
</pre></div>
</div>
<p>A particular example using the <code class="docutils literal"><span class="pre">bokeh_plot</span></code> function appears below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">demo_bokeh</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Solve a scaled ODE u&#39;&#39; + u = 0.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mf">1.0</span>        <span class="c"># Scaled problem (frequency)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>  <span class="c"># Period</span>
    <span class="n">num_steps_per_period</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">40</span><span class="o">*</span><span class="n">P</span>       <span class="c"># Simulation time: 40 periods</span>
    <span class="n">u</span> <span class="o">=</span> <span class="p">[]</span>         <span class="c"># List of numerical solutions</span>
    <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>         <span class="c"># List of corresponding meshes</span>
    <span class="n">legends</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">num_steps_per_period</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="n">n</span>
        <span class="n">u_</span><span class="p">,</span> <span class="n">t_</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">)</span>
        <span class="n">u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t_</span><span class="p">)</span>
        <span class="n">legends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;# time steps per period: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">bokeh_plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">legends</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">t_range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">P</span><span class="p">],</span>
               <span class="n">filename</span><span class="o">=</span><span class="s">&#39;tmp.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="using-a-line-by-line-ascii-plotter">
<h3>Using a line-by-line ascii plotter<a class="headerlink" href="#using-a-line-by-line-ascii-plotter" title="Permalink to this headline">¶</a></h3>
<p>Plotting functions vertically, line by line, in the terminal window
using ascii characters only is a simple, fast, and convenient
visualization technique for long time series. Note that the time
axis then is positive downwards on the screen.
The tool
<code class="docutils literal"><span class="pre">scitools.avplotter.Plotter</span></code> makes it easy to create such plots:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">visualize_front_ascii</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot u and the exact solution vs t line by line in a</span>
<span class="sd">    terminal window (only using ascii characters).</span>
<span class="sd">    Makes it easy to plot very long time series.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scitools.avplotter</span> <span class="kn">import</span> <span class="n">Plotter</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>
    <span class="n">umin</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">();</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Plotter</span><span class="p">(</span><span class="n">ymin</span><span class="o">=</span><span class="n">umin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">umax</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="s">&#39;+o&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
        <span class="k">print</span> <span class="n">p</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">I</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])),</span> \
              <span class="s">&#39;</span><span class="si">%.1f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">/</span><span class="n">P</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">fps</span><span class="p">))</span>
</pre></div>
</div>
<p>The call <code class="docutils literal"><span class="pre">p.plot</span></code> returns a line of text, with the <span class="math">\(t\)</span> axis marked and
a symbol <code class="docutils literal"><span class="pre">+</span></code> for the first function (<code class="docutils literal"><span class="pre">u</span></code>) and <code class="docutils literal"><span class="pre">o</span></code> for the second
function (the exact solution). Here we append to this text
a time counter reflecting how many periods the current time point
corresponds to. A typical output (<span class="math">\(\omega =2\pi\)</span>, <span class="math">\(\Delta t=0.05\)</span>)
looks like this:</p>
<div class="highlight-text"><div class="highlight"><pre>                         |                       o+      14.0
                         |                      + o      14.0
                         |                  +    o       14.1
                         |             +     o           14.1
                         |     +        o                14.2
                        +|       o                       14.2
                +        |                               14.2
         +       o       |                               14.3
    +     o              |                               14.4
 +   o                   |                               14.4
+o                       |                               14.5
o +                      |                               14.5
 o    +                  |                               14.6
     o      +            |                               14.6
          o        +     |                               14.7
                 o       | +                             14.7
                         |        +                      14.8
                         |       o       +               14.8
                         |              o     +          14.9
                         |                   o   +       14.9
                         |                       o+      15.0
</pre></div>
</div>
</div>
<div class="section" id="empirical-analysis-of-the-solution">
<span id="vib-ode1-empirical"></span><h3>Empirical analysis of the solution<a class="headerlink" href="#empirical-analysis-of-the-solution" title="Permalink to this headline">¶</a></h3>
<p>For oscillating functions like those in Figure <a class="reference internal" href="#vib-ode1-2dt"><span class="std std-ref">Effect of halving the time step</span></a> we may
compute the amplitude and frequency (or period) empirically.
That is, we run through the discrete solution points <span class="math">\((t_n, u_n)\)</span> and
find all maxima and minima points. The distance between two consecutive
maxima (or minima) points can be used as estimate of the local period,
while half the difference between the <span class="math">\(u\)</span> value at a maximum and a nearby
minimum gives an estimate of the local amplitude.</p>
<p>The local maxima are the points where</p>
<div class="math" id="eq-auto4">
\[\begin{split}\tag{14}
u^{n-1} &lt; u^n &gt; u^{n+1},\quad n=1,\ldots,N_t-1,\end{split}\]</div>
<p>and the local minima are recognized by</p>
<div class="math" id="eq-auto5">
\[\begin{split}\tag{15}
u^{n-1} &gt; u^n &lt; u^{n+1},\quad n=1,\ldots,N_t-1
    \tp\end{split}\]</div>
<p>In computer code this becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">minmax</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
    <span class="n">minima</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">maxima</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">minima</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">maxima</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">minima</span><span class="p">,</span> <span class="n">maxima</span>
</pre></div>
</div>
<p>Note that the two returned objects are lists of tuples.</p>
<p>Let <span class="math">\((t_i, e_i)\)</span>, <span class="math">\(i=0,\ldots,M-1\)</span>, be the sequence of all
the <span class="math">\(M\)</span> maxima points, where <span class="math">\(t_i\)</span>
is the time value and <span class="math">\(e_i\)</span> the corresponding <span class="math">\(u\)</span> value.
The local period can be defined as <span class="math">\(p_i=t_{i+1}-t_i\)</span>.
With Python syntax this reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">periods</span><span class="p">(</span><span class="n">maxima</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">extrema</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">maxima</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
         <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">maxima</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>The list <code class="docutils literal"><span class="pre">p</span></code> created by a list comprehension is converted to an array
since we probably want to compute with it, e.g., find the corresponding
frequencies <code class="docutils literal"><span class="pre">2*pi/p</span></code>.</p>
<p>Having the minima and the maxima, the local amplitude can be
calculated as the difference between two neighboring minimum and
maximum points:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">amplitudes</span><span class="p">(</span><span class="n">minima</span><span class="p">,</span> <span class="n">maxima</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">abs</span><span class="p">(</span><span class="n">maxima</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">minima</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span><span class="o">/</span><span class="mf">2.0</span>
         <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minima</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">maxima</span><span class="p">)))]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>The code segments are found in the file <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib_empirical_analysis.py">vib_empirical_analysis.py</a>.</p>
<p>Since <code class="docutils literal"><span class="pre">a[i]</span></code> and <code class="docutils literal"><span class="pre">p[i]</span></code> correspond to
the <span class="math">\(i\)</span>-th amplitude estimate and the <span class="math">\(i\)</span>-th period estimate, respectively,
it is most convenient to visualize the <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">p</span></code> values with the
index <code class="docutils literal"><span class="pre">i</span></code> on the horizontal axis.
(There is no unique time point associated with either of these estimate
since values at two different time points were used in the
computations.)</p>
<p>In the analysis of very long time series, it is advantageous to
compute and plot <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">a</span></code> instead of <span class="math">\(u\)</span> to get an impression of
the development of the oscillations. Let us do this for the scaled
problem and <span class="math">\(\Delta t=0.1, 0.05, 0.01\)</span>.
A ready-made function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot_empirical_freq_and_amplitude</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
<p>computes the empirical amplitudes and periods, and creates a plot
where the amplitudes and angular frequencies
are visualized together with the exact amplitude <code class="docutils literal"><span class="pre">I</span></code>
and the exact angular frequency <code class="docutils literal"><span class="pre">w</span></code>. We can make a little program
for creating the plot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">vib_undamped</span> <span class="kn">import</span> <span class="n">solver</span><span class="p">,</span> <span class="n">plot_empirical_freq_and_amplitude</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
<span class="n">dt_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">]</span>
<span class="n">u_cases</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">t_cases</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">:</span>
    <span class="c"># Simulate scaled problem for 40 periods</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
    <span class="n">u_cases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">t_cases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">plot_empirical_freq_and_amplitude</span><span class="p">(</span><span class="n">u_cases</span><span class="p">,</span> <span class="n">t_cases</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#vib-ode1-fig-freq-ampl"><span class="std std-ref">Empirical amplitude and angular frequency for three cases of time steps</span></a> shows the result: we clearly see that
lowering <span class="math">\(\Delta t\)</span> improves the angular frequency significantly, while the
amplitude seems to be more accurate.
The lines with
<span class="math">\(\Delta t=0.01\)</span>, corresponding to 100 steps per period, can hardly be
distinguished from the exact values. The next section shows how we
can get mathematical insight into why amplitudes are good and frequencies
are more inaccurate.</p>
<div class="figure" id="id8">
<span id="vib-ode1-fig-freq-ampl"></span><a class="reference internal image-reference" href="_images/empirical_ampl_freq.png"><img alt="_images/empirical_ampl_freq.png" src="_images/empirical_ampl_freq.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Empirical amplitude and angular frequency for three cases of time steps</em></span></p>
</div>
</div>
</div>
<div class="section" id="analysis-of-the-numerical-scheme">
<span id="vib-ode1-analysis"></span><h2>Analysis of the numerical scheme<a class="headerlink" href="#analysis-of-the-numerical-scheme" title="Permalink to this headline">¶</a></h2>
<div class="section" id="deriving-a-solution-of-the-numerical-scheme">
<h3>Deriving a solution of the numerical scheme<a class="headerlink" href="#deriving-a-solution-of-the-numerical-scheme" title="Permalink to this headline">¶</a></h3>
<p>After having seen the phase error grow with time in the previous
section, we shall now quantify this error through mathematical
analysis.  The key tool in the analysis will be to establish an exact
solution of the discrete equations.  The difference equation
<a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a> has constant coefficients and is
homogeneous. Such equations are known to have solutions on the form
<span class="math">\(u^n=CA^n\)</span>, where <span class="math">\(A\)</span> is some number
to be determined from the difference equation and <span class="math">\(C\)</span> is found as the
initial condition (<span class="math">\(C=I\)</span>).  Recall that <span class="math">\(n\)</span> in <span class="math">\(u^n\)</span> is a
superscript labeling the time level, while <span class="math">\(n\)</span> in <span class="math">\(A^n\)</span> is an
exponent.</p>
<p>With oscillating functions as solutions, the algebra will
be considerably simplified if we seek an <span class="math">\(A\)</span> on the form</p>
<div class="math">
\[A=e^{i\tilde\omega \Delta t},\]</div>
<p>and solve for the numerical frequency <span class="math">\(\tilde\omega\)</span> rather than
<span class="math">\(A\)</span>. Note that <span class="math">\(i=\sqrt{-1}\)</span> is the imaginary unit. (Using a
complex exponential function gives simpler arithmetics than working
with a sine or cosine function.)
We have</p>
<div class="math">
\[A^n = e^{i\tilde\omega \Delta t\, n}=e^{i\tilde\omega t} =
\cos (\tilde\omega t) + i\sin(\tilde \omega t)
\tp\]</div>
<p>The physically relevant numerical solution can
be taken as the real part of this complex expression.</p>
<p>The calculations go as</p>
<div class="math">
\[\begin{split}[D_tD_t u]^n &amp;= \frac{u^{n+1} - 2u^n + u^{n-1}}{\Delta t^2}\\
&amp;= I\frac{A^{n+1} - 2A^n + A^{n-1}}{\Delta t^2}\\
&amp;= \frac{I}{\Delta t^{2}}(e^{i\tilde\omega(t+\Delta t)} - 2e^{i\tilde\omega t} + e^{i\tilde\omega(t-\Delta t)})\\
&amp;= Ie^{i\tilde\omega t}\frac{1}{\Delta t^2}\left(e^{i\tilde\omega\Delta t} + e^{i\tilde\omega(-\Delta t)} - 2\right)\\
&amp;= Ie^{i\tilde\omega t}\frac{2}{\Delta t^2}\left(\cosh(i\tilde\omega\Delta t) -1 \right)\\
&amp;= Ie^{i\tilde\omega t}\frac{2}{\Delta t^2}\left(\cos(\tilde\omega\Delta t) -1 \right)\\
&amp;= -Ie^{i\tilde\omega t}\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})\end{split}\]</div>
<p>The last line follows from the relation
<span class="math">\(\cos x - 1 = -2\sin^2(x/2)\)</span> (try <code class="docutils literal"><span class="pre">cos(x)-1</span></code> in
<a class="reference external" href="http://www.wolframalpha.com">wolframalpha.com</a> to see the formula).</p>
<p>The scheme <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a>
with <span class="math">\(u^n=Ie^{i\omega\tilde\Delta t\, n}\)</span> inserted now gives</p>
<div class="math" id="eq-auto6">
\[\tag{16}
-Ie^{i\tilde\omega t}\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})
    + \omega^2 Ie^{i\tilde\omega t} = 0,\]</div>
<p>which after dividing by <span class="math">\(Ie^{i\tilde\omega t}\)</span> results in</p>
<div class="math" id="eq-auto7">
\[\tag{17}
\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2}) = \omega^2
    \tp\]</div>
<p>The first step in solving for the unknown <span class="math">\(\tilde\omega\)</span> is</p>
<div class="math">
\[\sin^2(\frac{\tilde\omega\Delta t}{2}) = \left(\frac{\omega\Delta t}{2}\right)^2
\tp\]</div>
<p>Then, taking the square root, applying the inverse sine function, and
multiplying by <span class="math">\(2/\Delta t\)</span>, results in</p>
<div class="math" id="eq-vib-ode1-tildeomega">
\[\tag{18}
\tilde\omega = \pm \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
    \tp\]</div>
<p>The first observation of <a class="reference internal" href="#eq-vib-ode1-tildeomega"><span class="std std-ref">(18)</span></a> tells that
there is a phase error since the numerical frequency <span class="math">\(\tilde\omega\)</span>
never equals the exact frequency <span class="math">\(\omega\)</span>. But how good is
the approximation <a class="reference internal" href="#eq-vib-ode1-tildeomega"><span class="std std-ref">(18)</span></a>? That is, what
is the error <span class="math">\(\omega - \tilde\omega\)</span> or <span class="math">\(\tilde\omega/\omega\)</span>?
Taylor series expansion
for small <span class="math">\(\Delta t\)</span> may give an expression that is easier to understand
than the complicated function in <a class="reference internal" href="#eq-vib-ode1-tildeomega"><span class="std std-ref">(18)</span></a>:</p>
<div class="highlight-ipy"><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dt</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;dt w&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w_tilde_e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">dt</span><span class="o">*</span><span class="n">asin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w_tilde_series</span> <span class="o">=</span> <span class="n">w_tilde_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">w_tilde_series</span>
<span class="n">w</span> <span class="o">+</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">24</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">dt</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>This means that</p>
<div class="math" id="eq-vib-ode1-tildeomega-series">
\[\tag{19}
\tilde\omega = \omega\left( 1 + \frac{1}{24}\omega^2\Delta t^2\right)
    + \Oof{\Delta t^4}
    \tp\]</div>
<p>The error in the numerical frequency is of second-order in
<span class="math">\(\Delta t\)</span>, and the error vanishes as <span class="math">\(\Delta t\rightarrow 0\)</span>.
We see that <span class="math">\(\tilde\omega &gt; \omega\)</span> since the term <span class="math">\(\omega^3\Delta t^2/24 &gt;0\)</span>
and this is by far the biggest term in the series expansion for small
<span class="math">\(\omega\Delta t\)</span>. A numerical frequency that is too large gives an oscillating
curve that oscillates too fast and therefore &#8220;lags behind&#8221; the exact
oscillations, a feature that can be seen in the left plot in Figure
<a class="reference internal" href="#vib-ode1-2dt"><span class="std std-ref">Effect of halving the time step</span></a>.</p>
<p>Figure <a class="reference internal" href="#vib-ode1-tildeomega-plot"><span class="std std-ref">Exact discrete frequency and its second-order series expansion</span></a> plots the discrete frequency
<a class="reference internal" href="#eq-vib-ode1-tildeomega"><span class="std std-ref">(18)</span></a>
and its approximation <a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><span class="std std-ref">(19)</span></a> for <span class="math">\(\omega =1\)</span> (based
on the program <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib_plot_freq.py">vib_plot_freq.py</a>).
Although <span class="math">\(\tilde\omega\)</span> is a function of <span class="math">\(\Delta t\)</span> in
<a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><span class="std std-ref">(19)</span></a>,
it is misleading to think of <span class="math">\(\Delta t\)</span> as the important
discretization parameter. It is the product <span class="math">\(\omega\Delta t\)</span> that is
the key discretization parameter. This quantity reflects the
<em>number of time steps per period</em> of the oscillations.
To see this, we set <span class="math">\(P=N_P\Delta t\)</span>, where <span class="math">\(P\)</span> is the length of
a period, and <span class="math">\(N_P\)</span> is the number of time steps during a period.
Since <span class="math">\(P\)</span> and <span class="math">\(\omega\)</span> are related by <span class="math">\(P=2\pi/\omega\)</span>,
we get that <span class="math">\(\omega\Delta t = 2\pi/N_P\)</span>, which shows that
<span class="math">\(\omega\Delta t\)</span> is directly related to <span class="math">\(N_P\)</span>.</p>
<p>The plot shows
that at least <span class="math">\(N_P\sim 25-30\)</span> points per period are necessary for reasonable
accuracy, but this depends on the length of the simulation (<span class="math">\(T\)</span>) as
the total phase error due to the frequency error grows linearly with time
(see <a class="reference internal" href="#vib-exer-phase-err-growth"><span class="std std-ref">Exercise 2: Show linear growth of the phase with time</span></a>).</p>
<div class="figure" id="id9">
<span id="vib-ode1-tildeomega-plot"></span><a class="reference internal image-reference" href="_images/discrete_freq.png"><img alt="_images/discrete_freq.png" src="_images/discrete_freq.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Exact discrete frequency and its second-order series expansion</em></span></p>
</div>
</div>
<div class="section" id="exact-discrete-solution">
<span id="vib-ode1-analysis-sol"></span><h3>Exact discrete solution<a class="headerlink" href="#exact-discrete-solution" title="Permalink to this headline">¶</a></h3>
<p>Perhaps more important than the <span class="math">\(\tilde\omega = \omega + {\cal O}(\Delta t^2)\)</span>
result found above is the fact that we have an exact discrete solution of
the problem:</p>
<div class="math" id="eq-vib-ode1-un-exact">
\[\tag{20}
u^n = I\cos\left(\tilde\omega n\Delta t\right),\quad
    \tilde\omega = \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
    \tp\]</div>
<p>We can then compute the error mesh function</p>
<div class="math" id="eq-vib-ode1-en">
\[\tag{21}
e^n = \uex(t_n) - u^n =
    I\cos\left(\omega n\Delta t\right) - I\cos\left(\tilde\omega n\Delta t\right)\tp\]</div>
<p>From the formula <span class="math">\(\cos 2x - \cos 2y = -2\sin(x-y)\sin(x+y)\)</span> we can
rewrite <span class="math">\(e^n\)</span> so the expression is easier to interpret:</p>
<div class="math" id="eq-vib-ode1-en2">
\[\tag{22}
e^n = -2I\sin\left(t\half\left( \omega - \tilde\omega\right)\right)
    \sin\left(t\half\left( \omega + \tilde\omega\right)\right)\tp\]</div>
<p>The error mesh function is ideal for verification purposes
and you are strongly encouraged to make a test based on <a class="reference internal" href="#eq-vib-ode1-un-exact"><span class="std std-ref">(20)</span></a>
by doing <a class="reference internal" href="#vib-exer-discrete-omega"><span class="std std-ref">Exercise 10: Use an exact discrete solution for verification</span></a>.</p>
</div>
<div class="section" id="convergence">
<span id="vib-ode1-analysis-conv"></span><h3>Convergence<a class="headerlink" href="#convergence" title="Permalink to this headline">¶</a></h3>
<p>We can use <a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><span class="std std-ref">(19)</span></a>, <a class="reference internal" href="#eq-vib-ode1-en"><span class="std std-ref">(21)</span></a>, or
<a class="reference internal" href="#eq-vib-ode1-en2"><span class="std std-ref">(22)</span></a> to show <em>convergence</em> of the
numerical scheme, i.e., <span class="math">\(e^n\rightarrow 0\)</span> as <span class="math">\(\Delta t\rightarrow 0\)</span>.
We have that</p>
<div class="math">
\[\lim_{\Delta t\rightarrow 0}
\tilde\omega = \lim_{\Delta t\rightarrow 0}
\frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
= \omega,\]</div>
<p>by L&#8217;Hopital&#8217;s rule or simply asking <code class="docutils literal"><span class="pre">sympy</span></code> or
<a class="reference external" href="http://www.wolframalpha.com/input/?i=%282%2Fx%29*asin%28w*x%2F2%29+as+x-%3E0">WolframAlpha</a> about the limit:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x w&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sym</span><span class="o">.</span><span class="n">limit</span><span class="p">((</span><span class="mi">2</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">asin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s">&#39;+&#39;</span><span class="p">)</span>
<span class="go">w</span>
</pre></div>
</div>
<p>Also <a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><span class="std std-ref">(19)</span></a> can be used to establish
this result that
<span class="math">\(\tilde\omega\rightarrow\omega\)</span>. It then follows from the expression(s)
for <span class="math">\(e^n\)</span> that <span class="math">\(e^n\rightarrow 0\)</span>.</p>
</div>
<div class="section" id="the-global-error">
<h3>The global error<a class="headerlink" href="#the-global-error" title="Permalink to this headline">¶</a></h3>
<p id="index-19">To achieve more analytical insight into the nature of the global error,
we can Taylor expand the error mesh function <a class="reference internal" href="#eq-vib-ode1-en"><span class="std std-ref">(21)</span></a>.
Since <span class="math">\(\tilde\omega\)</span> in <a class="reference internal" href="#eq-vib-ode1-tildeomega"><span class="std std-ref">(18)</span></a>
contains <span class="math">\(\Delta t\)</span> in the denominator we use the series expansion
for <span class="math">\(\tilde\omega\)</span> inside the cosine function. A relevant <code class="docutils literal"><span class="pre">sympy</span></code>
session is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;dt w t&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">dt</span><span class="o">*</span><span class="n">asin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_series</span> <span class="o">=</span> <span class="n">w_tilde_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_series</span>
<span class="go">w + dt**2*w**3/24 + O(dt**4)</span>
</pre></div>
</div>
<p>Series expansions in <code class="docutils literal"><span class="pre">sympy</span></code> have the inconvenient <code class="docutils literal"><span class="pre">O()</span></code> term that
prevents further calculations with the series. We can use the
<code class="docutils literal"><span class="pre">removeO()</span></code> command to get rid of the <code class="docutils literal"><span class="pre">O()</span></code> term:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_series</span> <span class="o">=</span> <span class="n">w_tilde_series</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_series</span>
<span class="go">dt**2*w**3/24 + w</span>
</pre></div>
</div>
<p>Using this <code class="docutils literal"><span class="pre">w_tilde_series</span></code> expression
for <span class="math">\(\tilde w\)</span> in <a class="reference internal" href="#eq-vib-ode1-en"><span class="std std-ref">(21)</span></a>,
dropping <span class="math">\(I\)</span> (which is a common factor), and performing a series
expansion of the error yields</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">error</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">w_tilde_series</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">error</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">dt**2*t*w**3*sin(t*w)/24 + dt**4*t**2*w**6*cos(t*w)/1152 + O(dt**6)</span>
</pre></div>
</div>
<p>Since we are mainly interested in the leading-order term in
such expansions (the term with lowest power in <span class="math">\(\Delta t\)</span> and
goes most slowly to zero), we use the <code class="docutils literal"><span class="pre">.as_leading_term(dt)</span></code>
construction to pick out this term:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">error</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
<span class="go">dt**2*t*w**3*sin(t*w)/24</span>
</pre></div>
</div>
<p>The last result
means that the leading order global (true) error at a point <span class="math">\(t\)</span>
is proportional to <span class="math">\(\omega^3t\Delta t^2\)</span>. Now, <span class="math">\(t\)</span> is related
to <span class="math">\(\Delta t\)</span> through <span class="math">\(t=n\Delta t\)</span>. The factor
<span class="math">\(\sin(\omega t)\)</span> can at most be 1, so we use this value to
bound the leading-order expression to its maximum value</p>
<div class="math">
\[e^n = \frac{1}{24}n\omega^3\Delta t^3\tp\]</div>
<p>This is the dominating term of the error <em>at a point</em>.</p>
<p>We are interested in the accumulated global error, which can
be taken as the <span class="math">\(\ell^2\)</span> norm of <span class="math">\(e^n\)</span>.
The norm is simply computed by summing contributions from all mesh
points:</p>
<div class="math">
\[||e^n||_{\ell^2}^2 = \Delta t\sum_{n=0}^{N_t} \frac{1}{24^2}n^2\omega^6\Delta t^6
=\frac{1}{24^2}\omega^6\Delta t^7 \sum_{n=0}^{N_t} n^2\tp\]</div>
<p>The sum <span class="math">\(\sum_{n=0}^{N_t} n^2\)</span> is approximately equal to
<span class="math">\(\frac{1}{3}N_t^3\)</span>. Replacing <span class="math">\(N_t\)</span> by <span class="math">\(T/\Delta t\)</span> and taking
the square root gives the expression</p>
<div class="math">
\[||e^n||_{\ell^2} = \frac{1}{24}\sqrt{\frac{T^3}{3}}\omega^3\Delta t^2\tp\]</div>
<p>This is our expression for the global (or integrated) error.
The main result from this expression is that also the global error
is proportional to <span class="math">\(\Delta t^2\)</span>.</p>
</div>
<div class="section" id="stability-1">
<h3>Stability<a class="headerlink" href="#stability-1" title="Permalink to this headline">¶</a></h3>
<p>Looking at <a class="reference internal" href="#eq-vib-ode1-un-exact"><span class="std std-ref">(20)</span></a>, it appears that the numerical
solution has constant and correct amplitude, but an error in the
angular frequency. A constant amplitude is not necessarily the case,
however! To see this, note that if only <span class="math">\(\Delta t\)</span> is large
enough, the magnitude of the argument to <span class="math">\(\sin^{-1}\)</span> in
<a class="reference internal" href="#eq-vib-ode1-tildeomega"><span class="std std-ref">(18)</span></a> may be larger than 1, i.e.,
<span class="math">\(\omega\Delta t/2 &gt; 1\)</span>. In this case, <span class="math">\(\sin^{-1}(\omega\Delta t/2)\)</span>
has a complex value and therefore <span class="math">\(\tilde\omega\)</span> becomes complex.
Type, for example, <code class="docutils literal"><span class="pre">asin(x)</span></code> in
<a class="reference external" href="http://www.wolframalpha.com">wolframalpha.com</a> to see basic properties of <span class="math">\(\sin^{-1} (x)\)</span>).</p>
<p>A complex <span class="math">\(\tilde\omega\)</span> can be written <span class="math">\(\tilde\omega = \tilde\omega_r +
i\tilde\omega_i\)</span>. Since <span class="math">\(\sin^{-1}(x)\)</span> has a <em>negative</em> imaginary part for
<span class="math">\(x&gt;1\)</span>, <span class="math">\(\tilde\omega_i &lt; 0\)</span>, which means that
<span class="math">\(e^{i\tilde\omega t}=e^{-\tilde\omega_i t}e^{i\tilde\omega_r t}\)</span>
will lead to exponential growth in time because
<span class="math">\(e^{-\tilde\omega_i t}\)</span> with <span class="math">\(\tilde\omega_i &lt;0\)</span> has a positive
exponent.</p>
<div class="admonition-stability-criterion admonition" id="index-20">
<p class="first admonition-title">Stability criterion</p>
<p class="last">We do not tolerate growth in the amplitude since such growth is not
present in the exact solution. Therefore, we
must impose a <em>stability criterion</em>  that
the argument in the inverse sine function leads
to real and not complex values of <span class="math">\(\tilde\omega\)</span>. The stability
criterion reads</p>
</div>
<div class="math" id="eq-auto8">
\[\tag{23}
\frac{\omega\Delta t}{2} \leq 1\quad\Rightarrow\quad
       \Delta t \leq \frac{2}{\omega}
       \tp\]</div>
<p>With <span class="math">\(\omega =2\pi\)</span>, <span class="math">\(\Delta t &gt; \pi^{-1} = 0.3183098861837907\)</span> will give
growing solutions. Figure <a class="reference internal" href="#vib-ode1-dt-unstable"><span class="std std-ref">Growing, unstable solution because of a time step slightly beyond the stability limit</span></a>
displays what happens when <span class="math">\(\Delta t =0.3184\)</span>,
which is slightly above the critical value: <span class="math">\(\Delta t =\pi^{-1} + 9.01\cdot
10^{-5}\)</span>.</p>
<div class="figure" id="id10">
<span id="vib-ode1-dt-unstable"></span><a class="reference internal image-reference" href="_images/vib_unstable.png"><img alt="_images/vib_unstable.png" src="_images/vib_unstable.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Growing, unstable solution because of a time step slightly beyond the stability limit</em></span></p>
</div>
</div>
<div class="section" id="about-the-accuracy-at-the-stability-limit">
<h3>About the accuracy at the stability limit<a class="headerlink" href="#about-the-accuracy-at-the-stability-limit" title="Permalink to this headline">¶</a></h3>
<p>An interesting question is whether the stability condition
<span class="math">\(\Delta t &lt; 2/\omega\)</span> is unfortunate, or more precisely:
would it be meaningful to take larger time steps to speed up computations?
The answer is a clear no. At the stability limit, we have that
<span class="math">\(\sin^{-1}\omega\Delta t/2 = \sin^{-1} 1 = \pi/2\)</span>, and therefore
<span class="math">\(\tilde\omega = \pi/\Delta t\)</span>. (Note that the approximate formula
<a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><span class="std std-ref">(19)</span></a> is very inaccurate for this
value of <span class="math">\(\Delta t\)</span> as it predicts <span class="math">\(\tilde\omega = 2.34/pi\)</span>, which is
a 25 percent reduction.) The corresponding
period of the numerical solution
is <span class="math">\(\tilde P=2\pi/\tilde\omega = 2\Delta t\)</span>, which means that there is
just one time step <span class="math">\(\Delta t\)</span> between a peak (maximum)
and a <a class="reference external" href="https://simple.wikipedia.org/wiki/Wave_(physics)">through</a>
(minimum) in the
numerical solution. This is the shortest possible wave that can be
represented in the mesh! In other words, it is not meaningful to
use a larger time step than the stability limit.</p>
<p>Also, the error in angular frequency
when <span class="math">\(\Delta t = 2/\omega\)</span> is severe: Figure
<a class="reference internal" href="#vib-ode1-dt-stablimit"><span class="std std-ref">Numerical solution with  \( Delta t \)  exactly at the stability limit</span></a> shows a comparison of the numerical and
analytical solution with <span class="math">\(\omega = 2\pi\)</span> and
<span class="math">\(\Delta t = 2/\omega = \pi^{-1}\)</span>. Already after one period, the
numerical solution has a through while the exact solution has a peak (!).
The error in frequency when <span class="math">\(\Delta t\)</span> is at the stability limit
becomes <span class="math">\(\omega - \tilde\omega = \omega(1-\pi/2)\approx -0.57\omega\)</span>.
The corresponding error in the period is <span class="math">\(P - \tilde P \approx 0.36P\)</span>.
The error after <span class="math">\(m\)</span> periods is then <span class="math">\(0.36mP\)</span>. This error has reached
half a period when <span class="math">\(m=1/(2\cdot 0.36)\approx 1.38\)</span>, which theoretically
confirms the observations in Figure <a class="reference internal" href="#vib-ode1-dt-stablimit"><span class="std std-ref">Numerical solution with  \( Delta t \)  exactly at the stability limit</span></a>
that the numerical solution is a through ahead of a peak already after
one and a half period. Consequently, <span class="math">\(\Delta t\)</span> should be chosen much
less than the stability limit to achieve meaningful numerical computations.</p>
<div class="figure" id="id11">
<span id="vib-ode1-dt-stablimit"></span><a class="reference internal image-reference" href="_images/vib_stability_limit.png"><img alt="_images/vib_stability_limit.png" src="_images/vib_stability_limit.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Numerical solution with  \( Delta t \)  exactly at the stability limit</em></span></p>
</div>
<div class="admonition-summary admonition">
<p class="first admonition-title">Summary</p>
<p>From the accuracy and stability
analysis we can draw three important conclusions:</p>
<ol class="last arabic simple">
<li>The key parameter in the formulas is <span class="math">\(p=\omega\Delta t\)</span>.
The period of oscillations is <span class="math">\(P=2\pi/\omega\)</span>, and the
number of time steps per period is <span class="math">\(N_P=P/\Delta t\)</span>.
Therefore, <span class="math">\(p=\omega\Delta t = 2\pi N_P\)</span>, showing that the
critical parameter is the number of time steps per period.
The smallest possible <span class="math">\(N_P\)</span> is 2, showing that <span class="math">\(p\in (0,\pi]\)</span>.</li>
<li>Provided <span class="math">\(p\leq 2\)</span>, the amplitude of the numerical solution is
constant.</li>
<li>The ratio of the numerical angular frequency and the exact
one is
<span class="math">\(\tilde\omega/\omega \approx 1 + \frac{1}{24}p^2\)</span>.
The error <span class="math">\(\frac{1}{24}p^2\)</span> leads to wrongly displaced peaks of the numerical
solution, and the error in peak location grows linearly with time
(see <a class="reference internal" href="#vib-exer-phase-err-growth"><span class="std std-ref">Exercise 2: Show linear growth of the phase with time</span></a>).</li>
</ol>
</div>
</div>
</div>
<div class="section" id="alternative-schemes-based-on-1st-order-equations">
<span id="vib-model2x2"></span><h2>Alternative schemes based on 1st-order equations<a class="headerlink" href="#alternative-schemes-based-on-1st-order-equations" title="Permalink to this headline">¶</a></h2>
<p>A standard technique for solving second-order ODEs is
to rewrite them as a system of first-order ODEs and then choose a
solution strategy from the
vast collection of methods for first-order ODE systems.
Given the second-order ODE problem</p>
<div class="math">
\[u^{\prime\prime} + \omega^2 u = 0,\quad u(0)=I,\ u^{\prime}(0)=0,\]</div>
<p>we introduce the auxiliary variable <span class="math">\(v=u^{\prime}\)</span> and express the ODE problem
in terms of first-order derivatives of <span class="math">\(u\)</span> and <span class="math">\(v\)</span>:</p>
<div class="math" id="eq-vib-model2x2-ueq">
\[\tag{24}
u^{\prime} = v,\]</div>
<div class="math" id="eq-vib-model2x2-veq">
\[\tag{25}
v' = -\omega^2 u\]\[    \tp\]</div>
<p>The initial conditions become <span class="math">\(u(0)=I\)</span> and <span class="math">\(v(0)=0\)</span>.</p>
<div class="section" id="the-forward-euler-scheme">
<h3>The Forward Euler scheme<a class="headerlink" href="#the-forward-euler-scheme" title="Permalink to this headline">¶</a></h3>
<p>A Forward Euler approximation to our <span class="math">\(2\times 2\)</span> system of ODEs
<a class="reference internal" href="#eq-vib-model2x2-ueq"><span class="std std-ref">(24)</span></a>-<a class="reference internal" href="#eq-vib-model2x2-veq"><span class="std std-ref">(25)</span></a>
becomes</p>
<div class="math" id="eq-auto9">
\[\tag{26}
\lbrack D_t^+ u = v\rbrack^n,
    \lbrack D_t^+ v = -\omega^2 u\rbrack^n,\]</div>
<p>or written out,</p>
<div class="math" id="eq-vib-undamped-fe1">
\[\tag{27}
u^{n+1} = u^n + \Delta t v^n,\]</div>
<div class="math" id="eq-vib-undamped-fe2">
\[\tag{28}
v^{n+1} = v^n -\Delta t \omega^2 u^n\]\[    \tp\]</div>
<p>Let us briefly compare this Forward Euler method with the
centered difference scheme for the second-order differential
equation. We have from <a class="reference internal" href="#eq-vib-undamped-fe1"><span class="std std-ref">(27)</span></a> and
<a class="reference internal" href="#eq-vib-undamped-fe2"><span class="std std-ref">(28)</span></a> applied at levels <span class="math">\(n\)</span> and <span class="math">\(n-1\)</span> that</p>
<div class="math">
\[u^{n+1} = u^n + \Delta t v^n = u^n + \Delta t (v^{n-1} -\Delta t \omega^2 u^{n-1}\tp\]</div>
<p>Since from <a class="reference internal" href="#eq-vib-undamped-fe1"><span class="std std-ref">(27)</span></a></p>
<div class="math">
\[v^{n-1} = \frac{1}{\Delta t}(u^{n}-u^{n-1}),\]</div>
<p>it follows that</p>
<div class="math">
\[u^{n+1} = 2u^n - u^{n-1} -\Delta t^2\omega^2 u^{n-1},\]</div>
<p>which is very close to the centered difference scheme, but
the last term is evaluated at <span class="math">\(t_{n-1}\)</span> instead of <span class="math">\(t_n\)</span>.
Dividing by <span class="math">\(\Delta t^2\)</span>, the left-hand side is an approximation to
<span class="math">\(u^{\prime\prime}\)</span> at <span class="math">\(t_n\)</span>, while the right-hand side is sampled at <span class="math">\(t_{n-1}\)</span>.
All terms should be sampled at the same mesh point, so using
<span class="math">\(\omega^2 u^{n-1}\)</span> instead of <span class="math">\(\omega^2 u^n\)</span> is an inconsistency
in the scheme. This inconsistency turns out to be rather
crucial for the accuracy of
the Forward Euler method applied to vibration problems.</p>
</div>
<div class="section" id="the-backward-euler-scheme">
<h3>The Backward Euler scheme<a class="headerlink" href="#the-backward-euler-scheme" title="Permalink to this headline">¶</a></h3>
<p>A Backward Euler approximation the ODE system is equally easy to
write up in the operator notation:</p>
<div class="math" id="eq-auto10">
\[\tag{29}
\lbrack D_t^- u = v\rbrack^{n+1},\]</div>
<div class="math" id="eq-auto11">
\[\tag{30}
\lbrack D_t^- v = -\omega u\rbrack^{n+1} \tp\]</div>
<p>This becomes a coupled system for <span class="math">\(u^{n+1}\)</span> and <span class="math">\(v^{n+1}\)</span>:</p>
<div class="math" id="eq-vib-undamped-be1">
\[\tag{31}
u^{n+1} - \Delta t v^{n+1} = u^{n},\]</div>
<div class="math" id="eq-vib-undamped-be2">
\[\tag{32}
v^{n+1} + \Delta t \omega^2 u^{n+1} = v^{n}\]\[    \tp\]</div>
<p>We can compare <a class="reference internal" href="#eq-vib-undamped-be1"><span class="std std-ref">(31)</span></a>-<a class="reference internal" href="#eq-vib-undamped-be2"><span class="std std-ref">(32)</span></a> with
the centered scheme <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a>
for the second-order differential equation.
To this end, we eliminate <span class="math">\(v^{n+1}\)</span> in <a class="reference internal" href="#eq-vib-undamped-be1"><span class="std std-ref">(31)</span></a>
using <a class="reference internal" href="#eq-vib-undamped-be2"><span class="std std-ref">(32)</span></a> solved with respect to <span class="math">\(v^{n+1}\)</span>.
Thereafter, we eliminate <span class="math">\(v^n\)</span> using <a class="reference internal" href="#eq-vib-undamped-be1"><span class="std std-ref">(31)</span></a>
solved with respect to <span class="math">\(v^{n+1}\)</span> and replacing <span class="math">\(n+1\)</span> by <span class="math">\(n\)</span>.
The resulting equation involving only <span class="math">\(u^{n+1}\)</span>, <span class="math">\(u^n\)</span>, and <span class="math">\(u^{n-1}\)</span>
can be ordered as</p>
<div class="math">
\[\frac{u^{n+1}-2u^n+u^{n-1}}{\Delta t^2} = -\omega^2 u^{n+1},\]</div>
<p>which has almost the same form as the centered scheme for the
second-order differential equation, but the right-hand side is
evaluated at <span class="math">\(u^{n+1}\)</span> and not <span class="math">\(u^n\)</span>. This inconsistent sampling
of terms has a dramatic effect on the numerical solution.</p>
</div>
<div class="section" id="the-crank-nicolson-scheme">
<h3>The Crank-Nicolson scheme<a class="headerlink" href="#the-crank-nicolson-scheme" title="Permalink to this headline">¶</a></h3>
<p>The Crank-Nicolson scheme takes this form in the operator notation:</p>
<div class="math" id="eq-auto12">
\[\tag{33}
\lbrack D_t u = \overline{v}^t\rbrack^{n+\half},\]</div>
<div class="math" id="eq-auto13">
\[\tag{34}
\lbrack D_t v = -\omega \overline{u}^t\rbrack^{n+\half}
    \tp\]</div>
<p>Writing the equations out shows that this is also a coupled system:</p>
<div class="math" id="eq-auto14">
\[\tag{35}
u^{n+1} - \half\Delta t v^{n+1} = u^{n} + \half\Delta t v^{n},\]</div>
<div class="math" id="eq-auto15">
\[\tag{36}
v^{n+1} + \half\Delta t \omega^2 u^{n+1} = v^{n}
    - \half\Delta t \omega^2 u^{n}
    \tp\]</div>
<p>To see the nature of this approximation, and that it is actually
very promising, we write the equations as follows</p>
<div class="math" id="eq-vib-undamped-cn3a">
\[\tag{37}
u^{n+1} - u^n = \frac{1}{2}\Delta t(v^{n+1} + v^n),\]</div>
<div class="math" id="eq-vib-undamped-cn4a">
\[\tag{38}
v^{n+1}  = v^n -\frac{1}{2}\Delta t(u^{n+1} + u^n),\]</div>
<p>and add the latter at the previous time level as well:</p>
<div class="math" id="eq-vib-undamped-cn4b1">
\[\tag{39}
v^{n}  = v^{n-1} -\frac{1}{2}\Delta t(u^{n} + u^{n-1})\]</div>
<p>We can also rewrite <a class="reference internal" href="#eq-vib-undamped-cn3a"><span class="std std-ref">(37)</span></a> at the previous time level
as</p>
<div class="math" id="eq-vib-undamped-cn4b">
\[\tag{40}
v^{n+1} + v^n = \frac{2}{\Delta t}(u^{n+1} - u^n)\tp\]</div>
<p>Inserting <a class="reference internal" href="#eq-vib-undamped-cn4a"><span class="std std-ref">(38)</span></a> for <span class="math">\(v^{n+1}\)</span> in
<a class="reference internal" href="#eq-vib-undamped-cn3a"><span class="std std-ref">(37)</span></a> and
<a class="reference internal" href="#eq-vib-undamped-cn4b1"><span class="std std-ref">(39)</span></a> for <span class="math">\(v^{n}\)</span> in
<a class="reference internal" href="#eq-vib-undamped-cn3a"><span class="std std-ref">(37)</span></a> yields after some reordering:</p>
<div class="math">
\[u^{n+1} - n^n = \frac{1}{2}(-\frac{1}{2}\Delta t\omega^2
(u^{n+1} + 2u^n + u^{n-1}) + v^ + v^{n-1})\tp\]</div>
<p>Now, <span class="math">\(v^n + v^{n-1}\)</span> can be eliminated by means of
<a class="reference internal" href="#eq-vib-undamped-cn4b"><span class="std std-ref">(40)</span></a>. The result becomes</p>
<div class="math" id="eq-vib-undamped-cn5">
\[\tag{41}
u^{n+1} - 2u^n + u^{n-1} = \Delta t^2\omega^2
    \frac{1}{4}(u^{n+1} + 2u^n + u^{n-1})\tp\]</div>
<p>We have that</p>
<div class="math">
\[\frac{1}{4}(u^{n+1} + 2u^n + u^{n-1}) \approx u^n + \Oof{\Delta t^2},\]</div>
<p>meaning that <a class="reference internal" href="#eq-vib-undamped-cn5"><span class="std std-ref">(41)</span></a> is an approximation to
the centered scheme <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a> for the second-order ODE where
the sampling error in the term <span class="math">\(\Delta t^2\omega^2 u^n\)</span> is of the same
order as the approximation errors in the finite differences, i.e.,
<span class="math">\(\Oof{\Delta t^2}\)</span>. The Crank-Nicolson scheme written as
<a class="reference internal" href="#eq-vib-undamped-cn5"><span class="std std-ref">(41)</span></a> therefore has consistent sampling of all
terms at the same time point <span class="math">\(t_n\)</span>. The implication is a much better
method than the Forward and Backward Euler schemes.</p>
</div>
<div class="section" id="comparison-of-schemes">
<span id="vib-model2x2-compare"></span><h3>Comparison of schemes<a class="headerlink" href="#comparison-of-schemes" title="Permalink to this headline">¶</a></h3>
<p>We can easily compare methods like the ones above (and many more!)
with the aid of the
<a class="reference external" href="https://github.com/hplgit/odespy">Odespy</a> package. Below is
a sketch of the code.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">odespy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">u</span>  <span class="c"># u is array of length 2 holding our [u, v]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="o">-</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">run_solvers_and_plot</span><span class="p">(</span><span class="n">solvers</span><span class="p">,</span> <span class="n">timesteps_per_period</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                         <span class="n">num_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>  <span class="c"># duration of one period</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="n">timesteps_per_period</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="n">num_periods</span><span class="o">*</span><span class="n">timesteps_per_period</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span>
    <span class="n">t_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">legends</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">solver</span> <span class="ow">in</span> <span class="n">solvers</span><span class="p">:</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">f_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;w&#39;</span><span class="p">:</span> <span class="n">w</span><span class="p">})</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">([</span><span class="n">I</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t_mesh</span><span class="p">)</span>
</pre></div>
</div>
<p>There is quite some more code dealing with plots also, and we refer
to the source file <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib_undamped_odespy.py">vib_undamped_odespy.py</a>
for details. Observe that keyword arguments in <code class="docutils literal"><span class="pre">f(u,t,w=1)</span></code> can
be supplied through a solver parameter <code class="docutils literal"><span class="pre">f_kwargs</span></code> (dictionary of
additional keyword arguments to <code class="docutils literal"><span class="pre">f</span></code>).</p>
<p>Specification of the Forward Euler, Backward Euler, and
Crank-Nicolson schemes is done like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solvers</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">odespy</span><span class="o">.</span><span class="n">ForwardEuler</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
    <span class="c"># Implicit methods must use Newton solver to converge</span>
    <span class="n">odespy</span><span class="o">.</span><span class="n">BackwardEuler</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nonlinear_solver</span><span class="o">=</span><span class="s">&#39;Newton&#39;</span><span class="p">),</span>
    <span class="n">odespy</span><span class="o">.</span><span class="n">CrankNicolson</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nonlinear_solver</span><span class="o">=</span><span class="s">&#39;Newton&#39;</span><span class="p">),</span>
    <span class="p">]</span>
</pre></div>
</div>
<p id="index-21">The <code class="docutils literal"><span class="pre">vib_undamped_odespy.py</span></code>
program makes two plots of the computed solutions with the various
methods in the <code class="docutils literal"><span class="pre">solvers</span></code> list: one plot with <span class="math">\(u(t)\)</span> versus <span class="math">\(t\)</span>, and
one <em>phase plane plot</em> where <span class="math">\(v\)</span> is plotted against <span class="math">\(u\)</span>.
That is, the phase plane plot is the curve <span class="math">\((u(t),v(t))\)</span> parameterized
by <span class="math">\(t\)</span>. Analytically, <span class="math">\(u=I\cos(\omega t)\)</span> and <span class="math">\(v=u^{\prime}=-\omega I\sin(\omega t)\)</span>.
The exact curve <span class="math">\((u(t),v(t))\)</span> is therefore an ellipse, which often
looks like a circle in a plot if the axes are automatically scaled. The
important feature, however, is that exact curve <span class="math">\((u(t),v(t))\)</span> is
closed and repeats itself for every period. Not all numerical schemes
are capable of doing that, meaning that the amplitude instead shrinks or
grows with time.</p>
<p>Figure
<a class="reference internal" href="#vib-ode1-1st-odespy-theta-phaseplane"><span class="std std-ref">Comparison of classical schemes in the phase plane for two time step values</span></a> show the results. Note that
Odespy applies the label MidpointImplicit for what we have specified
as <code class="docutils literal"><span class="pre">CrankNicolson</span></code> in the code (<code class="docutils literal"><span class="pre">CrankNicolson</span></code> is just a synonym for
class <code class="docutils literal"><span class="pre">MidpointImplicit</span></code> in the Odespy code).
The Forward Euler scheme in Figure
<a class="reference internal" href="#vib-ode1-1st-odespy-theta-phaseplane"><span class="std std-ref">Comparison of classical schemes in the phase plane for two time step values</span></a> has a pronounced spiral
curve, pointing to the fact that the amplitude steadily grows, which
is also evident in Figure <a class="reference internal" href="#vib-ode1-1st-odespy-theta"><span class="std std-ref">Comparison of solution curves for classical schemes</span></a>.
The Backward Euler scheme has a similar feature, except that the
spriral goes inward and the amplitude is significantly damped.  The
changing amplitude and the sprial form decreases with decreasing time
step.  The Crank-Nicolson scheme looks much more
accurate.  In fact, these plots tell that the Forward and Backward
Euler schemes are not suitable for solving our ODEs with oscillating
solutions.</p>
<div class="figure" id="id12">
<span id="vib-ode1-1st-odespy-theta-phaseplane"></span><a class="reference internal image-reference" href="_images/vib_theta_1_pp.png"><img alt="_images/vib_theta_1_pp.png" src="_images/vib_theta_1_pp.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Comparison of classical schemes in the phase plane for two time step values</em></span></p>
</div>
<div class="figure" id="id13">
<span id="vib-ode1-1st-odespy-theta"></span><a class="reference internal image-reference" href="_images/vib_theta_1_u.png"><img alt="_images/vib_theta_1_u.png" src="_images/vib_theta_1_u.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Comparison of solution curves for classical schemes</em></span></p>
</div>
</div>
<div class="section" id="runge-kutta-methods">
<h3>Runge-Kutta methods<a class="headerlink" href="#runge-kutta-methods" title="Permalink to this headline">¶</a></h3>
<p>We may run two popular standard methods for first-order ODEs, the 2nd-
and 4th-order Runge-Kutta methods, to see how they perform. Figures
<a class="reference internal" href="#vib-ode1-1st-odespy-rk-phaseplane"><span class="std std-ref">Comparison of Runge-Kutta schemes in the phase plane</span></a> and
<a class="reference internal" href="#vib-ode1-1st-odespy-rk"><span class="std std-ref">Comparison of Runge-Kutta schemes</span></a> show the solutions with larger <span class="math">\(\Delta
t\)</span> values than what was used in the previous two plots.</p>
<div class="figure" id="id14">
<span id="vib-ode1-1st-odespy-rk-phaseplane"></span><a class="reference internal image-reference" href="_images/vib_RK_1_pp.png"><img alt="_images/vib_RK_1_pp.png" src="_images/vib_RK_1_pp.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Comparison of Runge-Kutta schemes in the phase plane</em></span></p>
</div>
<div class="figure" id="id15">
<span id="vib-ode1-1st-odespy-rk"></span><a class="reference internal image-reference" href="_images/vib_RK_1_u.png"><img alt="_images/vib_RK_1_u.png" src="_images/vib_RK_1_u.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Comparison of Runge-Kutta schemes</em></span></p>
</div>
<p>The visual impression is that the
4th-order Runge-Kutta method is very accurate, under all circumstances
in these tests, while the 2nd-order scheme suffers from amplitude errors
unless the time step is very small.</p>
<p>The corresponding results for the Crank-Nicolson scheme are shown in
Figure <a class="reference internal" href="#vib-ode1-1st-odespy-cn-long-phaseplane"><span class="std std-ref">Long-time behavior of the Crank-Nicolson scheme in the phase plane</span></a>.
It is clear that the Crank-Nicolson
scheme outperforms the 2nd-order Runge-Kutta method. Both schemes have
the same order of accuracy <span class="math">\(\Oof{\Delta t^2}\)</span>, but their differences
in the accuracy that matters in a real physical application is very
clearly pronounced in this example.  <a class="reference internal" href="#vib-exer-undamped-odespy"><span class="std std-ref">Exercise 12: Investigate the amplitude errors of many solvers</span></a> invites you to investigate how the amplitude
is computed by a series of famous methods for first-order ODEs.</p>
<div class="figure" id="id16">
<span id="vib-ode1-1st-odespy-cn-long-phaseplane"></span><a class="reference internal image-reference" href="_images/vib_CN_10_pp.png"><img alt="_images/vib_CN_10_pp.png" src="_images/vib_CN_10_pp.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Long-time behavior of the Crank-Nicolson scheme in the phase plane</em></span></p>
</div>
</div>
<div class="section" id="analysis-of-the-forward-euler-scheme-1">
<h3>Analysis of the Forward Euler scheme<a class="headerlink" href="#analysis-of-the-forward-euler-scheme-1" title="Permalink to this headline">¶</a></h3>
<p>We may try to find exact solutions of the discrete
equations <a class="reference internal" href="#eq-vib-undamped-fe1"><span class="std std-ref">(27)</span></a>-<a class="reference internal" href="#eq-vib-undamped-fe2"><span class="std std-ref">(28)</span></a>
in the Forward Euler method. An &#8220;ansatz&#8221;
is</p>
<div class="math">
\[\begin{split}u^n &amp;= IA^n,\\
v^n &amp;= qIA^n,\end{split}\]</div>
<p>where <span class="math">\(q\)</span> and <span class="math">\(A\)</span> are unknown numbers. We could have used a complex
exponential form <span class="math">\(e^{i\tilde\omega n\Delta t}\)</span> since we get
oscillatory form, but the oscillations grow in the Forward Euler
method, so the numerical frequency <span class="math">\(\tilde\omega\)</span> will be complex
anyway (producing an exponentially growing amplitude). Therefore, it is
easier to just work with potentially complex <span class="math">\(A\)</span> and <span class="math">\(q\)</span> as introduced
above.</p>
<p>The Forward Euler scheme leads to</p>
<div class="math">
\[\begin{split}A &amp;= 1 + \Delta t q,\\
A &amp;= 1 - \Delta t\omega^2 q^{-1}\tp\end{split}\]</div>
<p>We can easily eliminate <span class="math">\(A\)</span>, get <span class="math">\(q^2 + \omega^2=0\)</span>, and solve for</p>
<div class="math">
\[q = \pm i\omega,\]</div>
<p>which gives</p>
<div class="math">
\[A = 1 \pm \Delta t i\omega\tp\]</div>
<p>We shall take the real part of <span class="math">\(A^n\)</span> as the solution. The two
values of <span class="math">\(A\)</span> are complex conjugates, and the real part of
<span class="math">\(A^n\)</span> will be the same for both roots. This is easy to realize if
we rewrite the complex numbers in polar form,
which is also convenient
for further analysis and understanding.
The polar form <span class="math">\(re^{i\theta}\)</span> of a complex number <span class="math">\(x+iy\)</span> has
<span class="math">\(r=\sqrt{x^2+y^2}\)</span> and <span class="math">\(\theta = \tan^{-1}(y/x)\)</span>.
Hence, the polar form of the two values for <span class="math">\(A\)</span> become</p>
<div class="math">
\[1 \pm \Delta t i\omega = \sqrt{1+\omega^2\Delta t^2}e^{\pm i\tan^{-1}(\omega\Delta t)}\tp\]</div>
<p>Now it is very easy to compute <span class="math">\(A^n\)</span>:</p>
<div class="math">
\[(1 \pm \Delta t i\omega)^n = (1+\omega^2\Delta t^2)^{n/2}e^{\pm ni\tan^{-1}(\omega\Delta t)}\tp\]</div>
<p>Since <span class="math">\(\cos (\theta n) = \cos (-\theta n)\)</span>, the real part of the two
numbers become the same. We therefore continue with the solution that has
the plus sign.</p>
<p>The general solution is <span class="math">\(u^n = CA^n\)</span>, where
<span class="math">\(C\)</span> is a constant determined from the initial condition:
<span class="math">\(u^0=C=I\)</span>. We have <span class="math">\(u^n=IA^n\)</span> and
<span class="math">\(v^n=qIA^n\)</span>. The final solutions
are just the real part of the expressions in polar form:</p>
<div class="math" id="eq-auto16">
\[\tag{42}
u^n  =
    I(1+\omega^2\Delta t^2)^{n/2}\cos (n\tan^{-1}(\omega\Delta t)),\]</div>
<div class="math" id="eq-auto17">
\[\tag{43}
v^n =- \omega
    I(1+\omega^2\Delta t^2)^{n/2}\sin (n\tan^{-1}(\omega\Delta t))\tp\]</div>
<p>The expression <span class="math">\((1+\omega^2\Delta t^2)^{n/2}\)</span> causes growth of
the amplitude, since a number greater than one is raised to a positive
exponent <span class="math">\(n/2\)</span>. We can develop a series expression to better understand
the formula for the amplitude. Introducing <span class="math">\(p=\omega\Delta t\)</span> as the
key variable and using <code class="docutils literal"><span class="pre">sympy</span></code> gives</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;p&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;n&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amplitude</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amplitude</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">1 + n*p**2/2 + O(p**4)</span>
</pre></div>
</div>
<p>The amplitude goes like <span class="math">\(1 + \half n\omega^2\Delta t^2\)</span>, clearly growing
linearly in time (with <span class="math">\(n\)</span>).</p>
<p>We can also investigate the error in the angular frequency by a
series expansion:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">*</span><span class="n">atan</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">n*(p - p**3/3 + O(p**4))</span>
</pre></div>
</div>
<p>This means that the solution for <span class="math">\(u^n\)</span> can be written as</p>
<div class="math">
\[u^n = (1 + \half n\omega^2\Delta t^2 + \Oof(\Delta t^4))
\cos\left(\omega t - \frac{1}{3}\omega t\Delta t^2 + \Oof{\Delta t^4}\right)
\tp\]</div>
<p>The error in the angular frequency is of the same order as in the
scheme <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a> for the second-order ODE, but error
in the amplitude is severe.</p>
</div>
</div>
<div class="section" id="energy-considerations">
<span id="vib-model1-energy"></span><h2>Energy considerations<a class="headerlink" href="#energy-considerations" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-22"></span><p id="index-23">The observations of various methods in the previous section can be
better interpreted if we compute a quantity reflecting
the total <em>energy of the system</em>. It turns out that this quantity,</p>
<div class="math">
\[E(t) = \half(u^{\prime})^2 + \half\omega^2u^2,\]</div>
<p>is <em>constant</em> for all <span class="math">\(t\)</span>. Checking that <span class="math">\(E(t)\)</span> really remains constant
brings evidence that the numerical computations are sound.
It turns out that <span class="math">\(E\)</span> is proportional to the mechanical energy
in the system. Conservation of energy is
much used to check numerical simulations.</p>
<div class="section" id="derivation-of-the-energy-expression">
<h3>Derivation of the energy expression<a class="headerlink" href="#derivation-of-the-energy-expression" title="Permalink to this headline">¶</a></h3>
<p>We start out with multiplying</p>
<div class="math">
\[u^{\prime\prime} + \omega^2 u = 0,\]</div>
<p>by <span class="math">\(u^{\prime}\)</span> and integrating from <span class="math">\(0\)</span> to <span class="math">\(T\)</span>:</p>
<div class="math">
\[\int_0^T u^{\prime\prime}u^{\prime} dt + \int_0^T\omega^2 u u^{\prime} dt = 0\tp\]</div>
<p>Observing that</p>
<div class="math">
\[u^{\prime\prime}u^{\prime} = \frac{d}{dt}\half(u^{\prime})^2,\quad uu^{\prime} = \frac{d}{dt} {\half}u^2,\]</div>
<p>we get</p>
<div class="math">
\[\int_0^T (\frac{d}{dt}\half(u^{\prime})^2 + \frac{d}{dt} \half\omega^2u^2)dt = E(T) - E(0)=0,\]</div>
<p>where we have introduced</p>
<div class="math" id="eq-vib-model1-energy-balance1">
\[\tag{44}
E(t) = \half(u^{\prime})^2 + \half\omega^2u^2\tp\]</div>
<p>The important result from this derivation is that the total energy
is constant:</p>
<div class="math">
\[E(t) = E(0)\tp\]</div>
<div class="admonition-math-e-t-is-closely-related-to-the-system-s-energy admonition">
<p class="first admonition-title"><span class="math">\(E(t)\)</span> is closely related to the system&#8217;s energy</p>
<p>The quantity <span class="math">\(E(t)\)</span> derived above is physically not the mechanical energy of a
vibrating mechanical system, but the energy per unit mass. To see this,
we start with Newton&#8217;s second law <span class="math">\(F=ma\)</span> (<span class="math">\(F\)</span> is the sum of forces, <span class="math">\(m\)</span>
is the mass of the system, and <span class="math">\(a\)</span> is the acceleration).
The displacement <span class="math">\(u\)</span> is related to <span class="math">\(a\)</span> through
<span class="math">\(a=u^{\prime\prime}\)</span>. With a spring force as the only force we have <span class="math">\(F=-ku\)</span>, where
<span class="math">\(k\)</span> is a spring constant measuring the stiffness of the spring.
Newton&#8217;s second law then implies the differential equation</p>
<div class="math">
\[-ku = mu^{\prime\prime}\quad\Rightarrow mu^{\prime\prime} + ku = 0\tp\]</div>
<p>This equation of motion can be turned into an energy balance equation
by finding the work done by each term during a time interval <span class="math">\([0,T]\)</span>.
To this end, we multiply the equation by <span class="math">\(du=u^{\prime}dt\)</span> and integrate:</p>
<div class="math">
\[\int_0^T muu^{\prime}dt + \int_0^T kuu^{\prime}dt = 0\tp\]</div>
<p>The result is</p>
<div class="math">
\[\tilde E(t) = E_k(t) + E_p(t) = 0,\]</div>
<p class="last">where</p>
</div>
<div class="math" id="eq-vib-model1-energy-kinetic">
\[ \tag{45}
 E_k(t) = \frac{1}{2}mv^2,\quad v=u^{\prime},\]\[is the *kinetic energy* of the system, and\]\[.. _Eq:vib:model1:energy:potential:\]</div>
<div class="math">
\[ \tag{46}
 E_p(t) = {\half}ku^2\]\[is the *potential energy*. The sum  \( \tilde E(t) \)  is the total mechanical energy.
The derivation demonstrates the famous energy principle that, under
the right physical circumstances, any
change in the kinetic energy is due to a change in potential energy
and vice versa. (This principle breaks down when we introduce damping
in system, as we do in the section :ref:`vib:model2`.)\]\[The equation  \( mu^{\prime\prime}+ku=0 \)  can be divided by  \( m \)  and written as
 \( u^{\prime\prime} + \omega^2u=0 \)  for  \( \omega=\sqrt{k/m} \) . The energy expression
 \( E(t)=\half(u^{\prime})^2 + \half\omega^2u^2 \)  derived earlier is then
 \( \tilde E(t)/m \) , i.e., mechanical energy per unit mass.\]</div>
<div class="section" id="energy-of-the-exact-solution">
<h4>Energy of the exact solution<a class="headerlink" href="#energy-of-the-exact-solution" title="Permalink to this headline">¶</a></h4>
<p>Analytically, we have <span class="math">\(u(t)=I\cos\omega t\)</span>, if <span class="math">\(u(0)=I\)</span> and <span class="math">\(u^{\prime}(0)=0\)</span>,
so we can easily check that the energy evolution and confirm that <span class="math">\(E(t)\)</span>
is constant:</p>
<div class="math">
\[E(t) = {\half}I^2 (-\omega\sin\omega t)^2
+ \half\omega^2 I^2 \cos^2\omega t
= \half\omega^2 (\sin^2\omega t + \cos^2\omega t) = \half\omega^2
\tp\]</div>
</div>
</div>
<div class="section" id="an-error-measure-based-on-energy">
<h3>An error measure based on energy<a class="headerlink" href="#an-error-measure-based-on-energy" title="Permalink to this headline">¶</a></h3>
<p>The constant energy is well expressed by its initial value <span class="math">\(E(0)\)</span>, so that
the error in mechanical energy can be computed as a mesh function by</p>
<div class="math" id="eq-auto18">
\[\tag{47}
e_E^n = \half\left(\frac{u^{n+1}-u^{n-1}}{2\Delta t}\right)^2
    + \half\omega^2 (u^n)^2 - E(0),
    \quad n=1,\ldots,N_t-1,\]</div>
<p>where</p>
<div class="math">
\[E(0) = {\half}V^2 + \half\omega^2I^2,\]</div>
<p>if <span class="math">\(u(0)=I\)</span> and <span class="math">\(u^{\prime}(0)=V\)</span>. Note that we have used
a centered approximation to <span class="math">\(u^{\prime}\)</span>: <span class="math">\(\u^{\prime}(t_n)\approx
[D_{2t}u]^n\)</span>.</p>
<p>A useful norm of the mesh function <span class="math">\(e_E^n\)</span>
for the discrete mechanical energy
can be the maximum absolute value of <span class="math">\(e_E^n\)</span>:</p>
<div class="math">
\[\begin{split}||e_E^n||_{\ell^\infty} = \max_{1\leq n &lt;N_t} |e_E^n|\tp\end{split}\]</div>
<p>Alternatively, we can compute other norms involving integration over
all mesh points, but we are often interested in worst case deviation
of the energy, and then the maximum value is of particular relevance.</p>
<p>A vectorized Python implementation takes the form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># import numpy as np and compute u, t</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">E</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">((</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
<span class="n">E0</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">V</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">**</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="o">**</span><span class="mi">2</span>
<span class="n">e_E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">-</span> <span class="n">E0</span>
<span class="n">e_E_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">e_E</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</pre></div>
</div>
<p>The convergence rates of the quantity <code class="docutils literal"><span class="pre">e_E_norm</span></code> can be used for verification.
The value of <code class="docutils literal"><span class="pre">e_E_norm</span></code> is also useful for comparing schemes
through their ability to preserve energy. Below is a table demonstrating
the error in total energy for various schemes. We clearly see that
the Crank-Nicolson and 4th-order Runge-Kutta schemes are superior to
the 2nd-order Runge-Kutta method and better compared to the Forward
and Backward Euler schemes.</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="11%" />
<col width="18%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head"><span class="math">\(T\)</span></th>
<th class="head"><span class="math">\(\Delta t\)</span></th>
<th class="head"><span class="math">\(\max \left\vert e_E^n\right\vert\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Forward Euler</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(1.113\cdot 10^{2}\)</span></td>
</tr>
<tr class="row-odd"><td>Forward Euler</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(3.312\cdot 10^{1}\)</span></td>
</tr>
<tr class="row-even"><td>Backward Euler</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(1.683\cdot 10^{1}\)</span></td>
</tr>
<tr class="row-odd"><td>Backward Euler</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(1.231\cdot 10^{1}\)</span></td>
</tr>
<tr class="row-even"><td>Runge-Kutta 2nd-order</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.1\)</span></td>
<td><span class="math">\(8.401\)</span></td>
</tr>
<tr class="row-odd"><td>Runge-Kutta 2nd-order</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(9.637\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-even"><td>Crank-Nicolson</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(9.389\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-odd"><td>Crank-Nicolson</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(2.411\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-even"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.1\)</span></td>
<td><span class="math">\(2.387\)</span></td>
</tr>
<tr class="row-odd"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(6.476\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-even"><td>Crank-Nicolson</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.1\)</span></td>
<td><span class="math">\(3.389\)</span></td>
</tr>
<tr class="row-odd"><td>Crank-Nicolson</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(9.389\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-even"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.1\)</span></td>
<td><span class="math">\(3.686\)</span></td>
</tr>
<tr class="row-odd"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(6.928\cdot 10^{-1}\)</span></td>
</tr>
</tbody>
</table>
<p>[<strong>hpl 6</strong>: The error reductions are not directly in accordance with the order of the schemes, probably caused by <span class="math">\(\Delta t\)</span> not being in the asympotic regime.]</p>
</div>
</div>
<div class="section" id="the-euler-cromer-method">
<span id="vib-model2x2-eulercromer"></span><h2>The Euler-Cromer method<a class="headerlink" href="#the-euler-cromer-method" title="Permalink to this headline">¶</a></h2>
<p>While the 4th-order Runge-Kutta method and a
Crank-Nicolson scheme work well for vibration equation modeled as a
first-order ODE system,
both were inferior to the straightforward centered
difference scheme for the second-order equation
<span class="math">\(u^{\prime\prime}+\omega^2u=0\)</span>. However, there is a similarly successful scheme
available for the first-order system <span class="math">\(u^{\prime}=v\)</span>, <span class="math">\(v'=-\omega^2u\)</span>, to be
presented next.</p>
<div class="section" id="forward-backward-discretization">
<span id="index-24"></span><h3>Forward-backward discretization<a class="headerlink" href="#forward-backward-discretization" title="Permalink to this headline">¶</a></h3>
<p>The idea is to apply a Forward Euler discretization to the first
equation and a Backward Euler discretization to the second. In operator
notation this is stated as</p>
<div class="math" id="eq-auto19">
\[\tag{48}
\lbrack D_t^+u = v\rbrack^n,\]</div>
<div class="math" id="eq-auto20">
\[\tag{49}
\lbrack D_t^-v = -\omega u\rbrack^{n+1}
    \tp\]</div>
<p>We can write out the formulas and collect the unknowns on the left-hand side:</p>
<div class="math" id="eq-vib-model2x2-eulercromer-ueq1">
\[\tag{50}
u^{n+1} = u^n + \Delta t v^n,\]</div>
<div class="math" id="eq-vib-model2x2-eulercromer-veq1">
\[\tag{51}
v^{n+1} = v^n -\Delta t \omega^2u^{n+1}\]\[    \tp\]</div>
<p>We realize that after <span class="math">\(u^{n+1}\)</span> has been computed from
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1"><span class="std std-ref">(50)</span></a>, it may be used directly
in
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1"><span class="std std-ref">(51)</span></a> to compute <span class="math">\(v^{n+1}\)</span>.</p>
<p>In physics, it is more common to update the <span class="math">\(v\)</span> equation first, with
a forward difference, and thereafter the <span class="math">\(u\)</span> equation, with a backward
difference that applies the most recently computed <span class="math">\(v\)</span> value:</p>
<div class="math" id="eq-vib-model2x2-eulercromer-veq1b">
\[\tag{52}
v^{n+1} = v^n -\Delta t \omega^2u^{n},\]</div>
<div class="math" id="eq-vib-model2x2-eulercromer-ueq1b">
\[\tag{53}
u^{n+1} = u^n + \Delta t v^{n+1}\tp\]</div>
<p>The advantage of ordering the ODEs as in
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><span class="std std-ref">(52)</span></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><span class="std std-ref">(53)</span></a>
becomes evident
when consider complicated models. Such models are included if
we write our vibration ODE more generally as</p>
<div class="math">
\[\ddot u + g(u, u^{\prime}, t)=0\tp\]</div>
<p>We can rewrite this second-order ODE as two first-order ODEs,</p>
<div class="math">
\[\begin{split}v' &amp;= -g(u,v,t),\\
u^{\prime} &amp;= v\tp\end{split}\]</div>
<p>This rewrite allows the following scheme to be used:</p>
<div class="math">
\[\begin{split}v^{n+1} &amp;= v^n -\Delta t\, g(u^n,v^n,t),\\
u^{n+1} &amp;= u^n + \Delta t\, v^{n+1}\tp\end{split}\]</div>
<p>We realize that the first update works well with any <span class="math">\(g\)</span> since old
values <span class="math">\(u^n\)</span> and <span class="math">\(v^n\)</span> are used. Switching the equations would
demand <span class="math">\(u^n{+1}\)</span> and <span class="math">\(v^{n+1}\)</span> values in <span class="math">\(g\)</span>.</p>
<p>The scheme
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><span class="std std-ref">(52)</span></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><span class="std std-ref">(53)</span></a>
goes under several names: forward-backward scheme, <a class="reference external" href="http://en.wikipedia.org/wiki/Semi-implicit_Euler_method">semi-implicit Euler method</a>, semi-explicit Euler,
symplectic Euler,
Newton-Stormer-Verlet,
and Euler-Cromer.
We shall stick to the latter name.
Since both time discretizations are based on first-order difference
approximation, one may think that the scheme is only of first-order,
but this is not true: the use of a forward and then a backward
difference make errors cancel so that the overall error in the scheme
is <span class="math">\(\Oof{\Delta t^2}\)</span>. This is explained below.</p>
</div>
<div class="section" id="equivalence-with-the-scheme-for-the-second-order-ode">
<span id="vib-model2x2-eulercromer-equiv"></span><h3>Equivalence with the scheme for the second-order ODE<a class="headerlink" href="#equivalence-with-the-scheme-for-the-second-order-ode" title="Permalink to this headline">¶</a></h3>
<p>We may eliminate the <span class="math">\(v^n\)</span> variable from
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1"><span class="std std-ref">(50)</span></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1"><span class="std std-ref">(51)</span></a>
or
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><span class="std std-ref">(52)</span></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><span class="std std-ref">(53)</span></a>.
The <span class="math">\(v^{n+1}\)</span> term in <a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><span class="std std-ref">(52)</span></a> can
be eliminated from <a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><span class="std std-ref">(53)</span></a>:</p>
<div class="math" id="eq-vib-model2x2-eulercromer-elim1">
\[\tag{54}
u^{n+1} = u^n + \Delta t (v^n - \omega^2\Delta t^2 u^n)\tp\]</div>
<p>The <span class="math">\(v^{n}\)</span> quantity can be expressed by <span class="math">\(u^n\)</span> and <span class="math">\(u^{n-1}\)</span>
using <a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><span class="std std-ref">(53)</span></a>:</p>
<div class="math">
\[v^{n} = \frac{u^n - u^{n-1}}{\Delta t},\]</div>
<p>and when this is inserted in <a class="reference internal" href="#eq-vib-model2x2-eulercromer-elim1"><span class="std std-ref">(54)</span></a> we get</p>
<div class="math" id="eq-auto21">
\[\tag{55}
u^{n+1} = 2u^n - u^{n-1} - \Delta t^2 \omega^2u^{n},\]</div>
<p>which is nothing but the centered scheme <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a>!
The two seemingly different numerical methods are mathematically
equivalent. Consequently,
the previous analysis of
<a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a> also applies to the Euler-Cromer
method. In particular, the amplitude is constant, given that the stability
criterion is fulfilled, but there is always an angular frequency error
<a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><span class="std std-ref">(19)</span></a>. <a class="reference internal" href="#vib-exer-eulercromer-analysis"><span class="std std-ref">Exercise 17: Analysis of the Euler-Cromer scheme</span></a>
gives guidance on how to derive the exact discrete solution of
the two equations in the Euler-Cromer method.</p>
<p>Although the Euler-Cromer scheme and the method <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a> are
equivalent, there could be differences in the way they handle
the initial conditions. Let is look into this topic.
The initial condition <span class="math">\(u^{\prime}=0\)</span> means <span class="math">\(u^{\prime}=v=0\)</span>.  From
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><span class="std std-ref">(53)</span></a> we get <span class="math">\(v^1=-\omega^2 u^0\)</span>
and <span class="math">\(u^1=u^0 - \omega^2\Delta t^2 u^0\)</span>. When using
a centered approximation of <span class="math">\(u^{\prime}(0)=0\)</span> combined with the
discretization <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a> of the second-order ODE, we
get <span class="math">\(u^1=u^0 - \frac{1}{2}\omega^2\Delta t^2 u^0\)</span>. The difference
is <span class="math">\(\frac{1}{2}\omega^2\Delta t^2 u^0\)</span>, which is of second order in <span class="math">\(\Delta t\)</span>,
seemingly
consistent with the overall error in the scheme for the differential equation
model.</p>
<p>A different view can also be taken.
If we approximate <span class="math">\(u^{\prime}(0)=0\)</span> by a backward difference,
<span class="math">\((u^0-u^{-1})/\Delta t =0\)</span>, we get <span class="math">\(u^{-1}=u^0\)</span>, and when combined
with <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a>, it results in
<span class="math">\(u^1=u^0 - \omega^2\Delta t^2 u^0\)</span>. This means that
the Euler-Cromer method based on
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><span class="std std-ref">(53)</span></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><span class="std std-ref">(52)</span></a>
corresponds to using only a first-order approximation to the initial condition
in the method from the section <a class="reference internal" href="#vib-ode1-fdm"><span class="std std-ref">A centered finite difference scheme</span></a>.</p>
<p>Correspondingly, using the formulation
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1"><span class="std std-ref">(50)</span></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1"><span class="std std-ref">(51)</span></a>
with <span class="math">\(v^n=0\)</span> leads to <span class="math">\(u^1=u^0\)</span>, which can be interpreted as using
a forward difference approximation for the initial condition <span class="math">\(u^{\prime}(0)=0\)</span>.
Both Euler-Cromer formulations lead to slightly different values for
<span class="math">\(u^1\)</span> compared to the method in the section <a class="reference internal" href="#vib-ode1-fdm"><span class="std std-ref">A centered finite difference scheme</span></a>.
The error is <span class="math">\(\frac{1}{2}\omega^2\Delta t^2 u^0\)</span> and of the same order
as the overall scheme.</p>
</div>
<div class="section" id="implementation-2">
<span id="vib-model2x2-eulercromer-impl"></span><h3>Implementation<a class="headerlink" href="#implementation-2" title="Permalink to this headline">¶</a></h3>
<p>The function below, found in <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib_EulerCromer.py">vib_EulerCromer.py</a> implements the Euler-Cromer scheme
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><span class="std std-ref">(52)</span></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><span class="std std-ref">(53)</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve v&#39; = - w**2*u, u&#39;=v for t in (0,T], u(0)=I and v(0)=0,</span>
<span class="sd">    by an Euler-Cromer method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>Since the Euler-Cromer scheme is equivalent to the finite difference
method for the second-order ODE <span class="math">\(u^{\prime\prime}+\omega^2u=0\)</span> (see the section <a class="reference internal" href="#vib-model2x2-eulercromer-equiv"><span class="std std-ref">Equivalence with the scheme for the second-order ODE</span></a>), the performance of the above
<code class="docutils literal"><span class="pre">solver</span></code> function is the same as for the <code class="docutils literal"><span class="pre">solver</span></code> function in the section <a class="reference internal" href="#vib-impl1"><span class="std std-ref">Implementation</span></a>. The only difference is the formula for the first time
step, as discussed above.  This deviation in the Euler-Cromer scheme
means that the discrete solution listed in the section <a class="reference internal" href="#vib-ode1-analysis-sol"><span class="std std-ref">Exact discrete solution</span></a> is not a solution of the Euler-Cromer
scheme!</p>
<p>To verify the implementation of the Euler-Cromer method we
can adjust <code class="docutils literal"><span class="pre">v[1]</span></code> so that the computer-generated values can be
compared with the formula
<a class="reference internal" href="#eq-vib-ode1-un-exact"><span class="std std-ref">(20)</span></a> from in the section <a class="reference internal" href="#vib-ode1-analysis-sol"><span class="std std-ref">Exact discrete solution</span></a>. This
adjustment is done in an alternative solver function, <code class="docutils literal"><span class="pre">solver_ic_fix</span></code>
in <code class="docutils literal"><span class="pre">vib_EulerCromer.py</span></code>. Since we now have an exact solution of the
discrete equations available, we can write a test function
<code class="docutils literal"><span class="pre">test_solver</span></code> for checking the equality of computed values with the
formula <a class="reference internal" href="#eq-vib-ode1-un-exact"><span class="std std-ref">(20)</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_solver</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test solver with fixed initial condition against</span>
<span class="sd">    equivalent scheme for the 2nd-order ODE u&#39;&#39; + u = 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span> <span class="n">w</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span> <span class="n">T</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">w</span>  <span class="c"># longest possible time step</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver_ic_fix</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">vib_undamped</span> <span class="kn">import</span> <span class="n">solver</span> <span class="k">as</span> <span class="n">solver2</span>  <span class="c"># 2nd-order ODE</span>
    <span class="n">u2</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">solver2</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>Another function, <code class="docutils literal"><span class="pre">demo</span></code>,
visualizes the difference between Euler-Cromer scheme and the scheme
<a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a>
for the second-oder ODE, arising from the mismatch in the first time level.</p>
<p>[<strong>hpl 7</strong>: Odespy&#8217;s Euler-Cromer, but it needs more work with the example code.]</p>
</div>
<div class="section" id="the-velocity-verlet-algorithm">
<h3>The velocity Verlet algorithm<a class="headerlink" href="#the-velocity-verlet-algorithm" title="Permalink to this headline">¶</a></h3>
<p>Another very popular algorithm for vibration problems <span class="math">\(u^{\prime\prime}+\omega^2u=0\)</span>
can be derived as follows. First, we step <span class="math">\(u\)</span> forward from <span class="math">\(t_n\)</span> to
<span class="math">\(t_{n+1}\)</span> using a three-term Taylor series,</p>
<div class="math">
\[u(t_{n+1}) = u(t_n) + u^{\prime}(t_n)\Delta t + \frac{1}{2}u^{\prime\prime}(t_n)\Delta t^2\tp\]</div>
<p>Using <span class="math">\(u^{\prime}=v\)</span> and <span class="math">\(u^{\prime\prime}=-\omega^2u\)</span>, we get the updating formula</p>
<div class="math">
\[u^{n+1} = u^n + v^n\Delta t - \frac{1}{2}\Delta^2\omega^2u^n\tp\]</div>
<p>Second, the first-order equation for <span class="math">\(v\)</span>,</p>
<div class="math">
\[v'=-\omega^2u,\]</div>
<p>is discretized by a centered difference
in a Crank-Nicolson fashion at <span class="math">\(t_{n+\frac{1}{2}}\)</span>:</p>
<div class="math">
\[\frac{v^{n+1}-v^n}{\Delta t} = -\omega^2\frac{1}{2}(u^n + u^{n+1})\tp\]</div>
<p>To summarize, we have the scheme</p>
<div class="math" id="eq-vib-model2x2-verlet-dueq">
\[\tag{56}
u^{n+1} = u^n + v^n\Delta t - \frac{1}{2}\Delta^2\omega^2u^n\]</div>
<div class="math" id="eq-vib-model2x2-verlet-dveq">
\[\tag{57}
v^{n+1} = v^n -\frac{1}{2}\Delta t\omega^2 (u^n + u^{n+1}),\]</div>
<p>known as the <em>velocity Verlet</em> algorithm.
Observe that this scheme is explicit since <span class="math">\(u^{n+1}\)</span> in
<a class="reference internal" href="#eq-vib-model2x2-verlet-dveq"><span class="std std-ref">(57)</span></a> is already computed
from <a class="reference internal" href="#eq-vib-model2x2-verlet-dueq"><span class="std std-ref">(56)</span></a>.</p>
<p>The algorithm can be straightforwardly implemented as shown below (the
code appears in the file <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib_undamped_velocity_Verlet.py">vib_undamped_velocity_Verlet.py</a>).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">vib_undamped</span> <span class="kn">import</span> <span class="n">convergence_rates</span><span class="p">,</span> <span class="n">main</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">return_v</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=v, v&#39;=-w**2*u for t in (0,T], u(0)=I and v(0)=0,</span>
<span class="sd">    by the velocity Verlet method with time step dt.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nt</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">*</span><span class="n">dt</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">return_v</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Return just u and t as in the vib_undamped.py&#39;s solver</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>We provide the option that this <code class="docutils literal"><span class="pre">solver</span></code> function returns the same data
as the <code class="docutils literal"><span class="pre">solver</span></code> function from the section <a class="reference internal" href="#vib-impl1-solver"><span class="std std-ref">Making a solver function</span></a> (if <code class="docutils literal"><span class="pre">return_v</span></code>
is <code class="docutils literal"><span class="pre">False</span></code>), but we may return <code class="docutils literal"><span class="pre">v</span></code> along with <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">t</span></code>.</p>
<p>The error in the Taylor series expansion behind
<a class="reference internal" href="#eq-vib-model2x2-verlet-dueq"><span class="std std-ref">(56)</span></a> is <span class="math">\(\Oof{\Delta t^3}\)</span>, while the error
in the central difference for <span class="math">\(v\)</span> is <span class="math">\(\Oof{\Delta t^2}\)</span>.  The overall
error is then no better than <span class="math">\(\Oof{\Delta t^2}\)</span>, which can be verified
empirically using the <code class="docutils literal"><span class="pre">convergence_rates</span></code> function from
<a class="reference internal" href="#vib-ode1-verify"><span class="std std-ref">Verification</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">vib_undamped_velocity_Verlet</span> <span class="kn">as</span> <span class="nn">m</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">convergence_rates</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">solver_function</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">solver</span><span class="p">)</span>
<span class="go">[2.0036366687367346, 2.0009497328124835, 2.000240105995295]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="generalization-damping-nonlinear-spring-and-external-excitation">
<span id="vib-model2"></span><h2>Generalization: damping, nonlinear spring, and external excitation<a class="headerlink" href="#generalization-damping-nonlinear-spring-and-external-excitation" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-25"></span><span class="target" id="index-26"></span><p id="index-27">We shall now generalize the simple model problem from
the section <a class="reference internal" href="#vib-model1"><span class="std std-ref">Finite difference discretization</span></a> to include a possibly nonlinear damping term <span class="math">\(f(u^{\prime})\)</span>,
a possibly nonlinear spring (or restoring) force <span class="math">\(s(u)\)</span>, and
some external excitation <span class="math">\(F(t)\)</span>:</p>
<div class="math" id="eq-vib-ode2">
\[\tag{58}
mu^{\prime\prime} + f(u^{\prime}) + s(u) = F(t),\quad u(0)=I,\ u^{\prime}(0)=V,\ t\in (0,T]
    \tp\]</div>
<p>We have also included a possibly nonzero initial value of <span class="math">\(u^{\prime}(0)\)</span>.
The parameters <span class="math">\(m\)</span>, <span class="math">\(f(u^{\prime})\)</span>, <span class="math">\(s(u)\)</span>, <span class="math">\(F(t)\)</span>, <span class="math">\(I\)</span>, <span class="math">\(V\)</span>, and <span class="math">\(T\)</span> are
input data.</p>
<p>There are two main types of damping (friction) forces: linear <span class="math">\(f(u^{\prime})=bu\)</span>, or
quadratic <span class="math">\(f(u^{\prime})=bu^{\prime}|u^{\prime}|\)</span>. Spring systems often feature linear
damping, while air resistance usually gives rise to quadratic damping.
Spring forces are often linear: <span class="math">\(s(u)=cu\)</span>, but nonlinear versions
are also common, the most famous is the gravity force on a pendulum
that acts as a spring with <span class="math">\(s(u)\sim \sin(u)\)</span>.</p>
<div class="section" id="a-centered-scheme-for-linear-damping">
<span id="vib-ode2-fdm-flin"></span><h3>A centered scheme for linear damping<a class="headerlink" href="#a-centered-scheme-for-linear-damping" title="Permalink to this headline">¶</a></h3>
<p>Sampling <a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(58)</span></a> at a mesh point <span class="math">\(t_n\)</span>, replacing
<span class="math">\(u^{\prime\prime}(t_n)\)</span> by <span class="math">\([D_tD_tu]^n\)</span>, and <span class="math">\(u^{\prime}(t_n)\)</span> by <span class="math">\([D_{2t}u]^n\)</span> results
in the discretization</p>
<div class="math" id="eq-auto22">
\[\tag{59}
[mD_tD_t u + f(D_{2t}u) + s(u) = F]^n,\]</div>
<p>which written out means</p>
<div class="math" id="eq-vib-ode2-step3b">
\[\tag{60}
m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
    + f(\frac{u^{n+1}-u^{n-1}}{2\Delta t}) + s(u^n) = F^n,\]</div>
<p>where <span class="math">\(F^n\)</span> as usual means <span class="math">\(F(t)\)</span> evaluated at <span class="math">\(t=t_n\)</span>.
Solving <a class="reference internal" href="#eq-vib-ode2-step3b"><span class="std std-ref">(60)</span></a> with respect to the unknown
<span class="math">\(u^{n+1}\)</span> gives a problem: the <span class="math">\(u^{n+1}\)</span> inside the <span class="math">\(f\)</span> function
makes the equation <em>nonlinear</em> unless <span class="math">\(f(u^{\prime})\)</span> is a linear function,
<span class="math">\(f(u^{\prime})=bu^{\prime}\)</span>. For now we shall assume that <span class="math">\(f\)</span> is linear in <span class="math">\(u^{\prime}\)</span>.
Then</p>
<div class="math" id="eq-vib-ode2-step3b2">
\[\tag{61}
m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
    + b\frac{u^{n+1}-u^{n-1}}{2\Delta t} + s(u^n) = F^n,\]</div>
<p>which gives an explicit formula for <span class="math">\(u\)</span> at each
new time level:</p>
<div class="math" id="eq-vib-ode2-step4">
\[\tag{62}
u^{n+1} = (2mu^n + (\frac{b}{2}\Delta t - m)u^{n-1} +
    \Delta t^2(F^n - s(u^n)))(m + \frac{b}{2}\Delta t)^{-1}\]\[    \tp\]</div>
<p>For the first time step we need to discretize <span class="math">\(u^{\prime}(0)=V\)</span>
as <span class="math">\([D_{2t}u = V]^0\)</span> and combine
with <a class="reference internal" href="#eq-vib-ode2-step4"><span class="std std-ref">(62)</span></a> for <span class="math">\(n=0\)</span>. The discretized initial condition
leads to</p>
<div class="math" id="eq-vib-ode2-ic-du">
\[\tag{63}
u^{-1} = u^{1} - 2\Delta t V,\]</div>
<p>which inserted in <a class="reference internal" href="#eq-vib-ode2-step4"><span class="std std-ref">(62)</span></a> for <span class="math">\(n=0\)</span> gives an equation
that can be solved for
<span class="math">\(u^1\)</span>:</p>
<div class="math" id="eq-vib-ode2-step4b">
\[\tag{64}
u^1 = u^0 + \Delta t\, V
    + \frac{\Delta t^2}{2m}(-bV - s(u^0) + F^0)
    \tp\]</div>
</div>
<div class="section" id="a-centered-scheme-for-quadratic-damping">
<span id="vib-ode2-fdm-fquad"></span><h3>A centered scheme for quadratic damping<a class="headerlink" href="#a-centered-scheme-for-quadratic-damping" title="Permalink to this headline">¶</a></h3>
<p>When <span class="math">\(f(u^{\prime})=bu^{\prime}|u^{\prime}|\)</span>, we get a quadratic equation for <span class="math">\(u^{n+1}\)</span>
in <a class="reference internal" href="#eq-vib-ode2-step3b"><span class="std std-ref">(60)</span></a>. This equation can be straightforwardly
solved by the well-known formula for the roots of a quadratic equation.
However, we can also avoid the nonlinearity by introducing
an approximation with an error of order no higher than what we
already have from replacing derivatives with finite differences.</p>
<span class="target" id="index-28"></span><p id="index-29">We start with <a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(58)</span></a> and only replace
<span class="math">\(u^{\prime\prime}\)</span> by <span class="math">\(D_tD_tu\)</span>, resulting in</p>
<div class="math" id="eq-vib-ode2-quad-idea1">
\[\tag{65}
[mD_tD_t u + bu^{\prime}|u^{\prime}| + s(u) = F]^n\tp\]</div>
<p>Here, <span class="math">\(u^{\prime}|u^{\prime}|\)</span> is to be computed at time <span class="math">\(t_n\)</span>. The idea
is now to introduce
a <em>geometric mean</em>, defined by</p>
<div class="math">
\[(w^2)^n \approx w^{n-\half}w^{n+\half},\]</div>
<p>for some quantity <span class="math">\(w\)</span> depending on time. The error in the geometric mean
approximation is <span class="math">\(\Oof{\Delta t^2}\)</span>, the same as in the
approximation <span class="math">\(u^{\prime\prime}\approx D_tD_tu\)</span>. With <span class="math">\(w=u^{\prime}\)</span> it follows
that</p>
<div class="math">
\[[u^{\prime}|u^{\prime}|]^n \approx u^{\prime}(t_{n+\half})|u^{\prime}(t_{n-\half})|\tp\]</div>
<p>The next step is to approximate
<span class="math">\(u^{\prime}\)</span> at <span class="math">\(t_{n\pm 1/2}\)</span>, and fortunately a centered difference
fits perfectly into the formulas since it involves <span class="math">\(u\)</span> values at
the mesh points only. With the approximations</p>
<div class="math" id="eq-vib-ode2-quad-idea2">
\[\tag{66}
u^{\prime}(t_{n+1/2})\approx [D_t u]^{n+\half},\quad u^{\prime}(t_{n-1/2})\approx [D_t u]^{n-\half},\]</div>
<p>we get</p>
<div class="math" id="eq-auto23">
\[\tag{67}
[u^{\prime}|u^{\prime}|]^n
    \approx [D_tu]^{n+\half}|[D_tu]^{n-\half}| = \frac{u^{n+1}-u^n}{\Delta t}
    \frac{|u^n-u^{n-1}|}{\Delta t}
    \tp\]</div>
<p>The counterpart to <a class="reference internal" href="#eq-vib-ode2-step3b"><span class="std std-ref">(60)</span></a> is then</p>
<div class="math" id="eq-vib-ode2-step3b-quad">
\[\tag{68}
m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
    + b\frac{u^{n+1}-u^n}{\Delta t}\frac{|u^n-u^{n-1}|}{\Delta t}
    + s(u^n) = F^n,\]</div>
<p>which is linear in the unknown <span class="math">\(u^{n+1}\)</span>. Therefore, we can easily solve
<a class="reference internal" href="#eq-vib-ode2-step3b-quad"><span class="std std-ref">(68)</span></a>
with respect to <span class="math">\(u^{n+1}\)</span> and achieve the explicit updating formula</p>
<div class="math">
\[u^{n+1} =  \left( m + b|u^n-u^{n-1}|\right)^{-1}\times \nonumber\]</div>
<div class="math" id="eq-vib-ode2-step4-quad">
\[\tag{69}
\qquad \left(2m u^n - mu^{n-1} + bu^n|u^n-u^{n-1}| + \Delta t^2 (F^n - s(u^n))
    \right)
    \tp\]</div>
<p>In the derivation of a special equation for the first
time step we run into some trouble: inserting <a class="reference internal" href="#eq-vib-ode2-ic-du"><span class="std std-ref">(63)</span></a>
in <a class="reference internal" href="#eq-vib-ode2-step4-quad"><span class="std std-ref">(69)</span></a> for <span class="math">\(n=0\)</span> results in a complicated nonlinear
equation for <span class="math">\(u^1\)</span>. By thinking differently about the problem we can
easily get away with the nonlinearity again. We have for <span class="math">\(n=0\)</span> that
<span class="math">\(b[u^{\prime}|u^{\prime}|]^0 = bV|V|\)</span>. Using this value in <a class="reference internal" href="#eq-vib-ode2-quad-idea1"><span class="std std-ref">(65)</span></a>
gives</p>
<div class="math" id="eq-auto24">
\[\tag{70}
[mD_tD_t u + bV|V| + s(u) = F]^0
    \tp\]</div>
<p>Writing this equation out and using <a class="reference internal" href="#eq-vib-ode2-ic-du"><span class="std std-ref">(63)</span></a> results in the
special equation for the first time step:</p>
<div class="math" id="eq-vib-ode2-step4b-quad">
\[\tag{71}
u^1 = u^0 + \Delta t V + \frac{\Delta t^2}{2m}\left(-bV|V| - s(u^0) + F^0\right)
    \tp\]</div>
</div>
<div class="section" id="a-forward-backward-discretization-of-the-quadratic-damping-term">
<h3>A forward-backward discretization of the quadratic damping term<a class="headerlink" href="#a-forward-backward-discretization-of-the-quadratic-damping-term" title="Permalink to this headline">¶</a></h3>
<p>The previous section first proposed to discretize the quadratic
damping term <span class="math">\(|u^{\prime}|u^{\prime}\)</span> using centered differences:
<span class="math">\([|D_{2t}|D_{2t}u]^n\)</span>. As this gives rise to a nonlinearity in
<span class="math">\(u^{n+1}\)</span>, it was instead proposed to use a geometric mean combined
with centered differences.  But there are other alternatives. To get
rid of the nonlinearity in <span class="math">\([|D_{2t}|D_{2t}u]^n\)</span>, one can think
differently: apply a backward difference to <span class="math">\(|u^{\prime}|\)</span>, such that
the term involves known values, and apply a forward difference to
<span class="math">\(u^{\prime}\)</span> to make the term linear in the unknown <span class="math">\(u^{n+1}\)</span>. With
mathematics,</p>
<div class="math" id="eq-vib-ode2-nonlin-fbdiff">
\[\tag{72}
[\beta |u^{\prime}|u^{\prime}]^n \approx \beta |[D_t^-u]^n|[D_t^+ u]^n =
    \beta\left\vert\frac{u^n-u^{n-1}}{\Delta t}\right\vert
    \frac{u^{n+1}-u^n}{\Delta t}\tp\]</div>
<p>The forward and backward differences have both an error proportional
to <span class="math">\(\Delta t\)</span> so one may think the discretization above leads to
a first-order scheme.
However, by looking at the formulas, we realize that the forward-backward
differences in <a class="reference internal" href="#eq-vib-ode2-nonlin-fbdiff"><span class="std std-ref">(72)</span></a>
result in exactly the same scheme as in
<a class="reference internal" href="#eq-vib-ode2-step3b-quad"><span class="std std-ref">(68)</span></a> where we
used a geometric mean and centered differences and committed errors
of size <span class="math">\(\Oof{\Delta t^2}\)</span>. Therefore, the forward-backward
differences in <a class="reference internal" href="#eq-vib-ode2-nonlin-fbdiff"><span class="std std-ref">(72)</span></a>
act in a symmetric way and actually produce a second-order
accurate discretization of the quadratic damping term.</p>
</div>
<div class="section" id="implementation-3">
<span id="vib-ode2-solver"></span><h3>Implementation<a class="headerlink" href="#implementation-3" title="Permalink to this headline">¶</a></h3>
<p>The algorithm arising from the methods in the sections <a class="reference internal" href="#vib-ode2-fdm-flin"><span class="std std-ref">A centered scheme for linear damping</span></a>
and <a class="reference internal" href="#vib-ode2-fdm-fquad"><span class="std std-ref">A centered scheme for quadratic damping</span></a> is very similar to the undamped case in
the section <a class="reference internal" href="#vib-ode1-fdm"><span class="std std-ref">A centered finite difference scheme</span></a>. The difference is
basically a question of different formulas for <span class="math">\(u^1\)</span> and
<span class="math">\(u^{n+1}\)</span>. This is actually quite remarkable. The equation
<a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(58)</span></a> is normally impossible to solve by pen and paper, but
possible for some special choices of <span class="math">\(F\)</span>, <span class="math">\(s\)</span>, and <span class="math">\(f\)</span>. On the
contrary, the complexity of the
nonlinear generalized model <a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(58)</span></a> versus the
simple undamped model is not a big deal when we solve the
problem numerically!</p>
<p>The computational algorithm takes the form</p>
<blockquote>
<div><ol class="arabic simple">
<li><span class="math">\(u^0=I\)</span></li>
<li>compute <span class="math">\(u^1\)</span> from <a class="reference internal" href="#eq-vib-ode2-step4b"><span class="std std-ref">(64)</span></a> if linear
damping or <a class="reference internal" href="#eq-vib-ode2-step4b-quad"><span class="std std-ref">(71)</span></a> if quadratic damping</li>
<li>for <span class="math">\(n=1,2,\ldots,N_t-1\)</span>:</li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li>compute <span class="math">\(u^{n+1}\)</span> from <a class="reference internal" href="#eq-vib-ode2-step4"><span class="std std-ref">(62)</span></a> if linear
damping or <a class="reference internal" href="#eq-vib-ode2-step4-quad"><span class="std std-ref">(69)</span></a> if quadratic damping</li>
</ol>
</div></blockquote>
</div></blockquote>
<p>Modifying the <code class="docutils literal"><span class="pre">solver</span></code> function for the undamped case is fairly
easy, the big difference being many more terms and if tests on
the type of damping:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="s">&#39;linear&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve m*u&#39;&#39; + f(u&#39;) + s(u) = F(t) for t in (0,T],</span>
<span class="sd">    u(0)=I and u&#39;(0)=V,</span>
<span class="sd">    by a central finite difference method with time step dt.</span>
<span class="sd">    If damping is &#39;linear&#39;, f(u&#39;)=b*u, while if damping is</span>
<span class="sd">    &#39;quadratic&#39;, f(u&#39;)=b*u&#39;*abs(u&#39;).</span>
<span class="sd">    F(t) and s(u) are Python functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="c"># avoid integer div.</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="k">if</span> <span class="n">damping</span> <span class="o">==</span> <span class="s">&#39;linear&#39;</span><span class="p">:</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span> <span class="o">+</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">V</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">damping</span> <span class="o">==</span> <span class="s">&#39;quadratic&#39;</span><span class="p">:</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span> <span class="o">+</span> \
               <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">V</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">damping</span> <span class="o">==</span> <span class="s">&#39;linear&#39;</span><span class="p">:</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                      <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">])))</span><span class="o">/</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">damping</span> <span class="o">==</span> <span class="s">&#39;quadratic&#39;</span><span class="p">:</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                      <span class="o">+</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">])))</span><span class="o">/</span>\
                      <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>The complete code resides in the file <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib.py">vib.py</a>.</p>
</div>
<div class="section" id="verification-2">
<span id="vib-ode2-verify"></span><h3>Verification<a class="headerlink" href="#verification-2" title="Permalink to this headline">¶</a></h3>
<div class="section" id="constant-solution">
<h4>Constant solution<a class="headerlink" href="#constant-solution" title="Permalink to this headline">¶</a></h4>
<p>For debugging and initial verification, a constant solution is often
very useful. We choose <span class="math">\(\uex(t)=I\)</span>, which implies <span class="math">\(V=0\)</span>.
Inserted in the ODE, we get
<span class="math">\(F(t)=s(I)\)</span> for any choice of <span class="math">\(f\)</span>. Since the discrete derivative
of a constant vanishes (in particular, <span class="math">\([D_{2t}I]^n=0\)</span>,
<span class="math">\([D_tI]^n=0\)</span>, and <span class="math">\([D_tD_t I]^n=0\)</span>), the constant solution also fulfills
the discrete equations. The constant should therefore be reproduced
to machine precision. The function <code class="docutils literal"><span class="pre">test_constant</span></code> in <code class="docutils literal"><span class="pre">vib.py</span></code>
implements this test.</p>
<p>[<strong>hpl 8</strong>: Add verification tests for constant, linear, quadratic. Check how many bugs that are caught by these tests.]</p>
</div>
<div class="section" id="linear-solution">
<h4>Linear solution<a class="headerlink" href="#linear-solution" title="Permalink to this headline">¶</a></h4>
<p>Now we choose a linear solution: <span class="math">\(\uex = ct + d\)</span>. The initial condition
<span class="math">\(u(0)=I\)</span> implies <span class="math">\(d=I\)</span>, and <span class="math">\(u^{\prime}(0)=V\)</span> forces <span class="math">\(c\)</span> to be <span class="math">\(V\)</span>.
Inserting <span class="math">\(\uex=Vt+I\)</span> in the ODE with linear damping results in</p>
<div class="math">
\[0 + bV + s(Vt+I) = F(t),\]</div>
<p>while quadratic damping requires the source term</p>
<div class="math">
\[0 + b|V|V + s(Vt+I) = F(t)\tp\]</div>
<p>Since the finite difference approximations used to compute <span class="math">\(u^{\prime}\)</span> all
are exact for a linear function, it turns out that the linear <span class="math">\(\uex\)</span>
is also a solution of the discrete equations.
<a class="reference internal" href="#vib-exer-verify-gen-linear"><span class="std std-ref">Exercise 9: Use linear/quadratic functions for verification</span></a> asks you to carry out
all the details.</p>
</div>
<div class="section" id="quadratic-solution">
<h4>Quadratic solution<a class="headerlink" href="#quadratic-solution" title="Permalink to this headline">¶</a></h4>
<p>Choosing <span class="math">\(\uex = bt^2 + Vt + I\)</span>, with <span class="math">\(b\)</span> arbitrary,
fulfills the initial conditions and
fits the ODE if <span class="math">\(F\)</span> is adjusted properly. The solution also solves
the discrete equations with linear damping. However, this quadratic
polynomial in <span class="math">\(t\)</span> does not fulfill the discrete equations in case
of quadratic damping, because the geometric mean used in the approximation
of this term introduces an error.
Doing <a class="reference internal" href="#vib-exer-verify-gen-linear"><span class="std std-ref">Exercise 9: Use linear/quadratic functions for verification</span></a> will reveal
the details. One can fit <span class="math">\(F^n\)</span> in the discrete equations such that
the quadratic polynomial is reproduced by the numerical method (to
machine precision).</p>
</div>
</div>
<div class="section" id="visualization">
<span id="vib-ode2-viz"></span><h3>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h3>
<p>The functions for visualizations differ significantly from
those in the undamped case in the <code class="docutils literal"><span class="pre">vib_undamped.py</span></code> program because,
in the present general case, we do not have an exact solution to
include in the plots. Moreover, we have no good estimate of
the periods of the oscillations as there will be one period
determined by the system parameters, essentially the
approximate frequency <span class="math">\(\sqrt{s'(0)/m}\)</span> for linear <span class="math">\(s\)</span> and small damping,
and one period dictated by <span class="math">\(F(t)\)</span> in case the excitation is periodic.
This is, however,
nothing that the program can depend on or make use of.
Therefore, the user has to specify <span class="math">\(T\)</span> and the window width
to get a plot that moves with the graph and shows
the most recent parts of it in long time simulations.</p>
<p>The <code class="docutils literal"><span class="pre">vib.py</span></code> code
contains several functions for analyzing the time series signal
and for visualizing the solutions.</p>
</div>
<div class="section" id="user-interface">
<span id="vib-ode2-ui"></span><h3>User interface<a class="headerlink" href="#user-interface" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-30"></span><p id="index-31">The <code class="docutils literal"><span class="pre">main</span></code> function is changed substantially from
the <code class="docutils literal"><span class="pre">vib_undamped.py</span></code> code, since we need to
specify the new data <span class="math">\(c\)</span>, <span class="math">\(s(u)\)</span>, and <span class="math">\(F(t)\)</span>.  In addition, we must
set <span class="math">\(T\)</span> and the plot window width (instead of the number of periods we
want to simulate as in <code class="docutils literal"><span class="pre">vib_undamped.py</span></code>). To figure out whether we
can use one plot for the whole time series or if we should follow the
most recent part of <span class="math">\(u\)</span>, we can use the <code class="docutils literal"><span class="pre">plot_empricial_freq_and_amplitude</span></code>
function&#8217;s estimate of the number of local maxima. This number is now
returned from the function and used in <code class="docutils literal"><span class="pre">main</span></code> to decide on the
visualization technique.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">argparse</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--I&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--V&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--m&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--c&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--s&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--F&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&#39;0&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--dt&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--T&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">140</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--damping&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&#39;linear&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--window_width&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--savefig&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;store_true&#39;</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="kn">from</span> <span class="nn">scitools.std</span> <span class="kn">import</span> <span class="n">StringFunction</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">StringFunction</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">independent_variable</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">StringFunction</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="n">independent_variable</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">window_width</span><span class="p">,</span> <span class="n">savefig</span><span class="p">,</span> <span class="n">damping</span> <span class="o">=</span> \
       <span class="n">a</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">window_width</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">savefig</span><span class="p">,</span> \
       <span class="n">a</span><span class="o">.</span><span class="n">damping</span>

    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">num_periods</span> <span class="o">=</span> <span class="n">empirical_freq_and_amplitude</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_periods</span> <span class="o">&lt;=</span> <span class="mi">15</span><span class="p">:</span>
        <span class="n">figure</span><span class="p">()</span>
        <span class="n">visualize</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">visualize_front</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">window_width</span><span class="p">,</span> <span class="n">savefig</span><span class="p">)</span>
    <span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The program <code class="docutils literal"><span class="pre">vib.py</span></code> contains
the above code snippets and can solve the model problem
<a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(58)</span></a>. As a demo of <code class="docutils literal"><span class="pre">vib.py</span></code>, we consider the case
<span class="math">\(I=1\)</span>, <span class="math">\(V=0\)</span>, <span class="math">\(m=1\)</span>, <span class="math">\(c=0.03\)</span>, <span class="math">\(s(u)=\sin(u)\)</span>, <span class="math">\(F(t)=3\cos(4t)\)</span>,
<span class="math">\(\Delta t = 0.05\)</span>, and <span class="math">\(T=140\)</span>. The relevant command to run is</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python vib.py --s &#39;sin(u)&#39; --F &#39;3*cos(4*t)&#39; --c 0.03
</pre></div>
</div>
<p>This results in a <a class="reference external" href="http://tinyurl.com/opdfafk/pub/mov-vib/vib_generalized_dt0.05/index.html">moving window following the function</a> on the screen.
Figure <a class="reference internal" href="#vib-ode2-fig-demo"><span class="std std-ref">Damped oscillator excited by a sinusoidal function</span></a> shows a part of the time series.</p>
<div class="figure" id="id17">
<span id="vib-ode2-fig-demo"></span><a class="reference internal image-reference" href="_images/vib_gen_demo.png"><img alt="_images/vib_gen_demo.png" src="_images/vib_gen_demo.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Damped oscillator excited by a sinusoidal function</em></span></p>
</div>
</div>
<div class="section" id="the-euler-cromer-scheme-for-the-generalized-model">
<h3>The Euler-Cromer scheme for the generalized model<a class="headerlink" href="#the-euler-cromer-scheme-for-the-generalized-model" title="Permalink to this headline">¶</a></h3>
<p>The ideas of the Euler-Cromer method from the section <a class="reference internal" href="#vib-model2x2-eulercromer"><span class="std std-ref">The Euler-Cromer method</span></a>
carry over to the generalized model. We write <a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(58)</span></a>
as two equations for <span class="math">\(u\)</span> and <span class="math">\(v=u^{\prime}\)</span>. The first equation is taken as the
one with <span class="math">\(v'\)</span> on the left-hand side:</p>
<div class="math" id="eq-vib-ode2-eulercromer-veq">
\[\tag{73}
v' = \frac{1}{m}(F(t)-s(u)-f(v)),\]</div>
<div class="math" id="eq-vib-ode2-eulercromer-ueq">
\[\tag{74}
u^{\prime} = v\tp\]</div>
<p>The idea is to step <a class="reference internal" href="#eq-vib-ode2-eulercromer-veq"><span class="std std-ref">(73)</span></a> forward using
a standard Forward Euler method, while we update <span class="math">\(u\)</span> from
<a class="reference internal" href="#eq-vib-ode2-eulercromer-ueq"><span class="std std-ref">(74)</span></a> with a Backward Euler method,
utilizing the recent, computed <span class="math">\(v^{n+1}\)</span> value. In detail,</p>
<div class="math" id="eq-vib-ode2-eulercromer-dveq0a">
\[\tag{75}
\frac{v^{n+1}-v^n}{\Delta t} = \frac{1}{m}(F(t_n)-s(u^n)-f(v^n)),\]</div>
<div class="math" id="eq-vib-ode2-eulercromer-dueq0a">
\[\tag{76}
\frac{u^{n+1}-u^n}{\Delta t} = v^{n+1},\]</div>
<p>resulting in the explicit scheme</p>
<div class="math" id="eq-vib-ode2-eulercromer-dveq">
\[\tag{77}
v^{n+1} = v^n + \Delta t\frac{1}{m}(F(t_n)-s(u^n)-f(v^n)),\]</div>
<div class="math" id="eq-vib-ode2-eulercromer-dueq0">
\[\tag{78}
u^{n+1} = u^n + \Delta t\,v^{n+1}\tp\]</div>
<p>We immediately note one very favorable feature of this scheme: all the
nonlinearities in <span class="math">\(s(u)\)</span> and <span class="math">\(f(v)\)</span> are evaluated at a previous time
level. This makes the Euler-Cromer method easier to apply and
hence much more convenient than the centered scheme for the second-order
ODE <a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(58)</span></a>.</p>
<p>The initial conditions are trivially set as</p>
<div class="math" id="eq-auto25">
\[\tag{79}
v^0 = V,\]</div>
<div class="math" id="eq-auto26">
\[\tag{80}
u^0 = I\tp\]</div>
<p>[<strong>hpl 9</strong>: odespy for the generalized problem]</p>
</div>
</div>
<div class="section" id="exercises-and-problems">
<h2>Exercises and Problems<a class="headerlink" href="#exercises-and-problems" title="Permalink to this headline">¶</a></h2>
<div class="section" id="problem-1-use-linear-quadratic-functions-for-verification">
<span id="vib-exer-undamped-verify-linquad"></span><h3>Problem 1: Use linear/quadratic functions for verification<a class="headerlink" href="#problem-1-use-linear-quadratic-functions-for-verification" title="Permalink to this headline">¶</a></h3>
<p>Consider the ODE problem</p>
<div class="math">
\[u^{\prime\prime} + \omega^2u=f(t), \quad u(0)=I,\ u^{\prime}(0)=V,\ t\in(0,T]\tp\]</div>
<p>Discretize this equation according to
<span class="math">\([D_tD_t u + \omega^2 u = f]^n\)</span>.</p>
<p><strong>a)</strong>
Derive the equation for the
first time step (<span class="math">\(u^1\)</span>).</p>
<p><strong>b)</strong>
For verification purposes,
we use the method of manufactured solutions (MMS) with the
choice of <span class="math">\(\uex(x,t)= ct+d\)</span>.
Find restrictions on <span class="math">\(c\)</span> and <span class="math">\(d\)</span> from
the initial conditions. Compute the corresponding source term <span class="math">\(f\)</span> by term.
Show that <span class="math">\([D_tD_t t]^n=0\)</span> and use the fact
that the <span class="math">\(D_tD_t\)</span> operator is linear,
<span class="math">\([D_tD_t (ct+d)]^n = c[D_tD_t t]^n + [D_tD_t d]^n = 0\)</span>, to show that
<span class="math">\(\uex\)</span> is also a perfect solution of the discrete equations.</p>
<p><strong>c)</strong>
Use <code class="docutils literal"><span class="pre">sympy</span></code> to do the symbolic calculations above. Here is a
sketch of the program <code class="docutils literal"><span class="pre">vib_undamped_verify_mms.py</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="n">V</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;V t I w dt&#39;</span><span class="p">)</span>  <span class="c"># global symbols</span>
<span class="n">f</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># global variable for the source term in the ODE</span>

<span class="k">def</span> <span class="nf">ode_source_term</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the terms in the ODE that the source term</span>
<span class="sd">    must balance, here u&#39;&#39; + w**2*u.</span>
<span class="sd">    u is symbolic Python function of t.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">residual_discrete_eq</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the residual of the discrete eq. with u inserted.&quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">residual_discrete_eq_step1</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the residual of the discrete eq. at the first</span>
<span class="sd">    step with u inserted.&quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DtDt</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return 2nd-order finite difference for u_tt.</span>
<span class="sd">    u is a symbolic Python function of t.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given some chosen solution u (as a function of t, implemented</span>
<span class="sd">    as a Python function), use the method of manufactured solutions</span>
<span class="sd">    to compute the source term f, and check if u also solves</span>
<span class="sd">    the discrete equations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="s">&#39;=== Testing exact solution: </span><span class="si">%s</span><span class="s"> ===&#39;</span> <span class="o">%</span> <span class="n">u</span>
    <span class="k">print</span> <span class="s">&quot;Initial conditions u(0)=</span><span class="si">%s</span><span class="s">, u&#39;(0)=</span><span class="si">%s</span><span class="s">:&quot;</span> <span class="o">%</span> \
          <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c"># Method of manufactured solution requires fitting f</span>
    <span class="k">global</span> <span class="n">f</span>  <span class="c"># source term in the ODE</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">ode_lhs</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

    <span class="c"># Residual in discrete equations (should be 0)</span>
    <span class="k">print</span> <span class="s">&#39;residual step1:&#39;</span><span class="p">,</span> <span class="n">residual_discrete_eq_step1</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;residual:&#39;</span><span class="p">,</span> <span class="n">residual_discrete_eq</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">linear</span><span class="p">():</span>
    <span class="n">main</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">V</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">linear</span><span class="p">()</span>
</pre></div>
</div>
<p>Fill in the various functions such that the calls in the <code class="docutils literal"><span class="pre">main</span></code>
function works.</p>
<p><strong>d)</strong>
The purpose now is to choose a quadratic function
<span class="math">\(\uex = bt^2 + ct + d\)</span> as exact solution. Extend the <code class="docutils literal"><span class="pre">sympy</span></code>
code above with a function <code class="docutils literal"><span class="pre">quadratic</span></code> for fitting <code class="docutils literal"><span class="pre">f</span></code> and checking
if the discrete equations are fulfilled. (The function is very similar
to <code class="docutils literal"><span class="pre">linear</span></code>.)</p>
<p><strong>e)</strong>
Will a polynomial of degree three fulfill the discrete equations?</p>
<p><strong>f)</strong>
Implement a <code class="docutils literal"><span class="pre">solver</span></code> function for computing the numerical
solution of this problem.</p>
<p><strong>g)</strong>
Write a nose test for checking that the quadratic solution
is computed to correctly (too machine precision, but the
round-off errors accumulate and increase with <span class="math">\(T\)</span>) by the <code class="docutils literal"><span class="pre">solver</span></code>
function.</p>
<p>Filename: <code class="docutils literal"><span class="pre">vib_undamped_verify_mms</span></code>.</p>
</div>
<div class="section" id="exercise-2-show-linear-growth-of-the-phase-with-time">
<span id="vib-exer-phase-err-growth"></span><h3>Exercise 2: Show linear growth of the phase with time<a class="headerlink" href="#exercise-2-show-linear-growth-of-the-phase-with-time" title="Permalink to this headline">¶</a></h3>
<p>Consider an exact solution <span class="math">\(I\cos (\omega t)\)</span> and an
approximation <span class="math">\(I\cos(\tilde\omega t)\)</span>.
Define the phase error as time lag between the peak <span class="math">\(I\)</span>
in the exact solution and the corresponding peak in the approximation
after <span class="math">\(m\)</span> periods of oscillations. Show that this phase error
is linear in <span class="math">\(m\)</span>.
Filename: <code class="docutils literal"><span class="pre">vib_phase_error_growth</span></code>.</p>
</div>
<div class="section" id="exercise-3-improve-the-accuracy-by-adjusting-the-frequency">
<span id="vib-exer-w-adjust"></span><h3>Exercise 3: Improve the accuracy by adjusting the frequency<a class="headerlink" href="#exercise-3-improve-the-accuracy-by-adjusting-the-frequency" title="Permalink to this headline">¶</a></h3>
<p>According to <a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><span class="std std-ref">(19)</span></a>, the numerical
frequency deviates from the exact frequency by a (dominating) amount
<span class="math">\(\omega^3\Delta t^2/24 &gt;0\)</span>. Replace the <code class="docutils literal"><span class="pre">w</span></code> parameter in the algorithm
in the <code class="docutils literal"><span class="pre">solver</span></code> function in <code class="docutils literal"><span class="pre">vib_undamped.py</span></code> by <code class="docutils literal"><span class="pre">w*(1</span> <span class="pre">-</span>
<span class="pre">(1./24)*w**2*dt**2</span></code> and test how this adjustment in the numerical
algorithm improves the accuracy (use <span class="math">\(\Delta t =0.1\)</span> and simulate
for 80 periods, with and without adjustment of <span class="math">\(\omega\)</span>).
Filename: <code class="docutils literal"><span class="pre">vib_adjust_w</span></code>.</p>
</div>
<div class="section" id="exercise-4-see-if-adaptive-methods-improve-the-phase-error">
<span id="vib-exer-undamped-adaptive"></span><h3>Exercise 4: See if adaptive methods improve the phase error<a class="headerlink" href="#exercise-4-see-if-adaptive-methods-improve-the-phase-error" title="Permalink to this headline">¶</a></h3>
<p>Adaptive methods for solving ODEs aim at adjusting <span class="math">\(\Delta t\)</span> such
that the error is within a user-prescribed tolerance. Implement the
equation <span class="math">\(u^{\prime\prime}+u=0\)</span> in the <a class="reference external" href="https://github.com/hplgit/odespy">Odespy</a>
software. Use the example <a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/sphinx/._book006.html#example-adaptive-runge-kutta-methods">on adaptive
schemes</a>
in <a class="reference internal" href="._book017.html#ref2" id="id5">[Ref2]</a>.  Run the scheme with a very low
tolerance (say <span class="math">\(10^{-14}\)</span>) and for a long time, check the number of
time points in the solver&#8217;s mesh (<code class="docutils literal"><span class="pre">len(solver.t_all)</span></code>), and compare
the phase error with that produced by the simple finite difference
method from the section <a class="reference internal" href="#vib-ode1-fdm"><span class="std std-ref">A centered finite difference scheme</span></a> with the same number of (equally
spaced) mesh points. The question is whether it pays off to use an
adaptive solver or if equally many points with a simple method gives
about the same accuracy.
Filename: <code class="docutils literal"><span class="pre">vib_undamped_adaptive</span></code>.</p>
</div>
<div class="section" id="exercise-5-use-a-taylor-polynomial-to-compute">
<span id="vib-exer-step4b-alt"></span><h3>Exercise 5: Use a Taylor polynomial to compute <span class="math">\(u^1\)</span><a class="headerlink" href="#exercise-5-use-a-taylor-polynomial-to-compute" title="Permalink to this headline">¶</a></h3>
<p>As an alternative to the derivation of <a class="reference internal" href="#eq-vib-ode1-step4b"><span class="std std-ref">(8)</span></a> for
computing <span class="math">\(u^1\)</span>, one can use a Taylor polynomial with three terms
for <span class="math">\(u^1\)</span>:</p>
<div class="math">
\[u(t_1) \approx u(0) + u^{\prime}(0)\Delta t + {\half}u^{\prime\prime}(0)\Delta t^2\]</div>
<p>With <span class="math">\(u^{\prime\prime}=-\omega^2 u\)</span> and <span class="math">\(u^{\prime}(0)=0\)</span>, show that this method also leads to
<a class="reference internal" href="#eq-vib-ode1-step4b"><span class="std std-ref">(8)</span></a>. Generalize the condition on <span class="math">\(u^{\prime}(0)\)</span> to
be <span class="math">\(u^{\prime}(0)=V\)</span> and compute <span class="math">\(u^1\)</span> in this case with both methods.
Filename: <code class="docutils literal"><span class="pre">vib_first_step</span></code>.</p>
</div>
<div class="section" id="exercise-6-find-the-minimal-resolution-of-an-oscillatory-function">
<span id="vib-exer-wdt-limit"></span><h3>Exercise 6: Find the minimal resolution of an oscillatory function<a class="headerlink" href="#exercise-6-find-the-minimal-resolution-of-an-oscillatory-function" title="Permalink to this headline">¶</a></h3>
<p>Sketch the function on a given mesh which has the highest possible
frequency. That is, this oscillatory &#8220;cos-like&#8221; function has its
maxima and minima at every two grid points.  Find an expression for
the frequency of this function, and use the result to find the largest
relevant value of <span class="math">\(\omega\Delta t\)</span> when <span class="math">\(\omega\)</span> is the frequency
of an oscillating function and <span class="math">\(\Delta t\)</span> is the mesh spacing.
Filename: <code class="docutils literal"><span class="pre">vib_largest_wdt</span></code>.</p>
</div>
<div class="section" id="exercise-7-visualize-the-accuracy-of-finite-differences-for-a-cosine-function">
<span id="vib-exer-fd-exp-plot"></span><h3>Exercise 7: Visualize the accuracy of finite differences for a cosine function<a class="headerlink" href="#exercise-7-visualize-the-accuracy-of-finite-differences-for-a-cosine-function" title="Permalink to this headline">¶</a></h3>
<p>We introduce the error fraction</p>
<div class="math">
\[E = \frac{[D_tD_t u]^n}{u^{\prime\prime}(t_n)}\]</div>
<p>to measure the error in the finite difference approximation <span class="math">\(D_tD_tu\)</span> to
<span class="math">\(u^{\prime\prime}\)</span>.
Compute <span class="math">\(E\)</span>
for the specific choice of a cosine/sine function of the
form <span class="math">\(u=\exp{(i\omega t)}\)</span> and show that</p>
<div class="math">
\[E = \left(\frac{2}{\omega\Delta t}\right)^2
\sin^2(\frac{\omega\Delta t}{2})
\tp\]</div>
<p>Plot <span class="math">\(E\)</span> as a function of <span class="math">\(p=\omega\Delta t\)</span>. The relevant
values of <span class="math">\(p\)</span> are <span class="math">\([0,\pi]\)</span> (see <a class="reference internal" href="#vib-exer-wdt-limit"><span class="std std-ref">Exercise 6: Find the minimal resolution of an oscillatory function</span></a>
for why <span class="math">\(p&gt;\pi\)</span> does not make sense).
The deviation of the curve from unity visualizes the error in the
approximation. Also expand <span class="math">\(E\)</span> as a Taylor polynomial in <span class="math">\(p\)</span> up to
fourth degree (use, e.g., <code class="docutils literal"><span class="pre">sympy</span></code>).
Filename: <code class="docutils literal"><span class="pre">vib_plot_fd_exp_error</span></code>.</p>
</div>
<div class="section" id="exercise-8-verify-convergence-rates-of-the-error-in-energy">
<span id="vib-exer-energy-convrate"></span><h3>Exercise 8: Verify convergence rates of the error in energy<a class="headerlink" href="#exercise-8-verify-convergence-rates-of-the-error-in-energy" title="Permalink to this headline">¶</a></h3>
<p>We consider the ODE problem <span class="math">\(u^{\prime\prime} + \omega^2u=0\)</span>, <span class="math">\(u(0)=I\)</span>, <span class="math">\(u^{\prime}(0)=V\)</span>,
for <span class="math">\(t\in (0,T]\)</span>. The total energy of the solution
<span class="math">\(E(t)=\half(u^{\prime})^2 + \half\omega^2 u^2\)</span> should stay
constant.
The error in energy can be computed as explained in
the section <a class="reference internal" href="#vib-model1-energy"><span class="std std-ref">Energy considerations</span></a>.</p>
<p>Make a nose test in a file <code class="docutils literal"><span class="pre">test_error_conv.py</span></code>, where code from
<code class="docutils literal"><span class="pre">vib_undamped.py</span></code> is imported, but the <code class="docutils literal"><span class="pre">convergence_rates</span></code> and
<code class="docutils literal"><span class="pre">test_convergence_rates</span></code> functions are copied and modified to also
incorporate computations of the error in energy and the convergence
rate of this error. The expected rate is 2.
Filename: <code class="docutils literal"><span class="pre">test_error_conv</span></code>.</p>
</div>
<div class="section" id="exercise-9-use-linear-quadratic-functions-for-verification">
<span id="vib-exer-verify-gen-linear"></span><h3>Exercise 9: Use linear/quadratic functions for verification<a class="headerlink" href="#exercise-9-use-linear-quadratic-functions-for-verification" title="Permalink to this headline">¶</a></h3>
<p>This exercise is a generalization of <a class="reference internal" href="#vib-exer-undamped-verify-linquad"><span class="std std-ref">Problem 1: Use linear/quadratic functions for verification</span></a> to the extended model problem
<a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(58)</span></a> where the damping term is either linear or quadratic.
Solve the various subproblems and see how the results and problem
settings change with the generalized ODE in case of linear or
quadratic damping. By modifying the code from <a class="reference internal" href="#vib-exer-undamped-verify-linquad"><span class="std std-ref">Problem 1: Use linear/quadratic functions for verification</span></a>, <code class="docutils literal"><span class="pre">sympy</span></code> will do most
of the work required to analyze the generalized problem.
Filename: <code class="docutils literal"><span class="pre">vib_verify_mms</span></code>.</p>
</div>
<div class="section" id="exercise-10-use-an-exact-discrete-solution-for-verification">
<span id="vib-exer-discrete-omega"></span><h3>Exercise 10: Use an exact discrete solution for verification<a class="headerlink" href="#exercise-10-use-an-exact-discrete-solution-for-verification" title="Permalink to this headline">¶</a></h3>
<p>Write a nose test function in a separate file
that employs the exact discrete solution
<a class="reference internal" href="#eq-vib-ode1-un-exact"><span class="std std-ref">(20)</span></a> to verify the implementation of the
<code class="docutils literal"><span class="pre">solver</span></code> function in the file <code class="docutils literal"><span class="pre">vib_undamped.py</span></code>.
Filename: <code class="docutils literal"><span class="pre">test_vib_undamped_exact_discrete_sol</span></code>.</p>
</div>
<div class="section" id="exercise-11-use-analytical-solution-for-convergence-rate-tests">
<span id="vib-exer-conv-rate"></span><h3>Exercise 11: Use analytical solution for convergence rate tests<a class="headerlink" href="#exercise-11-use-analytical-solution-for-convergence-rate-tests" title="Permalink to this headline">¶</a></h3>
<p>The purpose of this exercise is to perform convergence tests of the
problem <a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(58)</span></a> when <span class="math">\(s(u)=\omega^2u\)</span> and <span class="math">\(F(t)=A\sin\phi t\)</span>.
Find the complete analytical solution to the problem in this case
(most textbooks on mechanics or ordinary differential equations list
the various elements you need to write down the exact solution).
Modify the <code class="docutils literal"><span class="pre">convergence_rate</span></code> function from the <code class="docutils literal"><span class="pre">vib_undamped.py</span></code>
program to perform experiments with the extended model.  Verify that
the error is of order <span class="math">\(\Delta t^2\)</span>.
Filename: <code class="docutils literal"><span class="pre">vib_conv_rate</span></code>.</p>
</div>
<div class="section" id="exercise-12-investigate-the-amplitude-errors-of-many-solvers">
<span id="vib-exer-undamped-odespy"></span><h3>Exercise 12: Investigate the amplitude errors of many solvers<a class="headerlink" href="#exercise-12-investigate-the-amplitude-errors-of-many-solvers" title="Permalink to this headline">¶</a></h3>
<p>Use the program <code class="docutils literal"><span class="pre">vib_undamped_odespy.py</span></code> from the section <a class="reference internal" href="#vib-model2x2-compare"><span class="std std-ref">Comparison of schemes</span></a> and the amplitude estimation from the
<code class="docutils literal"><span class="pre">amplitudes</span></code> function in the <code class="docutils literal"><span class="pre">vib_undamped.py</span></code> file (see the section <a class="reference internal" href="#vib-ode1-empirical"><span class="std std-ref">Empirical analysis of the solution</span></a>) to investigate how well famous methods for
1st-order ODEs can preserve the amplitude of <span class="math">\(u\)</span> in undamped
oscillations.  Test, for example, the 3rd- and 4th-order Runge-Kutta
methods (<code class="docutils literal"><span class="pre">RK3</span></code>, <code class="docutils literal"><span class="pre">RK4</span></code>), the Crank-Nicolson method (<code class="docutils literal"><span class="pre">CrankNicolson</span></code>),
the 2nd- and 3rd-order Adams-Bashforth methods (<code class="docutils literal"><span class="pre">AdamsBashforth2</span></code>,
<code class="docutils literal"><span class="pre">AdamsBashforth3</span></code>), and a 2nd-order Backwards scheme
(<code class="docutils literal"><span class="pre">Backward2Step</span></code>).  The relevant governing equations are listed in
the beginning of the section <a class="reference internal" href="#vib-model2x2"><span class="std std-ref">Alternative schemes based on 1st-order equations</span></a>.
Filename: <code class="docutils literal"><span class="pre">vib_amplitude_errors</span></code>.</p>
</div>
<div class="section" id="exercise-13-minimize-memory-usage-of-a-vibration-solver">
<span id="vib-exer-memsave"></span><h3>Exercise 13: Minimize memory usage of a vibration solver<a class="headerlink" href="#exercise-13-minimize-memory-usage-of-a-vibration-solver" title="Permalink to this headline">¶</a></h3>
<p>The program <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib.py">vib.py</a>
store the complete solution <span class="math">\(u^0,u^1,\ldots,u^{N_t}\)</span> in memory, which is
convenient for later plotting.
Make a memory minimizing version of this program where only the last three
<span class="math">\(u^{n+1}\)</span>, <span class="math">\(u^n\)</span>, and <span class="math">\(u^{n-1}\)</span> values are stored in memory.
Write each computed <span class="math">\((t_{n+1}, u^{n+1})\)</span> pair to file.
Visualize the data in the file (a cool solution is to
read one line at a time and
plot the <span class="math">\(u\)</span> value using the line-by-line plotter in the
<code class="docutils literal"><span class="pre">visualize_front_ascii</span></code> function - this technique makes it trivial
to visualize very long time simulations).
Filename: <code class="docutils literal"><span class="pre">vib_memsave</span></code>.</p>
</div>
<div class="section" id="exercise-14-implement-the-solver-via-classes">
<span id="vib-exer-gen-class"></span><h3>Exercise 14: Implement the solver via classes<a class="headerlink" href="#exercise-14-implement-the-solver-via-classes" title="Permalink to this headline">¶</a></h3>
<p>Reimplement the <code class="docutils literal"><span class="pre">vib.py</span></code>
program
using a class <code class="docutils literal"><span class="pre">Problem</span></code> to hold all the physical parameters of the problem,
a class <code class="docutils literal"><span class="pre">Solver</span></code> to hold the numerical parameters and compute the
solution, and a class <code class="docutils literal"><span class="pre">Visualizer</span></code> to display the solution.</p>
<p><strong>Hint.</strong>
Use the ideas and examples
for an <a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/sphinx/._book009.html#classes-for-problem-and-solution-method">ODE model</a> in <a class="reference internal" href="._book017.html#ref2" id="id6">[Ref2]</a>.
More specifically, make a superclass <code class="docutils literal"><span class="pre">Problem</span></code> for holding the scalar
physical parameters of a problem and let subclasses implement the
<span class="math">\(s(u)\)</span> and <span class="math">\(F(t)\)</span> functions as methods.
Try to call up as much existing functionality in <code class="docutils literal"><span class="pre">vib.py</span></code> as possible.</p>
<p>Filename: <code class="docutils literal"><span class="pre">vib_class</span></code>.</p>
</div>
<div class="section" id="exercise-15-interpret-as-a-forward-backward-difference">
<span id="vib-exer-dtdt-asdtpdtm"></span><h3>Exercise 15: Interpret <span class="math">\([D_tD_t u]^n\)</span> as a forward-backward difference<a class="headerlink" href="#exercise-15-interpret-as-a-forward-backward-difference" title="Permalink to this headline">¶</a></h3>
<p>Show that the difference <span class="math">\([D_t D_tu]^n\)</span> is equal to <span class="math">\([D_t^+D_t^-u]^n\)</span>
and <span class="math">\(D_t^-D_t^+u]^n\)</span>. That is, instead of applying a centered difference
twice one can alternatively apply a mixture forward and backward
differences.
Filename: <code class="docutils literal"><span class="pre">vib_DtDt_fw_bw</span></code>.</p>
</div>
<div class="section" id="exercise-16-use-a-backward-difference-for-the-damping-term">
<span id="vib-exer-quad-damping-bw"></span><h3>Exercise 16: Use a backward difference for the damping term<a class="headerlink" href="#exercise-16-use-a-backward-difference-for-the-damping-term" title="Permalink to this headline">¶</a></h3>
<p>As an alternative to discretizing the damping terms <span class="math">\(\beta u^{\prime}\)</span> and
<span class="math">\(\beta |u^{\prime}|u^{\prime}\)</span> by centered differences, we may apply
backward differences:</p>
<div class="math">
\[\begin{split}[u^{\prime}]^n &amp;\approx [D_t^-u]^n,\\
&amp; [|u^{\prime}|u^{\prime}]^n &amp;\approx [|D_t^-u|D_t^-u]^n
= |[D_t^-u]^n|[D_t^-u]^n\tp\end{split}\]</div>
<p>The advantage of the backward difference is that the damping term is
evaluated using known values <span class="math">\(u^n\)</span> and <span class="math">\(u^{n-1}\)</span> only.
Extend the <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib.py">vib.py</a> code with a scheme based
on using backward differences in the damping terms. Add statements
to compare the original approach with centered difference and the
new idea launched in this exercise. Perform numerical experiments
to investigate how much accuracy that is lost by using the backward
differences.
Filename: <code class="docutils literal"><span class="pre">vib_gen_bwdamping</span></code>.</p>
</div>
<div class="section" id="exercise-17-analysis-of-the-euler-cromer-scheme">
<span id="vib-exer-eulercromer-analysis"></span><h3>Exercise 17: Analysis of the Euler-Cromer scheme<a class="headerlink" href="#exercise-17-analysis-of-the-euler-cromer-scheme" title="Permalink to this headline">¶</a></h3>
<p>The Euler-Cromer scheme for the model problem
<span class="math">\(u^{\prime\prime} + \omega^2 u =0\)</span>, <span class="math">\(u(0)=I\)</span>, <span class="math">\(u^{\prime}(0)=0\)</span>, is given in
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><span class="std std-ref">(53)</span></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><span class="std std-ref">(52)</span></a>.
Find the exact discrete solutions of this scheme and show that the solution
for <span class="math">\(u^n\)</span> coincides with that found in the section <a class="reference internal" href="#vib-ode1-analysis"><span class="std std-ref">Analysis of the numerical scheme</span></a>.</p>
<p><strong>Hint.</strong>
Use an &#8220;ansatz&#8221; <span class="math">\(u^n=I\exp{(i\tilde\omega\Delta t\,n)}\)</span> and
<span class="math">\(v^n=qu^n\)</span>, where <span class="math">\(\tilde\omega\)</span> and <span class="math">\(q\)</span> are unknown parameters. The
following formula is handy:</p>
<div class="math">
\[\e^{i\tilde\omega\Delta t} + e^{i\tilde\omega(-\Delta t)} - 2
= 2\left(\cosh(i\tilde\omega\Delta t) -1 \right)
=-4\sin^2(\frac{\tilde\omega\Delta t}{2})\tp\]</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Vibration ODEs</a><ul>
<li><a class="reference internal" href="#finite-difference-discretization">Finite difference discretization</a><ul>
<li><a class="reference internal" href="#a-basic-model-for-vibrations">A basic model for vibrations</a></li>
<li><a class="reference internal" href="#a-centered-finite-difference-scheme">A centered finite difference scheme</a><ul>
<li><a class="reference internal" href="#step-1-discretizing-the-domain">Step 1: Discretizing the domain</a></li>
<li><a class="reference internal" href="#step-2-fulfilling-the-equation-at-discrete-time-points">Step 2: Fulfilling the equation at discrete time points</a></li>
<li><a class="reference internal" href="#step-3-replacing-derivatives-by-finite-differences">Step 3: Replacing derivatives by finite differences</a></li>
<li><a class="reference internal" href="#step-4-formulating-a-recursive-algorithm">Step 4: Formulating a recursive algorithm</a></li>
<li><a class="reference internal" href="#computing-the-first-step">Computing the first step</a></li>
<li><a class="reference internal" href="#the-computational-algorithm">The computational algorithm</a></li>
<li><a class="reference internal" href="#operator-notation">Operator notation</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-1">Implementation</a><ul>
<li><a class="reference internal" href="#making-a-solver-function">Making a solver function</a><ul>
<li><a class="reference internal" href="#computing">Computing <span class="math">\(u^{\prime}\)</span></a></li>
</ul>
</li>
<li><a class="reference internal" href="#verification-1">Verification</a><ul>
<li><a class="reference internal" href="#manual-calculation">Manual calculation</a></li>
<li><a class="reference internal" href="#testing-very-simple-solutions">Testing very simple solutions</a></li>
<li><a class="reference internal" href="#checking-convergence-rates">Checking convergence rates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scaled-model">Scaled model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#long-time-simulations">Long time simulations</a><ul>
<li><a class="reference internal" href="#using-a-moving-plot-window">Using a moving plot window</a></li>
<li><a class="reference internal" href="#making-animations">Making animations</a><ul>
<li><a class="reference internal" href="#producing-standard-video-formats">Producing standard video formats</a></li>
<li><a class="reference internal" href="#paying-png-files-in-a-web-browser">Paying PNG files in a web browser</a></li>
<li><a class="reference internal" href="#making-animated-gif-files">Making animated GIF files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-bokeh-to-compare-graphs">Using Bokeh to compare graphs</a></li>
<li><a class="reference internal" href="#using-a-line-by-line-ascii-plotter">Using a line-by-line ascii plotter</a></li>
<li><a class="reference internal" href="#empirical-analysis-of-the-solution">Empirical analysis of the solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analysis-of-the-numerical-scheme">Analysis of the numerical scheme</a><ul>
<li><a class="reference internal" href="#deriving-a-solution-of-the-numerical-scheme">Deriving a solution of the numerical scheme</a></li>
<li><a class="reference internal" href="#exact-discrete-solution">Exact discrete solution</a></li>
<li><a class="reference internal" href="#convergence">Convergence</a></li>
<li><a class="reference internal" href="#the-global-error">The global error</a></li>
<li><a class="reference internal" href="#stability-1">Stability</a></li>
<li><a class="reference internal" href="#about-the-accuracy-at-the-stability-limit">About the accuracy at the stability limit</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternative-schemes-based-on-1st-order-equations">Alternative schemes based on 1st-order equations</a><ul>
<li><a class="reference internal" href="#the-forward-euler-scheme">The Forward Euler scheme</a></li>
<li><a class="reference internal" href="#the-backward-euler-scheme">The Backward Euler scheme</a></li>
<li><a class="reference internal" href="#the-crank-nicolson-scheme">The Crank-Nicolson scheme</a></li>
<li><a class="reference internal" href="#comparison-of-schemes">Comparison of schemes</a></li>
<li><a class="reference internal" href="#runge-kutta-methods">Runge-Kutta methods</a></li>
<li><a class="reference internal" href="#analysis-of-the-forward-euler-scheme-1">Analysis of the Forward Euler scheme</a></li>
</ul>
</li>
<li><a class="reference internal" href="#energy-considerations">Energy considerations</a><ul>
<li><a class="reference internal" href="#derivation-of-the-energy-expression">Derivation of the energy expression</a><ul>
<li><a class="reference internal" href="#energy-of-the-exact-solution">Energy of the exact solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#an-error-measure-based-on-energy">An error measure based on energy</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-euler-cromer-method">The Euler-Cromer method</a><ul>
<li><a class="reference internal" href="#forward-backward-discretization">Forward-backward discretization</a></li>
<li><a class="reference internal" href="#equivalence-with-the-scheme-for-the-second-order-ode">Equivalence with the scheme for the second-order ODE</a></li>
<li><a class="reference internal" href="#implementation-2">Implementation</a></li>
<li><a class="reference internal" href="#the-velocity-verlet-algorithm">The velocity Verlet algorithm</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generalization-damping-nonlinear-spring-and-external-excitation">Generalization: damping, nonlinear spring, and external excitation</a><ul>
<li><a class="reference internal" href="#a-centered-scheme-for-linear-damping">A centered scheme for linear damping</a></li>
<li><a class="reference internal" href="#a-centered-scheme-for-quadratic-damping">A centered scheme for quadratic damping</a></li>
<li><a class="reference internal" href="#a-forward-backward-discretization-of-the-quadratic-damping-term">A forward-backward discretization of the quadratic damping term</a></li>
<li><a class="reference internal" href="#implementation-3">Implementation</a></li>
<li><a class="reference internal" href="#verification-2">Verification</a><ul>
<li><a class="reference internal" href="#constant-solution">Constant solution</a></li>
<li><a class="reference internal" href="#linear-solution">Linear solution</a></li>
<li><a class="reference internal" href="#quadratic-solution">Quadratic solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#visualization">Visualization</a></li>
<li><a class="reference internal" href="#user-interface">User interface</a></li>
<li><a class="reference internal" href="#the-euler-cromer-scheme-for-the-generalized-model">The Euler-Cromer scheme for the generalized model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-and-problems">Exercises and Problems</a><ul>
<li><a class="reference internal" href="#problem-1-use-linear-quadratic-functions-for-verification">Problem 1: Use linear/quadratic functions for verification</a></li>
<li><a class="reference internal" href="#exercise-2-show-linear-growth-of-the-phase-with-time">Exercise 2: Show linear growth of the phase with time</a></li>
<li><a class="reference internal" href="#exercise-3-improve-the-accuracy-by-adjusting-the-frequency">Exercise 3: Improve the accuracy by adjusting the frequency</a></li>
<li><a class="reference internal" href="#exercise-4-see-if-adaptive-methods-improve-the-phase-error">Exercise 4: See if adaptive methods improve the phase error</a></li>
<li><a class="reference internal" href="#exercise-5-use-a-taylor-polynomial-to-compute">Exercise 5: Use a Taylor polynomial to compute <span class="math">\(u^1\)</span></a></li>
<li><a class="reference internal" href="#exercise-6-find-the-minimal-resolution-of-an-oscillatory-function">Exercise 6: Find the minimal resolution of an oscillatory function</a></li>
<li><a class="reference internal" href="#exercise-7-visualize-the-accuracy-of-finite-differences-for-a-cosine-function">Exercise 7: Visualize the accuracy of finite differences for a cosine function</a></li>
<li><a class="reference internal" href="#exercise-8-verify-convergence-rates-of-the-error-in-energy">Exercise 8: Verify convergence rates of the error in energy</a></li>
<li><a class="reference internal" href="#exercise-9-use-linear-quadratic-functions-for-verification">Exercise 9: Use linear/quadratic functions for verification</a></li>
<li><a class="reference internal" href="#exercise-10-use-an-exact-discrete-solution-for-verification">Exercise 10: Use an exact discrete solution for verification</a></li>
<li><a class="reference internal" href="#exercise-11-use-analytical-solution-for-convergence-rate-tests">Exercise 11: Use analytical solution for convergence rate tests</a></li>
<li><a class="reference internal" href="#exercise-12-investigate-the-amplitude-errors-of-many-solvers">Exercise 12: Investigate the amplitude errors of many solvers</a></li>
<li><a class="reference internal" href="#exercise-13-minimize-memory-usage-of-a-vibration-solver">Exercise 13: Minimize memory usage of a vibration solver</a></li>
<li><a class="reference internal" href="#exercise-14-implement-the-solver-via-classes">Exercise 14: Implement the solver via classes</a></li>
<li><a class="reference internal" href="#exercise-15-interpret-as-a-forward-backward-difference">Exercise 15: Interpret <span class="math">\([D_tD_t u]^n\)</span> as a forward-backward difference</a></li>
<li><a class="reference internal" href="#exercise-16-use-a-backward-difference-for-the-damping-term">Exercise 16: Use a backward difference for the damping term</a></li>
<li><a class="reference internal" href="#exercise-17-analysis-of-the-euler-cromer-scheme">Exercise 17: Analysis of the Euler-Cromer scheme</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book001.html"
                        title="previous chapter">Preface</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book003.html"
                        title="next chapter">Wave equations</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book002.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book003.html" title="Wave equations"
             >next</a> |</li>
        <li class="right" >
          <a href="._book001.html" title="Preface"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with Partial Differential Equations</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2015, Hans Petter Langtangen. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>