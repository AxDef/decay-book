
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Wave equations</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Finite Difference Computing with Partial Differential Equations" href="index.html" />
    <link rel="next" title="Analysis of the difference equations" href="._book004.html" />
    <link rel="prev" title="Vibration ODEs" href="._book002.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book004.html" title="Analysis of the difference equations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book002.html" title="Vibration ODEs"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with Partial Differential Equations</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="wave-equations">
<span id="decay-analysis"></span><h1>Wave equations<a class="headerlink" href="#wave-equations" title="Permalink to this headline">¶</a></h1>
<p>A very wide range of physical processes lead to wave motion, where
signals are propagated through a medium in space and time, normally
with little or no permanent movement of the medium itself.
The shape of the signals may undergo changes as they travel through
matter, but usually not so much that the signals cannot be recognized
at some later point in space and time.
Many types of wave motion can be described by the equation
<span class="math">\(u_{tt}=\nabla\cdot (c^2\nabla u) + f\)</span>, which we will solve
in the forthcoming text by finite difference methods.</p>
<div class="section" id="simulation-of-waves-on-a-string">
<span id="wave-string"></span><h2>Simulation of waves on a string<a class="headerlink" href="#simulation-of-waves-on-a-string" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-0"></span><p id="index-1">We begin our study of wave equations by simulating one-dimensional
waves on a string, say on a guitar or violin.
Let the string in the deformed state
coincide with the interval
<span class="math">\([0,L]\)</span> on the <span class="math">\(x\)</span> axis, and let <span class="math">\(u(x,t)\)</span> be the displacement at
time <span class="math">\(t\)</span> in the <span class="math">\(y\)</span> direction of a point initially at <span class="math">\(x\)</span>.
The displacement function <span class="math">\(u\)</span> is governed by the mathematical model</p>
<div class="math" id="eq-wave-pde1">
\[\tag{81}
\frac{\partial^2 u}{\partial t^2} =
    c^2 \frac{\partial^2 u}{\partial x^2}, \quad x\in (0,L),\ t\in (0,T]\]</div>
<div class="math" id="eq-wave-pde1-ic-u">
\[\tag{82}
u(x,0) = I(x), \quad x\in [0,L]\]</div>
<div class="math" id="eq-wave-pde1-ic-ut">
\[\tag{83}
\frac{\partial}{\partial t}u(x,0) = 0, \quad x\in [0,L]\]</div>
<div class="math" id="eq-wave-pde1-bc-0">
\[\tag{84}
u(0,t)  = 0, \quad  t\in (0,T]\]</div>
<div class="math" id="eq-wave-pde1-bc-l">
\[\tag{85}
u(L,t)  = 0, \quad  t\in (0,T]\]</div>
<p>The constant <span class="math">\(c\)</span> and the function <span class="math">\(I(x)\)</span> must be prescribed.</p>
<p>Equation <a class="reference internal" href="#eq-wave-pde1"><span class="std std-ref">(81)</span></a> is known as the one-dimensional
<em>wave equation</em>. Since this PDE contains a second-order derivative
in time, we need <em>two initial conditions</em>. The condition
<a class="reference internal" href="#eq-wave-pde1-ic-u"><span class="std std-ref">(82)</span></a> specifies
the initial shape of the string, <span class="math">\(I(x)\)</span>, and
<a class="reference internal" href="#eq-wave-pde1-ic-ut"><span class="std std-ref">(83)</span></a> expresses that the initial velocity of the
string is zero. In addition, PDEs need <em>boundary conditions</em>, give here as
<a class="reference internal" href="#eq-wave-pde1-bc-0"><span class="std std-ref">(84)</span></a> and <a class="reference internal" href="#eq-wave-pde1-bc-l"><span class="std std-ref">(85)</span></a>. These two
conditions specify that
the string is fixed at the ends, i.e., that the displacement <span class="math">\(u\)</span> is zero.</p>
<p>The solution <span class="math">\(u(x,t)\)</span> varies in space and time and describes waves that
move with velocity <span class="math">\(c\)</span> to the left and right.</p>
<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src="_static/mov-wave/guitar_C0.8/movie.webm" type='video/webm; codecs="vp8, vorbis"'>
    <source src="_static/mov-wave/guitar_C0.8/movie.ogg"  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em>Example of waves on a string.</em></p>

<!-- Issue warning if only .ogg or .webm movie in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script><p>Sometimes we will use a more compact notation for the partial derivatives
to save space:</p>
<div class="math" id="eq-auto27">
\[\tag{86}
u_t = \frac{\partial u}{\partial t}, \quad
    u_{tt} = \frac{\partial^2 u}{\partial t^2},\]</div>
<p>and similar expressions
for derivatives with respect to other variables. Then the
wave equation can be written compactly as <span class="math">\(u_{tt} = c^2u_{xx}\)</span>.</p>
<p id="index-2">The PDE problem <a class="reference internal" href="#eq-wave-pde1"><span class="std std-ref">(81)</span></a>-<a class="reference internal" href="#eq-wave-pde1-bc-l"><span class="std std-ref">(85)</span></a> will now be
discretized in space and time by a finite difference method.</p>
<div class="section" id="discretizing-the-domain">
<span id="wave-string-mesh"></span><span id="index-3"></span><h3>Discretizing the domain<a class="headerlink" href="#discretizing-the-domain" title="Permalink to this headline">¶</a></h3>
<p>The temporal domain <span class="math">\([0,T]\)</span> is represented by a finite number of mesh points</p>
<div class="math" id="eq-auto28">
\[\begin{split}\tag{87}
0 = t_0 &lt; t_1 &lt; t_2 &lt; \cdots &lt; t_{N_t-1} &lt; t_{N_t} = T \tp\end{split}\]</div>
<p>Similarly, the spatial domain <span class="math">\([0,L]\)</span> is replaced by a set of mesh points</p>
<div class="math" id="eq-auto29">
\[\begin{split}\tag{88}
0 = x_0 &lt; x_1 &lt; x_2 &lt; \cdots &lt; x_{N_x-1} &lt; x_{N_x} = L \tp\end{split}\]</div>
<p>One may view the mesh as two-dimensional in the <span class="math">\(x,t\)</span> plane, consisting
of points <span class="math">\((x_i, t_n)\)</span>, with <span class="math">\(i=0,\ldots,N_x\)</span> and <span class="math">\(n=0,\ldots,N_t\)</span>.</p>
<div class="section" id="uniform-meshes">
<h4>Uniform meshes<a class="headerlink" href="#uniform-meshes" title="Permalink to this headline">¶</a></h4>
<p>For uniformly distributed mesh points we can introduce the constant
mesh spacings <span class="math">\(\Delta t\)</span> and <span class="math">\(\Delta x\)</span>. We have that</p>
<div class="math" id="eq-auto30">
\[\tag{89}
x_i = i\Delta x,\ i=0,\ldots,N_x,\quad
    t_n = n\Delta t,\ n=0,\ldots,N_t\tp\]</div>
<p>We also have that <span class="math">\(\Delta x = x_i-x_{i-1}\)</span>, <span class="math">\(i=1,\ldots,N_x\)</span>, and
<span class="math">\(\Delta t = t_n - t_{n-1}\)</span>, <span class="math">\(n=1,\ldots,N_t\)</span>. Figure <a class="reference internal" href="#wave-pde1-fig-mesh"><span class="std std-ref">Mesh in space and time. The circles show points connected in a finite difference equation</span></a>
displays a mesh in the <span class="math">\(x,t\)</span> plane with <span class="math">\(N_t=5\)</span>, <span class="math">\(N_x=5\)</span>, and constant
mesh spacings.</p>
</div>
</div>
<div class="section" id="the-discrete-solution">
<span id="wave-string-numerical-sol"></span><h3>The discrete solution<a class="headerlink" href="#the-discrete-solution" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-4"></span><p id="index-5">The solution <span class="math">\(u(x,t)\)</span> is sought at the mesh points. We introduce
the mesh function <span class="math">\(u_i^n\)</span>, which approximates the exact
solution at the
mesh point <span class="math">\((x_i,t_n)\)</span> for <span class="math">\(i=0,\ldots,N_x\)</span> and <span class="math">\(n=0,\ldots,N_t\)</span>.
Using the finite difference method, we shall
develop algebraic equations for computing the mesh function.</p>
</div>
<div class="section" id="fulfilling-the-equation-at-the-mesh-points">
<span id="wave-string-samplingpde"></span><h3>Fulfilling the equation at the mesh points<a class="headerlink" href="#fulfilling-the-equation-at-the-mesh-points" title="Permalink to this headline">¶</a></h3>
<p>In the finite difference method, we relax
the condition that <a class="reference internal" href="#eq-wave-pde1"><span class="std std-ref">(81)</span></a> holds at all points in
the space-time domain <span class="math">\((0,L)\times (0,T]\)</span> to the requirement that the PDE is
fulfilled at the <em>interior</em> mesh points only:</p>
<div class="math" id="eq-wave-pde1-step2">
\[\tag{90}
\frac{\partial^2}{\partial t^2} u(x_i, t_n) =
    c^2\frac{\partial^2}{\partial x^2} u(x_i, t_n),\]</div>
<p>for <span class="math">\(i=1,\ldots,N_x-1\)</span> and <span class="math">\(n=1,\ldots,N_t-1\)</span>. For <span class="math">\(n=0\)</span> we have
the initial conditions <span class="math">\(u=I(x)\)</span> and <span class="math">\(u_t=0\)</span>,
and at the boundaries <span class="math">\(i=0,N_x\)</span> we
have the boundary condition <span class="math">\(u=0\)</span>.</p>
</div>
<div class="section" id="replacing-derivatives-by-finite-differences">
<span id="wave-string-fd"></span><h3>Replacing derivatives by finite differences<a class="headerlink" href="#replacing-derivatives-by-finite-differences" title="Permalink to this headline">¶</a></h3>
<p>The second-order derivatives can be replaced by central
differences. The most widely used difference approximation of
the second-order derivative is</p>
<div class="math">
\[\frac{\partial^2}{\partial t^2}u(x_i,t_n)\approx
\frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2}\tp\]</div>
<p>It is convenient to introduce the finite difference operator notation</p>
<div class="math">
\[[D_tD_t u]^n_i = \frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2}\tp\]</div>
<p>A similar approximation of the second-order derivative in the <span class="math">\(x\)</span>
direction reads</p>
<div class="math">
\[\frac{\partial^2}{\partial x^2}u(x_i,t_n)\approx
\frac{u_{i+1}^{n} - 2u_i^n + u^{n}_{i-1}}{\Delta x^2} = [D_xD_x u]^n_i
\tp\]</div>
<div class="section" id="algebraic-version-of-the-pde">
<h4>Algebraic version of the PDE<a class="headerlink" href="#algebraic-version-of-the-pde" title="Permalink to this headline">¶</a></h4>
<p>We can now replace the derivatives in <a class="reference internal" href="#eq-wave-pde1-step2"><span class="std std-ref">(90)</span></a>
and get</p>
<div class="math" id="eq-wave-pde1-step3b">
\[\tag{91}
\frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2} =
    c^2\frac{u_{i+1}^{n} - 2u_i^n + u^{n}_{i-1}}{\Delta x^2},\]</div>
<p>or written more compactly using the operator notation:</p>
<div class="math" id="eq-wave-pde1-step3a">
\[\tag{92}
[D_tD_t u = c^2 D_xD_x]^{n}_i
    \tp\]</div>
</div>
<div class="section" id="interpretation-of-the-equation-as-a-stencil">
<h4>Interpretation of the equation as a stencil<a class="headerlink" href="#interpretation-of-the-equation-as-a-stencil" title="Permalink to this headline">¶</a></h4>
<p>A typical feature of <a class="reference internal" href="#eq-wave-pde1-step3b"><span class="std std-ref">(91)</span></a> is that it involves
<span class="math">\(u\)</span> values from neighboring points only:
<span class="math">\(u_i^{n+1}\)</span>, <span class="math">\(u^n_{i\pm 1}\)</span>, <span class="math">\(u^n_i\)</span>, and <span class="math">\(u^{n-1}_i\)</span>.
The circles in Figure
<a class="reference internal" href="#wave-pde1-fig-mesh"><span class="std std-ref">Mesh in space and time. The circles show points connected in a finite difference equation</span></a> illustrate such neighboring mesh points that
contributes to an algebraic equation. In this
particular case, we have sampled the PDE at the point <span class="math">\((2,2)\)</span>
and constructed <a class="reference internal" href="#eq-wave-pde1-step3b"><span class="std std-ref">(91)</span></a>, which then
involves a coupling of <span class="math">\(u_2^1\)</span>, <span class="math">\(u_1^2\)</span>, <span class="math">\(u_2^2\)</span>, <span class="math">\(u_3^2\)</span>, and <span class="math">\(u_2^3\)</span>.
The term <em>stencil</em> is often used about the algebraic equation
at a mesh point, and the geometry of a typical stencil is
illustrated in Figure <a class="reference internal" href="#wave-pde1-fig-mesh"><span class="std std-ref">Mesh in space and time. The circles show points connected in a finite difference equation</span></a>. One also often refers
to the algebraic equations as <em>discrete equations</em>,
<em>(finite) difference equations</em> or a <em>finite difference
scheme</em>.</p>
<div class="figure" id="id2">
<span id="wave-pde1-fig-mesh"></span><a class="reference internal image-reference" href="_images/stencil_n_interior.png"><img alt="_images/stencil_n_interior.png" src="_images/stencil_n_interior.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Mesh in space and time. The circles show points connected in a finite difference equation</em></span></p>
</div>
</div>
<div class="section" id="algebraic-version-of-the-initial-conditions">
<h4>Algebraic version of the initial conditions<a class="headerlink" href="#algebraic-version-of-the-initial-conditions" title="Permalink to this headline">¶</a></h4>
<p>We also need to replace the derivative in the initial condition
<a class="reference internal" href="#eq-wave-pde1-ic-ut"><span class="std std-ref">(83)</span></a> by a finite difference approximation.
A centered difference of the type</p>
<div class="math">
\[\frac{\partial}{\partial t} u(x_i,t_n)\approx
\frac{u^1_i - u^{-1}_i}{2\Delta t} = [D_{2t} u]^0_i,\]</div>
<p>seems appropriate. In operator notation the initial condition is
written as</p>
<div class="math">
\[[D_{2t} u]^n_i = 0,\quad n=0 \tp\]</div>
<p>Writing out this equation and ordering the terms give</p>
<div class="math" id="eq-wave-pde1-step3c">
\[\tag{93}
u^{n-1}_i=u^{n+1}_i,\quad i=0,\ldots,N_x,\ n=0\tp\]</div>
<p>The other initial condition can be computed by</p>
<div class="math">
\[u_i^0 = I(x_i),\quad i=0,\ldots,N_x\tp\]</div>
</div>
</div>
<div class="section" id="formulating-a-recursive-algorithm">
<span id="wave-string-alg"></span><h3>Formulating a recursive algorithm<a class="headerlink" href="#formulating-a-recursive-algorithm" title="Permalink to this headline">¶</a></h3>
<p>We assume that <span class="math">\(u^n_i\)</span> and
<span class="math">\(u^{n-1}_i\)</span> are already computed for <span class="math">\(i=0,\ldots,N_x\)</span>.
The only unknown quantity in <a class="reference internal" href="#eq-wave-pde1-step3b"><span class="std std-ref">(91)</span></a> is
therefore <span class="math">\(u^{n+1}_i\)</span>, which we can solve for:</p>
<div class="math" id="eq-wave-pde1-step4">
\[\tag{94}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
    \left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right),\]</div>
<p>where we have introduced the parameter</p>
<div class="math" id="eq-auto31">
\[\tag{95}
C = c\frac{\Delta t}{\Delta x},\]</div>
<p>known as the <em>Courant number</em>.</p>
<div class="admonition-math-c-is-the-key-parameter-in-the-discrete-wave-equation admonition">
<p class="first admonition-title"><span class="math">\(C\)</span> is the key parameter in the discrete wave equation</p>
<p class="last">We see that the
discrete version of the PDE features only one parameter, <span class="math">\(C\)</span>,
which is therefore the key parameter that governs the
quality of the numerical solution (see the section <a class="reference internal" href="._book004.html#wave-pde1-analysis"><span class="std std-ref">Analysis of the difference equations</span></a>
for details). Both the primary
physical parameter <span class="math">\(c\)</span> and the numerical parameters <span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span>
are lumped together in <span class="math">\(C\)</span>. Note that <span class="math">\(C\)</span> is a dimensionless
parameter.</p>
</div>
<p>Given that <span class="math">\(u^{n-1}_i\)</span> and <span class="math">\(u^n_i\)</span> are computed for <span class="math">\(i=0,\ldots,N_x\)</span>,
we find new values at the next time level by applying the formula
<a class="reference internal" href="#eq-wave-pde1-step4"><span class="std std-ref">(94)</span></a> for <span class="math">\(i=1,\ldots,N_x-1\)</span>. Figure
<a class="reference internal" href="#wave-pde1-fig-mesh"><span class="std std-ref">Mesh in space and time. The circles show points connected in a finite difference equation</span></a> illustrates the points that are used to
compute <span class="math">\(u^3_2\)</span>. For the boundary points, <span class="math">\(i=0\)</span> and <span class="math">\(i=N_x\)</span>, we apply
the boundary conditions <span class="math">\(u_i^{n+1}=0\)</span>.</p>
<p>A problem with <a class="reference internal" href="#eq-wave-pde1-step4"><span class="std std-ref">(94)</span></a> arises when <span class="math">\(n=0\)</span> since the
formula for <span class="math">\(u^1_i\)</span> involves <span class="math">\(u^{-1}_i\)</span>, which is an undefined
quantity outside the time mesh (and the time domain). However, we can
use the initial condition <a class="reference internal" href="#eq-wave-pde1-step3c"><span class="std std-ref">(93)</span></a> in combination with
<a class="reference internal" href="#eq-wave-pde1-step4"><span class="std std-ref">(94)</span></a> when <span class="math">\(n=0\)</span> to eliminate <span class="math">\(u^{-1}_i\)</span> and
arrive at a special formula for <span class="math">\(u_i^1\)</span>:</p>
<div class="math" id="eq-wave-pde1-step4-1">
\[\tag{96}
u_i^1 = u^0_i - \half
    C^2\left(u^{0}_{i+1}-2u^{0}_{i} + u^{0}_{i-1}\right)
    \tp\]</div>
<p>Figure <a class="reference internal" href="#wave-pde1-fig-stencil-u1"><span class="std std-ref">Modified stencil for the first time step</span></a> illustrates how <a class="reference internal" href="#eq-wave-pde1-step4-1"><span class="std std-ref">(96)</span></a>
connects four instead of five points: <span class="math">\(u^1_2\)</span>, <span class="math">\(u_1^0\)</span>, <span class="math">\(u_2^0\)</span>, and <span class="math">\(u_3^0\)</span>.</p>
<div class="figure" id="id3">
<span id="wave-pde1-fig-stencil-u1"></span><a class="reference internal image-reference" href="_images/stencil_n0_interior.png"><img alt="_images/stencil_n0_interior.png" src="_images/stencil_n0_interior.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Modified stencil for the first time step</em></span></p>
</div>
<p>We can now summarize the computational algorithm:</p>
<ol class="arabic simple">
<li>Compute <span class="math">\(u^0_i=I(x_i)\)</span> for <span class="math">\(i=0,\ldots,N_x\)</span></li>
<li>Compute <span class="math">\(u^1_i\)</span> by <a class="reference internal" href="#eq-wave-pde1-step4-1"><span class="std std-ref">(96)</span></a> and set <span class="math">\(u_i^1=0\)</span>
for the boundary points <span class="math">\(i=0\)</span> and <span class="math">\(i=N_x\)</span>, for <span class="math">\(n=1,2,\ldots,N-1\)</span>,</li>
<li>For each time level <span class="math">\(n=1,2,\ldots,N_t-1\)</span></li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li>apply <a class="reference internal" href="#eq-wave-pde1-step4"><span class="std std-ref">(94)</span></a> to find <span class="math">\(u^{n+1}_i\)</span> for <span class="math">\(i=1,\ldots,N_x-1\)</span></li>
<li>set <span class="math">\(u^{n+1}_i=0\)</span> for the boundary points <span class="math">\(i=0\)</span>, <span class="math">\(i=N_x\)</span>.</li>
</ol>
</div></blockquote>
<p>The algorithm essentially consists of moving
a finite difference stencil through all the mesh points, which can be
seen as an animation in a <a class="reference external" href="http://tinyurl.com/opdfafk/pub/mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/index.html">web page</a>
or a <a class="reference external" href="http://tinyurl.com/opdfafk/pub/mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/movie.ogg">movie file</a>.</p>
</div>
<div class="section" id="sketch-of-an-implementation">
<span id="wave-string-impl"></span><h3>Sketch of an implementation<a class="headerlink" href="#sketch-of-an-implementation" title="Permalink to this headline">¶</a></h3>
<p>In a Python implementation of this algorithm, we use the array
elements <code class="docutils literal"><span class="pre">u[i]</span></code> to store <span class="math">\(u^{n+1}_i\)</span>, <code class="docutils literal"><span class="pre">u_1[i]</span></code> to store <span class="math">\(u^n_i\)</span>, and
<code class="docutils literal"><span class="pre">u_2[i]</span></code> to store <span class="math">\(u^{n-1}_i\)</span>. Our naming convention is use <code class="docutils literal"><span class="pre">u</span></code> for the
unknown new spatial field to be computed, <code class="docutils literal"><span class="pre">u_1</span></code> as the solution at
one time step back in time, <code class="docutils literal"><span class="pre">u_2</span></code> as the solution two time steps back
in time and so forth.</p>
<p>The algorithm only involves the three most recent time levels, so we
need only three arrays for <span class="math">\(u_i^{n+1}\)</span>, <span class="math">\(u_i^n\)</span>, and <span class="math">\(u_i^{n-1}\)</span>,
<span class="math">\(i=0,\ldots,N_x\)</span>.  Storing all the solutions in a two-dimensional
array of size <span class="math">\((N_x+1)\times (N_t+1)\)</span> would be possible in this simple
one-dimensional PDE problem, but is normally out of the question in
three-dimensional (3D) and large two-dimensional (2D) problems. We
shall therefore, in all our PDE solving programs, have the unknown in
memory at as few time levels as possible.</p>
<p>The following Python snippet realizes the steps in the computational
algorithm.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Given mesh points as arrays x and t (x[i], t[n])</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dx</span>            <span class="c"># Courant number</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
<span class="n">C2</span> <span class="o">=</span> <span class="n">C</span><span class="o">**</span><span class="mi">2</span>              <span class="c"># Help variable in the scheme</span>

<span class="c"># Set initial condition u(x,0) = I(x)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="c"># Apply special formula for first step, incorporating du/dt=0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">C</span><span class="o">**</span><span class="mi">2</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c"># Enforce boundary conditions</span>

<span class="c"># Switch variables before next step</span>
<span class="n">u_2</span><span class="p">[:],</span> <span class="n">u_1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
    <span class="c"># Update all inner mesh points at time t[n+1]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> \
               <span class="n">C</span><span class="o">**</span><span class="mi">2</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c"># Insert boundary conditions</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c"># Switch variables before next step</span>
    <span class="n">u_2</span><span class="p">[:],</span> <span class="n">u_1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="verification-3">
<h2>Verification<a class="headerlink" href="#verification-3" title="Permalink to this headline">¶</a></h2>
<p>Before implementing the algorithm, it is convenient to add a source
term to the PDE <a class="reference internal" href="#eq-wave-pde1"><span class="std std-ref">(81)</span></a>
since it gives us more freedom in finding test problems for
verification. Physically, a source term acts as a generation of waves
in the interior of the domain.</p>
<div class="section" id="a-slightly-generalized-model-problem">
<span id="wave-pde2-fd"></span><h3>A slightly generalized model problem<a class="headerlink" href="#a-slightly-generalized-model-problem" title="Permalink to this headline">¶</a></h3>
<p>We now address the following extended initial-boundary value problem
for one-dimensional wave phenomena:</p>
<div class="math" id="eq-wave-pde2">
\[\tag{97}
u_{tt} = c^2 u_{xx} + f(x,t), \quad x\in (0,L),\ t\in (0,T]\]</div>
<div class="math" id="eq-wave-pde2-ic-u">
\[\tag{98}
u(x,0) = I(x), \quad x\in [0,L]\]</div>
<div class="math" id="eq-wave-pde2-ic-ut">
\[\tag{99}
u_t(x,0) = V(x), \quad x\in [0,L]\]</div>
<div class="math" id="eq-wave-pde2-bc-0">
\[\begin{split}\tag{100}
u(0,t)  = 0, \quad  t&gt;0\end{split}\]</div>
<div class="math" id="eq-wave-pde2-bc-l">
\[\begin{split}\tag{101}
u(L,t)  = 0, \quad  t&gt;0\end{split}\]</div>
<p>Sampling the PDE at <span class="math">\((x_i,t_n)\)</span> and using the same finite difference
approximations as above, yields</p>
<div class="math" id="eq-wave-pde2-fdop">
\[\tag{102}
[D_tD_t u = c^2 D_xD_x u + f]^{n}_i
    \tp\]</div>
<p>Writing this out and solving for the unknown <span class="math">\(u^{n+1}_i\)</span> results in</p>
<div class="math" id="eq-wave-pde2-step3b">
\[\tag{103}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
    (u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}) + \Delta t^2 f^n_i\]\[    \tp\]</div>
<p>The equation for the first time step must be rederived. The discretization
of the initial condition <span class="math">\(u_t = V(x)\)</span> at <span class="math">\(t=0\)</span>
becomes</p>
<div class="math">
\[[D_{2t}u = V]^0_i\quad\Rightarrow\quad u^{-1}_i = u^{1}_i - 2\Delta t V_i,\]</div>
<p>which, when inserted in <a class="reference internal" href="#eq-wave-pde2-step3b"><span class="std std-ref">(103)</span></a> for <span class="math">\(n=0\)</span>, gives
the special formula</p>
<div class="math" id="eq-wave-pde2-step3c">
\[\tag{104}
u^{1}_i = u^0_i - \Delta t V_i + {\half}
    C^2
    \left(u^{0}_{i+1}-2u^{0}_{i} + u^{0}_{i-1}\right) + \half\Delta t^2 f^0_i\]\[    \tp\]</div>
</div>
<div class="section" id="using-an-analytical-solution-of-physical-significance">
<span id="wave-pde2-fd-standing-waves"></span><h3>Using an analytical solution of physical significance<a class="headerlink" href="#using-an-analytical-solution-of-physical-significance" title="Permalink to this headline">¶</a></h3>
<p>Many wave problems feature sinusoidal oscillations in time
and space. For example, the original PDE problem
<a class="reference internal" href="#eq-wave-pde1"><span class="std std-ref">(81)</span></a>-<a class="reference internal" href="#eq-wave-pde1-bc-l"><span class="std std-ref">(85)</span></a> allows an exact solution</p>
<div class="math" id="eq-wave-pde2-test-ue">
\[\tag{105}
\uex(x,t)) = A\sin\left(\frac{\pi}{L}x\right)
    \cos\left(\frac{\pi}{L}ct\right)\tp\]</div>
<p>This <span class="math">\(\uex\)</span> fulfills the PDE with <span class="math">\(f=0\)</span>, boundary conditions
<span class="math">\(\uex(0,t)=\uex(L,0)=0\)</span>, as well as initial
conditions <span class="math">\(I(x)=A\sin\left(\frac{\pi}{L}x\right)\)</span> and <span class="math">\(V=0\)</span>.</p>
<p>It is common to use such exact solutions of physical interest
to verify implementations. However, the numerical
solution <span class="math">\(u^n_i\)</span> will only be an approximation to <span class="math">\(\uex(x_i,t_n)\)</span>.
We have no knowledge of the precise size of the error in
this approximation, and therefore we can never know if discrepancies
between <span class="math">\(u^n_i\)</span> and <span class="math">\(\uex(x_i,t_n)\)</span> are caused
by mathematical approximations or programming errors.
In particular, if a plot of the computed solution <span class="math">\(u^n_i\)</span> and
the exact one eq:ref:<cite>wave:pde2:test:ue</cite> looks similar, many
are tempted to claim that the implementation works. However,
even if color plots look nice and the accuracy is &#8220;deemed good&#8221;,
there can still be serious programming errors present!</p>
<p>The only way to use exact physical solutions like
<a class="reference internal" href="#eq-wave-pde2-test-ue"><span class="std std-ref">(105)</span></a> for serious and thorough verification is to
run a series of finer and finer meshes, measure the integrated error
in each mesh, and from this information estimate the empirical convergence
rate of the method.
An introduction to the computing convergence rates is given in
the section
on <a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/sphinx/._book007.html#computing-convergence-rates">convergence rates</a> in <a class="reference internal" href="._book017.html#ref2" id="id1">[Ref2]</a>.
There is also a detailed example on computing convergence rates in
the section <a class="reference internal" href="._book002.html#vib-ode1-verify"><span class="std std-ref">Verification</span></a>.</p>
<p>In the present problem, one expects the method to have a convergence rate
of 2 (see the section <a class="reference internal" href="._book004.html#wave-pde1-analysis"><span class="std std-ref">Analysis of the difference equations</span></a>), so if the computed rates
are close to 2 on a sufficiently mesh, we have good evidence that
the implementation is free of programming mistakes.</p>
</div>
<div class="section" id="manufactured-solution">
<span id="wave-pde2-fd-mms"></span><h3>Manufactured solution<a class="headerlink" href="#manufactured-solution" title="Permalink to this headline">¶</a></h3>
<p>One problem with the exact solution <a class="reference internal" href="#eq-wave-pde2-test-ue"><span class="std std-ref">(105)</span></a> is
that it requires a simplification (<span class="math">\(V=0, f=0\)</span>) of the implemented problem
<a class="reference internal" href="#eq-wave-pde2"><span class="std std-ref">(97)</span></a>-<a class="reference internal" href="#eq-wave-pde2-bc-l"><span class="std std-ref">(101)</span></a>. An advantage of using
a <em>manufactured solution</em> is that we can test all terms in the
PDE problem. The idea of this approach is to set up some chosen
solution and fit the source term, boundary conditions, and initial
conditions to be compatible with the chosen solution.
Given that our boundary conditions in the implementation are
<span class="math">\(u(0,t)=u(L,t)=0\)</span>, we must choose a solution that fulfills these
conditions. One example is</p>
<div class="math">
\[\uex(x,t) = x(L-x)\sin t\tp\]</div>
<p>Inserted in the PDE <span class="math">\(u_{tt}=c^2u_{xx}+f\)</span> we get</p>
<div class="math">
\[-x(L-x)\sin t = -c^2 2\sin t + f\quad\Rightarrow f = (2c^2 - x(L-x))\sin t\tp\]</div>
<p>The initial conditions become</p>
<div class="math">
\[\begin{split}u(x,0) =&amp; I(x) = 0,\\
u_t(x,0) &amp;= V(x) = x(L-x)\tp\end{split}\]</div>
<p>To verify the code, we compute the convergence rates in a series of
simulations, letting each simulation use a finer mesh than the
previous one. Such empirical estimation of convergence rates
tests rely on an assumption that some
measure <span class="math">\(E\)</span> of the numerical error is related to the discretization
parameters through</p>
<div class="math">
\[E = C_t\Delta t^r + C_x\Delta x^p,\]</div>
<p>where <span class="math">\(C_t\)</span>, <span class="math">\(C_x\)</span>, <span class="math">\(r\)</span>, and <span class="math">\(p\)</span> are constants. The constants
<span class="math">\(r\)</span> and <span class="math">\(p\)</span> are known as the <em>convergence rates</em> in time and space,
respectively.
From the
accuracy in the finite difference approximations, we expect <span class="math">\(r=p=2\)</span>,
since the error terms are of order <span class="math">\(\Delta t^2\)</span> and <span class="math">\(\Delta x^2\)</span>.
This is confirmed by truncation error analysis and other types of analysis.</p>
<p>By using an exact solution of the PDE problem, we will next compute
the error measure <span class="math">\(E\)</span> on a sequence of refined meshes and see if
the rates <span class="math">\(r=p=2\)</span> are obtained. We will not be concerned with estimating
the constants <span class="math">\(C_t\)</span> and <span class="math">\(C_x\)</span>.</p>
<p>It is advantageous to introduce a single discretization parameter
<span class="math">\(h=\Delta t=\hat c \Delta x\)</span> for some constant <span class="math">\(\hat c\)</span>.
Since <span class="math">\(\Delta t\)</span> and <span class="math">\(\Delta x\)</span>
are related through the Courant number, <span class="math">\(\Delta t = C\Delta x/c\)</span>, we
set <span class="math">\(h=\Delta t\)</span>, and then <span class="math">\(\Delta x = hc/C\)</span>.
Now the expression for the error measure is greatly simplified:</p>
<div class="math">
\[E = C_t\Delta t^r + C_x\Delta x^r = C_t h^r + C_x\left(\frac{c}{C}\right)^r h^r
= Dh^r,\quad D = C_t+C_x\left(\frac{c}{C}\right)^r \tp\]</div>
<p>We choose an initial discretization parameter <span class="math">\(h_0\)</span> and run
experiments with decreasing <span class="math">\(h\)</span>: <span class="math">\(h_i=2^{-i}h_0\)</span>, <span class="math">\(i=1,2,\ldots,m\)</span>.
Halving <span class="math">\(h\)</span> in each experiment is not necessary, but it is a common choice.
For each experiment we must record <span class="math">\(E\)</span> and <span class="math">\(h\)</span>.
A standard choice of error measure
is the <span class="math">\(\ell^2\)</span> or <span class="math">\(\ell^\infty\)</span> norm of
the error mesh function <span class="math">\(e^n_i\)</span>:</p>
<div class="math" id="eq-auto32">
\[\tag{106}
E = ||e^n_i||_{\ell^2} = \left( \Delta t\Delta x
    \sum_{n=0}^{N_t}\sum_{i=0}^{N_x}
    (e^n_i)^2\right)^{\half},\quad e^n_i = \uex(x_i,t_n)-u^n_i,\]</div>
<div class="math" id="eq-auto33">
\[\tag{107}
E = ||e^n_i||_{\ell^\infty} = \max_{i,n} |e^i_n|\tp\]</div>
<p>In Python, one can compute <span class="math">\(\sum_{i}(e^{n}_i)^2\)</span> at each time step
and accumulate the value in some sum variable, say <code class="docutils literal"><span class="pre">e2_sum</span></code>.  At the
final time step one can do <code class="docutils literal"><span class="pre">sqrt(dt*dx*e2_sum)</span></code>.  For the
<span class="math">\(\ell^\infty\)</span> norm one must compare the maximum error at a time level
(<code class="docutils literal"><span class="pre">e.max()</span></code>) with the global maximum over the time domain: <code class="docutils literal"><span class="pre">e_max</span> <span class="pre">=</span>
<span class="pre">max(e_max,</span> <span class="pre">e.max())</span></code>.</p>
<p>An alternative error measure
is to use a spatial norm at one time step only, e.g.,
the end time <span class="math">\(T\)</span> (<span class="math">\(n=N_t\)</span>):</p>
<div class="math" id="eq-auto34">
\[\tag{108}
E = ||e^n_i||_{\ell^2} = \left( \Delta x\sum_{i=0}^{N_x}
    (e^n_i)^2\right)^{\half},\quad e^n_i = \uex(x_i,t_n)-u^n_i,\]</div>
<div class="math" id="eq-auto35">
\[\tag{109}
E = ||e^n_i||_{\ell^\infty} = \max_{0\leq i\leq N_x} |e^{n}_i|\tp\]</div>
<p>The important issue is that our error measure <span class="math">\(E\)</span> must be one number
that represents the error in the simulation.</p>
<p>Let <span class="math">\(E_i\)</span> be the error measure in experiment (mesh) number <span class="math">\(i\)</span> and
let <span class="math">\(h_i\)</span> be the corresponding discretization parameter (<span class="math">\(h\)</span>).
With the error model <span class="math">\(E_i = Dh_i^r\)</span>, we can
estimate <span class="math">\(r\)</span> by comparing two consecutive
experiments:</p>
<div class="math">
\[\begin{split}E_{i+1}&amp; =D h_{i+1}^{r},\\
E_{i}&amp; =D h_{i}^{r}\tp\end{split}\]</div>
<p>Dividing the two equations eliminates the (uninteresting) constant <span class="math">\(D\)</span>.
Thereafter, solving for <span class="math">\(r\)</span> yields</p>
<div class="math">
\[r = \frac{\ln E_{i+1}/E_{i}}{\ln h_{i+1}/h_{i}}\tp\]</div>
<p>Since <span class="math">\(r\)</span> depends on <span class="math">\(i\)</span>, i.e., which simulations we compare,
we add an index to <span class="math">\(r\)</span>: <span class="math">\(r_i\)</span>, where <span class="math">\(i=0,\ldots,m-2\)</span>, if we
have <span class="math">\(m\)</span> experiments: <span class="math">\((h_0,E_0),\ldots,(h_{m-1}, E_{m-1})\)</span>.</p>
<p>In our present discretization of the wave equation we expect <span class="math">\(r=2\)</span>, and
hence the <span class="math">\(r_i\)</span> values should converge to 2 as <span class="math">\(i\)</span> increases.</p>
</div>
<div class="section" id="constructing-an-exact-solution-of-the-discrete-equations">
<span id="wave-pde2-fd-verify-quadratic"></span><h3>Constructing an exact solution of the discrete equations<a class="headerlink" href="#constructing-an-exact-solution-of-the-discrete-equations" title="Permalink to this headline">¶</a></h3>
<p>With a manufactured or known analytical solution, as outlined above,
we can estimate convergence rates and see if they have the correct
asymptotic behavior. Experience shows that this is a quite good
verification technique in that many common bugs will destroy the
convergence rates. A significantly better test though,
would be to check that the
numerical solution is exactly what it should be. This will in general
require exact knowledge of the numerical error, which we do not normally have
(although we in the section <a class="reference internal" href="._book004.html#wave-pde1-analysis"><span class="std std-ref">Analysis of the difference equations</span></a> establish such knowledge
in simple cases).
However, it is possible to look for solutions where we can show that
the numerical error vanishes, i.e., the solution of the original continuous
PDE problem is
also a solution of the discrete equations. This property often arises
if the exact solution of the PDE
is a lower-order polynomial. (Truncation error
analysis leads to error measures that involve derivatives of the
exact solution. In the present problem, the truncation error involves
4th-order derivatives of <span class="math">\(u\)</span> in space and time. Choosing <span class="math">\(u\)</span>
as a polynomial of degree three or less
will therefore lead to vanishing error.)</p>
<p>We shall now illustrate the construction of an exact solution to both the
PDE itself and the discrete equations.
Our chosen manufactured solution is quadratic in space
and linear in time. More specifically, we set</p>
<div class="math" id="eq-wave-pde2-fd-verify-quadratic-uex">
\[\tag{110}
\uex (x,t) = x(L-x)(1+{\half}t),\]</div>
<p>which by insertion in the PDE leads to <span class="math">\(f(x,t)=2(1+t)c^2\)</span>. This <span class="math">\(\uex\)</span>
fulfills the boundary conditions <span class="math">\(u=0\)</span> and demands <span class="math">\(I(x)=x(L-x)\)</span>
and <span class="math">\(V(x)={\half}x(L-x)\)</span>.</p>
<p>To realize that the chosen <span class="math">\(\uex\)</span> is also an exact
solution of the discrete equations,
we first remind ourselves that <span class="math">\(t_n=n\Delta t\)</span> before we
establish that</p>
<div class="math" id="eq-auto36">
\[\tag{111}
\lbrack D_tD_t t^2\rbrack^n = \frac{t_{n+1}^2 - 2t_n^2 + t_{n-1}^2}{\Delta t^2}
    = (n+1)^2 -2n^2 + (n-1)^2 = 2,\]</div>
<div class="math" id="eq-auto37">
\[\tag{112}
\lbrack D_tD_t t\rbrack^n = \frac{t_{n+1} - 2t_n + t_{n-1}}{\Delta t^2}
    = \frac{((n+1) -2n + (n-1))\Delta t}{\Delta t^2} = 0
    \tp\]</div>
<p>Hence,</p>
<div class="math">
\[[D_tD_t \uex]^n_i = x_i(L-x_i)[D_tD_t (1+{\half}t)]^n =
x_i(L-x_i){\half}[D_tD_t t]^n = 0\tp\]</div>
<p>Similarly, we get that</p>
<div class="math">
\[\begin{split}\lbrack D_xD_x \uex\rbrack^n_i &amp;=
(1+{\half}t_n)\lbrack D_xD_x (xL-x^2)\rbrack_i =
(1+{\half}t_n)\lbrack LD_xD_x x - D_xD_x x^2\rbrack_i \\
&amp;= -2(1+{\half}t_n)
\tp\end{split}\]</div>
<p>Now, <span class="math">\(f^n_i = 2(1+{\half}t_n)c^2\)</span>, which results in</p>
<div class="math">
\[[D_tD_t \uex - c^2D_xD_x\uex - f]^n_i = 0 - c^2(-1)2(1 + {\half}t_n
+ 2(1+{\half}t_n)c^2 = 0\tp\]</div>
<p>Moreover, <span class="math">\(\uex(x_i,0)=I(x_i)\)</span>,
<span class="math">\(\partial \uex/\partial t = V(x_i)\)</span> at <span class="math">\(t=0\)</span>, and
<span class="math">\(\uex(x_0,t)=\uex(x_{N_x},0)=0\)</span>. Also the modified scheme for the
first time step is fulfilled by <span class="math">\(\uex(x_i,t_n)\)</span>.</p>
<p>Therefore, the exact solution <span class="math">\(\uex(x,t)=x(L-x)(1+t/2)\)</span>
of the PDE problem is also an exact solution of the discrete problem.
We can use this result to check that the computed <span class="math">\(u^n_i\)</span> values from
an implementation equals <span class="math">\(\uex(x_i,t_n)\)</span> within machine precision,
<em>regardless of the mesh spacings</em> <span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span>!
Nevertheless, there might be stability
restrictions on <span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span>, so the test can only be
run for a mesh that is compatible with the stability criterion (which
in the present case is <span class="math">\(C\leq 1\)</span>, to be derived later).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>A product of quadratic or linear expressions in the various
independent variables, as shown above, will often fulfill both the
PDE problem and the discrete equations, and can therefore be very useful
solutions for verifying implementations.</p>
<p class="last">However, for 1D wave
equations of the type <span class="math">\(u_{tt}=c^2u_{xx}\)</span> we shall see that there is always
another much more powerful way of generating exact
solutions (which consists in just setting <span class="math">\(C=1\)</span> (!), as shown in
the section <a class="reference internal" href="._book004.html#wave-pde1-analysis"><span class="std std-ref">Analysis of the difference equations</span></a>).</p>
</div>
</div>
</div>
<div class="section" id="implementation-4">
<span id="wave-pde1-impl"></span><h2>Implementation<a class="headerlink" href="#implementation-4" title="Permalink to this headline">¶</a></h2>
<p id="index-6">This section presents the complete computational algorithm, its
implementation in Python code, animation of the solution, and
verification of the implementation.</p>
<p>A real implementation of the basic computational algorithm from
the sections <a class="reference internal" href="#wave-string-alg"><span class="std std-ref">Formulating a recursive algorithm</span></a> and <a class="reference internal" href="#wave-string-impl"><span class="std std-ref">Sketch of an implementation</span></a> can be
encapsulated in a function, taking all the input data for the problem
as arguments.  The physical input data consists of <span class="math">\(c\)</span>, <span class="math">\(I(x)\)</span>,
<span class="math">\(V(x)\)</span>, <span class="math">\(f(x,t)\)</span>, <span class="math">\(L\)</span>, and <span class="math">\(T\)</span>.  The numerical input is the mesh
parameters <span class="math">\(\Delta t\)</span> and <span class="math">\(\Delta x\)</span>.</p>
<p>Instead of specifying <span class="math">\(\Delta t\)</span> <em>and</em> <span class="math">\(\Delta x\)</span>, we can specify one
of them and the Courant number <span class="math">\(C\)</span> instead, since having explicit
control of the Courant number is convenient when investigating the
numerical method. Many find it natural to prescribe the resolution of
the spatial grid and set <span class="math">\(N_x\)</span>. The solver function can then compute
<span class="math">\(\Delta t = CL/(cN_x)\)</span>. However, for comparing <span class="math">\(u(x,t)\)</span> curves (as
functions of <span class="math">\(x\)</span>) for various Courant numbers
it is more convenient to keep <span class="math">\(\Delta t\)</span> fixed for
all <span class="math">\(C\)</span> and let <span class="math">\(\Delta x\)</span> vary according to <span class="math">\(\Delta x = c\Delta t/C\)</span>.
With <span class="math">\(\Delta t\)</span> fixed, all frames correspond to the same time <span class="math">\(t\)</span>,
and this simplifies animations that compare simulations with different
mesh resolutions. Plotting functions of <span class="math">\(x\)</span>
with different spatial resolution is trivial,
so it is easier to let <span class="math">\(\Delta x\)</span> vary in the simulations than <span class="math">\(\Delta t\)</span>.</p>
<div class="section" id="callback-function-for-user-specific-actions">
<h3>Callback function for user-specific actions<a class="headerlink" href="#callback-function-for-user-specific-actions" title="Permalink to this headline">¶</a></h3>
<p id="index-7">The solution at all spatial points at a new time level is stored in an
array <code class="docutils literal"><span class="pre">u</span></code> of length <span class="math">\(N_x+1\)</span>. We need to decide what do to with
this solution, e.g., visualize the curve, analyze the values, or write
the array to file for later use. The decision about what to do is left to
the user in the form of a user-suppled supplied function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">user_action</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">u</span></code> is the solution at the spatial points <code class="docutils literal"><span class="pre">x</span></code> at time <code class="docutils literal"><span class="pre">t[n]</span></code>.
The <code class="docutils literal"><span class="pre">user_action</span></code> function is call from the solver at each time level <code class="docutils literal"><span class="pre">n</span></code>.</p>
<p>If the user wants to plot the solution or store the solution at a
time point, she needs to write such a function and take appropriate
actions inside it. We will show examples on many such <code class="docutils literal"><span class="pre">user_action</span></code>
functions.</p>
<p>Since the solver function make calls back to the user&#8217;s code
via such a function, this type of function is called a <em>callback function</em>.
When writing general software, like our solver function, which also needs
to carry out special problem-dependent actions (like visualization),
it is a common technique to leave those actions to user-supplied
callback functions.</p>
</div>
<div class="section" id="the-solver-function">
<span id="wave-pde1-impl-solver"></span><h3>The solver function<a class="headerlink" href="#the-solver-function" title="Permalink to this headline">¶</a></h3>
<p>A first attempt at a solver function is listed below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve u_tt=c^2*u_xx + f on (0,L)x(0,T].&quot;&quot;&quot;</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Mesh points in time</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">c</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">L</span><span class="o">/</span><span class="n">dx</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>       <span class="c"># Mesh points in space</span>
    <span class="n">C2</span> <span class="o">=</span> <span class="n">C</span><span class="o">**</span><span class="mi">2</span>                      <span class="c"># Help variable in the scheme</span>
    <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">V</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">V</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span>

    <span class="n">u</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Solution array at new time level</span>
    <span class="n">u_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Solution at 1 time level back</span>
    <span class="n">u_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Solution at 2 time levels back</span>

    <span class="kn">import</span> <span class="nn">time</span><span class="p">;</span>  <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>  <span class="c"># for measuring CPU time</span>

    <span class="c"># Load initial condition into u_1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">user_action</span><span class="p">(</span><span class="n">u_1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c"># Special formula for first time step</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> \
               <span class="mf">0.5</span><span class="o">*</span><span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
               <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">user_action</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c"># Switch variables before next step</span>
    <span class="n">u_2</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">;</span>  <span class="n">u_1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="c"># Update all inner points at time t[n+1]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
                     <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                     <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="c"># Insert boundary conditions</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">user_action</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">break</span>

        <span class="c"># Switch variables before next step</span>
        <span class="n">u_2</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">;</span>  <span class="n">u_1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u</span>

    <span class="n">cpu_time</span> <span class="o">=</span> <span class="n">t0</span> <span class="o">-</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">cpu_time</span>
</pre></div>
</div>
</div>
<div class="section" id="verification-exact-quadratic-solution">
<span id="wave-pde1-impl-verify-quadratic"></span><h3>Verification: exact quadratic solution<a class="headerlink" href="#verification-exact-quadratic-solution" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-8"></span><span class="target" id="index-9"></span><span class="target" id="index-10"></span><span class="target" id="index-11"></span><p id="index-12">We use the test problem derived in the section <a class="reference internal" href="#wave-pde2-fd"><span class="std std-ref">A slightly generalized model problem</span></a> for
verification. Below is a unit test based on this test problem
and realized as a proper <em>test function</em> (compatible with the unit test
frameworks nose or pytest).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_quadratic</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check that u(x,t)=x(L-x)(1+t/2) is exactly reproduced.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">V</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">L</span> <span class="o">=</span> <span class="mf">2.5</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">1.5</span>
    <span class="n">C</span> <span class="o">=</span> <span class="mf">0.75</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c"># Very coarse mesh for this exact test</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">/</span><span class="n">Nx</span><span class="p">)</span><span class="o">/</span><span class="n">c</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">18</span>

    <span class="k">def</span> <span class="nf">assert_no_error</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-13</span>
        <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>

    <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
           <span class="n">user_action</span><span class="o">=</span><span class="n">assert_no_error</span><span class="p">)</span>
</pre></div>
</div>
<p>When this function resides in the file <code class="docutils literal"><span class="pre">wave1D_u0.py</span></code>, one can run ether
<code class="docutils literal"><span class="pre">py.test</span></code> or <code class="docutils literal"><span class="pre">nosetests</span></code>,</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; py.test   -s -v wave1D_u0.py
Terminal&gt; nosetests -s -v wave1D_u0.py
</pre></div>
</div>
<p>to automatically run all test functions with name <code class="docutils literal"><span class="pre">test_*()</span></code>.</p>
</div>
<div class="section" id="visualization-animating-the-solution">
<span id="wave-pde1-impl-animate"></span><h3>Visualization: animating the solution<a class="headerlink" href="#visualization-animating-the-solution" title="Permalink to this headline">¶</a></h3>
<p>Now that we have verified the implementation it is time to do a
real computation where we also display the evolution of the waves
on the screen. Since the <code class="docutils literal"><span class="pre">solver</span></code> function knows nothing about
what type of visualizations we may want, it calls the callback function
<code class="docutils literal"><span class="pre">user_action(u,</span> <span class="pre">x,</span> <span class="pre">t,</span> <span class="pre">n)</span></code>. We must therefore write this function and
find the proper statements for plotting the solution.</p>
<div class="section" id="function-for-administering-the-simulation">
<h4>Function for administering the simulation<a class="headerlink" href="#function-for-administering-the-simulation" title="Permalink to this headline">¶</a></h4>
<p>The following <code class="docutils literal"><span class="pre">viz</span></code> function</p>
<ol class="arabic simple">
<li>defines a <code class="docutils literal"><span class="pre">user_action</span></code> callback function
for plotting the solution at each time level,</li>
<li>calls the <code class="docutils literal"><span class="pre">solver</span></code> function, and</li>
<li>combines all the plots (in files) to video in different formats.</li>
</ol>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">viz</span><span class="p">(</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>  <span class="c"># PDE paramteres</span>
    <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">,</span>               <span class="c"># Interval for u in plots</span>
    <span class="n">animate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>             <span class="c"># Simulation with animation?</span>
    <span class="n">tool</span><span class="o">=</span><span class="s">&#39;matplotlib&#39;</span><span class="p">,</span>        <span class="c"># &#39;matplotlib&#39; or &#39;scitools&#39;</span>
    <span class="n">solver_function</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span>   <span class="c"># Function with numerical algorithm</span>
    <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Run solver and visualize u at each time level.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">plot_u_st</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;user_action function for solver.&quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">,</span>
                 <span class="n">xlabel</span><span class="o">=</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">,</span>
                 <span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">],</span>
                 <span class="n">title</span><span class="o">=</span><span class="s">&#39;t=</span><span class="si">%f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">show</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c"># Let the initial condition stay on the screen for 2</span>
        <span class="c"># seconds, else insert a pause of 0.2 s between each plot</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;frame_</span><span class="si">%04d</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>  <span class="c"># for movie making</span>

    <span class="k">class</span> <span class="nc">PlotMatplotlib</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;user_action function for solver.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">])</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;t=</span><span class="si">%f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]],</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;lower left&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;t=</span><span class="si">%f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]],</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;lower left&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp_</span><span class="si">%04d</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>  <span class="c"># for movie making</span>

    <span class="k">if</span> <span class="n">tool</span> <span class="o">==</span> <span class="s">&#39;matplotlib&#39;</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="n">plot_u</span> <span class="o">=</span> <span class="n">PlotMatplotlib</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">tool</span> <span class="o">==</span> <span class="s">&#39;scitools&#39;</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">scitools.std</span> <span class="kn">as</span> <span class="nn">plt</span>  <span class="c"># scitools.easyviz interface</span>
        <span class="n">plot_u</span> <span class="o">=</span> <span class="n">plot_u_st</span>
    <span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">glob</span><span class="o">,</span> <span class="nn">os</span>

    <span class="c"># Clean up old movie frames</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s">&#39;tmp_*.png&#39;</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="c"># Call solver and do the simulaton</span>
    <span class="n">user_action</span> <span class="o">=</span> <span class="n">plot_u</span> <span class="k">if</span> <span class="n">animate</span> <span class="k">else</span> <span class="bp">None</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">solver_function</span><span class="p">(</span>
        <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">user_action</span><span class="p">)</span>

    <span class="c"># Make video files</span>
    <span class="n">fps</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c"># frames per second</span>
    <span class="n">codec2ext</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">flv</span><span class="o">=</span><span class="s">&#39;flv&#39;</span><span class="p">,</span> <span class="n">libx264</span><span class="o">=</span><span class="s">&#39;mp4&#39;</span><span class="p">,</span> <span class="n">libvpx</span><span class="o">=</span><span class="s">&#39;webm&#39;</span><span class="p">,</span>
                     <span class="n">libtheora</span><span class="o">=</span><span class="s">&#39;ogg&#39;</span><span class="p">)</span>  <span class="c"># video formats</span>
    <span class="n">filespec</span> <span class="o">=</span> <span class="s">&#39;tmp_</span><span class="si">%04d</span><span class="s">.png&#39;</span>
    <span class="n">movie_program</span> <span class="o">=</span> <span class="s">&#39;ffmpeg&#39;</span>  <span class="c"># or &#39;avconv&#39;</span>
    <span class="k">for</span> <span class="n">codec</span> <span class="ow">in</span> <span class="n">codec2ext</span><span class="p">:</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">codec2ext</span><span class="p">[</span><span class="n">codec</span><span class="p">]</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%(movie_program)s</span><span class="s"> -r </span><span class="si">%(fps)d</span><span class="s"> -i </span><span class="si">%(filespec)s</span><span class="s"> &#39;</span>\
              <span class="s">&#39;-vcodec </span><span class="si">%(codec)s</span><span class="s"> movie.</span><span class="si">%(ext)s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">()</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tool</span> <span class="o">==</span> <span class="s">&#39;scitools&#39;</span><span class="p">:</span>
        <span class="c"># Make an HTML play for showing the animation in a browser</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">movie</span><span class="p">(</span><span class="s">&#39;tmp_*.png&#39;</span><span class="p">,</span> <span class="n">encoder</span><span class="o">=</span><span class="s">&#39;html&#39;</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span>
                  <span class="n">output_file</span><span class="o">=</span><span class="s">&#39;movie.html&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cpu</span>
</pre></div>
</div>
</div>
<div class="section" id="dissection-of-the-code">
<h4>Dissection of the code<a class="headerlink" href="#dissection-of-the-code" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">viz</span></code> function can either use SciTools or Matplotlib for
visualizing the solution. The <code class="docutils literal"><span class="pre">user_action</span></code> function based on SciTools
is called <code class="docutils literal"><span class="pre">plot_u_st</span></code>, while the <code class="docutils literal"><span class="pre">user_action</span></code> function based on
Matplotlib is a bit more complicated as it is realized as a class and
needs statements that differ from those for making static plots.
SciTools can utilize both Matplotlib and Gnuplot (and many other
plotting programs) for doing the graphics, but Gnuplot is a relevant
choice for large <span class="math">\(N_x\)</span> or in two-dimensional problems
as Gnuplot is significantly faster than
Matplotlib for screen animations.</p>
<p id="index-13">A function inside another function, like <code class="docutils literal"><span class="pre">plot_u_st</span></code> in the above code
segment, has access to <em>and remembers</em> all the local variables in the
surrounding code inside the <code class="docutils literal"><span class="pre">viz</span></code> function (!). This is known in
computer science as a <em>closure</em> and is very convenient to program
with. For example, the <code class="docutils literal"><span class="pre">plt</span></code> and <code class="docutils literal"><span class="pre">time</span></code> modules defined outside
<code class="docutils literal"><span class="pre">plot_u</span></code> are accessible for <code class="docutils literal"><span class="pre">plot_u_st</span></code> when the function is called
(as <code class="docutils literal"><span class="pre">user_action</span></code>) in the <code class="docutils literal"><span class="pre">solver</span></code> function.  Some may think, however,
that a class instead of a closure is a cleaner and
easier-to-understand implementation of the user action function, see
the section <a class="reference internal" href="#wave-pde2-software"><span class="std std-ref">Building a general 1D wave equation solver</span></a>.</p>
<p>The <code class="docutils literal"><span class="pre">plot_u_st</span></code> function just makes a standard SciTools <code class="docutils literal"><span class="pre">plot</span></code> command
for plotting <code class="docutils literal"><span class="pre">u</span></code> as a function of <code class="docutils literal"><span class="pre">x</span></code> at time <code class="docutils literal"><span class="pre">t[n]</span></code>.  To achieve a
smooth animation, the <code class="docutils literal"><span class="pre">plot</span></code> command should take keyword arguments
instead of being broken into separate calls to <code class="docutils literal"><span class="pre">xlabel</span></code>, <code class="docutils literal"><span class="pre">ylabel</span></code>,
<code class="docutils literal"><span class="pre">axis</span></code>, <code class="docutils literal"><span class="pre">time</span></code>, and <code class="docutils literal"><span class="pre">show</span></code>.  Several <code class="docutils literal"><span class="pre">plot</span></code> calls will automatically
cause an animation on the screen. In addition, we want to save each
frame in the animation to file. We then need a filename where the
frame number is padded with zeros, here <code class="docutils literal"><span class="pre">tmp_0000.png</span></code>,
<code class="docutils literal"><span class="pre">tmp_0001.png</span></code>, and so on.  The proper printf construction is then
<code class="docutils literal"><span class="pre">tmp_%04d.png</span></code>.
The section <a class="reference internal" href="._book002.html#vib-ode1-anim"><span class="std std-ref">Making animations</span></a> contains more basic
information on making animations.</p>
<p>The solver is called with an argument <code class="docutils literal"><span class="pre">plot_u</span></code> as <code class="docutils literal"><span class="pre">user_function</span></code>.
If the user chooses to use SciTools, <code class="docutils literal"><span class="pre">plot_u</span></code> is the <code class="docutils literal"><span class="pre">plot_u_st</span></code>
callback function, but for Matplotlib it is an instance of the
class <code class="docutils literal"><span class="pre">PlotMatplotlib</span></code>. Also this class makes use of variables
defined in the <code class="docutils literal"><span class="pre">viz</span></code> function: <code class="docutils literal"><span class="pre">plt</span></code> and <code class="docutils literal"><span class="pre">time</span></code>.
With Matplotlib, one has to make the first plot the standard way, and
then update the <span class="math">\(y\)</span> data in the plot at every time level. The update
requires active use of the returned value from <code class="docutils literal"><span class="pre">plt.plot</span></code> in the first
plot.  This value would need to be stored in a local variable if we
were to use a closure for the <code class="docutils literal"><span class="pre">user_action</span></code> function when doing the
animation with Matplotlib. It is much easier to store the
variable as a class attribute <code class="docutils literal"><span class="pre">self.lines</span></code>. Since the class is essentially a
function, we implement the function as the special method <code class="docutils literal"><span class="pre">__call__</span></code>
such that the instance <code class="docutils literal"><span class="pre">plot_u(u,</span> <span class="pre">x,</span> <span class="pre">t,</span> <span class="pre">n)</span></code> can be called as a standard
callback function from <code class="docutils literal"><span class="pre">solver</span></code>.</p>
</div>
<div class="section" id="making-movie-files">
<h4>Making movie files<a class="headerlink" href="#making-movie-files" title="Permalink to this headline">¶</a></h4>
<p>From the
<code class="docutils literal"><span class="pre">frame_*.png</span></code> files containing the frames in the animation we can
make video files.
The section <a class="reference internal" href="._book002.html#vib-ode1-anim"><span class="std std-ref">Making animations</span></a> presents basic information on how to
use the <code class="docutils literal"><span class="pre">ffmpeg</span></code> (or <code class="docutils literal"><span class="pre">avconv</span></code>) program for producing video files
in different modern formats: Flash, MP4, Webm, and Ogg.</p>
<p>The <code class="docutils literal"><span class="pre">viz</span></code> function creates a <code class="docutils literal"><span class="pre">ffmpeg</span></code> or <code class="docutils literal"><span class="pre">avconv</span></code> command
with the proper arguments for each of the formats Flash, MP4, WebM,
and Ogg. The task is greatly simplified by having a
<code class="docutils literal"><span class="pre">codec2ext</span></code> dictionary for mapping
video codec names to filename extensions.
As mentioned in the section <a class="reference internal" href="._book002.html#vib-ode1-anim"><span class="std std-ref">Making animations</span></a>, only
two formats are actually needed to ensure that all browsers can
successfully play the video: MP4 and WebM.</p>
<p>Some animations consisting of a large number of plot files may not
be properly combined into a video using <code class="docutils literal"><span class="pre">ffmpeg</span></code> or <code class="docutils literal"><span class="pre">avconv</span></code>.
A method that always works is to play the PNG files as an animation
in a browser using JavaScript code in an HTML file.
The SciTools package has a function <code class="docutils literal"><span class="pre">movie</span></code> (or a stand-alone command
<code class="docutils literal"><span class="pre">scitools</span> <span class="pre">movie</span></code>) for creating such an HTML player. The <code class="docutils literal"><span class="pre">plt.movie</span></code>
call in the <code class="docutils literal"><span class="pre">viz</span></code> function shows how the function is used.
The file <code class="docutils literal"><span class="pre">movie.html</span></code> can be loaded into a browser and features
a user interface where the speed of the animation can be controlled.
Note that the movie in this case consists of the <code class="docutils literal"><span class="pre">movie.html</span></code> file
and all the frame files <code class="docutils literal"><span class="pre">tmp_*.png</span></code>.</p>
</div>
<div class="section" id="skipping-frames-for-animation-speed">
<h4>Skipping frames for animation speed<a class="headerlink" href="#skipping-frames-for-animation-speed" title="Permalink to this headline">¶</a></h4>
<p>Sometimes the time step is small and <span class="math">\(T\)</span> is large, leading to an
inconveniently large number of plot files and a slow animation on the
screen. The solution to such a problem is to decide on a total number
of frames in the animation, <code class="docutils literal"><span class="pre">num_frames</span></code>, and plot the solution only for
every <code class="docutils literal"><span class="pre">skip_frame</span></code> frames. For example, setting <code class="docutils literal"><span class="pre">skip_frame=5</span></code> leads
to plots of every 5 frames. The default value <code class="docutils literal"><span class="pre">skip_frame=1</span></code> plots
every frame.
The total number of time levels (i.e., maximum
possible number of frames) is the length of <code class="docutils literal"><span class="pre">t</span></code>, <code class="docutils literal"><span class="pre">t.size</span></code> (or <code class="docutils literal"><span class="pre">len(t)</span></code>),
so if we want <code class="docutils literal"><span class="pre">num_frames</span></code> frames in the animation,
we need to plot every <code class="docutils literal"><span class="pre">t.size/num_frames</span></code> frames:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">skip_frame</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">num_frames</span><span class="p">))</span>
<span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">skip_frame</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
    <span class="n">st</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>The initial condition (<code class="docutils literal"><span class="pre">n=0</span></code>) included by <code class="docutils literal"><span class="pre">n</span> <span class="pre">%</span> <span class="pre">skip_frame</span> <span class="pre">==</span> <span class="pre">0</span></code>,
as well as every <code class="docutils literal"><span class="pre">skip_frame</span></code>-th frame.
As <code class="docutils literal"><span class="pre">n</span> <span class="pre">%</span> <span class="pre">skip_frame</span> <span class="pre">==</span> <span class="pre">0</span></code> will very seldom be true for the
very final frame, we must also check if <code class="docutils literal"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">t.size-1</span></code> to
get the final frame included.</p>
<p>A simple choice of numbers may illustrate the formulas: say we have
801 frames in total (<code class="docutils literal"><span class="pre">t.size</span></code>) and we allow only 60 frames to be
plotted. Then we need to plot every 801/60 frame, which with integer
division yields 13 as <code class="docutils literal"><span class="pre">every</span></code>. Using the mod function, <code class="docutils literal"><span class="pre">n</span> <span class="pre">%</span> <span class="pre">every</span></code>,
this operation is zero every time <code class="docutils literal"><span class="pre">n</span></code> can be divided by 13 without a
remainder. That is, the <code class="docutils literal"><span class="pre">if</span></code> test is true when <code class="docutils literal"><span class="pre">n</span></code> equals <span class="math">\(0, 13, 26,
39, ..., 780, 801\)</span>. The associated code is included in the <code class="docutils literal"><span class="pre">plot_u</span></code>
function in the file <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_u0v.py">wave1D_u0v.py</a>.</p>
</div>
</div>
<div class="section" id="running-a-case">
<span id="wave-pde1-guitar-data"></span><h3>Running a case<a class="headerlink" href="#running-a-case" title="Permalink to this headline">¶</a></h3>
<p>The first demo of our 1D wave equation solver concerns vibrations of a
string that is initially deformed to a triangular shape, like when picking
a guitar string:</p>
<div class="math" id="eq-wave-pde1-guitar-i">
\[\begin{split}\tag{113}
I(x) = \left\lbrace
    \begin{array}{ll}
    ax/x_0, &amp; x &lt; x_0,\\
    a(L-x)/(L-x_0), &amp; \hbox{otherwise}
    \end{array}\right.\end{split}\]</div>
<p>We choose <span class="math">\(L=75\)</span> cm, <span class="math">\(x_0=0.8L\)</span>, <span class="math">\(a=5\)</span> mm, and a time frequency
<span class="math">\(\nu = 440\)</span> Hz. The relation between the wave speed <span class="math">\(c\)</span> and <span class="math">\(\nu\)</span> is
<span class="math">\(c=\nu\lambda\)</span>, where <span class="math">\(\lambda\)</span> is the wavelength, taken as <span class="math">\(2L\)</span> because
the longest wave on the string form half a wavelength. There is no
external force, so <span class="math">\(f=0\)</span>, and the string is at rest initially so
that <span class="math">\(V=0\)</span>.</p>
<p>Regarding numerical parameters, we need to specify a <span class="math">\(\Delta t\)</span>.
Sometimes it is more natural to think of a spatial resolution instead
of a time step. A natural semi-coarse spatial resolution in the present
problem is <span class="math">\(N_x=50\)</span>. We can then choose the associated <span class="math">\(\Delta t\)</span> (as required
by the <code class="docutils literal"><span class="pre">viz</span></code> and <code class="docutils literal"><span class="pre">solver</span></code> functions) as the stability limit:
<span class="math">\(\Delta t = L/(N_xc)\)</span>. This is the <span class="math">\(\Delta t\)</span> to be specified,
but notice that if <span class="math">\(C&lt;1\)</span>, the actual <span class="math">\(\Delta x\)</span> computed in <code class="docutils literal"><span class="pre">solver</span></code> gets
larger than <span class="math">\(L/N_x\)</span>: <span class="math">\(\Delta x = c\Delta t/C = L/(N_xC)\)</span>. (The reason
is that we fix <span class="math">\(\Delta t\)</span> and adjust <span class="math">\(\Delta x\)</span>, so if <span class="math">\(C\)</span> gets
smaller, the code implements this effect in terms of a larger <span class="math">\(\Delta x\)</span>.)</p>
<p>A function for setting the physical and numerical parameters and
calling <code class="docutils literal"><span class="pre">viz</span></code> in this application goes as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">guitar</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Triangular wave (pulled guitar string).&quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mf">0.75</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="mf">0.8</span><span class="o">*</span><span class="n">L</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">0.005</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="mi">440</span>
    <span class="n">wavelength</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">freq</span><span class="o">*</span><span class="n">wavelength</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">freq</span>
    <span class="n">num_periods</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">omega</span><span class="o">*</span><span class="n">num_periods</span>
    <span class="c"># Choose dt the same as the stability limit for Nx=50</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">L</span><span class="o">/</span><span class="mf">50.</span><span class="o">/</span><span class="n">c</span>

    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">x0</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">x0</span> <span class="k">else</span> <span class="n">a</span><span class="o">/</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>

    <span class="n">umin</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.2</span><span class="o">*</span><span class="n">a</span><span class="p">;</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>
    <span class="n">cpu</span> <span class="o">=</span> <span class="n">viz</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">,</span>
              <span class="n">animate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="s">&#39;scitools&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The associated program has the name <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_u0.py">wave1D_u0.py</a>. Run
the program and watch the <a class="reference external" href="http://tinyurl.com/opdfafk/pub/mov-wave/guitar_C0.8/index.html">movie of the vibrating string</a>.</p>
<p>[<strong>hpl 10</strong>: Must recompute these movies as <span class="math">\(\Delta t\)</span> is different when <span class="math">\(C&lt;1\)</span>.]</p>
</div>
<div class="section" id="working-with-a-scaled-pde-model">
<h3>Working with a scaled PDE model<a class="headerlink" href="#working-with-a-scaled-pde-model" title="Permalink to this headline">¶</a></h3>
<p>Depending on the model, it may be a substantial job to establish
consistent and relevant physical parameter values for a case.
The guitar string example illustrates the point.
However, by <em>scaling</em>
the mathematical problem we can often reduce the need to estimate
physical parameters dramatically. The scaling technique
consists of introducing new
independent and dependent variables, with the aim that the absolute
value of these is not very large or small, but preferably around unity
in size. We introduce the dimensionless variables</p>
<div class="math">
\[\bar x = \frac{x}{L},\quad \bar t = \frac{c}{L}t,\quad
\bar u = \frac{u}{a}
\tp\]</div>
<p>Here, <span class="math">\(L\)</span> is a typical length scale, e.g., the length of the domain,
and <span class="math">\(a\)</span> is a typical size of <span class="math">\(u\)</span>, e.g., determined from the
initial condition: <span class="math">\(a=\max_x|I(x)|\)</span>.</p>
<p>Inserting these new variables in the PDE and noting that</p>
<div class="math">
\[\frac{\partial u}{\partial t} = \frac{aL}{c}\frac{\partial\bar u}{\partial\bar t},\]</div>
<p>by the chain rule, one gets</p>
<div class="math">
\[\frac{a^2L^2}{c^2}\frac{\partial^2\bar u}{\partial\bar t^2}
= \frac{a^2c^2}{L^2}\frac{\partial^2\bar u}{\partial\bar x^2},\]</div>
<p>in case <span class="math">\(f=0\)</span>.
Dropping the bars, we arrive at the scaled PDE</p>
<div class="math" id="eq-auto38">
\[\tag{114}
\frac{\partial^2 u}{\partial t^2} = \frac{\partial^2 u}{\partial x^2},\]</div>
<p>which has not parameter <span class="math">\(c^2\)</span> anymore. The initial conditions are scaled
as</p>
<div class="math">
\[a\bar u(\bar x, 0) = I(L\bar x)\]</div>
<p>and</p>
<div class="math">
\[\frac{a}{L/c}\frac{\partial\bar u}{\partial\bar t}(\bar x,0) = V(L\bar x),\]</div>
<p>resulting in</p>
<div class="math">
\[\bar u(\bar x, 0) = \frac{I(L\bar x)}{\max_x |I(x)|},\quad
\frac{\partial\bar u}{\partial\bar t}(\bar x,0) = \frac{L}{ac}V(L\bar x)\tp\]</div>
<p>In the common case <span class="math">\(V=0\)</span> we see that there are no physical parameters to be
estimated in the PDE model!</p>
<p>If we have a program implemented for the physical wave equation with
dimensions, we can obtain the dimensionless, scaled version by
setting <span class="math">\(c=1\)</span>. The initial condition of a guitar string,
given in <a class="reference internal" href="#eq-wave-pde1-guitar-i"><span class="std std-ref">(113)</span></a>, gets its scaled form by choosing
<span class="math">\(a=1\)</span>, <span class="math">\(L=1\)</span>, and <span class="math">\(x_0\in [0,1]\)</span>. This means that we only need to
decide on the <span class="math">\(x_0\)</span> value as a fraction of unity, because
the scaled problem corresponds to setting all
other parameters to unity. In the code we can just set
<code class="docutils literal"><span class="pre">a=c=L=1</span></code>, <code class="docutils literal"><span class="pre">x0=0.8</span></code>, and there is no need to calculate with
wavelengths and frequencies to estimate <span class="math">\(c\)</span>!</p>
<p>The only non-trivial parameter to estimate in the scaled problem
is the final end time of the simulation, or more precisely, how it relates
to periods in periodic solutions in time, since we often want to
express the end time as a certain number of periods.
The period in the dimensionless problem is 2, so the end time can be
set to the desired number of periods times 2.</p>
<p>Why the dimensionless period is 2 can be explained by the following
reasoning.
Suppose as <span class="math">\(u\)</span> behaves as <span class="math">\(\cos (\omega t)\)</span> in time in variables
with dimension. The corresponding period is then <span class="math">\(P=2\pi/\omega\)</span>, but
we need to estimate <span class="math">\(\omega\)</span>. A typical solution of the wave
equation is <span class="math">\(u(x,t)=A\cos(kx)\cos(\omega t)\)</span>, where <span class="math">\(A\)</span> is an amplitude
and <span class="math">\(k\)</span> is related to the wave length <span class="math">\(\lambda\)</span> in space: <span class="math">\(\lambda = 2\pi/k\)</span>.
Both <span class="math">\(\lambda\)</span> and <span class="math">\(A\)</span> will be given by the initial condition <span class="math">\(I(x)\)</span>.
Inserting this <span class="math">\(u(x,t)\)</span> in the PDE yields <span class="math">\(-\omega^2 = -c^2k^2\)</span>, i.e.,
<span class="math">\(\omega = kc\)</span>. The period is therefore <span class="math">\(P=2\pi/(kc)\)</span>.
If the boundary conditions are <span class="math">\(u(0,t)=u(0,L)\)</span>, we need to have
<span class="math">\(kL = n\pi\)</span> for integer <span class="math">\(n\)</span>. The period becomes <span class="math">\(P=2L/nc\)</span>. The longest
period is <span class="math">\(P=2L/c\)</span>. The dimensionless period is <span class="math">\(\tilde P\)</span> is obtained
by dividing <span class="math">\(P\)</span> by the time scale <span class="math">\(L/c\)</span>, which results in <span class="math">\(\tilde P=2\)</span>.
Shorter waves in the initial condition will have a dimensionless
shorter period <span class="math">\(\tilde P=2/n\)</span> (<span class="math">\(n&gt;1\)</span>).</p>
</div>
</div>
<div class="section" id="vectorization">
<span id="wave-pde1-impl-vec"></span><h2>Vectorization<a class="headerlink" href="#vectorization" title="Permalink to this headline">¶</a></h2>
<p id="index-14">The computational algorithm for solving the wave equation visits one
mesh point at a time and evaluates a formula for the new value <span class="math">\(u_i^{n+1}\)</span>
at
that point. Technically, this is implemented by a loop over array
elements in a program. Such loops may run slowly in Python (and
similar interpreted languages such as R and MATLAB).
One technique for speeding up loops is to
perform operations on entire arrays instead of working with one element
at a time. This is referred to as <em>vectorization</em>, <em>vector computing</em>,
or <em>array computing</em>.
Operations on whole arrays are possible if the computations
involving each element is independent of each other and therefore can,
at least in principle, be performed simultaneously.
Vectorization not only speeds up the code on serial computers, but
also makes it easy to exploit parallel computing.</p>
<div class="section" id="operations-on-slices-of-arrays">
<span id="wave-pde1-impl-vec-slices-basics"></span><h3>Operations on slices of arrays<a class="headerlink" href="#operations-on-slices-of-arrays" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-15"></span><span class="target" id="index-16"></span><span class="target" id="index-17"></span><span class="target" id="index-18"></span><p id="index-19">Efficient computing with <code class="docutils literal"><span class="pre">numpy</span></code> arrays demands that we avoid loops
and compute with entire arrays at once (or at least large portions of them).
Consider this calculation of differences <span class="math">\(d_i = u_{i+1}-u_i\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">n</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">size</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>All the differences here are independent of each other.
The computation of <code class="docutils literal"><span class="pre">d</span></code> can therefore alternatively be done by
subtracting the array <span class="math">\((u_0,u_1,\ldots,u_{n-1})\)</span> from
the array where the elements are shifted one index upwards:
<span class="math">\((u_1,u_2,\ldots,u_n)\)</span>, see Figure <a class="reference internal" href="#wave-pde1-vec-fig1"><span class="std std-ref">Illustration of subtracting two slices of two arrays</span></a>.
The former subset of the array can be
expressed by <code class="docutils literal"><span class="pre">u[0:n-1]</span></code>,
<code class="docutils literal"><span class="pre">u[0:-1]</span></code>, or just
<code class="docutils literal"><span class="pre">u[:-1]</span></code>, meaning from index 0 up to,
but not including, the last element (<code class="docutils literal"><span class="pre">-1</span></code>). The latter subset
is obtained by <code class="docutils literal"><span class="pre">u[1:n]</span></code> or <code class="docutils literal"><span class="pre">u[1:]</span></code>,
meaning from index 1 and the rest of the array.
The computation of <code class="docutils literal"><span class="pre">d</span></code> can now be done without an explicit Python loop:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">d</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>or with explicit limits if desired:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">d</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Indices with a colon, going from an index to (but not including) another
index are called <em>slices</em>. With <code class="docutils literal"><span class="pre">numpy</span></code> arrays, the computations
are still done by loops, but in efficient, compiled, highly optimized
C or Fortran code. Such loops are sometimes referred to as <em>vectorized
loops</em>. Such loops can also easily be distributed
among many processors on parallel computers. We say that the <em>scalar code</em>
above, working on an element (a scalar) at a time, has been replaced by
an equivalent <em>vectorized code</em>. The process of vectorizing code is called
<em>vectorization</em>.</p>
<div class="figure" id="id4">
<span id="wave-pde1-vec-fig1"></span><a class="reference internal image-reference" href="_images/vectorized_diff.png"><img alt="_images/vectorized_diff.png" src="_images/vectorized_diff.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Illustration of subtracting two slices of two arrays</em></span></p>
</div>
<div class="admonition-test-your-understanding admonition">
<p class="first admonition-title">Test your understanding</p>
<p class="last">Newcomers to vectorization are encouraged to choose
a small array <code class="docutils literal"><span class="pre">u</span></code>, say with five elements,
and simulate with pen and paper
both the loop version and the vectorized version above.</p>
</div>
<p>Finite difference schemes basically contain differences between array
elements with shifted indices. As an example,
consider the updating formula</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>The vectorization consists of replacing the loop by arithmetics on
slices of arrays of length <code class="docutils literal"><span class="pre">n-2</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u2</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="n">u2</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>   <span class="c"># alternative</span>
</pre></div>
</div>
<p>Note that the length of <code class="docutils literal"><span class="pre">u2</span></code> becomes <code class="docutils literal"><span class="pre">n-2</span></code>. If <code class="docutils literal"><span class="pre">u2</span></code> is already an array of
length <code class="docutils literal"><span class="pre">n</span></code> and we want to use the formula to update all the &#8220;inner&#8221;
elements of <code class="docutils literal"><span class="pre">u2</span></code>, as we will when solving a 1D wave equation, we can write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="o">=</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="n">u2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>   <span class="c"># alternative</span>
</pre></div>
</div>
<p>The first expression&#8217;s right-hand side is realized by the
following steps, involving temporary arrays with intermediate results,
since each array operation can only involve one or two arrays.
The <code class="docutils literal"><span class="pre">numpy</span></code> package performs the first line above in
four steps:</p>
<div class="highlight-text"><div class="highlight"><pre>temp1 = 2*u[1:-1]
temp2 = u[:-2] - temp1
temp3 = temp2 + u[2:]
u2[1:-1] = temp3
</pre></div>
</div>
<p>We need three temporary arrays, but a user does not need to worry about
such temporary arrays.</p>
<div class="admonition-common-mistakes-with-array-slices admonition">
<p class="first admonition-title">Common mistakes with array slices</p>
<p>Array expressions with slices demand that the slices have the same
shape. It easy to make a mistake in, e.g.,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>and write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>Now <code class="docutils literal"><span class="pre">u[1:n]</span></code> has wrong length (<code class="docutils literal"><span class="pre">n-1</span></code>) compared to the other array
slices, causing a <code class="docutils literal"><span class="pre">ValueError</span></code> and the message
<code class="docutils literal"><span class="pre">could</span> <span class="pre">not</span> <span class="pre">broadcast</span> <span class="pre">input</span> <span class="pre">array</span> <span class="pre">from</span> <span class="pre">shape</span> <span class="pre">103</span> <span class="pre">into</span> <span class="pre">shape</span> <span class="pre">104</span></code>
(if <code class="docutils literal"><span class="pre">n</span></code> is 105). When such errors occur one must closely examine
all the slices. Usually, it is easier to get upper limits of slices
right when they use <code class="docutils literal"><span class="pre">-1</span></code> or <code class="docutils literal"><span class="pre">-2</span></code> or empty limit rather than
expressions involving the length.</p>
<p>Another common mistake is to forget the slice in the array on the
left-hand side,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u2</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p class="last">This is really crucial: now <code class="docutils literal"><span class="pre">u2</span></code> becomes a <em>new</em> array of length
<code class="docutils literal"><span class="pre">n-2</span></code>, which is the wrong length as we have no entries for the boundary
values. We meant to insert the right-hand side array <em>into</em> the
in the original <code class="docutils literal"><span class="pre">u2</span></code> array for the entries that correspond to the
internal points in the mesh (<code class="docutils literal"><span class="pre">1:n-1</span></code> or <code class="docutils literal"><span class="pre">1:-1</span></code>).</p>
</div>
<p>Vectorization may also work nicely with functions. To illustrate, we may
extend the previous example as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>Assuming <code class="docutils literal"><span class="pre">u2</span></code>, <code class="docutils literal"><span class="pre">u</span></code>, and <code class="docutils literal"><span class="pre">x</span></code> all have length <code class="docutils literal"><span class="pre">n</span></code>, the vectorized
version becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>Obviously, <code class="docutils literal"><span class="pre">f</span></code> must be able to take an array as argument for <code class="docutils literal"><span class="pre">f[x[1:-1])</span></code>
to make sense.</p>
</div>
<div class="section" id="finite-difference-schemes-expressed-as-slices">
<span id="wave-pde1-impl-vec-slices-fdm"></span><h3>Finite difference schemes expressed as slices<a class="headerlink" href="#finite-difference-schemes-expressed-as-slices" title="Permalink to this headline">¶</a></h3>
<p>We now have the necessary tools to vectorize the wave equation
algorithm as described mathematically in the section <a class="reference internal" href="#wave-string-alg"><span class="std std-ref">Formulating a recursive algorithm</span></a>
and through code in the section <a class="reference internal" href="#wave-pde1-impl-solver"><span class="std std-ref">The solver function</span></a>.  There are
three loops: one for the initial condition, one for the first time
step, and finally the loop that is repeated for all subsequent time
levels. Since only the latter is repeated a potentially large number
of times, we limit our vectorization efforts to this loop:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
           <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The vectorized version becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
          <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">]</span><span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">]</span> <span class="o">+</span> \
          <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The program
<a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_u0v.py">wave1D_u0v.py</a>
contains a new version of the function <code class="docutils literal"><span class="pre">solver</span></code> where both the scalar
and the vectorized loops are included (the argument <code class="docutils literal"><span class="pre">version</span></code> is
set to <code class="docutils literal"><span class="pre">scalar</span></code> or <code class="docutils literal"><span class="pre">vectorized</span></code>, respectively).</p>
</div>
<div class="section" id="verification-4">
<span id="wave-pde1-impl-vec-verify-quadratic"></span><h3>Verification<a class="headerlink" href="#verification-4" title="Permalink to this headline">¶</a></h3>
<p id="index-20">We may reuse the quadratic solution <span class="math">\(\uex(x,t)=x(L-x)(1+{\half}t)\)</span> for
verifying also the vectorized code. A test function can now verify
both the scalar and the vectorized version. Moreover, we may
use a <code class="docutils literal"><span class="pre">user_action</span></code> function that compares the computed and exact
solution at each time level and performs a test:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_quadratic</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check the scalar and vectorized versions work for</span>
<span class="sd">    a quadratic u(x,t)=x(L-x)(1+t/2) that is exactly reproduced.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># The following function must work for x as array or scalar</span>
    <span class="n">u_exact</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c"># f is a scalar (zeros_like(x) works for scalar x too)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

    <span class="n">L</span> <span class="o">=</span> <span class="mf">2.5</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">1.5</span>
    <span class="n">C</span> <span class="o">=</span> <span class="mf">0.75</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c"># Very coarse mesh for this exact test</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">/</span><span class="n">Nx</span><span class="p">)</span><span class="o">/</span><span class="n">c</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">18</span>

    <span class="k">def</span> <span class="nf">assert_no_error</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-13</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>

    <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
           <span class="n">user_action</span><span class="o">=</span><span class="n">assert_no_error</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&#39;scalar&#39;</span><span class="p">)</span>
    <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
           <span class="n">user_action</span><span class="o">=</span><span class="n">assert_no_error</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&#39;vectorized&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-lambda-functions admonition">
<p class="first admonition-title">Lambda functions</p>
<p>The code segment above demonstrates how to achieve very
compact code, without degraded readability,
by use of lambda functions for the various
input parameters that require a Python function. In essence,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">L</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">L</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>Note that lambda functions can just contain a single expression and no
statements.</p>
<p>One advantage with lambda functions is that they can be used directly
in calls:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">L</span><span class="p">),</span> <span class="n">V</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="efficiency-measurements">
<h3>Efficiency measurements<a class="headerlink" href="#efficiency-measurements" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">wave1D_u0v.py</span></code> contains our new <code class="docutils literal"><span class="pre">solver</span></code> function with both
scalar and vectorized code. For comparing the efficiency
of scalar versus vectorized code, we need a <code class="docutils literal"><span class="pre">viz</span></code> function
as discussed in the section <a class="reference internal" href="#wave-pde1-impl-animate"><span class="std std-ref">Visualization: animating the solution</span></a>.
All of this <code class="docutils literal"><span class="pre">viz</span></code> function can be reused, except the call
to <code class="docutils literal"><span class="pre">solver_function</span></code>. This call lacks the parameter
<code class="docutils literal"><span class="pre">version</span></code>, which we want to set to <code class="docutils literal"><span class="pre">vectorized</span></code> and <code class="docutils literal"><span class="pre">scalar</span></code>
for our efficiency measurements.</p>
<p>One solution is to copy the <code class="docutils literal"><span class="pre">viz</span></code> code from <code class="docutils literal"><span class="pre">wave1D_u0</span></code> into
<code class="docutils literal"><span class="pre">wave1D_u0v.py</span></code> and add a <code class="docutils literal"><span class="pre">version</span></code> argument to the <code class="docutils literal"><span class="pre">solver_function</span></code> call.
Taking into account how much quite complicated animation code we
then duplicate, this is not a good idea.
Introducing the <code class="docutils literal"><span class="pre">version</span></code> argument in <code class="docutils literal"><span class="pre">wave1D_u0.viz</span></code> is not
a good solution since <code class="docutils literal"><span class="pre">version</span></code> has no meaning in that file.</p>
<div class="section" id="solution-1">
<h4>Solution 1<a class="headerlink" href="#solution-1" title="Permalink to this headline">¶</a></h4>
<p>Calling <code class="docutils literal"><span class="pre">viz</span></code> in <code class="docutils literal"><span class="pre">wave1D_u0</span></code> with <code class="docutils literal"><span class="pre">solver_function</span></code> as our new
solver in <code class="docutils literal"><span class="pre">wave1D_u0v</span></code> works fine, since this solver has
<code class="docutils literal"><span class="pre">version='vectorized'</span></code> as default value. The problem arises when we
want to test <code class="docutils literal"><span class="pre">version='vectorized'</span></code>. The simplest solution is then
to use <code class="docutils literal"><span class="pre">wave1D_u0.solver</span></code> instead. We make a new <code class="docutils literal"><span class="pre">viz</span></code> function
in <code class="docutils literal"><span class="pre">wave1D_u0v.py</span></code> that has a <code class="docutils literal"><span class="pre">version</span></code> argument and that just
calls <code class="docutils literal"><span class="pre">wave1D_u0.viz</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">viz</span><span class="p">(</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>  <span class="c"># PDE paramteres</span>
    <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">,</span>               <span class="c"># Interval for u in plots</span>
    <span class="n">animate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>             <span class="c"># Simulation with animation?</span>
    <span class="n">tool</span><span class="o">=</span><span class="s">&#39;matplotlib&#39;</span><span class="p">,</span>        <span class="c"># &#39;matplotlib&#39; or &#39;scitools&#39;</span>
    <span class="n">solver_function</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span>   <span class="c"># Function with numerical algorithm</span>
    <span class="n">version</span><span class="o">=</span><span class="s">&#39;vectorized&#39;</span><span class="p">,</span>     <span class="c"># &#39;scalar&#39; or &#39;vectorized&#39;</span>
    <span class="p">):</span>
    <span class="kn">import</span> <span class="nn">wave1D_u0</span>
    <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="s">&#39;vectorized&#39;</span><span class="p">:</span>
        <span class="c"># Reuse viz from wave1D_u0, but with the present</span>
        <span class="c"># modules&#39; new vectorized solver (which has</span>
        <span class="c"># version=&#39;vectorized&#39; as default argument;</span>
        <span class="c"># wave1D_u0.viz does not feature this argument)</span>
        <span class="n">cpu</span> <span class="o">=</span> <span class="n">wave1D_u0</span><span class="o">.</span><span class="n">viz</span><span class="p">(</span>
            <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">,</span>
            <span class="n">animate</span><span class="p">,</span> <span class="n">tool</span><span class="p">,</span> <span class="n">solver_function</span><span class="o">=</span><span class="n">solver</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">version</span> <span class="o">==</span> <span class="s">&#39;scalar&#39;</span><span class="p">:</span>
        <span class="c"># Call wave1D_u0.viz with a solver with</span>
        <span class="c"># scalar code and use wave1D_u0.solver.</span>
        <span class="n">cpu</span> <span class="o">=</span> <span class="n">wave1D_u0</span><span class="o">.</span><span class="n">viz</span><span class="p">(</span>
            <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">,</span>
            <span class="n">animate</span><span class="p">,</span> <span class="n">tool</span><span class="p">,</span>
            <span class="n">solver_function</span><span class="o">=</span><span class="n">wave1D_u0</span><span class="o">.</span><span class="n">solver</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="solution-2">
<h4>Solution 2<a class="headerlink" href="#solution-2" title="Permalink to this headline">¶</a></h4>
<p>There is a more advanced, fancier solution featuring a very useful trick:
we can make a new function that will always call <code class="docutils literal"><span class="pre">wave1D_u0v.solver</span></code>
with <code class="docutils literal"><span class="pre">version='scalar'</span></code>. The <code class="docutils literal"><span class="pre">functools.partial</span></code> function from
standard Python takes a function <code class="docutils literal"><span class="pre">func</span></code> as argument and
a series of positional and keyword arguments and returns a
new function that will call <code class="docutils literal"><span class="pre">func</span></code> with the supplied arguments,
while the user can control all the other arguments in <code class="docutils literal"><span class="pre">func</span></code>.
Consider a trivial example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
</pre></div>
</div>
<p>We want to ensure that <code class="docutils literal"><span class="pre">f</span></code> is always called with <code class="docutils literal"><span class="pre">c=3</span></code>, i.e., <code class="docutils literal"><span class="pre">f</span></code>
has only two &#8220;free&#8221; arguments <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code>.
This functionality is obtained by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">functools</span>
<span class="n">f2</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="k">print</span> <span class="n">f2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c"># results in 1+2+3=6</span>
</pre></div>
</div>
<p>Now <code class="docutils literal"><span class="pre">f2</span></code> calls <code class="docutils literal"><span class="pre">f</span></code> with whatever the user supplies as <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code>,
but <code class="docutils literal"><span class="pre">c</span></code> is always <code class="docutils literal"><span class="pre">3</span></code>.</p>
<p>Back to our <code class="docutils literal"><span class="pre">viz</span></code> code, we can do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">functools</span>
<span class="c"># Call scalar with version fixed to `scalar`</span>
<span class="n">scalar_solver</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">scalar</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&#39;scalar&#39;</span><span class="p">)</span>
<span class="n">cpu</span> <span class="o">=</span> <span class="n">wave1D_u0</span><span class="o">.</span><span class="n">viz</span><span class="p">(</span>
        <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">,</span>
        <span class="n">animate</span><span class="p">,</span> <span class="n">tool</span><span class="p">,</span> <span class="n">solver_function</span><span class="o">=</span><span class="n">scalar_solver</span><span class="p">)</span>
</pre></div>
</div>
<p>The new <code class="docutils literal"><span class="pre">scalar_solver</span></code> takes the same arguments as
<code class="docutils literal"><span class="pre">wave1D_u0.scalar</span></code> and calls <code class="docutils literal"><span class="pre">wave1D_u0v.scalar</span></code>,
but always supplies the extra argument
<code class="docutils literal"><span class="pre">version='scalar'</span></code>. When sending this <code class="docutils literal"><span class="pre">solver_function</span></code>
to <code class="docutils literal"><span class="pre">wave1D_u0.viz</span></code>, the latter will call <code class="docutils literal"><span class="pre">wave1D_u0v.solver</span></code>
with all the <code class="docutils literal"><span class="pre">I</span></code>, <code class="docutils literal"><span class="pre">V</span></code>, <code class="docutils literal"><span class="pre">f</span></code>, etc., arguments we supply, plus
<code class="docutils literal"><span class="pre">version='scalar'</span></code>.</p>
</div>
<div class="section" id="efficiency-experiments">
<h4>Efficiency experiments<a class="headerlink" href="#efficiency-experiments" title="Permalink to this headline">¶</a></h4>
<p>We now have a <code class="docutils literal"><span class="pre">viz</span></code> function that can call our solver function both in
scalar and vectorized mode. The function <code class="docutils literal"><span class="pre">run_efficiency_experiments</span></code>
in <code class="docutils literal"><span class="pre">wave1D_u0v.py</span></code> performs a set of experiments and reports the
CPU time spent in the scalar and vectorized solver for
the previous string vibration example with spatial mesh resolutions
<span class="math">\(N_x=50,100,200,400,800\)</span>. Running this function reveals
that the vectorized
code runs substantially faster: the vectorized code runs approximately
<span class="math">\(N_x/10\)</span> times as fast as the scalar code!</p>
</div>
</div>
<div class="section" id="remark-on-the-updating-of-arrays">
<span id="wave-pde1-impl-ref-switch"></span><h3>Remark on the updating of arrays<a class="headerlink" href="#remark-on-the-updating-of-arrays" title="Permalink to this headline">¶</a></h3>
<p>At the end of each time step we need to update the <code class="docutils literal"><span class="pre">u_2</span></code> and <code class="docutils literal"><span class="pre">u_1</span></code>
arrays such that they have the right content for the next time step:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_2</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_1</span>
<span class="n">u_1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u</span>
</pre></div>
</div>
<p>The order here is important! (Updating <code class="docutils literal"><span class="pre">u_1</span></code> first, makes <code class="docutils literal"><span class="pre">u_2</span></code> equal
to <code class="docutils literal"><span class="pre">u</span></code>, which is wrong.)</p>
<p>The assignment <code class="docutils literal"><span class="pre">u_1[:]</span> <span class="pre">=</span> <span class="pre">u</span></code> copies the content of the <code class="docutils literal"><span class="pre">u</span></code> array into
the elements of the <code class="docutils literal"><span class="pre">u_1</span></code> array. Such copying takes time, but
that time is negligible compared to the time needed for
computing <code class="docutils literal"><span class="pre">u</span></code> from the finite difference formula,
even when the formula has a vectorized implementation.
However, efficiency of program code is a key topic when solving
PDEs numerically (particularly when there are two or three
space dimensions), so it must be mentioned that there exists a
much more efficient way of making the arrays <code class="docutils literal"><span class="pre">u_2</span></code> and <code class="docutils literal"><span class="pre">u_1</span></code>
ready for the next time step. The idea is based on <em>switching
references</em> and explained as follows.</p>
<p>A Python variable is actually a reference to some object (C programmers
may think of pointers). Instead of copying data, we can let <code class="docutils literal"><span class="pre">u_2</span></code>
refer to the <code class="docutils literal"><span class="pre">u_1</span></code> object and <code class="docutils literal"><span class="pre">u_1</span></code> refer to the <code class="docutils literal"><span class="pre">u</span></code> object.
This is a very efficiency operation (like switching pointers in C).
A naive implementation like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_2</span> <span class="o">=</span> <span class="n">u_1</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">u</span>
</pre></div>
</div>
<p>will fail, however, because now <code class="docutils literal"><span class="pre">u_2</span></code> refers to the <code class="docutils literal"><span class="pre">u_1</span></code> object,
but then the name <code class="docutils literal"><span class="pre">u_1</span></code> refers to <code class="docutils literal"><span class="pre">u</span></code>, so that this <code class="docutils literal"><span class="pre">u</span></code> object
has two references, <code class="docutils literal"><span class="pre">u_1</span></code> and <code class="docutils literal"><span class="pre">u</span></code>, while our third array, originally
referred to by <code class="docutils literal"><span class="pre">u_2</span></code> has no more references and is lost.
This means that the variables <code class="docutils literal"><span class="pre">u</span></code>, <code class="docutils literal"><span class="pre">u_1</span></code>, and <code class="docutils literal"><span class="pre">u_2</span></code> refer to two
arrays and not three. Consequently, the computations at the next
time level will be messed up since updating the elements in
<code class="docutils literal"><span class="pre">u</span></code> will imply updating the elements in <code class="docutils literal"><span class="pre">u_1</span></code> too so the solution
at the previous time step, which is crucial in our formulas, is
destroyed.</p>
<p>While <code class="docutils literal"><span class="pre">u_2</span> <span class="pre">=</span> <span class="pre">u_1</span></code> is fine, <code class="docutils literal"><span class="pre">u_1</span> <span class="pre">=</span> <span class="pre">u</span></code> is problematic, so
the solution to this problem is to ensure that <code class="docutils literal"><span class="pre">u</span></code>
points to the <code class="docutils literal"><span class="pre">u_2</span></code> array. This is mathematically wrong, but
new correct values will be filled into <code class="docutils literal"><span class="pre">u</span></code> at the next time step
and make it right.</p>
<p>The correct switch of references is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tmp</span> <span class="o">=</span> <span class="n">u_2</span>
<span class="n">u_2</span> <span class="o">=</span> <span class="n">u_1</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">u</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">tmp</span>
</pre></div>
</div>
<p>We can get rid of the temporary reference <code class="docutils literal"><span class="pre">tmp</span></code> by writing</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_2</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_2</span>
</pre></div>
</div>
<p>This switching of references for updating our arrays
will be used in later implementations.</p>
<div class="admonition-caution admonition">
<p class="first admonition-title">Caution</p>
<p class="last">The update <code class="docutils literal"><span class="pre">u_2,</span> <span class="pre">u_1,</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">u_1,</span> <span class="pre">u,</span> <span class="pre">u_2</span></code> leaves wrong content in <code class="docutils literal"><span class="pre">u</span></code>
at the final time step. This means that if we return <code class="docutils literal"><span class="pre">u</span></code>, as we
do in the example codes here, we actually return <code class="docutils literal"><span class="pre">u_2</span></code>, which is
obviously wrong. It is therefore important to adjust the content
of <code class="docutils literal"><span class="pre">u</span></code> to <code class="docutils literal"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">u_1</span></code> before returning <code class="docutils literal"><span class="pre">u</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="exercises-1">
<h2>Exercises<a class="headerlink" href="#exercises-1" title="Permalink to this headline">¶</a></h2>
<div class="section" id="exercise-18-simulate-a-standing-wave">
<span id="wave-exer-standingwave"></span><h3>Exercise 18: Simulate a standing wave<a class="headerlink" href="#exercise-18-simulate-a-standing-wave" title="Permalink to this headline">¶</a></h3>
<p>The purpose of this exercise is to simulate standing waves on <span class="math">\([0,L]\)</span>
and illustrate the error in the simulation.
Standing waves arise from an initial condition</p>
<div class="math">
\[u(x,0)= A \sin\left(\frac{\pi}{L}mx\right),\]</div>
<p>where <span class="math">\(m\)</span> is an integer and <span class="math">\(A\)</span> is a freely chosen amplitude.
The corresponding exact solution can be computed and reads</p>
<div class="math">
\[\uex(x,t) =  A\sin\left(\frac{\pi}{L}mx\right)
\cos\left(\frac{\pi}{L}mct\right)\tp\]</div>
<p><strong>a)</strong>
Explain that for a function <span class="math">\(\sin kx\cos \omega t\)</span> the wave length
in space is <span class="math">\(\lambda = 2\pi /k\)</span> and the period in time is <span class="math">\(P=2\pi/\omega\)</span>.
Use these expressions to find the wave length in space and period in
time of <span class="math">\(\uex\)</span> above.</p>
<p><strong>b)</strong>
Import the <code class="docutils literal"><span class="pre">solver</span></code> function <code class="docutils literal"><span class="pre">wave1D_u0.py</span></code> into a new file
where the <code class="docutils literal"><span class="pre">viz</span></code> function is reimplemented such that it
plots either the numerical <em>and</em> the exact solution, <em>or</em> the error.</p>
<p><strong>c)</strong>
Make animations where you illustrate how the error
<span class="math">\(e^n_i =\uex(x_i, t_n)- u^n_i\)</span>
develops and increases in time. Also make animations of
<span class="math">\(u\)</span> and <span class="math">\(\uex\)</span> simultaneously.</p>
<p><strong>Hint 1.</strong>
Quite long time simulations are needed in order to display significant
discrepancies between the numerical and exact solution.</p>
<p><strong>Hint 2.</strong>
A possible set of parameters is <span class="math">\(L=12\)</span>, <span class="math">\(m=9\)</span>, <span class="math">\(c=2\)</span>, <span class="math">\(A=1\)</span>, <span class="math">\(N_x=80\)</span>,
<span class="math">\(C=0.8\)</span>. The error mesh function <span class="math">\(e^n\)</span> can be simulated for 10 periods,
while 20-30 periods are needed to show significant differences between
the curves for the numerical and exact solution.</p>
<p>Filename: <code class="docutils literal"><span class="pre">wave_standing</span></code>.</p>
<div class="section" id="remarks-1">
<h4>Remarks<a class="headerlink" href="#remarks-1" title="Permalink to this headline">¶</a></h4>
<p>The important
parameters for numerical quality are <span class="math">\(C\)</span> and <span class="math">\(k\Delta x\)</span>, where
<span class="math">\(C=c\Delta t/\Delta x\)</span> is the Courant number and <span class="math">\(k\)</span> is defined above
(<span class="math">\(k\Delta x\)</span> is proportional to how many mesh points we have per wave length
in space, see the section <a class="reference internal" href="._book004.html#wave-pde1-num-dispersion"><span class="std std-ref">Numerical dispersion relation</span></a> for explanation).</p>
</div>
</div>
<div class="section" id="exercise-19-add-storage-of-solution-in-a-user-action-function">
<span id="wave-exer-store-list"></span><h3>Exercise 19: Add storage of solution in a user action function<a class="headerlink" href="#exercise-19-add-storage-of-solution-in-a-user-action-function" title="Permalink to this headline">¶</a></h3>
<p>Extend the <code class="docutils literal"><span class="pre">plot_u</span></code> function in the file <code class="docutils literal"><span class="pre">wave1D_u0.py</span></code> to also store
the solutions <code class="docutils literal"><span class="pre">u</span></code> in a list.
To this end, declare <code class="docutils literal"><span class="pre">all_u</span></code> as
an empty list in the <code class="docutils literal"><span class="pre">viz</span></code> function, outside <code class="docutils literal"><span class="pre">plot_u</span></code>, and perform
an append operation inside the <code class="docutils literal"><span class="pre">plot_u</span></code> function. Note that a
function, like <code class="docutils literal"><span class="pre">plot_u</span></code>, inside another function, like <code class="docutils literal"><span class="pre">viz</span></code>,
remembers all local variables in <code class="docutils literal"><span class="pre">viz</span></code> function, including <code class="docutils literal"><span class="pre">all_u</span></code>,
even when <code class="docutils literal"><span class="pre">plot_u</span></code> is called (as <code class="docutils literal"><span class="pre">user_action</span></code>) in the <code class="docutils literal"><span class="pre">solver</span></code> function.
Test both <code class="docutils literal"><span class="pre">all_u.append(u)</span></code> and <code class="docutils literal"><span class="pre">all_u.append(u.copy())</span></code>.
Why does one of these constructions fail to store the solution correctly?
Let the <code class="docutils literal"><span class="pre">viz</span></code> function return the <code class="docutils literal"><span class="pre">all_u</span></code> list
converted to a two-dimensional <code class="docutils literal"><span class="pre">numpy</span></code> array.
Filename: <code class="docutils literal"><span class="pre">wave1D_u0_s_store</span></code>.</p>
</div>
<div class="section" id="exercise-20-use-a-class-for-the-user-action-function">
<span id="wave-exer-store-list-class"></span><h3>Exercise 20: Use a class for the user action function<a class="headerlink" href="#exercise-20-use-a-class-for-the-user-action-function" title="Permalink to this headline">¶</a></h3>
<p>Redo <a class="reference internal" href="#wave-exer-store-list"><span class="std std-ref">Exercise 19: Add storage of solution in a user action function</span></a> using a class for the
user action function. That is, define a class <code class="docutils literal"><span class="pre">Action</span></code> where
the <code class="docutils literal"><span class="pre">all_u</span></code> list is an attribute, and implement the user action
function as a method (the special method <code class="docutils literal"><span class="pre">__call__</span></code> is a natural
choice). The class versions avoids that the user action function
depends on parameters defined outside the function (such as <code class="docutils literal"><span class="pre">all_u</span></code>
in <a class="reference internal" href="#wave-exer-store-list"><span class="std std-ref">Exercise 19: Add storage of solution in a user action function</span></a>).
Filename: <code class="docutils literal"><span class="pre">wave1D_u0_s2c</span></code>.</p>
</div>
<div class="section" id="exercise-21-compare-several-courant-numbers-in-one-movie">
<span id="wave-exer-multiple-c"></span><h3>Exercise 21: Compare several Courant numbers in one movie<a class="headerlink" href="#exercise-21-compare-several-courant-numbers-in-one-movie" title="Permalink to this headline">¶</a></h3>
<p>The goal of this exercise is to make movies where several curves,
corresponding to different Courant numbers, are visualized.
Import the <code class="docutils literal"><span class="pre">solver</span></code> function from the <code class="docutils literal"><span class="pre">wave1D_u0_s</span></code> movie
in a new file <code class="docutils literal"><span class="pre">wave_compare.py</span></code>. Reimplement the <code class="docutils literal"><span class="pre">viz</span></code> function
such that it can take a list of <code class="docutils literal"><span class="pre">C</span></code> values as argument
and create a movie with solutions corresponding to the given <code class="docutils literal"><span class="pre">C</span></code>
values. The <code class="docutils literal"><span class="pre">plot_u</span></code> function must be changed to store the solution
in an array (see <a class="reference internal" href="#wave-exer-store-list"><span class="std std-ref">Exercise 19: Add storage of solution in a user action function</span></a> or
<a class="reference internal" href="#wave-exer-store-list-class"><span class="std std-ref">Exercise 20: Use a class for the user action function</span></a> for details), <code class="docutils literal"><span class="pre">solver</span></code> must be
computed for each value of the Courant number, and finally
one must run through each time step and plot all the spatial
solution curves in one figure and store it in a file.</p>
<p>The challenge in such a visualization is to ensure that the curves in
one plot corresponds to the same time point. The easiest remedy is to
keep the time and space resolution constant and change the wave
velocity <span class="math">\(c\)</span> to change the Courant number.
Filename: <code class="docutils literal"><span class="pre">wave_numerics_comparison</span></code>.</p>
</div>
<div class="section" id="project-22-calculus-with-1d-mesh-functions">
<span id="wave-exer-mesh1d-calculus"></span><h3>Project 22: Calculus with 1D mesh functions<a class="headerlink" href="#project-22-calculus-with-1d-mesh-functions" title="Permalink to this headline">¶</a></h3>
<p>This project explores integration and differentiation of
mesh functions, both with scalar and vectorized implementations.
We are given a mesh function <span class="math">\(f_i\)</span> on a spatial one-dimensional
mesh <span class="math">\(x_i=i\Delta x\)</span>, <span class="math">\(i=0,\ldots,N_x\)</span>, over the interval <span class="math">\([a,b]\)</span>.</p>
<p><strong>a)</strong>
Define the discrete derivative of <span class="math">\(f_i\)</span> by using centered
differences at internal mesh points and one-sided differences
at the end points. Implement a scalar version of
the computation in a Python function and write an associated unit test
for the linear case <span class="math">\(f(x)=4x-2.5\)</span> where the discrete derivative should
be exact.</p>
<p><strong>b)</strong>
Vectorize the implementation of the discrete derivative.
Extend the unit test to check the validity of the implementation.</p>
<p><strong>c)</strong>
To compute the discrete integral <span class="math">\(F_i\)</span> of <span class="math">\(f_i\)</span>, we assume that
the mesh function <span class="math">\(f_i\)</span> varies linearly between the mesh points.
Let <span class="math">\(f(x)\)</span> be such a linear interpolant of <span class="math">\(f_i\)</span>. We then
have</p>
<div class="math">
\[F_i = \int_{x_0}^{x_i} f(x) dx\tp\]</div>
<p>The exact integral of a piecewise linear function <span class="math">\(f(x)\)</span> is
given by the Trapezoidal rule. S
how that if <span class="math">\(F_{i}\)</span> is already computed, we can find <span class="math">\(F_{i+1}\)</span>
from</p>
<div class="math">
\[F_{i+1} = F_i + \half(f_i + f_{i+1})\Delta x\tp\]</div>
<p>Make a function for the scalar implementation of the discrete integral
as a mesh function. That is, the function should return
<span class="math">\(F_i\)</span> for <span class="math">\(i=0,\ldots,N_x\)</span>.
For a unit test one can use the fact that the above defined
discrete integral of a linear
function (say <span class="math">\(f(x)=4x-2.5\)</span>) is exact.</p>
<p><strong>d)</strong>
Vectorize the implementation of the discrete integral.
Extend the unit test to check the validity of the implementation.</p>
<p><strong>Hint.</strong>
Interpret the recursive formula for <span class="math">\(F_{i+1}\)</span> as a sum.
Make an array with each element of the sum and use the &#8220;cumsum&#8221;
(<code class="docutils literal"><span class="pre">numpy.cumsum</span></code>) operation to compute the accumulative sum:
<code class="docutils literal"><span class="pre">numpy.cumsum([1,3,5])</span></code> is <code class="docutils literal"><span class="pre">[1,4,9]</span></code>.</p>
<p><strong>e)</strong>
Create a class <code class="docutils literal"><span class="pre">MeshCalculus</span></code> that can integrate and differentiate
mesh functions. The class can just define some methods that call
the previously implemented Python functions. Here is an example
on the usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">calc</span> <span class="o">=</span> <span class="n">MeshCalculus</span><span class="p">(</span><span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>        <span class="c"># mesh</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>                    <span class="c"># mesh function</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">calc</span><span class="o">.</span><span class="n">differentiate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>    <span class="c"># discrete derivative</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">calc</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>         <span class="c"># discrete anti-derivative</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">mesh_calculus_1D</span></code>.</p>
</div>
</div>
<div class="section" id="generalization-reflecting-boundaries">
<span id="wave-pde2-neumann"></span><h2>Generalization: reflecting boundaries<a class="headerlink" href="#generalization-reflecting-boundaries" title="Permalink to this headline">¶</a></h2>
<p>The boundary condition <span class="math">\(u=0\)</span> in a wave equation
reflects the wave, but <span class="math">\(u\)</span> changes sign at the boundary,
while the condition <span class="math">\(u_x=0\)</span> reflects the wave as a mirror and preserves
the sign, see
a <a class="reference external" href="http://tinyurl.com/opdfafk/pub/mov-wave/demo_BC_gaussian/index.html">web page</a>
or a <a class="reference external" href="http://tinyurl.com/opdfafk/pub/mov-wave/demo_BC_gaussian/movie.flv">movie file</a>
for demonstration.</p>
<p>Our next task is to explain how to implement the boundary
condition <span class="math">\(u_x=0\)</span>, which is
more complicated to express numerically and also to implement than
a given value of <span class="math">\(u\)</span>.
We shall present two methods for implementing <span class="math">\(u_x=0\)</span>
in a finite difference scheme, one based on deriving a modified
stencil at the boundary, and another one based on extending the mesh
with ghost cells and ghost points.</p>
<div class="section" id="neumann-boundary-condition">
<span id="wave-pde2-neumann-bc"></span><h3>Neumann boundary condition<a class="headerlink" href="#neumann-boundary-condition" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-21"></span><span class="target" id="index-22"></span><span class="target" id="index-23"></span><span class="target" id="index-24"></span><span class="target" id="index-25"></span><p id="index-26">When a wave hits a boundary and is to be reflected back, one applies
the condition</p>
<div class="math" id="eq-wave-pde1-neumann-0">
\[\tag{115}
\frac{\partial u}{\partial n} \equiv \normalvec\cdot\nabla u = 0\]\[    \tp\]</div>
<p>The derivative <span class="math">\(\partial /\partial n\)</span> is in the
outward normal direction from a general boundary.
For a 1D domain <span class="math">\([0,L]\)</span>,
we have that</p>
<div class="math">
\[\left.\frac{\partial}{\partial n}\right\vert_{x=L} =
\frac{\partial}{\partial x},\quad
\left.\frac{\partial}{\partial n}\right\vert_{x=0} = -
\frac{\partial}{\partial x}\tp\]</div>
<div class="admonition-boundary-condition-terminology admonition">
<p class="first admonition-title">Boundary condition terminology</p>
<p class="last">Boundary conditions
that specify the value of <span class="math">\(\partial u/\partial n\)</span>,
or shorter <span class="math">\(u_n\)</span>, are known as
<a class="reference external" href="http://en.wikipedia.org/wiki/Neumann_boundary_condition">Neumann</a> conditions, while <a class="reference external" href="http://en.wikipedia.org/wiki/Dirichlet_conditions">Dirichlet conditions</a>
refer to specifications of <span class="math">\(u\)</span>.
When the values are zero (<span class="math">\(\partial u/\partial n=0\)</span> or <span class="math">\(u=0\)</span>) we speak
about <em>homogeneous</em> Neumann or Dirichlet conditions.</p>
</div>
</div>
<div class="section" id="discretization-of-derivatives-at-the-boundary">
<span id="wave-pde2-neumann-discr"></span><h3>Discretization of derivatives at the boundary<a class="headerlink" href="#discretization-of-derivatives-at-the-boundary" title="Permalink to this headline">¶</a></h3>
<p>How can we incorporate the condition <a class="reference internal" href="#eq-wave-pde1-neumann-0"><span class="std std-ref">(115)</span></a>
in the finite difference scheme?  Since we have used central
differences in all the other approximations to derivatives in the
scheme, it is tempting to implement <a class="reference internal" href="#eq-wave-pde1-neumann-0"><span class="std std-ref">(115)</span></a> at
<span class="math">\(x=0\)</span> and <span class="math">\(t=t_n\)</span> by the difference</p>
<div class="math" id="eq-wave-pde1-neumann-0-cd">
\[\tag{116}
[D_{2x} u]^n_0 = \frac{u_{-1}^n - u_1^n}{2\Delta x} = 0
    \tp\]</div>
<p>The problem is that <span class="math">\(u_{-1}^n\)</span> is not a <span class="math">\(u\)</span> value that is being
computed since the point is outside the mesh. However, if we combine
<a class="reference internal" href="#eq-wave-pde1-neumann-0-cd"><span class="std std-ref">(116)</span></a> with the scheme</p>
<p>for <span class="math">\(i=0\)</span>,</p>
<div class="math" id="eq-wave-pde1-neumann-0-scheme">
\[\tag{117}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
    \left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right),\]</div>
<p>we can eliminate the fictitious value <span class="math">\(u_{-1}^n\)</span>. We see that
<span class="math">\(u_{-1}^n=u_1^n\)</span> from <a class="reference internal" href="#eq-wave-pde1-neumann-0-cd"><span class="std std-ref">(116)</span></a>, which
can be used in <a class="reference internal" href="#eq-wave-pde1-neumann-0-scheme"><span class="std std-ref">(117)</span></a> to
arrive at a modified scheme for the boundary point <span class="math">\(u_0^{n+1}\)</span>:</p>
<div class="math" id="eq-auto39">
\[\tag{118}
u^{n+1}_i = -u^{n-1}_i  + 2u^n_i + 2C^2
    \left(u^{n}_{i+1}-u^{n}_{i}\right),\quad i=0 \tp\]</div>
<p>Figure <a class="reference internal" href="#wave-pde1-fig-neumann-stencil"><span class="std std-ref">Modified stencil at a boundary with a Neumann condition</span></a> visualizes this equation
for computing <span class="math">\(u^3_0\)</span> in terms of <span class="math">\(u^2_0\)</span>, <span class="math">\(u^1_0\)</span>, and
<span class="math">\(u^2_1\)</span>.</p>
<div class="figure" id="id5">
<span id="wave-pde1-fig-neumann-stencil"></span><span id="index-27"></span><a class="reference internal image-reference" href="_images/stencil_n_left.png"><img alt="_images/stencil_n_left.png" src="_images/stencil_n_left.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Modified stencil at a boundary with a Neumann condition</em></span></p>
</div>
<p>Similarly, <a class="reference internal" href="#eq-wave-pde1-neumann-0"><span class="std std-ref">(115)</span></a> applied at <span class="math">\(x=L\)</span>
is discretized by a central difference</p>
<div class="math" id="eq-wave-pde1-neumann-0-cd2">
\[\tag{119}
\frac{u_{N_x+1}^n - u_{N_x-1}^n}{2\Delta x} = 0
    \tp\]</div>
<p>Combined with the scheme for <span class="math">\(i=N_x\)</span> we get a modified scheme for
the boundary value <span class="math">\(u_{N_x}^{n+1}\)</span>:</p>
<div class="math" id="eq-auto40">
\[\tag{120}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + 2C^2
    \left(u^{n}_{i-1}-u^{n}_{i}\right),\quad i=N_x \tp\]</div>
<p>The modification of the scheme at the boundary is also required for
the special formula for the first time step. How the stencil moves
through the mesh and is modified at the boundary can be illustrated
by an animation
in a <a class="reference external" href="http://tinyurl.com/opdfafk/pub/mov-wave/wave1D_PDE_Neumann_stencil_gpl/index.html">web page</a>
or a <a class="reference external" href="http://tinyurl.com/opdfafk/pub/mov-wave/wave1D_PDE_Neumann_stencil_gpl/movie.ogg">movie file</a>.</p>
</div>
<div class="section" id="implementation-of-neumann-conditions">
<span id="wave-pde2-neumann-impl"></span><h3>Implementation of Neumann conditions<a class="headerlink" href="#implementation-of-neumann-conditions" title="Permalink to this headline">¶</a></h3>
<p>We have seen in the preceding section
that the special formulas for the boundary points
arise from replacing <span class="math">\(u_{i-1}^n\)</span> by <span class="math">\(u_{i+1}^n\)</span> when computing
<span class="math">\(u_i^{n+1}\)</span> from the stencil formula for <span class="math">\(i=0\)</span>. Similarly, we
replace <span class="math">\(u_{i+1}^n\)</span> by <span class="math">\(u_{i-1}^n\)</span> in the stencil formula
for <span class="math">\(i=N_x\)</span>. This observation can conveniently
be used in the coding: we just work with the general stencil formula,
but write the code such that it is easy to replace <code class="docutils literal"><span class="pre">u[i-1]</span></code> by
<code class="docutils literal"><span class="pre">u[i+1]</span></code> and vice versa. This is achieved by
having the indices <code class="docutils literal"><span class="pre">i+1</span></code> and <code class="docutils literal"><span class="pre">i-1</span></code> as variables <code class="docutils literal"><span class="pre">ip1</span></code> (<code class="docutils literal"><span class="pre">i</span></code> plus 1)
and <code class="docutils literal"><span class="pre">im1</span></code> (<code class="docutils literal"><span class="pre">i</span></code> minus 1), respectively.
At the boundary we can easily define <code class="docutils literal"><span class="pre">im1=i+1</span></code> while we use
<code class="docutils literal"><span class="pre">im1=i-1</span></code> in the internal parts of the mesh. Here are the details
of the implementation (note that the updating formula for <code class="docutils literal"><span class="pre">u[i]</span></code>
is the general stencil formula):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">ip1</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
<span class="n">im1</span> <span class="o">=</span> <span class="n">ip1</span>  <span class="c"># i-1 -&gt; i+1</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">im1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">ip1</span><span class="p">])</span>

<span class="n">i</span> <span class="o">=</span> <span class="n">Nx</span>
<span class="n">im1</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span>
<span class="n">ip1</span> <span class="o">=</span> <span class="n">im1</span>  <span class="c"># i+1 -&gt; i-1</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">im1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">ip1</span><span class="p">])</span>
</pre></div>
</div>
<p>We can in fact create one loop over both the internal and boundary
points and use only one updating formula:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">ip1</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Nx</span> <span class="k">else</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">im1</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="k">else</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">im1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">ip1</span><span class="p">])</span>
</pre></div>
</div>
<p>The program <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_n0.py">wave1D_n0.py</a>
contains a complete implementation of the 1D wave equation with
boundary conditions <span class="math">\(u_x = 0\)</span> at <span class="math">\(x=0\)</span> and <span class="math">\(x=L\)</span>.</p>
<p>It would be nice to modify the <code class="docutils literal"><span class="pre">test_quadratic</span></code> test case from the
<code class="docutils literal"><span class="pre">wave1D_u0.py</span></code> with Dirichlet conditions, described in the section <a class="reference internal" href="#wave-pde1-impl-vec-verify-quadratic"><span class="std std-ref">Verification</span></a>. However, the Neumann
conditions requires the polynomial variation in <span class="math">\(x\)</span> direction to
be of third degree, which causes challenging problems when
designing a test where the numerical solution is known exactly.
<a class="reference internal" href="#wave-fd2-exer-verify-cubic"><span class="std std-ref">Exercise 31: Verification by a cubic polynomial in space</span></a> outlines ideas and code
for this purpose. The only test in <code class="docutils literal"><span class="pre">wave1D_n0.py</span></code> is to start
with a plug wave at rest and see that the initial condition is
reached again perfectly after one period of motion, but such
a test requires <span class="math">\(C=1\)</span> (so the numerical solution coincides with
the exact solution of the PDE, see the section <a class="reference internal" href="._book004.html#wave-pde1-num-dispersion"><span class="std std-ref">Numerical dispersion relation</span></a>).</p>
</div>
<div class="section" id="index-set-notation">
<span id="wave-indexset"></span><h3>Index set notation<a class="headerlink" href="#index-set-notation" title="Permalink to this headline">¶</a></h3>
<p id="index-28">To improve our mathematical writing and our implementations,
it is wise to introduce a special notation for index sets. This means
that we write
<span class="math">\(x_i\)</span>, <span class="math">\(i\in\Ix\)</span>, instead of <span class="math">\(i=0,\ldots,N_x\)</span>.
Obviously, <span class="math">\(\Ix\)</span> must be the index set <span class="math">\(\Ix =\{0,\ldots,N_x\}\)</span>, but it
is often advantageous to have a symbol for this set rather than
specifying all its elements (all the time, as we have done up to
now). This new notation saves writing and makes
specifications of algorithms and their implementation of computer code
simpler.</p>
<p>The first index in the set will be denoted <span class="math">\(\setb{\Ix}\)</span>
and the last <span class="math">\(\sete{\Ix}\)</span>. When we need to skip the first element of
the set, we use <span class="math">\(\setr{\Ix}\)</span> for the remaining subset
<span class="math">\(\setr{\Ix}=\{1,\ldots,N_x\}\)</span>. Similarly, if the last element is
to be dropped, we write <span class="math">\(\setl{\Ix}=\{0,\ldots,N_x-1\}\)</span> for the
remaining indices.
All the
indices corresponding to inner grid points are specified by
<span class="math">\(\seti{\Ix}=\{1,\ldots,N_x-1\}\)</span>.  For the time domain we find it
natural to explicitly use 0 as the first index, so we will usually
write <span class="math">\(n=0\)</span> and <span class="math">\(t_0\)</span> rather than <span class="math">\(n=\It^0\)</span>. We also avoid notation
like <span class="math">\(x_{\sete{\Ix}}\)</span> and will instead use <span class="math">\(x_i\)</span>, <span class="math">\(i=\sete{\Ix}\)</span>.</p>
<p>The Python code associated with index sets applies the following
conventions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Notation</th>
<th class="head">Python</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><span class="math">\(\Ix\)</span></td>
<td><code class="docutils literal"><span class="pre">Ix</span></code></td>
</tr>
<tr class="row-odd"><td><span class="math">\(\setb{\Ix}\)</span></td>
<td><code class="docutils literal"><span class="pre">Ix[0]</span></code></td>
</tr>
<tr class="row-even"><td><span class="math">\(\sete{\Ix}\)</span></td>
<td><code class="docutils literal"><span class="pre">Ix[-1]</span></code></td>
</tr>
<tr class="row-odd"><td><span class="math">\(\setl{\Ix}\)</span></td>
<td><code class="docutils literal"><span class="pre">Ix[:-1]</span></code></td>
</tr>
<tr class="row-even"><td><span class="math">\(\setr{\Ix}\)</span></td>
<td><code class="docutils literal"><span class="pre">Ix[1:]</span></code></td>
</tr>
<tr class="row-odd"><td><span class="math">\(\seti{\Ix}\)</span></td>
<td><code class="docutils literal"><span class="pre">Ix[1:-1]</span></code></td>
</tr>
</tbody>
</table>
<div class="admonition-why-index-sets-are-useful admonition">
<p class="first admonition-title">Why index sets are useful</p>
<p class="last">An important feature of the index set notation is that it
keeps our formulas and code independent of how
we count mesh points. For example, the notation <span class="math">\(i\in\Ix\)</span> or <span class="math">\(i=\setb{\Ix}\)</span>
remains the same whether <span class="math">\(\Ix\)</span> is defined as above or as starting at 1,
i.e., <span class="math">\(\Ix=\{1,\ldots,Q\}\)</span>. Similarly, we can in the code define
<code class="docutils literal"><span class="pre">Ix=range(Nx+1)</span></code> or <code class="docutils literal"><span class="pre">Ix=range(1,Q)</span></code>, and expressions
like <code class="docutils literal"><span class="pre">Ix[0]</span></code> and <code class="docutils literal"><span class="pre">Ix[1:-1]</span></code> remain correct. One application where
the index set notation is convenient is
conversion of code from a language where arrays has base index 0 (e.g.,
Python and C) to languages where the base index is 1 (e.g., MATLAB and
Fortran). Another important application is implementation of
Neumann conditions via ghost points (see next section).</p>
</div>
<p>For the current problem setting in the <span class="math">\(x,t\)</span> plane, we work with
the index sets</p>
<div class="math" id="eq-auto41">
\[\tag{121}
\Ix = \{0,\ldots,N_x\},\quad \It = \{0,\ldots,N_t\},\]</div>
<p>defined in Python as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Ix</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">It</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>A finite difference scheme can with the index set notation be specified as</p>
<div class="math">
\[\begin{split}u_i^{n+1} &amp;= u^n_i - \half
C^2\left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right),\quad,
i\in\seti{\Ix},\ n=0,\\
u^{n+1}_i &amp;= -u^{n-1}_i  + 2u^n_i + C^2
\left(u^{n}_{i+1}-2u^{n}_{i}+u^{n}_{i-1}\right),
\quad i\in\seti{\Ix},\ n\in\seti{\It},\\
u_i^{n+1} &amp;= 0,
\quad i=\setb{\Ix},\ n\in\setl{\It},\\
u_i^{n+1} &amp;= 0,
\quad i=\sete{\Ix},\ n\in\setl{\It}\tp\end{split}\]</div>
<p>The corresponding implementation becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Initial condition</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

<span class="c"># Time loop</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">It</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="c"># Compute internal points</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
               <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="c"># Compute boundary conditions</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The program <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_dn.py">wave1D_dn.py</a>
applies the index set notation and
solves the 1D wave equation <span class="math">\(u_{tt}=c^2u_{xx}+f(x,t)\)</span> with
quite general boundary and initial conditions:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math">\(x=0\)</span>: <span class="math">\(u=U_0(t)\)</span> or <span class="math">\(u_x=0\)</span></li>
<li><span class="math">\(x=L\)</span>: <span class="math">\(u=U_L(t)\)</span> or <span class="math">\(u_x=0\)</span></li>
<li><span class="math">\(t=0\)</span>: <span class="math">\(u=I(x)\)</span></li>
<li><span class="math">\(t=0\)</span>: <span class="math">\(u_t=I(x)\)</span></li>
</ul>
</div></blockquote>
<p>The program combines Dirichlet and Neumann conditions, scalar and vectorized
implementation of schemes, and the index notation into one piece of code.
A lot of test examples are also included in the program:</p>
<blockquote class="last">
<div><ul class="simple">
<li>A rectangular plug-shaped initial condition. (For <span class="math">\(C=1\)</span> the solution
will be a rectangle that jumps one cell per time step, making the case
well suited for verification.)</li>
<li>A Gaussian function as initial condition.</li>
<li>A triangular profile as initial condition, which resembles the
typical initial shape of a guitar string.</li>
<li>A sinusoidal variation of <span class="math">\(u\)</span> at <span class="math">\(x=0\)</span> and either <span class="math">\(u=0\)</span> or
<span class="math">\(u_x=0\)</span> at <span class="math">\(x=L\)</span>.</li>
<li>An exact analytical solution <span class="math">\(u(x,t)=\cos(m\pi t/L)\sin({\half}m\pi x/L)\)</span>, which can be used for convergence rate tests.</li>
</ul>
</div></blockquote>
</div>
<p>[<strong>hpl 11</strong>: Should include some experiments here or make exercises. Qualitative behavior of the wave equation can be exemplified.]</p>
</div>
<div class="section" id="verifying-the-implementation-of-neumann-conditions">
<span id="wave-pde1-verify"></span><h3>Verifying the implementation of Neumann conditions<a class="headerlink" href="#verifying-the-implementation-of-neumann-conditions" title="Permalink to this headline">¶</a></h3>
<p>How can we test that the Neumann conditions are correctly implemented?
The <code class="docutils literal"><span class="pre">solver</span></code> function in the <code class="docutils literal"><span class="pre">wave1D_dn.py</span></code> program described in the
box above accepts Dirichlet and Neumann conditions at <span class="math">\(x=0\)</span> and <span class="math">\(x=L\)</span>.
It is tempting to apply a quadratic solution as described in
the sections <a class="reference internal" href="#wave-pde2-fd"><span class="std std-ref">A slightly generalized model problem</span></a> and <a class="reference internal" href="#wave-pde1-impl-verify-quadratic"><span class="std std-ref">Verification: exact quadratic solution</span></a>,
but it turns out that this solution is no longer an exact solution
of the discrete equations if a Neumann condition is implemented on
the boundary. A linear solution does not help since we only have
homogeneous Neumann conditions in <code class="docutils literal"><span class="pre">wave1D_dn.py</span></code>, and we are
consequently left with testing just a constant solution: <span class="math">\(u=\hbox{const}\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_constant</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check the scalar and vectorized versions work for</span>
<span class="sd">    a constant u(x,t). We simulate in [0, L] and apply</span>
<span class="sd">    Neumann and Dirichlet conditions at both ends.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u_const</span> <span class="o">=</span> <span class="mf">0.45</span>
    <span class="n">u_exact</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">u_const</span>
    <span class="n">I</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">assert_no_error</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;diff=</span><span class="si">%E</span><span class="s">, t_</span><span class="si">%d</span><span class="s">=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-13</span>
        <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">msg</span>

    <span class="k">for</span> <span class="n">U_0</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">u_const</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">U_L</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">u_const</span><span class="p">):</span>
            <span class="n">L</span> <span class="o">=</span> <span class="mf">2.5</span>
            <span class="n">c</span> <span class="o">=</span> <span class="mf">1.5</span>
            <span class="n">C</span> <span class="o">=</span> <span class="mf">0.75</span>
            <span class="n">Nx</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c"># Very coarse mesh for this exact test</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">/</span><span class="n">Nx</span><span class="p">)</span><span class="o">/</span><span class="n">c</span>
            <span class="n">T</span> <span class="o">=</span> <span class="mi">18</span>  <span class="c"># long time integration</span>

            <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">U_0</span><span class="p">,</span> <span class="n">U_L</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
                   <span class="n">user_action</span><span class="o">=</span><span class="n">assert_no_error</span><span class="p">,</span>
                   <span class="n">version</span><span class="o">=</span><span class="s">&#39;scalar&#39;</span><span class="p">)</span>
            <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">U_0</span><span class="p">,</span> <span class="n">U_L</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
                   <span class="n">user_action</span><span class="o">=</span><span class="n">assert_no_error</span><span class="p">,</span>
                   <span class="n">version</span><span class="o">=</span><span class="s">&#39;vectorized&#39;</span><span class="p">)</span>
            <span class="k">print</span> <span class="n">U_0</span><span class="p">,</span> <span class="n">U_L</span>
</pre></div>
</div>
<p>The quadratic solution is very useful for testing though, but it requires
Dirichlet conditions at both ends.</p>
<p>Another test may utilize the fact that the approximation error vanishes
when the Courant number is unity. We can, for example, start with a
plug profile as initial condition, let this wave split into two plug waves,
one in each direction, and check that the two plug waves come back and
form the initial condition again after &#8220;one period&#8221; of the solution
process. Neumann conditions can be applied at both ends. A proper
test function reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_plug</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check that an initial plug is correct back after one period.&quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">L</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span><span class="o">/</span><span class="n">c</span>  <span class="c"># Nx=10</span>
    <span class="n">I</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">L</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.1</span> <span class="k">else</span> <span class="mi">1</span>

    <span class="n">u_s</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span>
        <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span>
        <span class="n">V</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">U_0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">U_L</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span>
        <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&#39;scalar&#39;</span><span class="p">)</span>
    <span class="n">u_v</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span>
        <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span>
        <span class="n">V</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">U_0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">U_L</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span>
        <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&#39;vectorized&#39;</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-13</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_s</span> <span class="o">-</span> <span class="n">u_v</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>
    <span class="n">u_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">I</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="k">for</span> <span class="n">x_</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_s</span> <span class="o">-</span> <span class="n">u_0</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>Other tests must rely on an unknown approximation error, so effectively
we are left with tests on the convergence rate.</p>
</div>
<div class="section" id="alternative-implementation-via-ghost-cells">
<span id="wave-pde1-neumann-ghost"></span><h3>Alternative implementation via ghost cells<a class="headerlink" href="#alternative-implementation-via-ghost-cells" title="Permalink to this headline">¶</a></h3>
<div class="section" id="idea">
<h4>Idea<a class="headerlink" href="#idea" title="Permalink to this headline">¶</a></h4>
<p>Instead of modifying the scheme at the boundary, we can introduce
extra points outside the domain such that the fictitious values
<span class="math">\(u_{-1}^n\)</span> and <span class="math">\(u_{N_x+1}^n\)</span>
are defined in the mesh.
Adding the intervals <span class="math">\([-\Delta x,0]\)</span> and <span class="math">\([L, L+\Delta x]\)</span>,
often referred to as <em>ghost cells</em>, to the mesh gives us all the
needed mesh points, corresponding to <span class="math">\(i=-1,0,\ldots,N_x,N_x+1\)</span>.
The extra points <span class="math">\(i=-1\)</span> and <span class="math">\(i=N_x+1\)</span> are known as <em>ghost points</em>,
and values at these points, <span class="math">\(u_{-1}^n\)</span> and <span class="math">\(u_{N_x+1}^n\)</span>, are
called <em>ghost values</em>.</p>
<p>The important idea is
to ensure that we always have</p>
<div class="math">
\[u_{-1}^n = u_{1}^n\hbox{ and } u_{N_x+1}^n = u_{N_x-1}^n,\]</div>
<p>because then
the application of the standard scheme at a boundary point <span class="math">\(i=0\)</span> or <span class="math">\(i=N_x\)</span>
will be correct and guarantee that the solution is compatible with the
boundary condition <span class="math">\(u_x=0\)</span>.</p>
</div>
<div class="section" id="implementation-5">
<h4>Implementation<a class="headerlink" href="#implementation-5" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">u</span></code> array now needs extra elements corresponding to the ghost
points. Two new point values are needed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span>   <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>The arrays <code class="docutils literal"><span class="pre">u_1</span></code> and <code class="docutils literal"><span class="pre">u_2</span></code> must be defined accordingly.</p>
<p>Unfortunately, a major indexing problem arises with ghost cells.
The reason is that Python indices <em>must</em> start
at 0 and <code class="docutils literal"><span class="pre">u[-1]</span></code> will always mean the last element in <code class="docutils literal"><span class="pre">u</span></code>.
This fact gives, apparently, a mismatch between the mathematical
indices <span class="math">\(i=-1,0,\ldots,N_x+1\)</span> and the Python indices running over
<code class="docutils literal"><span class="pre">u</span></code>: <code class="docutils literal"><span class="pre">0,..,Nx+2</span></code>. One remedy is to change the mathematical indexing
of <span class="math">\(i\)</span> in the scheme and write</p>
<div class="math">
\[u^{n+1}_i = \cdots,\quad i=1,\ldots,N_x+1,\]</div>
<p>instead of <span class="math">\(i=0,\ldots,N_x\)</span> as we have previously used. The ghost
points now correspond to <span class="math">\(i=0\)</span> and <span class="math">\(i=N_x+1\)</span>.
A better solution is to use the ideas of the section <a class="reference internal" href="#wave-indexset"><span class="std std-ref">Index set notation</span></a>:
we hide the specific index value in an index set and operate with
inner and boundary points using the index set notation.</p>
<p>To this end, we define <code class="docutils literal"><span class="pre">u</span></code> with proper length and <code class="docutils literal"><span class="pre">Ix</span></code> to be the corresponding
indices for the real physical mesh points (<span class="math">\(1,2,\ldots,N_x+1\)</span>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Ix</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>That is, the boundary points have indices <code class="docutils literal"><span class="pre">Ix[0]</span></code> and <code class="docutils literal"><span class="pre">Ix[-1]</span></code> (as before).
We first update the solution at all physical mesh points (i.e., interior
points in the mesh):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
           <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The indexing becomes a bit more complicated when we call functions like
<code class="docutils literal"><span class="pre">V(x)</span></code> and <code class="docutils literal"><span class="pre">f(x,</span> <span class="pre">t)</span></code>, as we must remember that the appropriate
<span class="math">\(x\)</span> coordinate is given as <code class="docutils literal"><span class="pre">x[i-Ix[0]]</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">+</span> \
           <span class="mf">0.5</span><span class="o">*</span><span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
           <span class="mf">0.5</span><span class="o">*</span><span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>It remains to update the solution at ghost points, i.e, <code class="docutils literal"><span class="pre">u[0]</span></code>
and <code class="docutils literal"><span class="pre">u[-1]</span></code> (or <code class="docutils literal"><span class="pre">u[Nx+2]</span></code>). For a boundary condition <span class="math">\(u_x=0\)</span>,
the ghost value must equal the value at the associated inner mesh
point. Computer code makes this statement precise:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>          <span class="c"># x=0 boundary</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>         <span class="c"># x=L boundary</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>The physical solution to be plotted is now in <code class="docutils literal"><span class="pre">u[1:-1]</span></code>, or
equivalently <code class="docutils literal"><span class="pre">u[Ix[0]:Ix[-1]+1]</span></code>, so this slice is
the quantity to be returned from a solver function.
A complete implementation appears in the program
<a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_n0_ghost.py">wave1D_n0_ghost.py</a>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>We have to be careful with how the spatial and temporal mesh
points are stored. Say we let <code class="docutils literal"><span class="pre">x</span></code> be the physical mesh points,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>&#8220;Standard coding&#8221; of the initial condition,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>becomes wrong, since <code class="docutils literal"><span class="pre">u_1</span></code> and <code class="docutils literal"><span class="pre">x</span></code> have different lengths and the index <code class="docutils literal"><span class="pre">i</span></code>
corresponds to two different mesh points. In fact, <code class="docutils literal"><span class="pre">x[i]</span></code> corresponds
to <code class="docutils literal"><span class="pre">u[1+i]</span></code>. A correct implementation is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
</pre></div>
</div>
<p>Similarly, a source term usually coded as <code class="docutils literal"><span class="pre">f(x[i],</span> <span class="pre">t[n])</span></code> is incorrect
if <code class="docutils literal"><span class="pre">x</span></code> is defined to be the physical points, so <code class="docutils literal"><span class="pre">x[i]</span></code> must be
replaced by <code class="docutils literal"><span class="pre">x[i-Ix[0]]</span></code>.</p>
<p class="last">An alternative remedy is to let <code class="docutils literal"><span class="pre">x</span></code> also cover the ghost points such that
<code class="docutils literal"><span class="pre">u[i]</span></code> is the value at <code class="docutils literal"><span class="pre">x[i]</span></code>.</p>
</div>
<p>The ghost cell is only added to the boundary where we have a Neumann
condition. Suppose we have a Dirichlet condition at <span class="math">\(x=L\)</span> and
a homogeneous Neumann condition at <span class="math">\(x=0\)</span>. One ghost cell <span class="math">\([-\Delta x,0]\)</span>
is added to the mesh, so the index set for the physical points
becomes <span class="math">\(\{1,\ldots,N_x+1\}\)</span>. A relevant implementation
is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Ix</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="o">...</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
           <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
           <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_0</span>       <span class="c"># set Dirichlet value</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># update ghost value</span>
</pre></div>
</div>
<p>The physical solution to be plotted is now in <code class="docutils literal"><span class="pre">u[1:]</span></code>
or (as always) <code class="docutils literal"><span class="pre">u[Ix[0]:Ix[-1]+1]</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="generalization-variable-wave-velocity">
<span id="wave-pde2-var-c"></span><h2>Generalization: variable wave velocity<a class="headerlink" href="#generalization-variable-wave-velocity" title="Permalink to this headline">¶</a></h2>
<p>Our next generalization of the 1D wave equation <a class="reference internal" href="#eq-wave-pde1"><span class="std std-ref">(81)</span></a> or
<a class="reference internal" href="#eq-wave-pde2"><span class="std std-ref">(97)</span></a> is to allow for a variable wave velocity <span class="math">\(c\)</span>:
<span class="math">\(c=c(x)\)</span>, usually motivated by wave motion in a domain composed of
different physical media. When the media differ in physical properties
like density or porosity, the wave velocity <span class="math">\(c\)</span> is affected and
will depend on the position in space.
Figure <a class="reference internal" href="#wave-pde1-fig-pulse1-two-media"><span class="std std-ref">Left: wave entering another medium; right: transmitted and reflected wave</span></a> shows a wave
propagating in one medium <span class="math">\([0, 0.7]\cup [0.9,1]\)</span> with wave
velocity <span class="math">\(c_1\)</span> (left) before it enters a second medium <span class="math">\((0.7,0.9)\)</span>
with wave velocity <span class="math">\(c_2\)</span> (right). When the wave passes the boundary
where <span class="math">\(c\)</span> jumps from <span class="math">\(c_1\)</span> to <span class="math">\(c_2\)</span>, a part of the wave is reflected back
into the first medium (the <em>reflected</em> wave), while one part is
transmitted through the second medium (the <em>transmitted</em> wave).</p>
<div class="figure" id="id6">
<span id="wave-pde1-fig-pulse1-two-media"></span><a class="reference internal image-reference" href="_images/pulse1_in_two_media.png"><img alt="_images/pulse1_in_two_media.png" src="_images/pulse1_in_two_media.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Left: wave entering another medium; right: transmitted and reflected wave</em></span></p>
</div>
<div class="section" id="the-model-pde-with-a-variable-coefficient">
<h3>The model PDE with a variable coefficient<a class="headerlink" href="#the-model-pde-with-a-variable-coefficient" title="Permalink to this headline">¶</a></h3>
<p>Instead of working with the squared quantity <span class="math">\(c^2(x)\)</span>, we
shall for notational convenience introduce <span class="math">\(q(x) = c^2(x)\)</span>.
A 1D wave equation with variable wave velocity often takes the form</p>
<div class="math" id="eq-wave-pde2-var-c-pde">
\[\tag{122}
\frac{\partial^2 u}{\partial t^2} =
    \frac{\partial}{\partial x}\left( q(x)
    \frac{\partial u}{\partial x}\right) + f(x,t)\]\[    \tp\]</div>
<p>This is the most frequent form of a wave
equation with variable wave velocity,
but other forms also appear, see the section <a class="reference internal" href="._book006.html#wave-app-string"><span class="std std-ref">Waves on a string</span></a>
and equation <a class="reference internal" href="._book006.html#eq-wave-app-string-model2"><span class="std std-ref">(205)</span></a>.</p>
<p>As usual, we sample <a class="reference internal" href="#eq-wave-pde2-var-c-pde"><span class="std std-ref">(122)</span></a> at a mesh point,</p>
<div class="math">
\[\frac{\partial^2 }{\partial t^2} u(x_i,t_n) =
\frac{\partial}{\partial x}\left( q(x_i)
\frac{\partial}{\partial x} u(x_i,t_n)\right) + f(x_i,t_n),\]</div>
<p>where the only new term to discretize is</p>
<div class="math">
\[\frac{\partial}{\partial x}\left( q(x_i)
\frac{\partial}{\partial x} u(x_i,t_n)\right) = \left[
\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right)\right]^n_i
\tp\]</div>
</div>
<div class="section" id="discretizing-the-variable-coefficient">
<span id="wave-pde2-var-c-ideas"></span><h3>Discretizing the variable coefficient<a class="headerlink" href="#discretizing-the-variable-coefficient" title="Permalink to this headline">¶</a></h3>
<p>The principal idea is to first discretize the outer derivative.
Define</p>
<div class="math">
\[\phi = q(x)
\frac{\partial u}{\partial x},\]</div>
<p>and use a centered derivative around <span class="math">\(x=x_i\)</span> for the derivative of <span class="math">\(\phi\)</span>:</p>
<div class="math">
\[\left[\frac{\partial\phi}{\partial x}\right]^n_i
\approx \frac{\phi_{i+\half} - \phi_{i-\half}}{\Delta x}
= [D_x\phi]^n_i
\tp\]</div>
<p>Then discretize</p>
<div class="math">
\[\phi_{i+\half}  = q_{i+\half}
\left[\frac{\partial u}{\partial x}\right]^n_{i+\half}
\approx q_{i+\half} \frac{u^n_{i+1} - u^n_{i}}{\Delta x}
= [q D_x u]_{i+\half}^n
\tp\]</div>
<p>Similarly,</p>
<div class="math">
\[\phi_{i-\half}  = q_{i-\half}
\left[\frac{\partial u}{\partial x}\right]^n_{i-\half}
\approx q_{i-\half} \frac{u^n_{i} - u^n_{i-1}}{\Delta x}
= [q D_x u]_{i-\half}^n
\tp\]</div>
<p>These intermediate results are now combined to</p>
<div class="math" id="eq-wave-pde2-var-c-formula">
\[\tag{123}
\left[
    \frac{\partial}{\partial x}\left( q(x)
    \frac{\partial u}{\partial x}\right)\right]^n_i
    \approx \frac{1}{\Delta x^2}
    \left( q_{i+\half} \left({u^n_{i+1} - u^n_{i}}\right)
    - q_{i-\half} \left({u^n_{i} - u^n_{i-1}}\right)\right)\]\[    \tp\]</div>
<p>With operator notation we can write the discretization as</p>
<div class="math" id="eq-wave-pde2-var-c-formula-op">
\[\tag{124}
\left[
    \frac{\partial}{\partial x}\left( q(x)
    \frac{\partial u}{\partial x}\right)\right]^n_i
    \approx [D_xq D_x u]^n_i\]\[    \tp\]</div>
<div class="admonition-do-not-use-the-chain-rule-on-the-spatial-derivative-term admonition">
<p class="first admonition-title">Do not use the chain rule on the spatial derivative term</p>
<p>Many are tempted to use the chain rule on the
term <span class="math">\(\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right)\)</span>, but this is not a good idea
when discretizing such a term.</p>
<p>The term with a variable coefficient expresses the net flux
<span class="math">\(qu_x\)</span> into a small volume (i.e., interval in 1D):</p>
<div class="math">
\[\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right) \approx
\frac{1}{\Delta x}(q(x+\Delta x)u_x(x+\Delta x) - q(x)u_x(x))\tp\]</div>
<p>Our discretization reflects this
principle directly: <span class="math">\(qu_x\)</span> at the right end of the cell minus <span class="math">\(qu_x\)</span>
at the left end, because this follows from the formula
<a class="reference internal" href="#eq-wave-pde2-var-c-formula"><span class="std std-ref">(123)</span></a> or <span class="math">\([D_x(q D_x u)]^n_i\)</span>.</p>
<p class="last">When using the chain rule, we get two
terms <span class="math">\(qu_{xx} + q_xu_x\)</span>. The typical discretization is</p>
</div>
<div class="math" id="eq-wave-pde2-var-c-chainrule-scheme">
\[ \tag{125}
 qD_xD_x u + D_{2x}q D_{2x} u]_i^n,\]\[\begin{split}Writing this out shows that it is different from
 \( [D_x(q D_x u)]^n_i \)  and lacks the physical interpretation of
net flux into a cell. With a smooth and slowly varying  \( q(x) \)  the
differences between the two discretizations are not substantial.
However, when  \( q \)  exhibits (potentially large) jumps,
 \( [D_x(q D_x u)]^n_i \)  with harmonic averaging of  \( q \)  yields
a better solution than arithmetic averaging or
:ref:`(125) &lt;Eq:wave:pde2:var:c:chainrule_scheme&gt;`.
In the literature, the discretization  \( [D_x(q D_x u)]^n_i \)  totally
dominant and very few mention the possibility of
:ref:`(125) &lt;Eq:wave:pde2:var:c:chainrule_scheme&gt;`.\end{split}\]</div>
</div>
<div class="section" id="computing-the-coefficient-between-mesh-points">
<span id="wave-pde2-var-c-means"></span><h3>Computing the coefficient between mesh points<a class="headerlink" href="#computing-the-coefficient-between-mesh-points" title="Permalink to this headline">¶</a></h3>
<p>If <span class="math">\(q\)</span> is a known function of <span class="math">\(x\)</span>, we can easily evaluate
<span class="math">\(q_{i+\half}\)</span> simply as <span class="math">\(q(x_{i+\half})\)</span> with
<span class="math">\(x_{i+\half} = x_i + \half\Delta x\)</span>.
However, in many cases <span class="math">\(c\)</span>, and hence <span class="math">\(q\)</span>,
is only known as a discrete function, often at the mesh points <span class="math">\(x_i\)</span>.
Evaluating <span class="math">\(q\)</span> between two mesh points <span class="math">\(x_i\)</span> and <span class="math">\(x_{i+1}\)</span> can then
be done by averaging in three ways:</p>
<span class="target" id="index-29"></span><span class="target" id="index-30"></span><span class="target" id="index-31"></span><span class="target" id="index-32"></span><span class="target" id="index-33"></span><div class="math" id="eq-wave-pde2-var-c-mean-arithmetic">
<span id="index-34"></span>\[\tag{126}
q_{i+\half} \approx
    \half\left( q_{i} + q_{i+1}\right) =
    [\overline{q}^{x}]_i
    \quad \hbox{(arithmetic mean)}\]</div>
<div class="math" id="eq-wave-pde2-var-c-mean-harmonic">
\[\tag{127}
q_{i+\half} \approx
    2\left( \frac{1}{q_{i}} + \frac{1}{q_{i+1}}\right)^{-1}
    \quad \hbox{(harmonic mean)}\]</div>
<div class="math" id="eq-wave-pde2-var-c-mean-geometric">
\[\tag{128}
q_{i+\half} \approx
    \left(q_{i}q_{i+1}\right)^{1/2}
    \quad \hbox{(geometric mean)}\]</div>
<p>The arithmetic mean in <a class="reference internal" href="#eq-wave-pde2-var-c-mean-arithmetic"><span class="std std-ref">(126)</span></a> is by
far the most commonly used averaging technique and is well suited
for smooth <span class="math">\(q(x)\)</span> functions.
The harmonic mean is often preferred when <span class="math">\(q(x)\)</span> exhibits large
jumps (which is typical for geological media).
The geometric mean is less used, but popular in
discretizations to linearize quadratic
nonlinearities (see the section <a class="reference internal" href="._book002.html#vib-ode2-fdm-fquad"><span class="std std-ref">A centered scheme for quadratic damping</span></a> for an example).</p>
<p>With the operator notation from <a class="reference internal" href="#eq-wave-pde2-var-c-mean-arithmetic"><span class="std std-ref">(126)</span></a>
we can specify the discretization of the complete variable-coefficient
wave equation in a compact way:</p>
<div class="math" id="eq-wave-pde2-var-c-scheme-op">
\[\tag{129}
\lbrack D_tD_t u = D_x\overline{q}^{x}D_x u + f\rbrack^{n}_i
    \tp\]</div>
<p>From this notation we immediately see what kind of differences that
each term is approximated with. The notation <span class="math">\(\overline{q}^{x}\)</span>
also specifies that the variable coefficient is approximated by
an arithmetic mean, the definition being
<span class="math">\([\overline{q}^{x}]_{i+\half}=(q_i+q_{i+1})/2\)</span>.
With the notation <span class="math">\([D_xq D_x u]^n_i\)</span>,
we specify that <span class="math">\(q\)</span> is evaluated directly, as a function,
between the mesh points:
<span class="math">\(q(x_{i-\half})\)</span> and <span class="math">\(q(x_{i+\half})\)</span>.</p>
<p>Before any implementation, it remains to solve
<a class="reference internal" href="#eq-wave-pde2-var-c-scheme-op"><span class="std std-ref">(129)</span></a> with respect to <span class="math">\(u_i^{n+1}\)</span>:</p>
<div class="math">
\[u^{n+1}_i = - u_i^{n-1}  + 2u_i^n + \nonumber\]</div>
<div class="math">
\[\quad \left(\frac{\Delta t}{\Delta x}\right)^2 \left(
\half(q_{i} + q_{i+1})(u_{i+1}^n - u_{i}^n) -
\half(q_{i} + q_{i-1})(u_{i}^n - u_{i-1}^n)\right)
+ \nonumber\]</div>
<div class="math" id="eq-wave-pde2-var-c-scheme-impl">
\[\tag{130}
\quad \Delta t^2 f^n_i
    \tp\]</div>
</div>
<div class="section" id="how-a-variable-coefficient-affects-the-stability">
<span id="wave-pde2-var-c-stability"></span><h3>How a variable coefficient affects the stability<a class="headerlink" href="#how-a-variable-coefficient-affects-the-stability" title="Permalink to this headline">¶</a></h3>
<p>The stability criterion derived in the section <a class="reference internal" href="._book004.html#wave-pde1-stability"><span class="std std-ref">Stability</span></a>
reads <span class="math">\(\Delta t\leq \Delta x/c\)</span>. If <span class="math">\(c=c(x)\)</span>, the criterion will depend
on the spatial location. We must therefore choose a <span class="math">\(\Delta t\)</span> that
is small enough such that no mesh cell has <span class="math">\(\Delta x/c(x) &gt;\Delta t\)</span>.
That is, we must use the largest <span class="math">\(c\)</span> value in the criterion:</p>
<div class="math" id="eq-auto42">
\[\tag{131}
\Delta t \leq \beta \frac{\Delta x}{\max_{x\in [0,L]}c(x)}
    \tp\]</div>
<p>The parameter <span class="math">\(\beta\)</span> is included as a safety factor: in some problems with a
significantly varying <span class="math">\(c\)</span> it turns out that one must choose <span class="math">\(\beta &lt;1\)</span> to
have stable solutions (<span class="math">\(\beta =0.9\)</span> may act as an all-round value).</p>
<p>A different strategy to handle the stability criterion with variable
wave velocity is to use a spatially varying <span class="math">\(\Delta t\)</span>. While the idea
is mathematically attractive at first sight, the implementation quickly
becomes very complicated, so we stick to using a constant <span class="math">\(\Delta t\)</span>
and a worst case value of <span class="math">\(c(x)\)</span> (with a safety factor <span class="math">\(\beta\)</span>).</p>
</div>
<div class="section" id="neumann-condition-and-a-variable-coefficient">
<span id="wave-pde2-var-c-neumann"></span><h3>Neumann condition and a variable coefficient<a class="headerlink" href="#neumann-condition-and-a-variable-coefficient" title="Permalink to this headline">¶</a></h3>
<p>Consider a Neumann condition <span class="math">\(\partial u/\partial x=0\)</span> at <span class="math">\(x=L=N_x\Delta x\)</span>,
discretized as</p>
<div class="math">
\[[D_{2x} u]^n_i =
\frac{u_{i+1}^{n} - u_{i-1}^n}{2\Delta x} = 0\quad u_{i+1}^n = u_{i-1}^n,\]</div>
<p>for <span class="math">\(i=N_x\)</span>. Using the scheme <a class="reference internal" href="#eq-wave-pde2-var-c-scheme-impl"><span class="std std-ref">(130)</span></a>
at the end point <span class="math">\(i=N_x\)</span> with <span class="math">\(u_{i+1}^n=u_{i-1}^n\)</span> results in</p>
<div class="math">
\[u^{n+1}_i = - u_i^{n-1}  + 2u_i^n + \nonumber\]</div>
<div class="math" id="eq-wave-pde2-var-c-scheme-impl-neumann0">
\[\tag{132}
\quad \left(\frac{\Delta t}{\Delta x}\right)^2 \left(
    q_{i+\half}(u_{i-1}^n - u_{i}^n) -
    q_{i-\half}(u_{i}^n - u_{i-1}^n)\right)
    + \Delta t^2 f^n_i\]</div>
<div class="math" id="eq-auto43">
\[\tag{133}
= - u_i^{n-1}  + 2u_i^n + \left(\frac{\Delta t}{\Delta x}\right)^2
    (q_{i+\half} + q_{i-\half})(u_{i-1}^n - u_{i}^n) +
    \Delta t^2 f^n_i\]</div>
<div class="math" id="eq-wave-pde2-var-c-scheme-impl-neumann">
\[\tag{134}
\approx - u_i^{n-1}  + 2u_i^n + \left(\frac{\Delta t}{\Delta x}\right)^2
    2q_{i}(u_{i-1}^n - u_{i}^n) + \Delta t^2 f^n_i
    \tp\]</div>
<p>Here we used the approximation</p>
<div class="math">
\[q_{i+\half} + q_{i-\half} =
q_i + \left(\frac{dq}{dx}\right)_i \Delta x
+ \left(\frac{d^2q}{dx^2}\right)_i \Delta x^2 + \cdots
+\nonumber\]</div>
<div class="math">
\[\quad q_i - \left(\frac{dq}{dx}\right)_i \Delta x
+ \left(\frac{d^2q}{dx^2}\right)_i \Delta x^2 + \cdots\nonumber\]</div>
<div class="math">
\[= 2q_i + 2\left(\frac{d^2q}{dx^2}\right)_i \Delta x^2 + {\cal O}(\Delta x^4)
\nonumber\]</div>
<div class="math" id="eq-auto44">
\[\tag{135}
\approx 2q_i
    \tp\]</div>
<p>An alternative derivation may apply the arithmetic mean of <span class="math">\(q\)</span> in
<a class="reference internal" href="#eq-wave-pde2-var-c-scheme-impl-neumann0"><span class="std std-ref">(132)</span></a>, leading to the term</p>
<div class="math">
\[(q_i + \half(q_{i+1}+q_{i-1}))(u_{i-1}^n-u_i^n)\tp\]</div>
<p>Since <span class="math">\(\half(q_{i+1}+q_{i-1}) = q_i + {\cal O}(\Delta x^2)\)</span>,
we can approximate with <span class="math">\(2q_i(u_{i-1}^n-u_i^n)\)</span> for <span class="math">\(i=N_x\)</span> and
get the same term as we did above.</p>
<p>A common technique when implementing <span class="math">\(\partial u/\partial x=0\)</span>
boundary conditions, is to assume <span class="math">\(dq/dx=0\)</span> as well. This implies
<span class="math">\(q_{i+1}=q_{i-1}\)</span> and <span class="math">\(q_{i+1/2}=q_{i-1/2}\)</span> for <span class="math">\(i=N_x\)</span>.
The implications for the scheme are</p>
<div class="math">
\[u^{n+1}_i = - u_i^{n-1}  + 2u_i^n + \nonumber\]</div>
<div class="math">
\[\quad \left(\frac{\Delta t}{\Delta x}\right)^2 \left(
q_{i+\half}(u_{i-1}^n - u_{i}^n) -
q_{i-\half}(u_{i}^n - u_{i-1}^n)\right)
+ \nonumber\]</div>
<div class="math" id="eq-auto45">
\[\tag{136}
\quad \Delta t^2 f^n_i\]</div>
<div class="math" id="eq-wave-pde2-var-c-scheme-impl-neumann2">
\[\tag{137}
= - u_i^{n-1}  + 2u_i^n + \left(\frac{\Delta t}{\Delta x}\right)^2
    2q_{i-\half}(u_{i-1}^n - u_{i}^n) +
    \Delta t^2 f^n_i
    \tp\]</div>
</div>
<div class="section" id="implementation-of-variable-coefficients">
<span id="wave-pde2-var-c-impl"></span><h3>Implementation of variable coefficients<a class="headerlink" href="#implementation-of-variable-coefficients" title="Permalink to this headline">¶</a></h3>
<p>The implementation of the scheme with a variable wave velocity <span class="math">\(q(x)=c^2(x)\)</span>
may assume that <span class="math">\(q\)</span> is available as an array <code class="docutils literal"><span class="pre">q[i]</span></code> at
the spatial mesh points. The following loop is a straightforward
implementation of the scheme <a class="reference internal" href="#eq-wave-pde2-var-c-scheme-impl"><span class="std std-ref">(130)</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
           <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="o">-</span> \
               <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> \
           <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>The coefficient <code class="docutils literal"><span class="pre">C2</span></code> is now defined as <code class="docutils literal"><span class="pre">(dt/dx)**2</span></code>, i.e., <em>not</em> as the
squared Courant number, since the wave velocity is variable and appears
inside the parenthesis.</p>
<p>With Neumann conditions <span class="math">\(u_x=0\)</span> at the
boundary, we need to combine this scheme with the discrete
version of the boundary condition, as shown in the section <a class="reference internal" href="#wave-pde2-var-c-neumann"><span class="std std-ref">Neumann condition and a variable coefficient</span></a>.
Nevertheless, it would be convenient to reuse the formula for the
interior points and just modify the indices <code class="docutils literal"><span class="pre">ip1=i+1</span></code> and <code class="docutils literal"><span class="pre">im1=i-1</span></code>
as we did in the section <a class="reference internal" href="#wave-pde2-neumann-impl"><span class="std std-ref">Implementation of Neumann conditions</span></a>. Assuming
<span class="math">\(dq/dx=0\)</span> at the boundaries, we can implement the scheme at
the boundary with the following code.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">ip1</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
<span class="n">im1</span> <span class="o">=</span> <span class="n">ip1</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
       <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="n">ip1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">ip1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="o">-</span> \
           <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="n">im1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">im1</span><span class="p">]))</span> <span class="o">+</span> \
       <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>With ghost cells we can just reuse the formula for the interior
points also at the boundary, provided that the ghost values of both
<span class="math">\(u\)</span> and <span class="math">\(q\)</span> are correctly updated to ensure <span class="math">\(u_x=0\)</span> and <span class="math">\(q_x=0\)</span>.</p>
<p>A vectorized version of the scheme with a variable coefficient
at internal mesh points becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
          <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span>
              <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span> <span class="o">+</span> \
          <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="a-more-general-pde-model-with-variable-coefficients">
<h3>A more general PDE model with variable coefficients<a class="headerlink" href="#a-more-general-pde-model-with-variable-coefficients" title="Permalink to this headline">¶</a></h3>
<p>Sometimes a wave PDE has a variable coefficient in front of
the time-derivative term:</p>
<div class="math" id="eq-wave-pde2-var-c-pde2">
\[\tag{138}
\varrho(x)\frac{\partial^2 u}{\partial t^2} =
    \frac{\partial}{\partial x}\left( q(x)
    \frac{\partial u}{\partial x}\right) + f(x,t)\]\[    \tp\]</div>
<p>One example appears when modeling elastic waves in a rod
with varying density, cf.&nbsp;(<a class="reference internal" href="._book006.html#wave-app-string"><span class="std std-ref">Waves on a string</span></a>) with <span class="math">\(\varrho (x)\)</span>.</p>
<p>A natural scheme for <a class="reference internal" href="#eq-wave-pde2-var-c-pde2"><span class="std std-ref">(138)</span></a> is</p>
<div class="math" id="eq-auto46">
\[\tag{139}
[\varrho D_tD_t u = D_x\overline{q}^xD_x u + f]^n_i
    \tp\]</div>
<p>We realize that the <span class="math">\(\varrho\)</span> coefficient poses no particular
difficulty, since <span class="math">\(\varrho\)</span> enters the formula just a simple factor
in front of a derivative. There is hence no need for any averaging
of <span class="math">\(\varrho\)</span>. Often, <span class="math">\(\varrho\)</span> will be moved to the right-hand side,
also without any difficulty:</p>
<div class="math" id="eq-auto47">
\[\tag{140}
[D_tD_t u = \varrho^{-1}D_x\overline{q}^xD_x u + f]^n_i
    \tp\]</div>
</div>
<div class="section" id="generalization-damping">
<h3>Generalization: damping<a class="headerlink" href="#generalization-damping" title="Permalink to this headline">¶</a></h3>
<p>Waves die out by two mechanisms. In 2D and 3D the energy of the wave
spreads out in space, and energy conservation then requires
the amplitude to decrease. This effect is not present in 1D.
Damping is another cause of amplitude reduction. For example,
the vibrations of a string die out because of damping due to
air resistance and non-elastic effects in the string.</p>
<p>The simplest way of including damping is to add a first-order derivative
to the equation (in the same way as friction forces enter a vibrating
mechanical system):</p>
<div class="math" id="eq-wave-pde3">
\[\tag{141}
\frac{\partial^2 u}{\partial t^2} + b\frac{\partial u}{\partial t} =
    c^2\frac{\partial^2 u}{\partial x^2}
     + f(x,t),\]</div>
<p>where <span class="math">\(b \geq 0\)</span> is a prescribed damping coefficient.</p>
<p>A typical discretization of <a class="reference internal" href="#eq-wave-pde3"><span class="std std-ref">(141)</span></a> in terms of centered
differences reads</p>
<div class="math" id="eq-wave-pde3-fd">
\[\tag{142}
[D_tD_t u + bD_{2t}u = c^2D_xD_x u + f]^n_i
    \tp\]</div>
<p>Writing out the equation and solving for the unknown <span class="math">\(u^{n+1}_i\)</span>
gives the scheme</p>
<div class="math" id="eq-wave-pde3-fd2">
\[\tag{143}
u^{n+1}_i = (1 + {\half}b\Delta t)^{-1}(({\half}b\Delta t -1)
    u^{n-1}_i + 2u^n_i + C^2
    \left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right) + \Delta t^2 f^n_i),\]</div>
<p>for <span class="math">\(i\in\seti{\Ix}\)</span> and <span class="math">\(n\geq 1\)</span>.
New equations must be derived for <span class="math">\(u^1_i\)</span>, and for boundary points in case
of Neumann conditions.</p>
<p>The damping is very small in many wave phenomena and thus only evident
for very long time simulations. This makes the standard wave equation
without damping relevant for a lot of applications.</p>
</div>
</div>
<div class="section" id="building-a-general-1d-wave-equation-solver">
<span id="wave-pde2-software"></span><h2>Building a general 1D wave equation solver<a class="headerlink" href="#building-a-general-1d-wave-equation-solver" title="Permalink to this headline">¶</a></h2>
<p>The program <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_dn_vc.py">wave1D_dn_vc.py</a>
is a fairly general code for 1D wave propagation problems that
targets the following initial-boundary value problem</p>
<div class="math" id="eq-wave-pde2-software-ueq">
\[\tag{144}
u_{tt} = (c^2(x)u_x)_x + f(x,t),\quad x\in (0,L),\ t\in (0,T]\]</div>
<div class="math" id="eq-auto48">
\[\tag{145}
u(x,0) = I(x),\quad x\in [0,L]\]</div>
<div class="math" id="eq-auto49">
\[\tag{146}
u_t(x,0) = V(t),\quad x\in [0,L]\]</div>
<div class="math" id="eq-auto50">
\[\tag{147}
u(0,t) = U_0(t)\hbox{ or } u_x(0,t)=0,\quad t\in (0,T]\]</div>
<div class="math" id="eq-wave-pde2-software-bcl">
\[\tag{148}
u(L,t) = U_L(t)\hbox{ or } u_x(L,t)=0,\quad t\in (0,T]\]</div>
<p>The only new feature here is the time-dependent Dirichlet conditions.
These are trivial to implement:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># x=0</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_0</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

<span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c"># x=L</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_L</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">solver</span></code> function is a natural extension of the simplest
<code class="docutils literal"><span class="pre">solver</span></code> function in the initial <code class="docutils literal"><span class="pre">wave1D_u0.py</span></code> program,
extended with Neumann boundary conditions (<span class="math">\(u_x=0\)</span>),
a the time-varying Dirichlet conditions, as well as
a variable wave velocity. The different code segments needed
to make these extensions have been shown and commented upon in the
preceding text. We refer to the <code class="docutils literal"><span class="pre">solver</span></code> function in the
<code class="docutils literal"><span class="pre">wave1D_dn_vc.py</span></code> file for all the details.</p>
<p>The vectorization is only applied inside the time loop, not for the
initial condition or the first time steps, since this initial work
is negligible for long time simulations in 1D problems.</p>
<p>The following sections explain various more advanced programming
techniques applied in the general 1D wave equation solver.</p>
<div class="section" id="user-action-function-as-a-class">
<h3>User action function as a class<a class="headerlink" href="#user-action-function-as-a-class" title="Permalink to this headline">¶</a></h3>
<p>A useful feature in the <code class="docutils literal"><span class="pre">wave1D_dn_vc.py</span></code> program is the specification of
the <code class="docutils literal"><span class="pre">user_action</span></code> function as a class. This part of the program may
need some motivation and explanation. Although the <code class="docutils literal"><span class="pre">plot_u_st</span></code>
function (and the <code class="docutils literal"><span class="pre">PlotMatplotlib</span></code> class)
in the <code class="docutils literal"><span class="pre">wave1D_u0.viz</span></code> function
remembers the local variables in the <code class="docutils literal"><span class="pre">viz</span></code> function, it is a
cleaner solution to store the needed variables together with
the function, which is exactly what a class offers.</p>
<div class="section" id="the-code">
<h4>The code<a class="headerlink" href="#the-code" title="Permalink to this headline">¶</a></h4>
<p>A class for flexible plotting, cleaning up files, making movie
files, like the function <code class="docutils literal"><span class="pre">wave1D_u0.viz</span></code> did, can be coded as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">PlotAndStoreSolution</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for the user_action function in solver.</span>
<span class="sd">    Visualizes the solution only.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">casename</span><span class="o">=</span><span class="s">&#39;tmp&#39;</span><span class="p">,</span>    <span class="c"># Prefix in filenames</span>
        <span class="n">umin</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">umax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>   <span class="c"># Fixed range of y axis</span>
        <span class="n">pause_between_frames</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>  <span class="c"># Movie speed</span>
        <span class="n">backend</span><span class="o">=</span><span class="s">&#39;matplotlib&#39;</span><span class="p">,</span>       <span class="c"># or &#39;gnuplot&#39; or None</span>
        <span class="n">screen_movie</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="c"># Show movie on screen?</span>
        <span class="n">title</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span>          <span class="c"># Extra message in title</span>
        <span class="n">skip_frame</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>      <span class="c"># Skip every skip_frame frame</span>
        <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>    <span class="c"># Name of file with solutions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">casename</span> <span class="o">=</span> <span class="n">casename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span> <span class="o">=</span> <span class="p">[</span><span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pause</span> <span class="o">=</span> <span class="n">pause_between_frames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">=</span> <span class="n">backend</span>
        <span class="k">if</span> <span class="n">backend</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Use native matplotlib</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="k">elif</span> <span class="n">backend</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;matplotlib&#39;</span><span class="p">,</span> <span class="s">&#39;gnuplot&#39;</span><span class="p">):</span>
            <span class="n">module</span> <span class="o">=</span> <span class="s">&#39;scitools.easyviz.&#39;</span> <span class="o">+</span> <span class="n">backend</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span>
            <span class="k">exec</span><span class="p">(</span><span class="s">&#39;import </span><span class="si">%s</span><span class="s"> as plt&#39;</span> <span class="o">%</span> <span class="n">module</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plt</span> <span class="o">=</span> <span class="n">plt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">screen_movie</span> <span class="o">=</span> <span class="n">screen_movie</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">title</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_frame</span> <span class="o">=</span> <span class="n">skip_frame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Store time points when u is written to file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">filenames</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s">&#39;.&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;*.dat.npz&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="c"># Clean up old movie frames</span>
        <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s">&#39;frame_*.png&#39;</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Callback function user_action, call by solver:</span>
<span class="sd">        Store solution, plot on screen and save to file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Save solution u to a file using numpy.savez</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;u</span><span class="si">%04d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">n</span>  <span class="c"># array name</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">u</span><span class="p">}</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="s">&#39;.&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&#39;.dat&#39;</span>
            <span class="n">savez</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>  <span class="c"># store corresponding time value</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>           <span class="c"># save x once</span>
                <span class="n">savez</span><span class="p">(</span><span class="s">&#39;.&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;_x.dat&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>

        <span class="c"># Animate</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_frame</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s">&#39;t=</span><span class="si">%.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span> <span class="o">+</span> <span class="s">&#39; &#39;</span> <span class="o">+</span> <span class="n">title</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># native matplotlib animation</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;t=</span><span class="si">%.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Update new solution</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;t=</span><span class="si">%.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># scitools.easyviz animation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">,</span>
                          <span class="n">xlabel</span><span class="o">=</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">,</span>
                          <span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                          <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                          <span class="n">show</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">screen_movie</span><span class="p">)</span>
        <span class="c"># pause</span>
        <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c"># let initial condition stay 2 s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pause</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">pause</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">pause</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;frame_</span><span class="si">%04d</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="dissection">
<h4>Dissection<a class="headerlink" href="#dissection" title="Permalink to this headline">¶</a></h4>
<p>Understanding this class requires quite some familiarity with Python
in general and class programming in particular.
The class supports plotting with Matplotlib (<code class="docutils literal"><span class="pre">backend=None</span></code>) or
SciTools (<code class="docutils literal"><span class="pre">backend=matplotlib</span></code> or <code class="docutils literal"><span class="pre">backend=gnuplot</span></code>) for maximum
flexibility.</p>
<p>The constructor shows how we can flexibly import the plotting engine
as (typically) <code class="docutils literal"><span class="pre">scitools.easyviz.gnuplot_</span></code> or
<code class="docutils literal"><span class="pre">scitools.easyviz.matplotlib_</span></code> (note the trailing underscore - it is required).
With the <code class="docutils literal"><span class="pre">screen_movie</span></code> parameter
we can suppress displaying each movie frame on the screen.
Alternatively, for slow movies associated with
fine meshes, one can set
<code class="docutils literal"><span class="pre">skip_frame=10</span></code>, causing every 10 frames to be shown.</p>
<p>The <code class="docutils literal"><span class="pre">__call__</span></code> method makes <code class="docutils literal"><span class="pre">PlotAndStoreSolution</span></code> instances behave like
functions, so we can just pass an instance, say <code class="docutils literal"><span class="pre">p</span></code>, as the
<code class="docutils literal"><span class="pre">user_action</span></code> argument in the <code class="docutils literal"><span class="pre">solver</span></code> function, and any call to
<code class="docutils literal"><span class="pre">user_action</span></code> will be a call to <code class="docutils literal"><span class="pre">p.__call__</span></code>. The <code class="docutils literal"><span class="pre">__call__</span></code>
method plots the solution on the screen,
saves the plot to file, and stores the solution in a file for
later retrieval.</p>
<p>More details on storing the solution in files appear in
the section <a class="reference internal" href="._book016.html#softeng2-wave1d-filestorage-hashlib"><span class="std std-ref">Making hash strings from input data</span></a>.</p>
</div>
</div>
<div class="section" id="pulse-propagation-in-two-media">
<h3>Pulse propagation in two media<a class="headerlink" href="#pulse-propagation-in-two-media" title="Permalink to this headline">¶</a></h3>
<p>The function <code class="docutils literal"><span class="pre">pulse</span></code> in <code class="docutils literal"><span class="pre">wave1D_dn_vc.py</span></code> demonstrates wave motion in
heterogeneous media where <span class="math">\(c\)</span> varies. One can specify an interval
where the wave velocity is decreased by a factor <code class="docutils literal"><span class="pre">slowness_factor</span></code>
(or increased by making this factor less than one).
Figure <a class="reference internal" href="#wave-pde1-fig-pulse1-two-media"><span class="std std-ref">Left: wave entering another medium; right: transmitted and reflected wave</span></a> shows a typical simulation
scenario.</p>
<p>Four types of initial conditions are available:</p>
<ol class="arabic simple">
<li>a rectangular pulse (<code class="docutils literal"><span class="pre">plug</span></code>),</li>
<li>a Gaussian function (<code class="docutils literal"><span class="pre">gaussian</span></code>),</li>
<li>a &#8220;cosine hat&#8221; consisting of one period of the cosine function
(<code class="docutils literal"><span class="pre">cosinehat</span></code>),</li>
<li>half a period of a &#8220;cosine hat&#8221; (<code class="docutils literal"><span class="pre">half-cosinehat</span></code>)</li>
</ol>
<p>These peak-shaped initial
conditions can be placed in the middle (<code class="docutils literal"><span class="pre">loc='center'</span></code>) or at
the left end (<code class="docutils literal"><span class="pre">loc='left'</span></code>) of the domain.
With the pulse in the middle, it splits in two parts, each with half the
initial amplitude, traveling in opposite directions. With the pulse
at the left end, centered at <span class="math">\(x=0\)</span>, and using the
symmetry condition <span class="math">\(\partial u/\partial x=0\)</span>, only a right-going pulse
is generated. There is also a left-going pulse, but it travels from <span class="math">\(x=0\)</span>
in negative <span class="math">\(x\)</span> direction and is not visible in the domain <span class="math">\([0,L]\)</span>.</p>
<p>The <code class="docutils literal"><span class="pre">pulse</span></code>
function is a flexible tool for playing around with various wave
shapes and location of a medium with a different wave velocity.</p>
<p>The code is shown to demonstrate how easy it is to reach this
flexibility with the building blocks we have already developed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">pulse</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>            <span class="c"># aximum Courant number</span>
          <span class="n">Nx</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>         <span class="c"># spatial resolution</span>
          <span class="n">animate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
          <span class="n">version</span><span class="o">=</span><span class="s">&#39;vectorized&#39;</span><span class="p">,</span>
          <span class="n">T</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>            <span class="c"># end time</span>
          <span class="n">loc</span><span class="o">=</span><span class="s">&#39;left&#39;</span><span class="p">,</span>     <span class="c"># location of initial condition</span>
          <span class="n">pulse_tp</span><span class="o">=</span><span class="s">&#39;gaussian&#39;</span><span class="p">,</span>  <span class="c"># pulse/init.cond. type</span>
          <span class="n">slowness_factor</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="c"># wave vel. in right medium</span>
          <span class="n">medium</span><span class="o">=</span><span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">],</span> <span class="c"># interval for right medium</span>
          <span class="n">skip_frame</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>      <span class="c"># skip frames in animations</span>
          <span class="n">sigma</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>        <span class="c"># width measure of the pulse</span>
          <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Various peaked-shaped initial conditions on [0,1].</span>
<span class="sd">    Wave velocity is decreased by the slowness_factor inside</span>
<span class="sd">    medium. The loc parameter can be &#39;center&#39; or &#39;left&#39;,</span>
<span class="sd">    depending on where the initial pulse is to be located.</span>
<span class="sd">    The sigma parameter governs the width of the pulse.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Use scaled parameters: L=1 for domain length, c_0=1</span>
    <span class="c"># for wave velocity outside the domain.</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">c_0</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">loc</span> <span class="o">==</span> <span class="s">&#39;center&#39;</span><span class="p">:</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="n">L</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">elif</span> <span class="n">loc</span> <span class="o">==</span> <span class="s">&#39;left&#39;</span><span class="p">:</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">pulse_tp</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;gaussian&#39;</span><span class="p">,</span><span class="s">&#39;Gaussian&#39;</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">xc</span><span class="p">)</span><span class="o">/</span><span class="n">sigma</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">pulse_tp</span> <span class="o">==</span> <span class="s">&#39;plug&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">xc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sigma</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">pulse_tp</span> <span class="o">==</span> <span class="s">&#39;cosinehat&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="c"># One period of a cosine</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">sigma</span>
            <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">xc</span><span class="p">)</span><span class="o">/</span><span class="n">a</span><span class="p">))</span> \
                   <span class="k">if</span> <span class="n">xc</span> <span class="o">-</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">xc</span> <span class="o">+</span> <span class="n">a</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="k">elif</span> <span class="n">pulse_tp</span> <span class="o">==</span> <span class="s">&#39;half-cosinehat&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="c"># Half a period of a cosine</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">sigma</span>
            <span class="k">return</span> <span class="n">cos</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">xc</span><span class="p">)</span><span class="o">/</span><span class="n">a</span><span class="p">)</span> \
                   <span class="k">if</span> <span class="n">xc</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">xc</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">a</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Wrong pulse_tp=&quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="n">pulse_tp</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">c</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">c_0</span><span class="o">/</span><span class="n">slowness_factor</span> \
               <span class="k">if</span> <span class="n">medium</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">medium</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="n">c_0</span>

    <span class="n">umin</span><span class="o">=-</span><span class="mf">0.5</span><span class="p">;</span> <span class="n">umax</span><span class="o">=</span><span class="mf">1.5</span><span class="o">*</span><span class="n">I</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span>
    <span class="n">casename</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">_Nx</span><span class="si">%s</span><span class="s">_sf</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> \
               <span class="p">(</span><span class="n">pulse_tp</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">slowness_factor</span><span class="p">)</span>
    <span class="n">action</span> <span class="o">=</span> <span class="n">PlotMediumAndSolution</span><span class="p">(</span>
        <span class="n">medium</span><span class="p">,</span> <span class="n">casename</span><span class="o">=</span><span class="n">casename</span><span class="p">,</span> <span class="n">umin</span><span class="o">=</span><span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="o">=</span><span class="n">umax</span><span class="p">,</span>
        <span class="n">skip_frame</span><span class="o">=</span><span class="n">skip_frame</span><span class="p">,</span> <span class="n">screen_movie</span><span class="o">=</span><span class="n">animate</span><span class="p">,</span>
        <span class="n">backend</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&#39;tmpdata&#39;</span><span class="p">)</span>

    <span class="c"># Choose the stability limit with given Nx, worst case c</span>
    <span class="c"># (lower C will then use this dt, but smaller Nx)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">L</span><span class="o">/</span><span class="n">Nx</span><span class="p">)</span><span class="o">/</span><span class="n">c_0</span>
    <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">U_0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">U_L</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
           <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span>
           <span class="n">user_action</span><span class="o">=</span><span class="n">action</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="n">version</span><span class="p">,</span>
           <span class="n">stability_safety_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">action</span><span class="o">.</span><span class="n">make_movie_file</span><span class="p">()</span>
    <span class="n">action</span><span class="o">.</span><span class="n">file_close</span><span class="p">()</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">PlotMediumAndSolution</span></code> class used here is a subclass of
<code class="docutils literal"><span class="pre">PlotAndStoreSolution</span></code> where the medium with reduced <span class="math">\(c\)</span> value,
as specified by the <code class="docutils literal"><span class="pre">medium</span></code> interval,
is visualized in the plots.</p>
<div class="admonition-comment-on-the-choices-of-discretization-parameters admonition">
<p class="first admonition-title">Comment on the choices of discretization parameters</p>
<p class="last">The argument <span class="math">\(N_x\)</span> in the <code class="docutils literal"><span class="pre">pulse</span></code> function does not correspond to
the actual spatial resolution of <span class="math">\(C&lt;1\)</span>, since the <code class="docutils literal"><span class="pre">solver</span></code>
function takes a fixed <span class="math">\(\Delta t\)</span> and <span class="math">\(C\)</span>, and adjusts <span class="math">\(\Delta x\)</span>
accordingly. As seen in the <code class="docutils literal"><span class="pre">pulse</span></code> function,
the specified <span class="math">\(\Delta t\)</span> is chosen according to the
limit <span class="math">\(C=1\)</span>, so if <span class="math">\(C&lt;1\)</span>, <span class="math">\(\Delta t\)</span> remains the same, but the
<code class="docutils literal"><span class="pre">solver</span></code> function operates with a larger <span class="math">\(\Delta x\)</span> and smaller
<span class="math">\(N_x\)</span> than was specified in the call to <code class="docutils literal"><span class="pre">pulse</span></code>. The practical reason
is that we always want to keep <span class="math">\(\Delta t\)</span> fixed such that
plot frames and movies are synchronized in time regardless of the
value of <span class="math">\(C\)</span> (i.e., <span class="math">\(\Delta x\)</span> is varies when the
Courant number varies).</p>
</div>
<p>The reader is encouraged to play around with the <code class="docutils literal"><span class="pre">pulse</span></code> function:</p>
<div class="highlight-ipy"><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">wave1D_dn_vc</span> <span class="kn">as</span> <span class="nn">w</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span><span class="o">.</span><span class="n">pulse</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s">&#39;left&#39;</span><span class="p">,</span> <span class="n">pulse_tp</span><span class="o">=</span><span class="s">&#39;cosinehat&#39;</span><span class="p">,</span> <span class="n">Nx</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">every_frame</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>To easily kill the graphics by Ctrl-C and restart a new simulation it might be
easier to run the above two statements from the command line
with</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python -c &#39;import wave1D_dn_vc as w; w.pulse(...)&#39;
</pre></div>
</div>
</div>
</div>
<div class="section" id="exercises-2">
<h2>Exercises<a class="headerlink" href="#exercises-2" title="Permalink to this headline">¶</a></h2>
<div class="section" id="exercise-23-find-the-analytical-solution-to-a-damped-wave-equation">
<span id="wave-exer-standingwave-damped-uex"></span><h3>Exercise 23: Find the analytical solution to a damped wave equation<a class="headerlink" href="#exercise-23-find-the-analytical-solution-to-a-damped-wave-equation" title="Permalink to this headline">¶</a></h3>
<p>Consider the wave equation with damping <a class="reference internal" href="#eq-wave-pde3"><span class="std std-ref">(141)</span></a>.
The goal is to find an exact solution to a wave problem with damping.
A starting point is the standing wave solution from
<a class="reference internal" href="#wave-exer-standingwave"><span class="std std-ref">Exercise 18: Simulate a standing wave</span></a>. It becomes necessary to
include a damping term <span class="math">\(e^{-ct}\)</span> and also have both a sine and cosine
component in time:</p>
<div class="math">
\[\uex(x,t) =  e^{-\beta t}
\sin kx \left( A\cos\omega t
+ B\sin\omega t\right)
\tp\]</div>
<p>Find <span class="math">\(k\)</span> from the boundary conditions
<span class="math">\(u(0,t)=u(L,t)=0\)</span>. Then use the PDE to find constraints on
<span class="math">\(\beta\)</span>, <span class="math">\(\omega\)</span>, <span class="math">\(A\)</span>, and <span class="math">\(B\)</span>.
Set up a complete initial-boundary value problem
and its solution.
Filename: <code class="docutils literal"><span class="pre">damped_waves</span></code>.</p>
</div>
<div class="section" id="problem-24-explore-symmetry-boundary-conditions">
<span id="wave-exer-symmetry-bc"></span><h3>Problem 24: Explore symmetry boundary conditions<a class="headerlink" href="#problem-24-explore-symmetry-boundary-conditions" title="Permalink to this headline">¶</a></h3>
<p>Consider the simple &#8220;plug&#8221; wave where <span class="math">\(\Omega = [-L,L]\)</span> and</p>
<div class="math">
\[\begin{split}I(x) = \left\lbrace\begin{array}{ll}
1, &amp; x\in [-\delta, \delta],\\
0, &amp; \hbox{otherwise}
\end{array}\right.\end{split}\]</div>
<p>for some number <span class="math">\(0 &lt; \delta &lt; L\)</span>. The other initial condition is
<span class="math">\(u_t(x,0)=0\)</span> and there is no source term <span class="math">\(f\)</span>.
The boundary conditions can be set to <span class="math">\(u=0\)</span>.
The solution to this problem is symmetric around <span class="math">\(x=0\)</span>.
This means that we can simulate the wave process in only the half
of the domain <span class="math">\([0,L]\)</span>.</p>
<p><strong>a)</strong>
Argue why the symmetry boundary condition
is <span class="math">\(u_x=0\)</span> at <span class="math">\(x=0\)</span>.</p>
<p><strong>Hint.</strong>
Symmetry of a function about <span class="math">\(x=x_0\)</span> means that
<span class="math">\(f(x_0+h) = f(x_0-h)\)</span>.</p>
<p><strong>b)</strong>
Perform simulations of the complete wave problem from
on <span class="math">\([-L,L]\)</span>. Thereafter, utilize the
symmetry of the solution and run a simulation
in half of the domain <span class="math">\([0,L]\)</span>, using a boundary condition
at <span class="math">\(x=0\)</span>. Compare the two solutions and
make sure that they are the same.</p>
<p><strong>c)</strong>
Prove the symmetry property of the solution
by setting up the complete initial-boundary value problem
and showing that if <span class="math">\(u(x,t)\)</span> is a solution, then also <span class="math">\(u(-x,t)\)</span>
is a solution.</p>
<p>Filename: <code class="docutils literal"><span class="pre">wave1D_symmetric</span></code>.</p>
</div>
<div class="section" id="exercise-25-send-pulse-waves-through-a-layered-medium">
<span id="wave-app-exer-pulse1d"></span><h3>Exercise 25: Send pulse waves through a layered medium<a class="headerlink" href="#exercise-25-send-pulse-waves-through-a-layered-medium" title="Permalink to this headline">¶</a></h3>
<p>Use the <code class="docutils literal"><span class="pre">pulse</span></code> function in <code class="docutils literal"><span class="pre">wave1D_dn_vc.py</span></code> to investigate
sending a pulse, located with its peak at <span class="math">\(x=0\)</span>, through two
media with different wave velocities. The (scaled) velocity in
the left medium is 1 while it is <span class="math">\(s_f\)</span> in the right medium.
Report what happens with a Gaussian pulse, a &#8220;cosine hat&#8221; pulse,
half a &#8220;cosine hat&#8221; pulse, and a plug pulse for resolutions
<span class="math">\(N_x=40,80,160\)</span>, and <span class="math">\(s_f=2,4\)</span>. Simulate until <span class="math">\(T=2\)</span>.
Filename: <code class="docutils literal"><span class="pre">pulse1D</span></code>.</p>
</div>
<div class="section" id="exercise-26-explain-why-numerical-noise-occurs">
<span id="wave-app-exer-pulse1d-analysis"></span><h3>Exercise 26: Explain why numerical noise occurs<a class="headerlink" href="#exercise-26-explain-why-numerical-noise-occurs" title="Permalink to this headline">¶</a></h3>
<p>The experiments performed in <a class="reference internal" href="#wave-app-exer-pulse1d"><span class="std std-ref">Exercise 25: Send pulse waves through a layered medium</span></a> shows
considerable numerical noise in the form of non-physical waves,
especially for <span class="math">\(s_f=4\)</span> and the plug pulse or the half a &#8220;cosinehat&#8221;
pulse. The noise is much less visible for a Gaussian pulse. Run the
case with the plug and half a &#8220;cosinehat&#8221; pulses for <span class="math">\(s_f=1\)</span>, <span class="math">\(C=0.9,
0.25\)</span>, and <span class="math">\(N_x=40,80,160\)</span>. Use the numerical dispersion relation to
explain the observations.
Filename: <code class="docutils literal"><span class="pre">pulse1D_analysis</span></code>.</p>
</div>
<div class="section" id="exercise-27-investigate-harmonic-averaging-in-a-1d-model">
<span id="wave-app-exer-pulse1d-harmonic"></span><h3>Exercise 27: Investigate harmonic averaging in a 1D model<a class="headerlink" href="#exercise-27-investigate-harmonic-averaging-in-a-1d-model" title="Permalink to this headline">¶</a></h3>
<p>Harmonic means are often used if the wave velocity is non-smooth or
discontinuous.  Will harmonic averaging of the wave velocity give less
numerical noise for the case <span class="math">\(s_f=4\)</span> in <a class="reference internal" href="#wave-app-exer-pulse1d"><span class="std std-ref">Exercise 25: Send pulse waves through a layered medium</span></a>?
Filename: <code class="docutils literal"><span class="pre">pulse1D_harmonic</span></code>.</p>
</div>
<div class="section" id="problem-28-implement-open-boundary-conditions">
<span id="wave-app-exer-radiationbc"></span><h3>Problem 28: Implement open boundary conditions<a class="headerlink" href="#problem-28-implement-open-boundary-conditions" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-35"></span><span class="target" id="index-36"></span><p id="index-37">To enable a wave to leave the computational domain and travel
undisturbed through
the boundary <span class="math">\(x=L\)</span>, one can in a one-dimensional problem impose the
following condition, called a <em>radiation condition</em> or
<em>open boundary condition</em>:</p>
<div class="math" id="eq-wave-app-exer-radiationbc-eq">
\[\tag{149}
\frac{\partial u}{\partial t} + c\frac{\partial u}{\partial x} = 0\tp\]</div>
<p>The parameter <span class="math">\(c\)</span> is the wave velocity.</p>
<p>Show that <a class="reference internal" href="#eq-wave-app-exer-radiationbc-eq"><span class="std std-ref">(149)</span></a> accepts
a solution <span class="math">\(u = g_R(x-ct)\)</span> (right-going wave),
but not <span class="math">\(u = g_L(x+ct)\)</span> (left-going wave). This means
that <a class="reference internal" href="#eq-wave-app-exer-radiationbc-eq"><span class="std std-ref">(149)</span></a> will allow any
right-going wave <span class="math">\(g_R(x-ct)\)</span> to pass through the boundary undisturbed.</p>
<p>A corresponding open boundary condition for a left-going wave
through <span class="math">\(x=0\)</span> is</p>
<div class="math" id="eq-wave-app-exer-radiationbc-eql">
\[\tag{150}
\frac{\partial u}{\partial t} - c\frac{\partial u}{\partial x} = 0\tp\]</div>
<p><strong>a)</strong>
A natural idea for discretizing
the condition <a class="reference internal" href="#eq-wave-app-exer-radiationbc-eq"><span class="std std-ref">(149)</span></a>
at the spatial end point <span class="math">\(i=N_x\)</span> is to apply
centered differences in time and space:</p>
<div class="math" id="eq-wave-app-exer-radiationbc-eq-op">
\[\tag{151}
[D_{2t}u + cD_{2x}u =0]^n_{i},\quad i=N_x\tp\]</div>
<p>Eliminate the fictitious value <span class="math">\(u_{N_x+1}^n\)</span> by using
the discrete equation at the same point.</p>
<p>The equation for the first step, <span class="math">\(u_i^1\)</span>, is in principle also affected,
but we can then use the condition <span class="math">\(u_{N_x}=0\)</span> since the wave
has not yet reached the right boundary.</p>
<p><strong>b)</strong>
A much more convenient implementation of the open boundary condition
at <span class="math">\(x=L\)</span> can be based on an explicit discretization</p>
<div class="math" id="eq-wave-app-exer-radiationbc-eq-op-1storder">
\[\tag{152}
[D^+_tu + cD_x^- u = 0]_i^n,\quad i=N_x\tp\]</div>
<p>From this equation, one can solve for <span class="math">\(u^{n+1}_{N_x}\)</span> and apply the
formula as a Dirichlet condition at the boundary point.
However, the finite difference approximations involved are of
first order.</p>
<p>Implement this scheme for a wave equation
<span class="math">\(u_{tt}=c^2u_{xx}\)</span> in a domain <span class="math">\([0,L]\)</span>,
where you have <span class="math">\(u_x=0\)</span> at <span class="math">\(x=0\)</span>, the condition <a class="reference internal" href="#eq-wave-app-exer-radiationbc-eq"><span class="std std-ref">(149)</span></a>
at <span class="math">\(x=L\)</span>, and an initial disturbance in the middle
of the domain, e.g., a plug profile like</p>
<div class="math">
\[\begin{split}u(x,0) = \left\lbrace\begin{array}{ll} 1,&amp; L/2-\ell \leq x \leq  L/2+\ell,\\
0,\hbox{otherwise}\end{array}\right.\end{split}\]</div>
<p>Observe that the initial wave is split in two, the left-going wave
is reflected at <span class="math">\(x=0\)</span>, and both waves travel out of <span class="math">\(x=L\)</span>,
leaving the solution as <span class="math">\(u=0\)</span> in <span class="math">\([0,L]\)</span>. Use a unit Courant number
such that the numerical solution is exact.
Make a movie to illustrate what happens.</p>
<p>Because this simplified
implementation of the open boundary condition works, there is no
need to pursue the more complicated discretization in a).</p>
<p><strong>Hint.</strong>
Modify the solver function in
<a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_dn.py">wave1D_dn.py</a>.</p>
<p><strong>c)</strong>
Add the possibility to have either <span class="math">\(u_x=0\)</span> or an open boundary
condition at the left boundary. The latter condition is discretized
as</p>
<div class="math" id="eq-wave-app-exer-radiationbc-eq-op-1storder2">
\[\tag{153}
[D^+_tu - cD_x^+ u = 0]_i^n,\quad i=0,\]</div>
<p>leading to an explicit update of the boundary value <span class="math">\(u^{n+1}_0\)</span>.</p>
<p>The implementation can be tested with a Gaussian function as initial condition:</p>
<div class="math">
\[g(x;m,s) = \frac{1}{\sqrt{2\pi}s}e^{-\frac{(x-m)^2}{2s^2}}\tp\]</div>
<p>Run two tests:</p>
<ol class="arabic simple">
<li>Disturbance in the middle of the domain, <span class="math">\(I(x)=g(x;L/2,s)\)</span>, and
open boundary condition at the left end.</li>
<li>Disturbance at the left end, <span class="math">\(I(x)=g(x;0,s)\)</span>, and <span class="math">\(u_x=0\)</span>
as symmetry boundary condition at this end.</li>
</ol>
<p>Make nose tests for both cases, testing that the solution is zero
after the waves have left the domain.</p>
<p><strong>d)</strong>
In 2D and 3D it is difficult to compute the correct wave velocity
normal to the boundary, which is needed in generalizations of
the open boundary conditions in higher dimensions. Test the effect
of having a slightly wrong wave velocity in
<a class="reference internal" href="#eq-wave-app-exer-radiationbc-eq-op-1storder"><span class="std std-ref">(152)</span></a>.
Make a movies to illustrate what happens.</p>
<p>Filename: <code class="docutils literal"><span class="pre">wave1D_open_BC</span></code>.</p>
<div class="section" id="remarks-2">
<h4>Remarks<a class="headerlink" href="#remarks-2" title="Permalink to this headline">¶</a></h4>
<p>The condition <a class="reference internal" href="#eq-wave-app-exer-radiationbc-eq"><span class="std std-ref">(149)</span></a>
works perfectly in 1D when <span class="math">\(c\)</span> is known. In 2D and 3D, however, the
condition reads <span class="math">\(u_t + c_x u_x + c_y u_y=0\)</span>, where <span class="math">\(c_x\)</span> and
<span class="math">\(c_y\)</span> are the wave speeds in the <span class="math">\(x\)</span> and <span class="math">\(y\)</span> directions. Estimating
these components (i.e., the direction of the wave) is often
challenging. Other methods are normally used in 2D and 3D to
let waves move out of a computational domain.</p>
</div>
</div>
<div class="section" id="exercise-29-implement-periodic-boundary-conditions">
<span id="wave-exer-periodic"></span><h3>Exercise 29: Implement periodic boundary conditions<a class="headerlink" href="#exercise-29-implement-periodic-boundary-conditions" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-38"></span><p id="index-39">It is frequently of interest to follow wave motion over large
distances and long times. A straightforward approach is to
work with a very large domain, but might lead to a lot of
computations in areas of the domain where the waves cannot
be noticed. A more efficient approach is to let a right-going
wave out of the domain and at the same time let it enter
the domain on the left. This is called a <em>periodic boundary
condition</em>.</p>
<p>The boundary condition at the right end <span class="math">\(x=L\)</span> is an open boundary
condition (see <a class="reference internal" href="#wave-app-exer-radiationbc"><span class="std std-ref">Problem 28: Implement open boundary conditions</span></a>) to let a
right-going wave out of the domain.  At the left end, <span class="math">\(x=0\)</span>, we apply,
in the beginning of the simulation, either a symmetry boundary
condition (see <a class="reference internal" href="#wave-exer-symmetry-bc"><span class="std std-ref">Problem 24: Explore symmetry boundary conditions</span></a>) <span class="math">\(u_x=0\)</span>, or an
open boundary condition.</p>
<p>This initial wave will split in two and either reflected or
transported out of the domain at <span class="math">\(x=0\)</span>. The purpose of the exercise is
to follow the right-going wave. We can do that with a <em>periodic
boundary condition</em>.  This means that when the right-going wave hits
the boundary <span class="math">\(x=L\)</span>, the open boundary condition lets the wave out of
the domain, but at the same time we use a boundary condition on the
left end <span class="math">\(x=0\)</span> that feeds the outgoing wave into the domain
again. This periodic condition is simply <span class="math">\(u(0)=u(L)\)</span>. The switch from
<span class="math">\(u_x=0\)</span> or an open boundary condition at the left end to a periodic
condition can happen when <span class="math">\(u(L,t)&gt;\epsilon\)</span>, where <span class="math">\(\epsilon =10^{-4}\)</span>
might be an appropriate value for determining when the right-going
wave hits the boundary <span class="math">\(x=L\)</span>.</p>
<p>The open boundary conditions can conveniently be discretized as
explained in <a class="reference internal" href="#wave-app-exer-radiationbc"><span class="std std-ref">Problem 28: Implement open boundary conditions</span></a>.  Implement the
described type of boundary conditions and test them on two different
initial shapes: a plug <span class="math">\(u(x,0)=1\)</span> for <span class="math">\(x\leq 0.1\)</span>, <span class="math">\(u(x,0)=0\)</span> for
<span class="math">\(x&gt;0.1\)</span>, and a Gaussian function in the middle of the domain:
<span class="math">\(u(x,0)=\exp{(-\frac{1}{2}(x-0.5)^2/0.05)}\)</span>. The domain is the unit
interval <span class="math">\([0,1]\)</span>. Run these two shapes for Courant numbers 1 and
0.5. Assume constant wave velocity.  Make movies of the four cases.
Reason why the solutions are correct.
Filename: <code class="docutils literal"><span class="pre">periodic</span></code>.</p>
</div>
<div class="section" id="exercise-30-compare-discretizations-of-a-neumann-condition">
<h3>Exercise 30: Compare discretizations of a Neumann condition<a class="headerlink" href="#exercise-30-compare-discretizations-of-a-neumann-condition" title="Permalink to this headline">¶</a></h3>
<p>We have a 1D wave equation with variable wave velocity:
<span class="math">\(u_{tt}=(qu_x)_x\)</span>.
A Neumann condition <span class="math">\(u_x\)</span> at <span class="math">\(x=0, L\)</span> can be
discretized as shown in <a class="reference internal" href="#eq-wave-pde2-var-c-scheme-impl-neumann"><span class="std std-ref">(134)</span></a>
and <a class="reference internal" href="#eq-wave-pde2-var-c-scheme-impl-neumann2"><span class="std std-ref">(137)</span></a>.</p>
<p>The aim of this exercise is to examine the rate of the numerical
error when using different ways of discretizing the Neumann condition.</p>
<p><strong>a)</strong>
As a test problem, <span class="math">\(q=1+(x-L/2)^4\)</span> can be used, with <span class="math">\(f(x,t)\)</span>
adapted such that the solution has a simple form, say
<span class="math">\(u(x,t)=\cos (\pi x/L)\cos (\omega t)\)</span> for, e.g., <span class="math">\(\omega = 1\)</span>.
Perform numerical experiments and find the convergence rate of the
error using the approximation
<a class="reference internal" href="#eq-wave-pde2-var-c-scheme-impl-neumann"><span class="std std-ref">(134)</span></a>.</p>
<p><strong>b)</strong>
Switch to <span class="math">\(q(x)=1+\cos(\pi x/L)\)</span>, which is symmetric at <span class="math">\(x=0,L\)</span>,
and check the convergence rate
of the scheme
<a class="reference internal" href="#eq-wave-pde2-var-c-scheme-impl-neumann2"><span class="std std-ref">(137)</span></a>. Now,
<span class="math">\(q_{i-1/2}\)</span> is a 2nd-order approximation to <span class="math">\(q_i\)</span>,
<span class="math">\(q_{i-1/2}=q_i + 0.25q_i''\Delta x^2 + \cdots\)</span>, because <span class="math">\(q_i'=0\)</span>
for <span class="math">\(i=N_x\)</span> (a similar argument can be applied to the case <span class="math">\(i=0\)</span>).</p>
<p><strong>c)</strong>
A third discretization can be based on a simple and convenient,
but less accurate, one-sided difference:
<span class="math">\(u_{i}-u_{i-1}=0\)</span> at <span class="math">\(i=N_x\)</span> and <span class="math">\(u_{i+1}-u_i=0\)</span> at <span class="math">\(i=0\)</span>.
Derive the resulting scheme in detail and implement it.
Run experiments with <span class="math">\(q\)</span> from a) or b) to establish the rate of convergence
of the scheme.</p>
<p><strong>d)</strong>
A fourth technique is to view the scheme as</p>
<div class="math">
\[[D_tD_tu]^n_i = \frac{1}{\Delta x}\left(
[qD_xu]_{i+\half}^n - [qD_xu]_{i-\half}^n\right)
+ [f]_i^n,\]</div>
<p>and place the boundary at <span class="math">\(x_{i+\half}\)</span>, <span class="math">\(i=N_x\)</span>, instead of
exactly at the physical boundary. With this idea of approximating (moving) the
boundary,
we can just set <span class="math">\([qD_xu]_{i+\half}^n=0\)</span>.
Derive the complete scheme
using this technique. The implementation of the boundary condition at
<span class="math">\(L-\Delta x/2\)</span> is <span class="math">\(\Oof{\Delta x^2}\)</span> accurate, but the interesting question
is what impact the movement of the boundary has on the convergence
rate. Compute the errors as usual over the entire mesh and use <span class="math">\(q\)</span> from
a) or b).</p>
<p>Filename: <code class="docutils literal"><span class="pre">Neumann_discr</span></code>.</p>
</div>
<div class="section" id="exercise-31-verification-by-a-cubic-polynomial-in-space">
<span id="wave-fd2-exer-verify-cubic"></span><h3>Exercise 31: Verification by a cubic polynomial in space<a class="headerlink" href="#exercise-31-verification-by-a-cubic-polynomial-in-space" title="Permalink to this headline">¶</a></h3>
<p>The purpose of this exercise is to verify the implementation of the
<code class="docutils literal"><span class="pre">solver</span></code> function in the program <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_n0.py">wave1D_n0.py</a> by using an exact numerical solution
for the wave equation <span class="math">\(u_{tt}=c^2u_{xx} + f\)</span> with Neumann boundary
conditions <span class="math">\(u_x(0,t)=u_x(L,t)=0\)</span>.</p>
<p>A similar verification is used in the file <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_u0.py">wave1D_u0.py</a>, which solves the same PDE, but with
Dirichlet boundary conditions <span class="math">\(u(0,t)=u(L,t)=0\)</span>.  The idea of the
verification test in function <code class="docutils literal"><span class="pre">test_quadratic</span></code> in <code class="docutils literal"><span class="pre">wave1D_u0.py</span></code> is to
produce a solution that is a lower-order polynomial such that both the
PDE problem, the boundary conditions, and all the discrete equations
are exactly fulfilled. Then the <code class="docutils literal"><span class="pre">solver</span></code> function should reproduce
this exact solution to machine precision.  More precisely, we seek
<span class="math">\(u=X(x)T(t)\)</span>, with <span class="math">\(T(t)\)</span> as a linear function and <span class="math">\(X(x)\)</span> as a
parabola that fulfills the boundary conditions.  Inserting this <span class="math">\(u\)</span> in
the PDE determines <span class="math">\(f\)</span>.  It turns out that <span class="math">\(u\)</span> also fulfills the
discrete equations, because the truncation error of the discretized
PDE has derivatives in <span class="math">\(x\)</span> and <span class="math">\(t\)</span> of order four and higher. These
derivatives all vanish for a quadratic <span class="math">\(X(x)\)</span> and linear <span class="math">\(T(t)\)</span>.</p>
<p>It would be attractive to use a similar approach in the case of
Neumann conditions. We set <span class="math">\(u=X(x)T(t)\)</span> and seek lower-order
polynomials <span class="math">\(X\)</span> and <span class="math">\(T\)</span>.
To force <span class="math">\(u_x\)</span> to vanish at the boundary, we let <span class="math">\(X_x\)</span> be
a parabola. Then <span class="math">\(X\)</span> is a cubic polynomial. The fourth-order
derivative of a cubic polynomial vanishes, so <span class="math">\(u=X(x)T(t)\)</span>
will fulfill the discretized PDE also in this case, if <span class="math">\(f\)</span>
is adjusted such that <span class="math">\(u\)</span> fulfills the PDE.</p>
<p>However, the discrete boundary condition is not exactly fulfilled
by this choice of <span class="math">\(u\)</span>. The reason is that</p>
<div class="math" id="eq-wave-fd2-exer-verify-cubic-d2x">
\[\tag{154}
[D_{2x}u]^n_i = u_{x}(x_i,t_n) + \frac{1}{6}u_{xxx}(x_i,t_n)\Delta x^2
    + \Oof{\Delta x^4}\tp\]</div>
<p>At the boundary two boundary points, <span class="math">\(X_x(x)=0\)</span> such that <span class="math">\(u_x=0\)</span>.
However, <span class="math">\(u_{xxx}\)</span> is a constant and not zero
when <span class="math">\(X(x)\)</span> is a cubic polynomial.
Therefore, our <span class="math">\(u=X(x)T(t)\)</span> fulfills</p>
<div class="math">
\[[D_{2x}u]^n_i = \frac{1}{6}u_{xxx}(x_i,t_n)\Delta x^2,\]</div>
<p>and not</p>
<div class="math">
\[[D_{2x}u]^n_i =0, \quad i=0,N_x,\]</div>
<p>as it should. (Note that all the higher-order terms <span class="math">\(\Oof{\Delta x^4}\)</span>
also have higher-order derivatives that vanish for a cubic polynomial.)
So to summarize, the fundamental problem is that <span class="math">\(u\)</span> as a product of
a cubic polynomial and a linear or quadratic polynomial in time
is not an exact solution of the discrete boundary conditions.</p>
<p>To make progress,
we assume that <span class="math">\(u=X(x)T(t)\)</span>, where <span class="math">\(T\)</span> for simplicity is taken as a
prescribed linear function <span class="math">\(1+\frac{1}{2}t\)</span>, and <span class="math">\(X(x)\)</span> is taken
as an <em>unknown</em> cubic polynomial <span class="math">\(\sum_{j=0}^3 a_jx^j\)</span>.
There are two different ways of determining the coefficients
<span class="math">\(a_0,\ldots,a_3\)</span> such that both the discretized PDE and the
discretized boundary conditions are fulfilled, under the
constraint that we can specify a function <span class="math">\(f(x,t)\)</span> for the PDE to feed
to the <code class="docutils literal"><span class="pre">solver</span></code> function in <code class="docutils literal"><span class="pre">wave1D_n0.py</span></code>. Both approaches
are explained in the subexercises.</p>
<p><strong>a)</strong>
One can insert <span class="math">\(u\)</span> in the discretized PDE and find the corresponding <span class="math">\(f\)</span>.
Then one can insert <span class="math">\(u\)</span> in the discretized boundary conditions.
This yields two equations for the four coefficients <span class="math">\(a_0,\ldots,a_3\)</span>.
To find the coefficients, one can set <span class="math">\(a_0=0\)</span> and <span class="math">\(a_1=1\)</span> for
simplicity and then determine <span class="math">\(a_2\)</span> and <span class="math">\(a_3\)</span>. This approach will make
<span class="math">\(a_2\)</span> and <span class="math">\(a_3\)</span> depend on <span class="math">\(\Delta x\)</span> and <span class="math">\(f\)</span> will depend on both
<span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span>.</p>
<p>Use <code class="docutils literal"><span class="pre">sympy</span></code> to perform analytical computations.
A starting point is to define <span class="math">\(u\)</span> as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_cubic1</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sm</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x t c L dx dt&#39;</span><span class="p">)</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;i n&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c"># Assume discrete solution is a polynomial of degree 3 in x</span>
    <span class="n">T</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">sm</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">t</span>  <span class="c"># Temporal term</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;a_0 a_1 a_2 a_3&#39;</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">q</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>  <span class="c"># Spatial term</span>
    <span class="n">u</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">X</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">T</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>The symbolic expression for <span class="math">\(u\)</span> is reached by calling <code class="docutils literal"><span class="pre">u(x,t)</span></code>
with <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">t</span></code> as <code class="docutils literal"><span class="pre">sympy</span></code> symbols.</p>
<p>Define <code class="docutils literal"><span class="pre">DxDx(u,</span> <span class="pre">i,</span> <span class="pre">n)</span></code>, <code class="docutils literal"><span class="pre">DtDt(u,</span> <span class="pre">i,</span> <span class="pre">n)</span></code>, and <code class="docutils literal"><span class="pre">D2x(u,</span> <span class="pre">i,</span> <span class="pre">n)</span></code>
as Python functions for returning the difference
approximations <span class="math">\([D_xD_x u]^n_i\)</span>, <span class="math">\([D_tD_t u]^n_i\)</span>, and
<span class="math">\([D_{2x}u]^n_i\)</span>. The next step is to set up the residuals
for the equations <span class="math">\([D_{2x}u]^n_0=0\)</span> and <span class="math">\([D_{2x}u]^n_{N_x}=0\)</span>,
where <span class="math">\(N_x=L/\Delta x\)</span>. Call the residuals <code class="docutils literal"><span class="pre">R_0</span></code> and <code class="docutils literal"><span class="pre">R_L</span></code>.
Substitute <span class="math">\(a_0\)</span> and <span class="math">\(a_1\)</span> by 0 and 1, respectively, in
<code class="docutils literal"><span class="pre">R_0</span></code>, <code class="docutils literal"><span class="pre">R_L</span></code>, and <code class="docutils literal"><span class="pre">a</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">R_0</span> <span class="o">=</span> <span class="n">R_0</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">R_L</span> <span class="o">=</span> <span class="n">R_L</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c"># enable in-place assignment</span>
<span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Determining <span class="math">\(a_2\)</span> and <span class="math">\(a_3\)</span> from the discretized boundary conditions
is then about solving two equations with respect to <span class="math">\(a_2\)</span> and <span class="math">\(a_3\)</span>,
i.e., <code class="docutils literal"><span class="pre">a[2:]</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">s</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">solve</span><span class="p">([</span><span class="n">R_0</span><span class="p">,</span> <span class="n">R_L</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
<span class="c"># s is dictionary with the unknowns a[2] and a[3] as keys</span>
<span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">s</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
</pre></div>
</div>
<p>Now, <code class="docutils literal"><span class="pre">a</span></code> contains computed values and <code class="docutils literal"><span class="pre">u</span></code> will automatically use
these new values since <code class="docutils literal"><span class="pre">X</span></code> accesses <code class="docutils literal"><span class="pre">a</span></code>.</p>
<p>Compute the source term <span class="math">\(f\)</span> from the discretized PDE:
<span class="math">\(f^n_i = [D_tD_t u - c^2D_xD_x u]^n_i\)</span>. Turn <span class="math">\(u\)</span>, the time
derivative <span class="math">\(u_t\)</span> (needed for the initial condition <span class="math">\(V(x)\)</span>),
and <span class="math">\(f\)</span> into Python functions. Set numerical values for
<span class="math">\(L\)</span>, <span class="math">\(N_x\)</span>, <span class="math">\(C\)</span>, and <span class="math">\(c\)</span>. Prescribe the time interval as
<span class="math">\(\Delta t = CL/(N_xc)\)</span>, which imply <span class="math">\(\Delta x = c\Delta t/C = L/N_x\)</span>.
Define new functions <code class="docutils literal"><span class="pre">I(x)</span></code>, <code class="docutils literal"><span class="pre">V(x)</span></code>, and <code class="docutils literal"><span class="pre">f(x,t)</span></code> as wrappers of the ones
made above, where fixed values of <span class="math">\(L\)</span>, <span class="math">\(c\)</span>, <span class="math">\(\Delta x\)</span>, and <span class="math">\(\Delta t\)</span>
are inserted, such that <code class="docutils literal"><span class="pre">I</span></code>, <code class="docutils literal"><span class="pre">V</span></code>, and <code class="docutils literal"><span class="pre">f</span></code> can be passed on to the
<code class="docutils literal"><span class="pre">solver</span></code> function. Finally, call <code class="docutils literal"><span class="pre">solver</span></code> with a <code class="docutils literal"><span class="pre">user_action</span></code>
function that compares the numerical solution to this exact
solution <span class="math">\(u\)</span> of the discrete PDE problem.</p>
<p><strong>Hint.</strong>
To turn a <code class="docutils literal"><span class="pre">sympy</span></code> expression <code class="docutils literal"><span class="pre">e</span></code>, depending on a series of
symbols, say <code class="docutils literal"><span class="pre">x</span></code>, <code class="docutils literal"><span class="pre">t</span></code>, <code class="docutils literal"><span class="pre">dx</span></code>, <code class="docutils literal"><span class="pre">dt</span></code>, <code class="docutils literal"><span class="pre">L</span></code>, and <code class="docutils literal"><span class="pre">c</span></code>, into plain
Python function <code class="docutils literal"><span class="pre">e_exact(x,t,L,dx,dt,c)</span></code>, one can write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">e_exact</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">dx</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">c</span><span class="p">],</span> <span class="n">e</span><span class="p">,</span> <span class="s">&#39;numpy&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">'numpy'</span></code> argument is a good habit as the <code class="docutils literal"><span class="pre">e_exact</span></code> function
will then work with array arguments if it contains mathematical
functions (but here we only do plain arithmetics, which automatically
work with arrays).</p>
<p><strong>b)</strong>
An alternative way of determining <span class="math">\(a_0,\ldots,a_3\)</span> is to reason as
follows. We first construct <span class="math">\(X(x)\)</span> such that the boundary conditions
are fulfilled: <span class="math">\(X=x(L-x)\)</span>. However, to compensate for the fact
that this choice of <span class="math">\(X\)</span> does not fulfill the discrete boundary
condition, we seek <span class="math">\(u\)</span> such that</p>
<div class="math">
\[u_x = \frac{\partial}{\partial x}x(L-x)T(t) - \frac{1}{6}u_{xxx}\Delta x^2,\]</div>
<p>since this <span class="math">\(u\)</span> will fit the discrete boundary condition.
Assuming <span class="math">\(u=T(t)\sum_{j=0}^3a_jx^j\)</span>, we can use the above equation to
determine the coefficients <span class="math">\(a_1,a_2,a_3\)</span>. A value, e.g., 1 can be used for
<span class="math">\(a_0\)</span>. The following <code class="docutils literal"><span class="pre">sumpy</span></code> code computes this <span class="math">\(u\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_cubic2</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sm</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x t c L dx&#39;</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">sm</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">t</span>  <span class="c"># Temporal term</span>
    <span class="c"># Set u as a 3rd-degree polynomial in space</span>
    <span class="n">X</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;a_0 a_1 a_2 a_3&#39;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">X</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">T</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="c"># Force discrete boundary condition to be zero by adding</span>
    <span class="c"># a correction term the analytical suggestion x*(L-x)*T</span>
    <span class="c"># u_x = x*(L-x)*T(t) - 1/6*u_xxx*dx**2</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span>
        <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">sm</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span><span class="o">*</span><span class="n">sm</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c"># R is a polynomial: force all coefficients to vanish.</span>
    <span class="c"># Turn R to Poly to extract coefficients:</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">poly</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">all_coeffs</span><span class="p">()</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>  <span class="c"># a[0] is not present in R</span>
    <span class="c"># s is dictionary with a[i] as keys</span>
    <span class="c"># Fix a[0] as 1</span>
    <span class="n">s</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">X</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">sm</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">X</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">T</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;u:&#39;</span><span class="p">,</span> <span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>The next step is to find the source term <code class="docutils literal"><span class="pre">f_e</span></code> by inserting <code class="docutils literal"><span class="pre">u_e</span></code>
in the PDE. Thereafter, turn <code class="docutils literal"><span class="pre">u</span></code>, <code class="docutils literal"><span class="pre">f</span></code>, and the time derivative of <code class="docutils literal"><span class="pre">u</span></code>
into plain Python functions as in a), and then wrap these functions
in new functions <code class="docutils literal"><span class="pre">I</span></code>, <code class="docutils literal"><span class="pre">V</span></code>, and <code class="docutils literal"><span class="pre">f</span></code>, with the right signature as
required by the <code class="docutils literal"><span class="pre">solver</span></code> function. Set parameters as in a) and
check that the solution is exact to machine precision at each
time level using an appropriate <code class="docutils literal"><span class="pre">user_action</span></code> function.</p>
<p>Filename: <code class="docutils literal"><span class="pre">wave1D_n0_test_cubic</span></code>.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Wave equations</a><ul>
<li><a class="reference internal" href="#simulation-of-waves-on-a-string">Simulation of waves on a string</a><ul>
<li><a class="reference internal" href="#discretizing-the-domain">Discretizing the domain</a><ul>
<li><a class="reference internal" href="#uniform-meshes">Uniform meshes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-discrete-solution">The discrete solution</a></li>
<li><a class="reference internal" href="#fulfilling-the-equation-at-the-mesh-points">Fulfilling the equation at the mesh points</a></li>
<li><a class="reference internal" href="#replacing-derivatives-by-finite-differences">Replacing derivatives by finite differences</a><ul>
<li><a class="reference internal" href="#algebraic-version-of-the-pde">Algebraic version of the PDE</a></li>
<li><a class="reference internal" href="#interpretation-of-the-equation-as-a-stencil">Interpretation of the equation as a stencil</a></li>
<li><a class="reference internal" href="#algebraic-version-of-the-initial-conditions">Algebraic version of the initial conditions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#formulating-a-recursive-algorithm">Formulating a recursive algorithm</a></li>
<li><a class="reference internal" href="#sketch-of-an-implementation">Sketch of an implementation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#verification-3">Verification</a><ul>
<li><a class="reference internal" href="#a-slightly-generalized-model-problem">A slightly generalized model problem</a></li>
<li><a class="reference internal" href="#using-an-analytical-solution-of-physical-significance">Using an analytical solution of physical significance</a></li>
<li><a class="reference internal" href="#manufactured-solution">Manufactured solution</a></li>
<li><a class="reference internal" href="#constructing-an-exact-solution-of-the-discrete-equations">Constructing an exact solution of the discrete equations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-4">Implementation</a><ul>
<li><a class="reference internal" href="#callback-function-for-user-specific-actions">Callback function for user-specific actions</a></li>
<li><a class="reference internal" href="#the-solver-function">The solver function</a></li>
<li><a class="reference internal" href="#verification-exact-quadratic-solution">Verification: exact quadratic solution</a></li>
<li><a class="reference internal" href="#visualization-animating-the-solution">Visualization: animating the solution</a><ul>
<li><a class="reference internal" href="#function-for-administering-the-simulation">Function for administering the simulation</a></li>
<li><a class="reference internal" href="#dissection-of-the-code">Dissection of the code</a></li>
<li><a class="reference internal" href="#making-movie-files">Making movie files</a></li>
<li><a class="reference internal" href="#skipping-frames-for-animation-speed">Skipping frames for animation speed</a></li>
</ul>
</li>
<li><a class="reference internal" href="#running-a-case">Running a case</a></li>
<li><a class="reference internal" href="#working-with-a-scaled-pde-model">Working with a scaled PDE model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vectorization">Vectorization</a><ul>
<li><a class="reference internal" href="#operations-on-slices-of-arrays">Operations on slices of arrays</a></li>
<li><a class="reference internal" href="#finite-difference-schemes-expressed-as-slices">Finite difference schemes expressed as slices</a></li>
<li><a class="reference internal" href="#verification-4">Verification</a></li>
<li><a class="reference internal" href="#efficiency-measurements">Efficiency measurements</a><ul>
<li><a class="reference internal" href="#solution-1">Solution 1</a></li>
<li><a class="reference internal" href="#solution-2">Solution 2</a></li>
<li><a class="reference internal" href="#efficiency-experiments">Efficiency experiments</a></li>
</ul>
</li>
<li><a class="reference internal" href="#remark-on-the-updating-of-arrays">Remark on the updating of arrays</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-1">Exercises</a><ul>
<li><a class="reference internal" href="#exercise-18-simulate-a-standing-wave">Exercise 18: Simulate a standing wave</a><ul>
<li><a class="reference internal" href="#remarks-1">Remarks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercise-19-add-storage-of-solution-in-a-user-action-function">Exercise 19: Add storage of solution in a user action function</a></li>
<li><a class="reference internal" href="#exercise-20-use-a-class-for-the-user-action-function">Exercise 20: Use a class for the user action function</a></li>
<li><a class="reference internal" href="#exercise-21-compare-several-courant-numbers-in-one-movie">Exercise 21: Compare several Courant numbers in one movie</a></li>
<li><a class="reference internal" href="#project-22-calculus-with-1d-mesh-functions">Project 22: Calculus with 1D mesh functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generalization-reflecting-boundaries">Generalization: reflecting boundaries</a><ul>
<li><a class="reference internal" href="#neumann-boundary-condition">Neumann boundary condition</a></li>
<li><a class="reference internal" href="#discretization-of-derivatives-at-the-boundary">Discretization of derivatives at the boundary</a></li>
<li><a class="reference internal" href="#implementation-of-neumann-conditions">Implementation of Neumann conditions</a></li>
<li><a class="reference internal" href="#index-set-notation">Index set notation</a></li>
<li><a class="reference internal" href="#verifying-the-implementation-of-neumann-conditions">Verifying the implementation of Neumann conditions</a></li>
<li><a class="reference internal" href="#alternative-implementation-via-ghost-cells">Alternative implementation via ghost cells</a><ul>
<li><a class="reference internal" href="#idea">Idea</a></li>
<li><a class="reference internal" href="#implementation-5">Implementation</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#generalization-variable-wave-velocity">Generalization: variable wave velocity</a><ul>
<li><a class="reference internal" href="#the-model-pde-with-a-variable-coefficient">The model PDE with a variable coefficient</a></li>
<li><a class="reference internal" href="#discretizing-the-variable-coefficient">Discretizing the variable coefficient</a></li>
<li><a class="reference internal" href="#computing-the-coefficient-between-mesh-points">Computing the coefficient between mesh points</a></li>
<li><a class="reference internal" href="#how-a-variable-coefficient-affects-the-stability">How a variable coefficient affects the stability</a></li>
<li><a class="reference internal" href="#neumann-condition-and-a-variable-coefficient">Neumann condition and a variable coefficient</a></li>
<li><a class="reference internal" href="#implementation-of-variable-coefficients">Implementation of variable coefficients</a></li>
<li><a class="reference internal" href="#a-more-general-pde-model-with-variable-coefficients">A more general PDE model with variable coefficients</a></li>
<li><a class="reference internal" href="#generalization-damping">Generalization: damping</a></li>
</ul>
</li>
<li><a class="reference internal" href="#building-a-general-1d-wave-equation-solver">Building a general 1D wave equation solver</a><ul>
<li><a class="reference internal" href="#user-action-function-as-a-class">User action function as a class</a><ul>
<li><a class="reference internal" href="#the-code">The code</a></li>
<li><a class="reference internal" href="#dissection">Dissection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pulse-propagation-in-two-media">Pulse propagation in two media</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-2">Exercises</a><ul>
<li><a class="reference internal" href="#exercise-23-find-the-analytical-solution-to-a-damped-wave-equation">Exercise 23: Find the analytical solution to a damped wave equation</a></li>
<li><a class="reference internal" href="#problem-24-explore-symmetry-boundary-conditions">Problem 24: Explore symmetry boundary conditions</a></li>
<li><a class="reference internal" href="#exercise-25-send-pulse-waves-through-a-layered-medium">Exercise 25: Send pulse waves through a layered medium</a></li>
<li><a class="reference internal" href="#exercise-26-explain-why-numerical-noise-occurs">Exercise 26: Explain why numerical noise occurs</a></li>
<li><a class="reference internal" href="#exercise-27-investigate-harmonic-averaging-in-a-1d-model">Exercise 27: Investigate harmonic averaging in a 1D model</a></li>
<li><a class="reference internal" href="#problem-28-implement-open-boundary-conditions">Problem 28: Implement open boundary conditions</a><ul>
<li><a class="reference internal" href="#remarks-2">Remarks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercise-29-implement-periodic-boundary-conditions">Exercise 29: Implement periodic boundary conditions</a></li>
<li><a class="reference internal" href="#exercise-30-compare-discretizations-of-a-neumann-condition">Exercise 30: Compare discretizations of a Neumann condition</a></li>
<li><a class="reference internal" href="#exercise-31-verification-by-a-cubic-polynomial-in-space">Exercise 31: Verification by a cubic polynomial in space</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book002.html"
                        title="previous chapter">Vibration ODEs</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book004.html"
                        title="next chapter">Analysis of the difference equations</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book003.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book004.html" title="Analysis of the difference equations"
             >next</a> |</li>
        <li class="right" >
          <a href="._book002.html" title="Vibration ODEs"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with Partial Differential Equations</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2015, Hans Petter Langtangen. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>