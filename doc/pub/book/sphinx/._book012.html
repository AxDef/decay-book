
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Truncation errors in exponential decay ODE</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Finite Difference Computing with Partial Differential Equations" href="index.html" />
    <link rel="next" title="Truncation errors in vibration ODEs" href="._book013.html" />
    <link rel="prev" title="Appendix: Truncation error analysis" href="._book011.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book013.html" title="Truncation errors in vibration ODEs"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book011.html" title="Appendix: Truncation error analysis"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with Partial Differential Equations</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="truncation-errors-in-exponential-decay-ode">
<span id="trunc-decay"></span><h1>Truncation errors in exponential decay ODE<a class="headerlink" href="#truncation-errors-in-exponential-decay-ode" title="Permalink to this headline">¶</a></h1>
<p id="index-0">We shall now compute the truncation error of a finite difference
scheme for a differential equation.
Our first problem involves the following
the linear ODE modeling exponential decay,</p>
<div class="math" id="eq-trunc-decay-ode">
\[\tag{457}
u'(t)=-au(t)\tp\]</div>
<div class="section" id="truncation-error-of-the-forward-euler-scheme">
<span id="trunc-decay-fe"></span><h2>Truncation error of the Forward Euler scheme<a class="headerlink" href="#truncation-error-of-the-forward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>We begin with the Forward Euler scheme for discretizing <a class="reference internal" href="#eq-trunc-decay-ode"><span class="std std-ref">(457)</span></a>:</p>
<div class="math" id="eq-trunc-decay-fe-scheme">
\[\tag{458}
\lbrack D_t^+ u = -au \rbrack^n\]\[    \tp\]</div>
<p>The idea behind the truncation error computation is to insert
the exact solution <span class="math">\(\uex\)</span> of the differential equation problem
<a class="reference internal" href="#eq-trunc-decay-ode"><span class="std std-ref">(457)</span></a>
in the discrete equations <a class="reference internal" href="#eq-trunc-decay-fe-scheme"><span class="std std-ref">(458)</span></a> and find the residual
that arises because <span class="math">\(\uex\)</span> does not solve the discrete equations.
Instead, <span class="math">\(\uex\)</span> solves the discrete equations with a residual <span class="math">\(R^n\)</span>:</p>
<div class="math" id="eq-trunc-decay-fe-uex">
\[\tag{459}
[D_t^+ \uex + a\uex = R]^n\]\[    \tp\]</div>
<p>From <a class="reference internal" href="._book011.html#eq-trunc-table-fd1-fw-eq"><span class="std std-ref">(441)</span></a>-<a class="reference internal" href="._book011.html#eq-trunc-table-fd1-fw"><span class="std std-ref">(442)</span></a> it follows that</p>
<div class="math">
\[[D_t^+ \uex]^n = \uex'(t_n) +
\half\uex''(t_n)\Delta t + \Oof{\Delta t^2},\]</div>
<p>which inserted in <a class="reference internal" href="#eq-trunc-decay-fe-uex"><span class="std std-ref">(459)</span></a> results in</p>
<div class="math">
\[\uex'(t_n) +
\half\uex''(t_n)\Delta t + \Oof{\Delta t^2}
+ a\uex(t_n) = R^n
\tp\]</div>
<p>Now, <span class="math">\(\uex'(t_n) + a\uex^n = 0\)</span> since <span class="math">\(\uex\)</span> solves the differential equation.
The remaining terms constitute the residual:</p>
<div class="math" id="eq-trunc-decay-fe-r">
\[\tag{460}
R^n = \half\uex''(t_n)\Delta t + \Oof{\Delta t^2}\]\[    \tp\]</div>
<p>This is the truncation error <span class="math">\(R^n\)</span> of the Forward Euler scheme.</p>
<p>Because <span class="math">\(R^n\)</span> is proportional to <span class="math">\(\Delta t\)</span>, we say that
the Forward Euler scheme is of first order in <span class="math">\(\Delta t\)</span>.
However, the truncation error
is just one error measure, and it is not equal to the true error
<span class="math">\(\uex^n - u^n\)</span>. For this simple model problem we can compute
a range of different error measures for the Forward Euler scheme,
including the true error <span class="math">\(\uex^n - u^n\)</span>, and all of them
have dominating terms proportional to <span class="math">\(\Delta t\)</span>.</p>
</div>
<div class="section" id="truncation-error-of-the-crank-nicolson-scheme">
<span id="trunc-decay-cn"></span><h2>Truncation error of the Crank-Nicolson scheme<a class="headerlink" href="#truncation-error-of-the-crank-nicolson-scheme" title="Permalink to this headline">¶</a></h2>
<p>For the Crank-Nicolson scheme,</p>
<div class="math" id="eq-trunc-decay-cn-scheme">
\[\tag{461}
[D_t u = -au]^{n+\half},\]</div>
<p>we compute the truncation error by inserting the exact solution of
the ODE and adding a residual <span class="math">\(R\)</span>,</p>
<div class="math" id="eq-trunc-decay-cn-scheme-r">
\[\tag{462}
[D_t \uex + a\overline{\uex}^{t} = R]^{n+\half}
    \tp\]</div>
<p>The term <span class="math">\([D_t\uex]^{n+\half}\)</span> is easily computed
from <a class="reference internal" href="._book011.html#eq-trunc-table-fd1-center-eq"><span class="std std-ref">(435)</span></a>-<a class="reference internal" href="._book011.html#eq-trunc-table-fd1-center"><span class="std std-ref">(436)</span></a>
by replacing <span class="math">\(n\)</span>
with <span class="math">\(n+{\half}\)</span> in the formula,</p>
<div class="math">
\[\lbrack D_t\uex\rbrack^{n+\half} = u'(t_{n+\half}) +
\frac{1}{24}\uex'''(t_{n+\half})\Delta t^2 + \Oof{\Delta t^4}\tp\]</div>
<p>The arithmetic mean is related to <span class="math">\(u(t_{n+\half})\)</span> by
<a class="reference internal" href="._book011.html#eq-trunc-table-avg-arith-eq"><span class="std std-ref">(451)</span></a>-<a class="reference internal" href="._book011.html#eq-trunc-table-avg-arith"><span class="std std-ref">(452)</span></a> so</p>
<div class="math">
\[[a\overline{\uex}^{t}]^{n+\half}
= u(t_{n+\half}) + \frac{1}{8}u''(t_{n})\Delta t^2 +
+ \Oof{\Delta t^4}\tp\]</div>
<p>Inserting these expressions in <a class="reference internal" href="#eq-trunc-decay-cn-scheme-r"><span class="std std-ref">(462)</span></a> and
observing that <span class="math">\(\uex'(t_{n+\half}) +a\uex^{n+\half} = 0\)</span>, because
<span class="math">\(\uex(t)\)</span> solves the ODE <span class="math">\(u'(t)=-au(t)\)</span> at any point <span class="math">\(t\)</span>,
we find that</p>
<div class="math" id="eq-auto142">
\[\tag{463}
R^{n+\half} = \left(
    \frac{1}{24}\uex'''(t_{n+\half}) + \frac{1}{8}u''(t_{n})
    \right)\Delta t^2 + \Oof{\Delta t^4}\]</div>
<p>Here, the truncation error is of second order because the leading
term in <span class="math">\(R\)</span> is proportional to <span class="math">\(\Delta t^2\)</span>.</p>
<p>At this point it is wise to redo some of the computations above
to establish the truncation error of the Backward Euler scheme,
see <a class="reference internal" href="._book015.html#trunc-exer-decay-be"><span class="std std-ref">Exercise 61: Truncation error of the Backward Euler scheme</span></a>.</p>
</div>
<div class="section" id="truncation-error-of-the-rule">
<span id="trunc-decay-theta"></span><h2>Truncation error of the <span class="math">\(\theta\)</span>-rule<a class="headerlink" href="#truncation-error-of-the-rule" title="Permalink to this headline">¶</a></h2>
<p>We may also compute the truncation error of the <span class="math">\(\theta\)</span>-rule,</p>
<div class="math">
\[[\bar D_t u = -a\overline{u}^{t,\theta}]^{n+\theta}
\tp\]</div>
<p>Our computational task is to find <span class="math">\(R^{n+\theta}\)</span> in</p>
<div class="math">
\[[\bar D_t \uex  + a\overline{\uex}^{t,\theta} = R]^{n+\theta}
\tp\]</div>
<p>From <a class="reference internal" href="._book011.html#eq-trunc-table-fd1-theta-eq"><span class="std std-ref">(443)</span></a>-<a class="reference internal" href="._book011.html#eq-trunc-table-fd1-theta"><span class="std std-ref">(444)</span></a> and
<a class="reference internal" href="._book011.html#eq-trunc-table-avg-theta-eq"><span class="std std-ref">(449)</span></a>-<a class="reference internal" href="._book011.html#eq-trunc-table-avg-theta"><span class="std std-ref">(450)</span></a> we get
expressions for the terms with <span class="math">\(\uex\)</span>.
Using that <span class="math">\(\uex'(t_{n+\theta}) + a\uex(t_{n+\theta})=0\)</span>,
we end up with</p>
<div class="math">
\[R^{n+\theta}
=
({\half}-\theta)\uex''(t_{n+\theta})\Delta t +
\half\theta (1-\theta)\uex''(t_{n+\theta})\Delta t^2 + \nonumber\]</div>
<div class="math" id="eq-auto143">
\[\tag{464}
\half(\theta^2 -\theta + 3)\uex'''(t_{n+\theta})\Delta t^2
    + \Oof{\Delta t^3}\]</div>
<p>For <span class="math">\(\theta =1/2\)</span> the first-order term vanishes and the scheme is of
second order, while for <span class="math">\(\theta\neq 1/2\)</span> we only have a first-order scheme.</p>
</div>
<div class="section" id="using-symbolic-software">
<span id="trunc-decay-software"></span><h2>Using symbolic software<a class="headerlink" href="#using-symbolic-software" title="Permalink to this headline">¶</a></h2>
<p>The previously mentioned <code class="docutils literal"><span class="pre">truncation_error</span></code> module can be used to
automate the Taylor series expansions and the process of
collecting terms. Here is an example on possible use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">truncation_error</span> <span class="kn">import</span> <span class="n">DiffOp</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">decay</span><span class="p">():</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;u a&#39;</span><span class="p">)</span>
    <span class="n">diffop</span> <span class="o">=</span> <span class="n">DiffOp</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">independent_variable</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">,</span>
                    <span class="n">num_terms_Taylor_series</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">D1u</span> <span class="o">=</span> <span class="n">diffop</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># symbol for du/dt</span>
    <span class="n">ODE</span> <span class="o">=</span> <span class="n">D1u</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span>     <span class="c"># define ODE</span>

    <span class="c"># Define schemes</span>
    <span class="n">FE</span> <span class="o">=</span> <span class="n">diffop</span><span class="p">[</span><span class="s">&#39;Dtp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span>
    <span class="n">CN</span> <span class="o">=</span> <span class="n">diffop</span><span class="p">[</span><span class="s">&#39;Dt&#39;</span> <span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span>
    <span class="n">BE</span> <span class="o">=</span> <span class="n">diffop</span><span class="p">[</span><span class="s">&#39;Dtm&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">diffop</span><span class="p">[</span><span class="s">&#39;barDt&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">diffop</span><span class="p">[</span><span class="s">&#39;weighted_arithmetic_mean&#39;</span><span class="p">]</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">sm</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
    <span class="c"># Residuals (truncation errors)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;FE&#39;</span><span class="p">:</span> <span class="n">FE</span><span class="o">-</span><span class="n">ODE</span><span class="p">,</span> <span class="s">&#39;BE&#39;</span><span class="p">:</span> <span class="n">BE</span><span class="o">-</span><span class="n">ODE</span><span class="p">,</span> <span class="s">&#39;CN&#39;</span><span class="p">:</span> <span class="n">CN</span><span class="o">-</span><span class="n">ODE</span><span class="p">,</span>
         <span class="s">&#39;theta&#39;</span><span class="p">:</span> <span class="n">theta</span><span class="o">-</span><span class="n">ODE</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">R</span>
</pre></div>
</div>
<p>The returned dictionary becomes</p>
<div class="highlight-text"><div class="highlight"><pre>decay: {
 &#39;BE&#39;: D2u*dt/2 + D3u*dt**2/6,
 &#39;FE&#39;: -D2u*dt/2 + D3u*dt**2/6,
 &#39;CN&#39;: D3u*dt**2/24,
 &#39;theta&#39;: -D2u*a*dt**2*theta**2/2 + D2u*a*dt**2*theta/2 -
           D2u*dt*theta + D2u*dt/2 + D3u*a*dt**3*theta**3/3 -
           D3u*a*dt**3*theta**2/2 + D3u*a*dt**3*theta/6 +
           D3u*dt**2*theta**2/2 - D3u*dt**2*theta/2 + D3u*dt**2/6,
}
</pre></div>
</div>
<p>The results are in correspondence with our hand-derived expressions.</p>
</div>
<div class="section" id="empirical-verification-of-the-truncation-error">
<span id="trunc-decay-estimate-r"></span><h2>Empirical verification of the truncation error<a class="headerlink" href="#empirical-verification-of-the-truncation-error" title="Permalink to this headline">¶</a></h2>
<p>The task of this section is to demonstrate how we can compute
the truncation error <span class="math">\(R\)</span> numerically. For example, the truncation
error of the Forward Euler scheme applied to the decay ODE <span class="math">\(u'=-ua\)</span>
is</p>
<div class="math" id="eq-trunc-decay-fe-r-comp">
\[\tag{465}
R^n = [D_t^+\uex + a\uex]^n\]\[    \tp\]</div>
<p>If we happen to know the exact solution <span class="math">\(\uex(t)\)</span>, we can easily evaluate
<span class="math">\(R^n\)</span> from the above formula.</p>
<p>To estimate how <span class="math">\(R\)</span> varies with the discretization parameter <span class="math">\(\Delta
t\)</span>, which has been our focus in the previous mathematical derivations,
we first make the assumption that <span class="math">\(R=C\Delta t^r\)</span> for
appropriate constants <span class="math">\(C\)</span> and
<span class="math">\(r\)</span> and small enough <span class="math">\(\Delta t\)</span>. The rate <span class="math">\(r\)</span> can be estimated from a series
of experiments where <span class="math">\(\Delta t\)</span> is varied. Suppose we have
<span class="math">\(m\)</span> experiments <span class="math">\((\Delta t_i, R_i)\)</span>, <span class="math">\(i=0,\ldots,m-1\)</span>.
For two consecutive experiments <span class="math">\((\Delta t_{i-1}, R_{i-1})\)</span>
and <span class="math">\((\Delta t_i, R_i)\)</span>, a corresponding <span class="math">\(r_{i-1}\)</span> can be estimated by</p>
<div class="math" id="eq-trunc-r-empir1">
\[\tag{466}
r_{i-1} = \frac{\ln (R_{i-1}/R_i)}{\ln (\Delta t_{i-1}/\Delta t_i)},\]</div>
<p>for <span class="math">\(i=1,\ldots,m-1\)</span>. Note that the truncation error <span class="math">\(R_i\)</span> varies
through the mesh, so <a class="reference internal" href="#eq-trunc-r-empir1"><span class="std std-ref">(466)</span></a> is to be applied
pointwise. A complicating issue is that <span class="math">\(R_i\)</span> and <span class="math">\(R_{i-1}\)</span> refer to
different meshes. Pointwise comparisons of the truncation error at a
certain point in all meshes therefore requires any
computed <span class="math">\(R\)</span> to be restricted to the <em>coarsest mesh</em> and that
all finer meshes contain all the points in the coarsest mesh.
Suppose we have
<span class="math">\(N_0\)</span> intervals in the coarsest mesh. Inserting a superscript <span class="math">\(n\)</span> in
<a class="reference internal" href="#eq-trunc-r-empir1"><span class="std std-ref">(466)</span></a>, where <span class="math">\(n\)</span> counts mesh points in the coarsest
mesh, <span class="math">\(n=0,\ldots,N_0\)</span>, leads to the formula</p>
<div class="math" id="eq-trunc-r-empir2">
\[\tag{467}
r_{i-1}^n = \frac{\ln (R_{i-1}^n/R_i^n)}{\ln (\Delta t_{i-1}/\Delta t_i)}
    \tp\]</div>
<p>Experiments are most conveniently defined by <span class="math">\(N_0\)</span> and a number of
refinements <span class="math">\(m\)</span>. Suppose each mesh have twice as many cells <span class="math">\(N_i\)</span> as the previous
one:</p>
<div class="math">
\[N_i = 2^iN_0,\quad \Delta t_i = TN_i^{-1},\]</div>
<p>where <span class="math">\([0,T]\)</span> is the total time interval for the computations.
Suppose the computed <span class="math">\(R_i\)</span> values on the mesh with <span class="math">\(N_i\)</span> intervals
are stored in an array <code class="docutils literal"><span class="pre">R[i]</span></code> (<code class="docutils literal"><span class="pre">R</span></code> being a list of arrays, one for
each mesh). Restricting this <span class="math">\(R_i\)</span> function to
the coarsest mesh means extracting every <span class="math">\(N_i/N_0\)</span> point and is done
as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">stride</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">N_0</span>
<span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">][::</span><span class="n">stride</span><span class="p">]</span>
</pre></div>
</div>
<p>The quantity <code class="docutils literal"><span class="pre">R[i][n]</span></code> now corresponds to <span class="math">\(R_i^n\)</span>.</p>
<p>In addition to estimating <span class="math">\(r\)</span> for the pointwise values
of <span class="math">\(R=C\Delta t^r\)</span>, we may also consider an integrated quantity
on mesh <span class="math">\(i\)</span>,</p>
<div class="math" id="eq-auto144">
\[\tag{468}
R_{I,i} = \left(\Delta t_i\sum_{n=0}^{N_i} (R_i^n)^2\right)^\half\approx \int_0^T R_i(t)dt
    \tp\]</div>
<p>The sequence <span class="math">\(R_{I,i}\)</span>, <span class="math">\(i=0,\ldots,m-1\)</span>, is also expected to
behave as <span class="math">\(C\Delta t^r\)</span>, with the same <span class="math">\(r\)</span> as for the pointwise quantity
<span class="math">\(R\)</span>, as <span class="math">\(\Delta t\rightarrow 0\)</span>.</p>
<p>The function below computes the <span class="math">\(R_i\)</span> and <span class="math">\(R_{I,i}\)</span> quantities, plots
them and compares with
the theoretically derived truncation error (<code class="docutils literal"><span class="pre">R_a</span></code>) if available.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scitools.std</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">estimate</span><span class="p">(</span><span class="n">truncation_error</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N_0</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the truncation error in a problem with one independent</span>
<span class="sd">    variable, using m meshes, and estimate the convergence</span>
<span class="sd">    rate of the truncation error.</span>

<span class="sd">    The user-supplied function truncation_error(dt, N) computes</span>
<span class="sd">    the truncation error on a uniform mesh with N intervals of</span>
<span class="sd">    length dt::</span>

<span class="sd">      R, t, R_a = truncation_error(dt, N)</span>

<span class="sd">    where R holds the truncation error at points in the array t,</span>
<span class="sd">    and R_a are the corresponding theoretical truncation error</span>
<span class="sd">    values (None if not available).</span>

<span class="sd">    The truncation_error function is run on a series of meshes</span>
<span class="sd">    with 2**i*N_0 intervals, i=0,1,...,m-1.</span>
<span class="sd">    The values of R and R_a are restricted to the coarsest mesh.</span>
<span class="sd">    and based on these data, the convergence rate of R (pointwise)</span>
<span class="sd">    and time-integrated R can be estimated empirically.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">N_0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>

    <span class="n">R_I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="c"># time-integrated R values on various meshes</span>
    <span class="n">R</span>   <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">m</span>    <span class="c"># time series of R restricted to coarsest mesh</span>
    <span class="n">R_a</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">m</span>    <span class="c"># time series of R_a restricted to coarsest mesh</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">legends_R</span> <span class="o">=</span> <span class="p">[];</span>  <span class="n">legends_R_a</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># all legends of curves</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">dt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">,</span> <span class="n">R_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">truncation_error</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">R_I</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">t_coarse</span> <span class="o">=</span> <span class="n">t</span>           <span class="c"># the coarsest mesh</span>

        <span class="n">stride</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">N_0</span>
        <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">][::</span><span class="n">stride</span><span class="p">]</span>      <span class="c"># restrict to coarsest mesh</span>
        <span class="n">R_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">R_a</span><span class="p">[</span><span class="n">i</span><span class="p">][::</span><span class="n">stride</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">makeplot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_coarse</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">log</span><span class="o">=</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
            <span class="n">legends_R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;N=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_coarse</span><span class="p">,</span> <span class="n">R_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">log</span><span class="o">=</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
            <span class="n">legends_R_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;N=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">makeplot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;pointwise truncation error&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legends_R</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;R_series.png&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;R_series.pdf&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;pointwise error in estimated truncation error&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legends_R_a</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;R_error.png&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;R_error.pdf&#39;</span><span class="p">)</span>

    <span class="c"># Convergence rates</span>
    <span class="n">r_R_I</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">R_I</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;R integrated in time; r:&#39;</span><span class="p">,</span>
    <span class="k">print</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;</span><span class="si">%.1f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">r_R_I</span><span class="p">])</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>  <span class="c"># two-dim. numpy array</span>
    <span class="n">r_R</span> <span class="o">=</span> <span class="p">[</span><span class="n">convergence_rates</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">R</span><span class="p">[:,</span><span class="n">n</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
           <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_coarse</span><span class="p">))]</span>
</pre></div>
</div>
<p>The first <code class="docutils literal"><span class="pre">makeplot</span></code> block demonstrates how to build up two figures
in parallel, using <code class="docutils literal"><span class="pre">plt.figure(i)</span></code> to create and switch to figure number
<code class="docutils literal"><span class="pre">i.</span></code> Figure numbers start at 1. A logarithmic scale is used on the
<span class="math">\(y\)</span> axis since we expect that <span class="math">\(R\)</span> as a function of time (or mesh points)
is exponential. The reason is that the theoretical estimate
<a class="reference internal" href="#eq-trunc-decay-fe-r"><span class="std std-ref">(460)</span></a> contains <span class="math">\(\uex''\)</span>, which for the present model
goes like <span class="math">\(e^{-at}\)</span>. Taking the logarithm makes a straight line.</p>
<p>The code follows closely the previously
stated mathematical formulas, but the statements for computing the convergence
rates might deserve an explanation.
The generic help function <code class="docutils literal"><span class="pre">convergence_rate(h,</span> <span class="pre">E)</span></code> computes and returns
<span class="math">\(r_{i-1}\)</span>, <span class="math">\(i=1,\ldots,m-1\)</span> from <a class="reference internal" href="#eq-trunc-r-empir2"><span class="std std-ref">(467)</span></a>,
given <span class="math">\(\Delta t_i\)</span> in <code class="docutils literal"><span class="pre">h</span></code> and
<span class="math">\(R_i^n\)</span> in <code class="docutils literal"><span class="pre">E</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">convergence_rates</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">log</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>Calling <code class="docutils literal"><span class="pre">r_R_I</span> <span class="pre">=</span> <span class="pre">convergence_rates(dt,</span> <span class="pre">R_I)</span></code> computes the sequence
of rates <span class="math">\(r_0,r_1,\ldots,r_{m-2}\)</span> for the model <span class="math">\(R_I\sim\Delta t^r\)</span>,
while the statements</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>  <span class="c"># two-dim. numpy array</span>
<span class="n">r_R</span> <span class="o">=</span> <span class="p">[</span><span class="n">convergence_rates</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">R</span><span class="p">[:,</span><span class="n">n</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
       <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_coarse</span><span class="p">))]</span>
</pre></div>
</div>
<p>compute the final rate <span class="math">\(r_{m-2}\)</span> for <span class="math">\(R^n\sim\Delta t^r\)</span> at each mesh
point <span class="math">\(t_n\)</span> in the coarsest mesh. This latter computation deserves
more explanation. Since <code class="docutils literal"><span class="pre">R[i][n]</span></code> holds the estimated
truncation error <span class="math">\(R_i^n\)</span> on mesh <span class="math">\(i\)</span>, at point <span class="math">\(t_n\)</span> in the coarsest mesh,
<code class="docutils literal"><span class="pre">R[:,n]</span></code> picks out the sequence <span class="math">\(R_i^n\)</span> for <span class="math">\(i=0,\ldots,m-1\)</span>.
The <code class="docutils literal"><span class="pre">convergence_rate</span></code> function computes the rates at <span class="math">\(t_n\)</span>, and by
indexing <code class="docutils literal"><span class="pre">[-1]</span></code> on the returned array from <code class="docutils literal"><span class="pre">convergence_rate</span></code>,
we pick the rate <span class="math">\(r_{m-2}\)</span>, which we believe is the best estimation since
it is based on the two finest meshes.</p>
<p>The <code class="docutils literal"><span class="pre">estimate</span></code> function is available in a module
<a class="reference external" href="http://tinyurl.com/nm5587k/trunc/trunc_empir.py">trunc_empir.py</a>.
Let us apply this function to estimate the truncation
error of the Forward Euler scheme. We need a function <code class="docutils literal"><span class="pre">decay_FE(dt,</span> <span class="pre">N)</span></code>
that can compute <a class="reference internal" href="#eq-trunc-decay-fe-r-comp"><span class="std std-ref">(465)</span></a> at the
points in a mesh with time step <code class="docutils literal"><span class="pre">dt</span></code> and <code class="docutils literal"><span class="pre">N</span></code> intervals:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">trunc_empir</span>

<span class="k">def</span> <span class="nf">decay_FE</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>  <span class="c"># exact solution, I and a are global</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">u_e</span>  <span class="c"># naming convention when writing up the scheme</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">R</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">/</span><span class="n">dt</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

    <span class="c"># Theoretical expression for the trunction error</span>
    <span class="n">R_a</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span>

    <span class="k">return</span> <span class="n">R</span><span class="p">,</span> <span class="n">t</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">R_a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c"># global variables needed in decay_FE</span>
    <span class="n">trunc_empir</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">decay_FE</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">N_0</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The estimated rates for the integrated truncation error <span class="math">\(R_I\)</span> become
1.1, 1.0, and 1.0 for this sequence of four meshes. All the rates
for <span class="math">\(R^n\)</span>, computed as <code class="docutils literal"><span class="pre">r_R</span></code>, are also very close to 1 at all mesh points.
The agreement between the theoretical formula <a class="reference internal" href="#eq-trunc-decay-fe-r"><span class="std std-ref">(460)</span></a>
and the computed quantity (ref:ref:<cite>(465) &lt;Eq:trunc:decay:FE:R:comp&gt;</cite>) is
very good, as illustrated in
Figures <a class="reference internal" href="#trunc-fig-fe-rates"><span class="std std-ref">Estimated truncation error at mesh points for different meshes</span></a> and <a class="reference internal" href="#trunc-fig-fe-error"><span class="std std-ref">Difference between theoretical and estimated truncation error at mesh points for different meshes</span></a>.
The program <a class="reference external" href="http://tinyurl.com/nm5587k/trunc/trunc_decay_FE.py">trunc_decay_FE.py</a>
was used to perform the simulations and it can easily be modified to
test other schemes (see also <a class="reference internal" href="._book015.html#trunc-exer-decay-estimate"><span class="std std-ref">Exercise 62: Empirical estimation of truncation errors</span></a>).</p>
<div class="figure" id="id1">
<span id="trunc-fig-fe-rates"></span><a class="reference internal image-reference" href="_images/R_series.png"><img alt="_images/R_series.png" src="_images/R_series.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Estimated truncation error at mesh points for different meshes</em></span></p>
</div>
<div class="figure" id="id2">
<span id="trunc-fig-fe-error"></span><a class="reference internal image-reference" href="_images/R_error.png"><img alt="_images/R_error.png" src="_images/R_error.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Difference between theoretical and estimated truncation error at mesh points for different meshes</em></span></p>
</div>
</div>
<div class="section" id="increasing-the-accuracy-by-adding-correction-terms">
<span id="trunc-decay-corr"></span><h2>Increasing the accuracy by adding correction terms<a class="headerlink" href="#increasing-the-accuracy-by-adding-correction-terms" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-1"></span><p id="index-2">Now we ask the question: can we add terms in the differential equation
that can help increase the order of the truncation error? To be precise,
let us revisit the Forward Euler scheme for <span class="math">\(u'=-au\)</span>, insert the
exact solution <span class="math">\(\uex\)</span>, include a residual <span class="math">\(R\)</span>, but also include
new terms <span class="math">\(C\)</span>:</p>
<div class="math" id="eq-trunc-decay-fe-corr">
\[\tag{469}
\lbrack D_t^+ \uex + a\uex = C + R \rbrack^n\tp\]</div>
<p>Inserting the Taylor expansions for <span class="math">\([D_t^+\uex]^n\)</span> and keeping
terms up to 3rd order in <span class="math">\(\Delta t\)</span> gives the equation</p>
<div class="math">
\[\half\uex''(t_n)\Delta t - \frac{1}{6}\uex'''(t_n)\Delta t^2
+ \frac{1}{24}\uex''''(t_n)\Delta t^3
+ \Oof{\Delta t^4}  = C^n + R^n\tp\]</div>
<p>Can we find <span class="math">\(C^n\)</span> such that <span class="math">\(R^n\)</span> is <span class="math">\(\Oof{\Delta t^2}\)</span>?
Yes, by setting</p>
<div class="math">
\[C^n = \half\uex''(t_n)\Delta t,\]</div>
<p>we manage to cancel the first-order term and</p>
<div class="math">
\[R^n = \frac{1}{6}\uex'''(t_n)\Delta t^2 + \Oof{\Delta t^3}\tp\]</div>
<p>The correction term <span class="math">\(C^n\)</span> introduces <span class="math">\(\half\Delta t u''\)</span>
in the discrete equation, and we have to get rid of the derivative
<span class="math">\(u''\)</span>. One idea is to approximate <span class="math">\(u''\)</span> by a second-order accurate finite
difference formula, <span class="math">\(u''\approx (u^{n+1}-2u^n+u^{n-1})/\Delta t^2\)</span>,
but this introduces an additional time level
with <span class="math">\(u^{n-1}\)</span>. Another approach is to rewrite <span class="math">\(u''\)</span> in terms of <span class="math">\(u'\)</span>
or <span class="math">\(u\)</span> using the ODE:</p>
<div class="math">
\[u'=-au\quad\Rightarrow\quad u''=-au' = -a(-au)= a^2u\tp\]</div>
<p>This  means that we can simply set
<span class="math">\(C^n = {\half}a^2\Delta t u^n\)</span>. We can then either
solve the discrete equation</p>
<div class="math" id="eq-trunc-decay-corr-fe-discrete">
\[\tag{470}
[D_t^+ u = -au + {\half}a^2\Delta t u]^n,\]</div>
<p>or we can equivalently discretize the perturbed ODE</p>
<div class="math" id="eq-trunc-decay-corr-fe-ode">
\[\tag{471}
u' = -\hat au ,\quad \hat a = a(1 - {\half}a\Delta t),\]</div>
<p>by a Forward Euler method. That is, we replace the original coefficient
<span class="math">\(a\)</span> by the perturbed coefficient <span class="math">\(\hat a\)</span>. Observe that
<span class="math">\(\hat a\rightarrow a\)</span> as <span class="math">\(\Delta t\rightarrow 0\)</span>.</p>
<p>The Forward Euler method applied to <a class="reference internal" href="#eq-trunc-decay-corr-fe-ode"><span class="std std-ref">(471)</span></a>
results in</p>
<div class="math">
\[[D_t^+ u = -a(1 - {\half}a\Delta t)u]^n\tp\]</div>
<p>We can control our computations and verify that the truncation error
of the scheme above is indeed <span class="math">\(\Oof{\Delta t^2}\)</span>.</p>
<p>Another way of revealing the fact that the perturbed ODE leads
to a more accurate solution is to look at the amplification factor.
Our scheme can be written as</p>
<div class="math">
\[u^{n+1} = Au^n,\quad A = 1-\hat a\Delta t = 1 - p + {\half}p^2,\quad p=a\Delta t,\]</div>
<p>The amplification factor <span class="math">\(A\)</span> as a function of <span class="math">\(p=a\Delta t\)</span> is seen to be
the first three terms of the Taylor series for the exact amplification
factor <span class="math">\(e^{-p}\)</span>. The Forward Euler scheme for <span class="math">\(u=-au\)</span> gives only the
first two terms <span class="math">\(1-p\)</span> of the Taylor series for <span class="math">\(e^{-p}\)</span>. That is,
using <span class="math">\(\hat a\)</span> increases the order of the accuracy in the amplification factor.</p>
<p>Instead of replacing <span class="math">\(u''\)</span> by <span class="math">\(a^2u\)</span>, we use the relation
<span class="math">\(u''=-au'\)</span> and add a term <span class="math">\(-{\half}a\Delta t u'\)</span>
in the ODE:</p>
<div class="math">
\[u'=-au - {\half}a\Delta t u'\quad\Rightarrow\quad
\left( 1 + {\half}a\Delta t\right) u' = -au\tp\]</div>
<p>Using a Forward Euler method results in</p>
<div class="math">
\[\left( 1 + {\half}a\Delta t\right)\frac{u^{n+1}-u^n}{\Delta t}
= -au^n,\]</div>
<p>which after some algebra can be written as</p>
<div class="math">
\[u^{n+1} = \frac{1 - {\half}a\Delta t}{1+{\half}a\Delta t}u^n\tp\]</div>
<p>This is the same formula as the one arising from a Crank-Nicolson
scheme applied to <span class="math">\(u'=-au\)</span>!
It now recommended to do <a class="reference internal" href="._book015.html#trunc-exer-decay-corr-be"><span class="std std-ref">Exercise 63: Correction term for a Backward Euler scheme</span></a> and
repeat the above steps to see what kind of correction term is needed
in the Backward Euler scheme to make it second order.</p>
<p>The Crank-Nicolson scheme is a bit more challenging to analyze, but
the ideas and techniques are the same. The discrete equation reads</p>
<div class="math">
\[[D_t u = -au ]^{n+\half},\]</div>
<p>and the truncation error is defined through</p>
<div class="math">
\[[D_t \uex + a\overline{\uex}^{t} = C + R]^{n+\half},\]</div>
<p>where we have added a correction term.  We need to Taylor expand both
the discrete derivative and the arithmetic mean with aid of
<a class="reference internal" href="._book011.html#eq-trunc-table-fd1-center-eq"><span class="std std-ref">(435)</span></a>-<a class="reference internal" href="._book011.html#eq-trunc-table-fd1-center"><span class="std std-ref">(436)</span></a> and
<a class="reference internal" href="._book011.html#eq-trunc-table-avg-arith-eq"><span class="std std-ref">(451)</span></a>-<a class="reference internal" href="._book011.html#eq-trunc-table-avg-arith"><span class="std std-ref">(452)</span></a>, respectively.
The result is</p>
<div class="math">
\[\frac{1}{24}\uex'''(t_{n+\half})\Delta t^2 + \Oof{\Delta t^4}
+ \frac{a}{8}\uex''(t_{n+\half})\Delta t^2 + \Oof{\Delta t^4} = C^{n+\half} + R^{n+\half}\tp\]</div>
<p>The goal now is to make <span class="math">\(C^{n+\half}\)</span> cancel the <span class="math">\(\Delta t^2\)</span> terms:</p>
<div class="math">
\[C^{n+\half} =
\frac{1}{24}\uex'''(t_{n+\half})\Delta t^2
+ \frac{a}{8}\uex''(t_{n})\Delta t^2\tp\]</div>
<p>Using <span class="math">\(u'=-au\)</span>, we have that <span class="math">\(u''=a^2u\)</span>, and we find that <span class="math">\(u'''=-a^3u\)</span>.
We can therefore solve the perturbed ODE problem</p>
<div class="math">
\[u' = -\hat a u,\quad \hat a = a(1 - \frac{1}{12}a^2\Delta t^2),\]</div>
<p>by the Crank-Nicolson scheme and obtain a method that is of fourth
order in <span class="math">\(\Delta t\)</span>. <a class="reference internal" href="._book015.html#trunc-exer-decay-corr-verify"><span class="std std-ref">Exercise 64: Verify the effect of correction terms</span></a>
encourages you to implement these correction terms and calculate
empirical convergence rates to verify that higher-order accuracy
is indeed obtained in real computations.</p>
</div>
<div class="section" id="extension-to-variable-coefficients-1">
<h2>Extension to variable coefficients<a class="headerlink" href="#extension-to-variable-coefficients-1" title="Permalink to this headline">¶</a></h2>
<p>Let us address the decay ODE with variable coefficients,</p>
<div class="math">
\[u'(t) = -a(t)u(t) + b(t),\]</div>
<p>discretized by the Forward Euler scheme,</p>
<div class="math" id="eq-auto145">
\[\tag{472}
[D_t^+ u = -au + b]^n
    \tp\]</div>
<p>The truncation error <span class="math">\(R\)</span> is as always found by inserting the exact
solution <span class="math">\(\uex(t)\)</span> in the discrete scheme:</p>
<div class="math" id="eq-auto146">
\[\tag{473}
[D_t^+ \uex + a\uex - b = R]^n
    \tp\]</div>
<p>Using <a class="reference internal" href="._book011.html#eq-trunc-table-fd1-fw-eq"><span class="std std-ref">(441)</span></a>-<a class="reference internal" href="._book011.html#eq-trunc-table-fd1-fw"><span class="std std-ref">(442)</span></a>,</p>
<div class="math">
\[\uex'(t_n) - \half\uex''(t_n)\Delta t + \Oof{\Delta t^2}
+ a(t_n)\uex(t_n) - b(t_n) = R^n
\tp\]</div>
<p>Because of the ODE,</p>
<div class="math">
\[\uex'(t_n) + a(t_n)\uex(t_n) - b(t_n) =0,\]</div>
<p>so we are left with the result</p>
<div class="math" id="eq-trunc-decay-vc-r">
\[\tag{474}
R^n = -\half\uex''(t_n)\Delta t + \Oof{\Delta t^2}
    \
    \tp\]</div>
<p>We see that the variable coefficients do not pose any additional difficulties
in this case. <a class="reference internal" href="._book015.html#trunc-exer-decay-varcoeff-cn"><span class="std std-ref">Exercise 65: Truncation error of the Crank-Nicolson scheme</span></a> takes the
analysis above one step further to the Crank-Nicolson scheme.</p>
</div>
<div class="section" id="exact-solutions-of-the-finite-difference-equations">
<h2>Exact solutions of the finite difference equations<a class="headerlink" href="#exact-solutions-of-the-finite-difference-equations" title="Permalink to this headline">¶</a></h2>
<p id="index-3">Having a mathematical expression for the numerical solution is very
valuable in program verification since we then know the exact numbers
that the program should produce. Looking at the various
formulas for the truncation errors in
<a class="reference internal" href="._book011.html#eq-trunc-table-fd1-center-eq"><span class="std std-ref">(435)</span></a>-<a class="reference internal" href="._book011.html#eq-trunc-table-fd1-center"><span class="std std-ref">(436)</span></a> and
<a class="reference internal" href="._book011.html#eq-trunc-table-avg-harm-eq"><span class="std std-ref">(455)</span></a>-<a class="reference internal" href="._book011.html#eq-trunc-table-avg-harm"><span class="std std-ref">(456)</span></a> in
the section <a class="reference internal" href="._book011.html#trunc-table"><span class="std std-ref">Overview of leading-order error terms in finite difference formulas</span></a>, we see that all but two of
the <span class="math">\(R\)</span> expressions contains a second or higher order derivative
of <span class="math">\(\uex\)</span>. The exceptions are the geometric and harmonic
means where the truncation
error involves <span class="math">\(\uex'\)</span> and even <span class="math">\(\uex\)</span> in case of the harmonic mean.
So, apart from these two means,
choosing <span class="math">\(\uex\)</span> to be a linear function of
<span class="math">\(t\)</span>, <span class="math">\(\uex = ct+d\)</span> for constants <span class="math">\(c\)</span> and <span class="math">\(d\)</span>, will make
the truncation error vanish since <span class="math">\(\uex''=0\)</span>. Consequently,
the truncation error of a finite difference scheme will be zero
since the various
approximations used will all be exact. This means that the linear solution
is an exact solution of the discrete equations.</p>
<p>In a particular differential equation problem, the reasoning above can
be used to determine if we expect a linear <span class="math">\(\uex\)</span> to fulfill the
discrete equations. To actually prove that this is true, we can either
compute the truncation error and see that it vanishes, or we can
simply insert <span class="math">\(\uex(t)=ct+d\)</span> in the scheme and see that it fulfills
the equations. The latter method is usually the simplest. It will
often be necessary to add some source term to the ODE in order to
allow a linear solution.</p>
<p>Many ODEs are discretized by centered differences.
From the section <a class="reference internal" href="._book011.html#trunc-table"><span class="std std-ref">Overview of leading-order error terms in finite difference formulas</span></a> we see that all the centered
difference formulas have truncation errors involving <span class="math">\(\uex'''\)</span> or
higher-order derivatives.
A quadratic solution, e.g., <span class="math">\(\uex(t) =t^2 + ct + d\)</span>,
will then make the truncation errors vanish. This observation
can be used to test if a quadratic solution will fulfill the
discrete equations. Note that a quadratic solution will not
obey the equations for a Crank-Nicolson scheme for <span class="math">\(u'=-au+b\)</span>
because the approximation applies an arithmetic mean, which
involves a truncation error with <span class="math">\(\uex''\)</span>.</p>
</div>
<div class="section" id="computing-truncation-errors-in-nonlinear-problems">
<span id="trunc-decay-gen"></span><h2>Computing truncation errors in nonlinear problems<a class="headerlink" href="#computing-truncation-errors-in-nonlinear-problems" title="Permalink to this headline">¶</a></h2>
<p>The general nonlinear ODE</p>
<div class="math" id="eq-trunc-decay-gen-ode">
\[\tag{475}
u'=f(u,t),\]</div>
<p>can be solved by a Crank-Nicolson scheme</p>
<div class="math" id="eq-trunc-decay-gen-ode-fdm">
\[\tag{476}
[D_t u=\overline{f}^{t}]^{n+\half}\tp\]</div>
<p>The truncation error is as always defined as the residual arising
when inserting the
exact solution <span class="math">\(\uex\)</span> in the scheme:</p>
<div class="math" id="eq-trunc-decay-gen-ode-cn">
\[\tag{477}
[D_t \uex - \overline{f}^{t}= R]^{n+\half}\tp\]</div>
<p>Using <a class="reference internal" href="._book011.html#eq-trunc-table-avg-arith-eq"><span class="std std-ref">(451)</span></a>-<a class="reference internal" href="._book011.html#eq-trunc-table-avg-arith"><span class="std std-ref">(452)</span></a> for
<span class="math">\(\overline{f}^{t}\)</span> results in</p>
<div class="math">
\[\begin{split}[\overline{f}^{t}]^{n+\half} &amp;=
\half(f(\uex^n,t_n) + f(\uex^{n+1},t_{n+1}))\\
&amp;= f(\uex^{n+\half},t_{n+\half}) +
\frac{1}{8}\uex''(t_{n+\half})\Delta t^2
+ \Oof{\Delta t^4}\tp\end{split}\]</div>
<p>With <a class="reference internal" href="._book011.html#eq-trunc-table-fd1-center-eq"><span class="std std-ref">(435)</span></a>-<a class="reference internal" href="._book011.html#eq-trunc-table-fd1-center"><span class="std std-ref">(436)</span></a> the discrete
equations <a class="reference internal" href="#eq-trunc-decay-gen-ode-cn"><span class="std std-ref">(477)</span></a> lead to</p>
<div class="math">
\[\uex'(t_{n+\half}) +
\frac{1}{24}\uex'''(t_{n+\half})\Delta t^2
- f(\uex^{n+\half},t_{n+\half}) -
\frac{1}{8}u''(t_{n+\half})\Delta t^2
+ \Oof{\Delta t^4} = R^{n+\half}\tp\]</div>
<p>Since <span class="math">\(\uex'(t_{n+\half}) - f(\uex^{n+\half},t_{n+\half})=0\)</span>,
the truncation error becomes</p>
<div class="math">
\[R^{n+\half} = (\frac{1}{24}\uex'''(t_{n+\half})
- \frac{1}{8}u''(t_{n+\half})) \Delta t^2\tp\]</div>
<p>The computational techniques worked well
even for this nonlinear ODE.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Truncation errors in exponential decay ODE</a><ul>
<li><a class="reference internal" href="#truncation-error-of-the-forward-euler-scheme">Truncation error of the Forward Euler scheme</a></li>
<li><a class="reference internal" href="#truncation-error-of-the-crank-nicolson-scheme">Truncation error of the Crank-Nicolson scheme</a></li>
<li><a class="reference internal" href="#truncation-error-of-the-rule">Truncation error of the <span class="math">\(\theta\)</span>-rule</a></li>
<li><a class="reference internal" href="#using-symbolic-software">Using symbolic software</a></li>
<li><a class="reference internal" href="#empirical-verification-of-the-truncation-error">Empirical verification of the truncation error</a></li>
<li><a class="reference internal" href="#increasing-the-accuracy-by-adding-correction-terms">Increasing the accuracy by adding correction terms</a></li>
<li><a class="reference internal" href="#extension-to-variable-coefficients-1">Extension to variable coefficients</a></li>
<li><a class="reference internal" href="#exact-solutions-of-the-finite-difference-equations">Exact solutions of the finite difference equations</a></li>
<li><a class="reference internal" href="#computing-truncation-errors-in-nonlinear-problems">Computing truncation errors in nonlinear problems</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book011.html"
                        title="previous chapter">Appendix: Truncation error analysis</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book013.html"
                        title="next chapter">Truncation errors in vibration ODEs</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book012.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book013.html" title="Truncation errors in vibration ODEs"
             >next</a> |</li>
        <li class="right" >
          <a href="._book011.html" title="Appendix: Truncation error analysis"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with Partial Differential Equations</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2015, Hans Petter Langtangen. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>