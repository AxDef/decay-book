

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Models</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Finite Difference Computing with Exponential Decay Models" href="index.html" />
    <link rel="next" title="Scientific software engineering" href="._book009.html" />
    <link rel="prev" title="Generalizations" href="._book007.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book009.html" title="Scientific software engineering"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book007.html" title="Generalizations"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Finite Difference Computing with Exponential Decay Models</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="models">
<span id="decay-app"></span><h1>Models<a class="headerlink" href="#models" title="Permalink to this headline">¶</a></h1>
<p>This chapter presents many mathematical models that all
end up with ODEs of the type <span class="math">\(u^{\prime}=-au+b\)</span>.
The applications are taken from biology,
finance, and physics, and cover population growth or decay, compound
interest and inflation, radioactive decay, cooling of objects,
compaction of geological media, pressure
variations in the atmosphere, and air resistance on falling or rising
bodies.</p>
<p>Before we turn to the applications, however, we take a brief look at
the technique of scaling, which is so useful in many applications.</p>
<div class="section" id="scaling-1">
<span id="decay-app-scaling"></span><h2>Scaling  (1)<a class="headerlink" href="#scaling-1" title="Permalink to this headline">¶</a></h2>
<p>Real applications of a model <span class="math">\(u^{\prime}=-au+b\)</span> will often involve a lot
of parameters in the expressions for <span class="math">\(a\)</span> and <span class="math">\(b\)</span>. It can be quite
a challenge to find relevant values of all parameters. In simple
problems, however, it turns out that it is not always necessary
to estimate all parameters because we can lump them into one or
a few <em>dimensionless</em> numbers by using a very attractive technique
called scaling. It simply means to stretch the <span class="math">\(u\)</span> and <span class="math">\(t\)</span> axis
in the present problem - and suddenly all parameters in the problem
are lumped into one parameter if <span class="math">\(b\neq 0\)</span> and no parameter when <span class="math">\(b=0\)</span>!</p>
<div class="section" id="dimensionless-variables">
<h3>Dimensionless variables<a class="headerlink" href="#dimensionless-variables" title="Permalink to this headline">¶</a></h3>
<p>Scaling means that we introduce a new function <span class="math">\(\bar u(\bar t)\)</span>,
with</p>
<div class="math">
\[\bar u = \frac{u - u_m}{u_c},\quad \bar t = \frac{t}{t_c},\]</div>
<p>where <span class="math">\(u_m\)</span> is a characteristic value of <span class="math">\(u\)</span>, <span class="math">\(u_c\)</span> is a characteristic
size of the range of <span class="math">\(u\)</span> values, and <span class="math">\(t_c\)</span> is a characteristic
size of the range of <span class="math">\(t\)</span> where <span class="math">\(u\)</span> shows significant variation.
Choosing <span class="math">\(u_m\)</span>, <span class="math">\(u_c\)</span>, and <span class="math">\(t_c\)</span> is not always easy and is often an art
in complicated problems. We just state one choice first:</p>
<div class="math">
\[u_c = I,\quad u_m = b/a,\quad t_c = 1/a\tp\]</div>
<p>Inserting <span class="math">\(u=u_m + u_c\bar u\)</span> and <span class="math">\(t=t_c\bar t\)</span> in the problem
<span class="math">\(u^{\prime}=-au + b\)</span>, assuming <span class="math">\(a\)</span> and <span class="math">\(b\)</span> are constants, results (after some
algebra) in the <em>scaled problem</em></p>
<div class="math">
\[\frac{d\bar u}{d\bar t} = -\bar u,\quad \bar u(0)=1 - \beta,\]</div>
<p>where</p>
<div class="math">
\[\beta = \frac{b}{Ia}\tp\]</div>
</div>
<div class="section" id="dimensionless-numbers">
<h3>Dimensionless numbers<a class="headerlink" href="#dimensionless-numbers" title="Permalink to this headline">¶</a></h3>
<p>The parameter <span class="math">\(\beta\)</span> is a dimensionless number. From the equation we
see that <span class="math">\(b\)</span> must have the same unit as the term <span class="math">\(au\)</span>. The initial
condition <span class="math">\(I\)</span> must have the same unit as <span class="math">\(u\)</span>, so <span class="math">\(Ia\)</span> has the same
unit as <span class="math">\(b\)</span>, making the fraction <span class="math">\(b/(Ia)\)</span> dimensionless.</p>
<p>An important observation is that <span class="math">\(\bar u\)</span> depends on <span class="math">\(\bar t\)</span>
and <span class="math">\(\beta\)</span>.
That is, only the special combination of <span class="math">\(b/(Ia)\)</span> matters, not what
the individual values of <span class="math">\(b\)</span>, <span class="math">\(a\)</span>, and <span class="math">\(I\)</span> are. The original unscaled
function <span class="math">\(u\)</span> depends on <span class="math">\(t\)</span>, <span class="math">\(b\)</span>, <span class="math">\(a\)</span>, and <span class="math">\(I\)</span>.</p>
<p>A second observation is striking: if <span class="math">\(b=0\)</span>, the scaled problem is
independent of <span class="math">\(a\)</span> and <span class="math">\(I\)</span>! In practice this means that we can perform
a single numerical simulation of the scaled problem and recover the
solution of any problem for a given <span class="math">\(a\)</span> and <span class="math">\(I\)</span> by stretching the axis
in the plot: <span class="math">\(u=I\bar u\)</span> and <span class="math">\(t =\bar t/a\)</span>.  For <span class="math">\(b\neq 0\)</span>, we
simulate the scaled problem for a few <span class="math">\(\beta\)</span> values and recover the
physical solution <span class="math">\(u\)</span> by translating and stretching the <span class="math">\(u\)</span> axis and
stretching the <span class="math">\(t\)</span> axis.</p>
<p>In general, scaling combines the parameters in a problem to a set
of dimensionless parameters. The number of dimensionless parameters is
usually much smaller than the number of original parameters.
The section <a class="reference internal" href="#decay-app-drag"><span class="std std-ref">Vertical motion of a body in a viscous fluid</span></a> presents an example where 11 parameters
are reduced to one!</p>
</div>
<div class="section" id="a-scaling-for-vanishing-initial-condition">
<h3>A scaling for vanishing initial condition<a class="headerlink" href="#a-scaling-for-vanishing-initial-condition" title="Permalink to this headline">¶</a></h3>
<p>The scaling breaks down if <span class="math">\(I=0\)</span>. In that case we may choose <span class="math">\(u_m=0\)</span>,
<span class="math">\(u_c=b/a\)</span>, and <span class="math">\(t_c=1/b\)</span>, resulting in a slightly different scaled problem:</p>
<div class="math">
\[\frac{d\bar u}{d\bar t} = 1 -\bar u,\quad \bar u(0)=0\tp\]</div>
<p>As with <span class="math">\(b=0\)</span>, the case <span class="math">\(I=0\)</span> has a scaled problem with no physical
parameters!</p>
<p>It is common to drop the bars after scaling and write the scaled
problem as <span class="math">\(u^{\prime}=-u\)</span>, <span class="math">\(u(0)=1-\beta\)</span>, or <span class="math">\(u^{\prime}=1-u\)</span>, <span class="math">\(u(0)=0\)</span>.
Any implementation of the problem <span class="math">\(u^{\prime}=-au+b\)</span>, <span class="math">\(u(0)=I\)</span>, can be
reused for the scaled problem by setting <span class="math">\(a=1\)</span>, <span class="math">\(b=0\)</span>, and <span class="math">\(I=1-\beta\)</span>
in the code, if <span class="math">\(I\neq 0\)</span>, or one sets
<span class="math">\(a=1\)</span>, <span class="math">\(b=1\)</span>, and <span class="math">\(I=0\)</span> when the physical <span class="math">\(I\)</span> is zero.
Falling bodies in fluids, as described in the section <a class="reference internal" href="#decay-app-drag"><span class="std std-ref">Vertical motion of a body in a viscous fluid</span></a>,
involves <span class="math">\(u^{\prime}=-au+b\)</span> with seven physical parameters. All these vanish
in the scaled version of the problem if we start the motion from rest!</p>
<p>Many more details about scaling is presented in
<a class="reference internal" href="._book010.html#ref09" id="id1">[Ref09]</a>.</p>
</div>
</div>
<div class="section" id="evolution-of-a-population">
<span id="decay-app-pop"></span><h2>Evolution of a population<a class="headerlink" href="#evolution-of-a-population" title="Permalink to this headline">¶</a></h2>
<div class="section" id="exponential-growth">
<span id="index-0"></span><h3>Exponential growth<a class="headerlink" href="#exponential-growth" title="Permalink to this headline">¶</a></h3>
<p>Let <span class="math">\(N\)</span> be the number of individuals in a population occupying some
spatial domain.  Despite <span class="math">\(N\)</span> being an integer in this problem, we
shall compute with <span class="math">\(N\)</span> as a real number and view <span class="math">\(N(t)\)</span> as a
continuous function of time.  The basic model assumption is that in a
time interval <span class="math">\(\Delta t\)</span> the number of newcomers to the populations
(newborns) is proportional to <span class="math">\(N\)</span>, with proportionality constant <span class="math">\(\bar
b\)</span>. The amount of newcomers will increase the population and result in</p>
<div class="math">
\[N(t+\Delta t) = N(t) + \bar bN(t)\tp\]</div>
<p>It is obvious that a long time interval <span class="math">\(\Delta t\)</span> will result in
more newcomers and hence a larger <span class="math">\(\bar b\)</span>. Therefore, we introduce
<span class="math">\(b=\bar b/\Delta t\)</span>: the number of newcomers per unit time and per
individual. We must then multiply <span class="math">\(b\)</span> by the length of the time
interval considered and by the population size to get the
total number of new individuals, <span class="math">\(b\Delta t N\)</span>.</p>
<p>If the number of removals from the population (deaths) is also
proportional to <span class="math">\(N\)</span>, with proportionality constant <span class="math">\(d\Delta t\)</span>,
the population evolves according to</p>
<div class="math">
\[N(t+\Delta t) = N(t) + b\Delta t N(t) - d\Delta t N(t)\tp\]</div>
<p>Dividing by <span class="math">\(\Delta t\)</span> and letting <span class="math">\(\Delta t \rightarrow 0\)</span>,
we get the ODE</p>
<div class="math">
\[N^{\prime} = (b-d)N,\quad N(0)=N_0\tp\]</div>
<p>In a population where the death rate (<span class="math">\(d\)</span>) is larger than
then newborn rate (<span class="math">\(b\)</span>), <span class="math">\(b-d &lt; 0\)</span>, and the population experiences
exponential decay rather than exponential growth.</p>
<p>In some populations there is an immigration of individuals into the
spatial domain. With <span class="math">\(I\)</span> individuals coming in per time unit,
the equation for the population change becomes</p>
<div class="math">
\[N(t+\Delta t) = N(t) + b\Delta t N(t) - d\Delta t N(t) + \Delta t I\tp\]</div>
<p>The corresponding ODE reads</p>
<div class="math">
\[N^{\prime} = (b-d)N + I,\quad N(0)=N_0
\tp\]</div>
<p>Emigration is also modeled by this <span class="math">\(I\)</span> term if we just change its sign: <span class="math">\(I &lt; 0\)</span>.
So, the <span class="math">\(I\)</span> term models migration in and out of the domain in general.</p>
<p>Some simplification arises if we introduce a fractional measure
of the population: <span class="math">\(u=N/N_0\)</span> and set <span class="math">\(r=b-d\)</span>. The ODE problem
now becomes</p>
<div class="math" id="equation-decay:app:pop:ueq">
<span id="eq-decay-app-pop-ueq"></span><span class="eqno">(1)</span>\[     u^{\prime} = ru + f,\quad u(0)=1,\]</div>
<p>where <span class="math">\(f=I/N_0\)</span> measures the net immigration per time unit as
the fraction of the initial population. Very often, <span class="math">\(r\)</span> is approximately
constant, but <span class="math">\(f\)</span> is usually a function of time.</p>
</div>
<div class="section" id="logistic-growth">
<h3>Logistic growth<a class="headerlink" href="#logistic-growth" title="Permalink to this headline">¶</a></h3>
<p id="index-1">The growth rate <span class="math">\(r\)</span> of a population decreases if the environment
has limited resources. Suppose the environment can sustain at
most <span class="math">\(N_{\max}\)</span> individuals. We may then assume that the growth rate
approaches zero as <span class="math">\(N\)</span> approaches <span class="math">\(N_{\max}\)</span>, i.e., as <span class="math">\(u\)</span> approaches
<span class="math">\(M=N_{\max}/N_0\)</span>. The simplest possible evolution of <span class="math">\(r\)</span> is then a
linear function: <span class="math">\(r(t)={\varrho}(1-u(t)/M)\)</span>, where <span class="math">\(\varrho\)</span>
is the initial growth rate when the population is small relative to the
maximum size and there is enough resources. Using this <span class="math">\(r(t)\)</span> in
<a href="#equation-decay:app:pop:ueq">(1)</a> results in the <em>logistic model</em> for the
evolution of a population (assuming for the moment that <span class="math">\(f=0\)</span>):</p>
<div class="math" id="equation-decay:app:pop:logistic">
<span id="eq-decay-app-pop-logistic"></span><span class="eqno">(2)</span>\[     u^{\prime} = {\varrho}(1-u/M)u,\quad u(0)=1
     \tp\]</div>
<p>Initially, <span class="math">\(u\)</span> will grow at rate <span class="math">\(\varrho\)</span>, but the growth will decay
as <span class="math">\(u\)</span> approaches <span class="math">\(M\)</span>, and then there is no more change in <span class="math">\(u\)</span>, causing
<span class="math">\(u\rightarrow M\)</span> as <span class="math">\(t\rightarrow\infty\)</span>.
Note that the logistic equation <span class="math">\(u^{\prime}={\varrho}(1-u/M)u\)</span> is <em>nonlinear</em> because
of the quadratic term <span class="math">\(-u^2{\varrho}/M\)</span>.</p>
</div>
</div>
<div class="section" id="compound-interest-and-inflation">
<span id="decay-app-interest"></span><h2>Compound interest and inflation<a class="headerlink" href="#compound-interest-and-inflation" title="Permalink to this headline">¶</a></h2>
<p>Say the annual interest rate is <span class="math">\(r\)</span> percent and that the bank
adds the interest once a year to your investment.
If <span class="math">\(u^n\)</span> is the investment in year <span class="math">\(n\)</span>, the investment in year <span class="math">\(u^{n+1}\)</span>
grows to</p>
<div class="math">
\[u^{n+1} = u^n + \frac{r}{100}u^n
\tp\]</div>
<p>In reality, the interest rate is added every day. We therefore introduce
a parameter <span class="math">\(m\)</span> for the number of periods per year when the interest
is added. If <span class="math">\(n\)</span> counts the periods, we have the fundamental model
for compound interest:</p>
<div class="math" id="equation-decay:app:interest:eq1">
<span id="eq-decay-app-interest-eq1"></span><span class="eqno">(3)</span>\[     u^{n+1} = u^n + \frac{r}{100 m}u^n
     \tp\]</div>
<p>This model is a <em>difference equation</em>, but it can be transformed to a
continuous differential equation through a limit process.
The first step is to derive a formula for the growth of the investment
over a time <span class="math">\(t\)</span>.
Starting with an investment <span class="math">\(u^0\)</span>, and assuming that <span class="math">\(r\)</span> is constant in time,
we get</p>
<div class="math">
\[\begin{split}u^{n+1} &amp;= \left(1 + \frac{r}{100 m}\right)u^{n}\\
&amp;= \left(1 + \frac{r}{100 m}\right)^2u^{n-1}\\
&amp;\ \ \vdots\\
&amp;= \left(1 +\frac{r}{100 m}\right)^{n+1}u^{0}\end{split}\]</div>
<p>Introducing time <span class="math">\(t\)</span>, which here is a real-numbered counter for years,
we have that <span class="math">\(n=mt\)</span>, so we can write</p>
<div class="math">
\[u^{mt} = \left(1 + \frac{r}{100 m}\right)^{mt} u^0\tp\]</div>
<p>The second step is to assume <em>continuous compounding</em>, meaning that the
interest is added continuously. This implies <span class="math">\(m\rightarrow\infty\)</span>, and
in the limit one gets the formula</p>
<div class="math">
\[u(t) = u_0e^{rt/100},\]</div>
<p>which is nothing but the solution of the ODE problem</p>
<div class="math" id="equation-decay:app:interest:eq2">
<span id="eq-decay-app-interest-eq2"></span><span class="eqno">(4)</span>\[     u^{\prime} = \frac{r}{100}u,\quad u(0)=u_0
     \tp\]</div>
<p>This is then taken as the ODE model for compound interest if <span class="math">\(r&gt;0\)</span>.
However, the reasoning applies equally well to inflation, which is
just the case <span class="math">\(r &lt; 0\)</span>.
One may also take the <span class="math">\(r\)</span> in <a href="#equation-decay:app:interest:eq2">(4)</a>
as the net growth of an investment, where <span class="math">\(r\)</span> takes both compound interest
and inflation into account. Note that for real applications we must
use a time-dependent <span class="math">\(r\)</span> in <a href="#equation-decay:app:interest:eq2">(4)</a>.</p>
<p>Introducing <span class="math">\(a=\frac{r}{100}\)</span>, continuous inflation of an initial
fortune <span class="math">\(I\)</span> is then
a process exhibiting exponential decay according to</p>
<div class="math">
\[u^{\prime} = -au,\quad u(0)=I\tp\]</div>
</div>
<div class="section" id="newton-s-law-of-cooling">
<span id="decay-app-newton-cooling"></span><h2>Newton&#8217;s law of cooling<a class="headerlink" href="#newton-s-law-of-cooling" title="Permalink to this headline">¶</a></h2>
<p>When a body at some temperature is placed in a cooling environment,
experience shows that the temperature falls rapidly in the beginning,
and then the change in temperature levels off until the body&#8217;s
temperature equals that of the surroundings. Newton carried out some
experiments on cooling hot iron and found that the temperature
evolved as a &#8220;geometric progression at times in arithmetic progression&#8221;,
meaning that the temperature decayed exponentially.
Later, this result was formulated as a differential equation:
the rate of change of the temperature in a body is proportional to
the temperature difference between the body and its surroundings.
This statement is known as <em>Newton&#8217;s law of cooling</em>, which
mathematically can be expressed as</p>
<div class="math" id="equation-decay:Newton:cooling">
<span id="eq-decay-newton-cooling"></span><span class="eqno">(5)</span>\[     {dT\over dt} = -k(T-T_s),\]</div>
<p>where <span class="math">\(T\)</span> is the temperature of the body, <span class="math">\(T_s\)</span> is the temperature
of the surroundings (which may be time-dependent),
<span class="math">\(t\)</span> is time, and <span class="math">\(k\)</span> is a positive constant.
Equation <a href="#equation-decay:Newton:cooling">(5)</a> is primarily viewed as an
empirical law, valid when heat is efficiently convected away
from the surface of the body by a flowing fluid such as air
at constant temperature <span class="math">\(T_s\)</span>.
The <em>heat transfer coefficient</em> <span class="math">\(k\)</span> reflects the transfer of
heat from the body to
the surroundings and must be determined from physical experiments.</p>
<p>The cooling law <a href="#equation-decay:Newton:cooling">(5)</a> needs an initial
condition <span class="math">\(T(0)=T_0\)</span>.</p>
</div>
<div class="section" id="radioactive-decay">
<span id="decay-app-nuclear"></span><h2>Radioactive decay<a class="headerlink" href="#radioactive-decay" title="Permalink to this headline">¶</a></h2>
<p id="index-2">An atomic nucleus of an unstable atom may lose energy by emitting
ionizing particles and thereby be transformed to a nucleus with a
different number of protons and neutrons.  This process is known as
<a class="reference external" href="http://en.wikipedia.org/wiki/Radioactive_decay">radioactive decay</a>.
Actually, the process is stochastic when viewed for a single atom,
because it is impossible to predict exactly when a particular atom
emits a particle. Nevertheless, with a large number of atoms, <span class="math">\(N\)</span>, one
may view the process as deterministic and compute the mean behavior of
the decay. Below we reason intuitively about an ODE for the mean
behavior. Thereafter, we show mathematically that a detailed stochastic model
for single atoms leads to the same mean behavior.</p>
<div class="section" id="deterministic-model">
<h3>Deterministic model<a class="headerlink" href="#deterministic-model" title="Permalink to this headline">¶</a></h3>
<p>Suppose at time <span class="math">\(t\)</span>, the number of the original atom type is <span class="math">\(N(t)\)</span>.
A basic model assumption is that the transformation of the atoms of the original
type in a small time interval <span class="math">\(\Delta t\)</span> is proportional to
<span class="math">\(N\)</span>, so that</p>
<div class="math">
\[N(t+\Delta t) = N(t) - a\Delta t N(t),\]</div>
<p>where <span class="math">\(a&gt;0\)</span> is a constant. Introducing <span class="math">\(u=N(t)/N(0)\)</span>, dividing by
<span class="math">\(\Delta t\)</span> and letting <span class="math">\(\Delta t\rightarrow 0\)</span> gives the
following ODE:</p>
<div class="math">
\[u^{\prime} = -au,\quad u(0)=1
\tp\]</div>
<p>The parameter <span class="math">\(a\)</span> can for a given nucleus be expressed through the
<em>half-life</em> <span class="math">\(t_{1/2}\)</span>, which is the time taken for the decay to reduce the
initial amount by one half, i.e., <span class="math">\(u(t_{1/2}) = 0.5\)</span>.
With <span class="math">\(u(t)=e^{-at}\)</span>, we get <span class="math">\(t_{1/2}=a^{-1}\ln 2\)</span> or <span class="math">\(a=\ln 2/t_{1/2}\)</span>.</p>
</div>
<div class="section" id="stochastic-model">
<h3>Stochastic model<a class="headerlink" href="#stochastic-model" title="Permalink to this headline">¶</a></h3>
<p>Originally, we have <span class="math">\(N_0\)</span> atoms. Up to some particular time <span class="math">\(t\)</span>, each
atom may either have decayed or not. If not, they have &#8220;survived&#8221;.
We want to count how many original
atoms that have survived.
The survival of a single atom at time <span class="math">\(t\)</span> is a random event. Since there
are only two outcomes, survival or decay, we have a
<a class="reference external" href="http://en.wikipedia.org/wiki/Bernoulli_trial">Bernoulli trial</a>.
Let <span class="math">\(p\)</span> be the
probability of survival (implying that the probability of decay
is <span class="math">\(1-p\)</span>). If each atom survives independently of
the others, and the probability of survival is the same for every
atom, we have <span class="math">\(N_0\)</span> Bernoulli trials, known as
a <em>binomial experiment</em> from probability theory.
The probability <span class="math">\(P(N)\)</span> that <span class="math">\(N\)</span> out
of the <span class="math">\(N_0\)</span> atoms have survived at time <span class="math">\(t\)</span> is then given by the
famous <em>binomial distribution</em></p>
<div class="math">
\[P(N) = \frac{N_0!}{N! (N_0-N)!}p^N (1-p)^{N_0-N}\tp\]</div>
<p>The mean (or expected) value <span class="math">\(\E{P}\)</span> of <span class="math">\(P(N)\)</span> is known to be <span class="math">\(N_0p\)</span>.</p>
<p>It remains to estimate <span class="math">\(p\)</span>. Let the interval <span class="math">\([0,t]\)</span> be divided into <span class="math">\(m\)</span>
small subintervals of length <span class="math">\(\Delta t\)</span>. We make the assumption that
the probability of decay of a single atom in an interval of length <span class="math">\(\Delta t\)</span>
is <span class="math">\(\tilde p\)</span>, and that this probability is proportional to <span class="math">\(\Delta t\)</span>:
<span class="math">\(\tilde p = \lambda\Delta t\)</span> (it sounds natural that the probability
of decay increases with <span class="math">\(\Delta t\)</span>). The corresponding probability of survival
is <span class="math">\(1-\lambda\Delta t\)</span>. Believing that <span class="math">\(\lambda\)</span> is independent
of time, we have, for each interval of length <span class="math">\(\Delta t\)</span>,
a Bernoulli trial: the atom either survives or
decays in that interval. Now, <span class="math">\(p\)</span> should be the probability that the atom
survives in all the intervals, i.e., that we have <span class="math">\(m\)</span> successful
Bernoulli trials in a row and therefore</p>
<div class="math">
\[p = (1-\lambda\Delta t)^m\tp\]</div>
<p>The expected number of atoms of the original type at time <span class="math">\(t\)</span> is</p>
<div class="math">
\[\E{P} = N_0p = N_0(1-\lambda\Delta t)^m,\quad m=t/\Delta t\tp\]</div>
<p>To see the relation between the two types of Bernoulli trials and the
ODE above, we go to the limit <span class="math">\(\Delta t\rightarrow t\)</span>, <span class="math">\(m\rightarrow\infty\)</span>.
One can show that</p>
<div class="math">
\[p = \lim_{m\rightarrow\infty} (1-\lambda\Delta t)^m
= \lim_{m\rightarrow\infty} \left(1-\lambda\frac{t}{m}\right)^m = e^{-\lambda t}\]</div>
<p>This is the famous exponential waiting time (or arrival time) distribution for a
Poisson process in probability theory (obtained here, as often done, as
the limit of a binomial experiment). The probability of decay,
<span class="math">\(1-e^{-\lambda t}\)</span>, follows an <a class="reference external" href="http://en.wikipedia.org/wiki/Exponential_distribution">exponential distribution</a>.
The limit means that <span class="math">\(m\)</span> is very
large, hence <span class="math">\(\Delta t\)</span> is very small, and <span class="math">\(\tilde p=\lambda\Delta t\)</span>
is very small since the intensity of the events, <span class="math">\(\lambda\)</span>, is assumed
finite. This situation corresponds to a very small probability
that an atom will decay in a very short time interval, which is a
reasonable model.
The same model occurs in lots of different applications, e.g.,
when waiting for a taxi, or when finding defects along a rope.</p>
</div>
<div class="section" id="relation-between-stochastic-and-deterministic-models">
<h3>Relation between stochastic and deterministic models<a class="headerlink" href="#relation-between-stochastic-and-deterministic-models" title="Permalink to this headline">¶</a></h3>
<p>With <span class="math">\(p=e^{-\lambda t}\)</span> we get the expected number of original atoms
at <span class="math">\(t\)</span> as <span class="math">\(N_0p=N_0e^{-\lambda t}\)</span>, which is exactly the solution of
the ODE model <span class="math">\(N^{\prime}=-\lambda N\)</span>. This also gives an interpretation
of <span class="math">\(a\)</span> via <span class="math">\(\lambda\)</span> or vice versa. Our important finding here
is that the ODE model
captures the mean behavior of the underlying stochastic model. This
is, however, not always the common relation between microscopic stochastic
models and macroscopic &#8220;averaged&#8221; models.</p>
<p>Also of interest, is that a Forward Euler discretization of
<span class="math">\(N^{\prime}=-\lambda N\)</span>, <span class="math">\(N(0)=N_0\)</span>, gives <span class="math">\(N^m = N_0(1-\lambda\Delta t)^m\)</span>
at time <span class="math">\(t_m=m\Delta t\)</span>, which is exactly the
expected value of the stochastic experiment with <span class="math">\(N_0\)</span> atoms
and <span class="math">\(m\)</span> small intervals of length <span class="math">\(\Delta t\)</span>, where each atom can
decay with probability <span class="math">\(\lambda\Delta t\)</span> in an interval.</p>
<p>A fundamental question is how accurate the ODE model is. The underlying
stochastic model fluctuates around its expected value. A measure
of the fluctuations is the standard deviation of the binomial experiment with
<span class="math">\(N_0\)</span> atoms, which can be shown to be <span class="math">\(\Std{P}=\sqrt{N_0p(1-p)}\)</span>. Compared
to the size of the expectation, we get
the normalized standard deviation</p>
<div class="math">
\[\frac{\sqrt{\Var{P}}}{\E{P}} = N_0^{-1/2}\sqrt{p^{-1}-1}
= N_0^{-1/2}\sqrt{(1-e^{-\lambda t})^{-1}-1}\approx
(N_0\lambda t)^{-1/2},\]</div>
<p>showing that the normalized fluctuations are very small if <span class="math">\(N_0\)</span> is
very large, which is usually the case.</p>
</div>
<div class="section" id="generalization-of-the-radioactive-decay-modeling">
<span id="decay-app-waitingtime"></span><h3>Generalization of the radioactive decay modeling<a class="headerlink" href="#generalization-of-the-radioactive-decay-modeling" title="Permalink to this headline">¶</a></h3>
<p>The modeling in the section <a class="reference internal" href="#decay-app-nuclear"><span class="std std-ref">Radioactive decay</span></a> is in fact very
general, despite a focus on a particular physical process. We may
instead of atoms and decay speak about a set of <em>items</em>, where each
item can undergo a stochastic <em>transition</em> from one state to
another. In the section <a class="reference internal" href="#decay-app-kinetics"><span class="std std-ref">Chemical kinetics</span></a> the item is a molecule and
the transition is a chemical reaction, while in the section <a class="reference internal" href="#decay-app-sir"><span class="std std-ref">Spreading of diseases</span></a> the item is an ill person and the transition is
recovering from the illness (or an immune person who loses her
immunity).</p>
<p>From the modeling in the section <a class="reference internal" href="#decay-app-nuclear"><span class="std std-ref">Radioactive decay</span></a> we can establish
a deterministic model for a large number of items and a stochastic
model for an arbitrary number of items, even a single one.
The stochastic model has a parameter <span class="math">\(\lambda\)</span> reflecting the
probability that a transition takes place in a time interval of
unit length (or equivalently, that the probability is <span class="math">\(\lambda\Delta t\)</span>
for a transition during a time interval of length <span class="math">\(\Delta t\)</span>).
The probability of making a transition before time <span class="math">\(t\)</span> is given by</p>
<div class="math">
\[F(t) = 1- e^{-\lambda t}\tp\]</div>
<p>The corresponding probability density is <span class="math">\(f(t)=F'(t)=e^{-\lambda t}\)</span>.
The expected value of <span class="math">\(F(t)\)</span>, i.e., the expected time to transition,
is <span class="math">\(\lambda^{-1}\)</span>. This interpretation of <span class="math">\(\lambda\)</span> makes it easy to
measure its value: just carry out a large number of experiments,
measure the time to transition, and take one over the average of these times as
an estimate of <span class="math">\(\lambda\)</span>.
The variance is <span class="math">\(\lambda^{-2}\)</span>.</p>
<p>The deterministic model counts how many items, <span class="math">\(N(t)\)</span>, that have
undergone the transition (on average), and <span class="math">\(N(t)\)</span> is governed by the ODE</p>
<div class="math">
\[N^{\prime} = -\lambda N(t),\quad N(0)=N_0\tp\]</div>
<p>[<strong>hpl 1</strong>: make sure transition is correctly interpreted: it is decay, while no transition is survival.]</p>
</div>
</div>
<div class="section" id="chemical-kinetics">
<span id="decay-app-kinetics"></span><h2>Chemical kinetics<a class="headerlink" href="#chemical-kinetics" title="Permalink to this headline">¶</a></h2>
<div class="section" id="irreversible-reaction-of-two-substances">
<span id="index-3"></span><h3>Irreversible reaction of two substances<a class="headerlink" href="#irreversible-reaction-of-two-substances" title="Permalink to this headline">¶</a></h3>
<p>Consider two chemical substances, A and B, and a chemical reaction that
turns A into B. In a small time interval, some of the
molecules of type A are transformed into molecules of B. This process is,
from a mathematical modeling point of view, equivalent to the
radioactive decay process described in the previous section. We can
therefore apply the same modeling approach. If <span class="math">\(N_A\)</span> is the number of
molecules of substance A, we have that <span class="math">\(N_A\)</span> is governed by the
differential equation</p>
<div class="math">
\[\frac{dN_A}{dt} = -kN_A,\]</div>
<p>where (the constant) <span class="math">\(k\)</span> is called the <em>rate constant</em> of the reaction.
Rather than using the number of molecules, we use the <em>concentration</em>
of molecules: <span class="math">\([A](t) = N_A(t)/N_A(0)\)</span>.
We see that <span class="math">\(d[A]/dt = N_A(0)^{-1} dN_A/dt\)</span>.
Replacing <span class="math">\(N_A\)</span> by <span class="math">\([A]\)</span> in the equation for <span class="math">\(N_A\)</span> leads to the equation
for the concentration <span class="math">\([A]\)</span>:</p>
<div class="math" id="equation-decay:app:kinetics:irrev:A">
<span id="eq-decay-app-kinetics-irrev-a"></span><span class="eqno">(6)</span>\[     \frac{d[A]}{dt} = -k[A],\quad t\in (0,T],\ [A](0)=A_0, \tp\]</div>
<p>Since substance A is transformed to substance B, we have that the concentration
of <span class="math">\([B]\)</span> grows by the loss of <span class="math">\([A]\)</span>:</p>
<div class="math">
\[\frac{d[B]}{dt} = k[A],\quad [B](0)=B_0\tp\]</div>
<p>The mathematical model can either be <a href="#equation-decay:app:kinetics:irrev:A">(6)</a> or
the system</p>
<div class="math">
\[\frac{d[A]}{dt} = -k[A], t\in (0,T]\]</div>
<div class="math">
\[\frac{d[B]}{dt} = k[A], t\in (0,T]\]</div>
<div class="math">
\[[A](0) = A_0,\]</div>
<div class="math">
\[[B](0) = B_0\tp\]</div>
<p>This reaction is known as a <em>first-order reaction</em>, where each molecule of
A makes an independent decision about whether to complete the reaction,
i.e., independent of what happens to any other molecule.</p>
<p>An <span class="math">\(n\)</span>-th order reaction is modeled by</p>
<div class="math">
\[\frac{d[A]}{dt} = -k[A]^n,\]</div>
<div class="math">
\[\frac{d[B]}{dt} = k[A]^n,\]</div>
<p>for <span class="math">\(t\in (0,T]\)</span> with initial conditions <span class="math">\([A](0) = A_0\)</span> and
<span class="math">\([B](0) = B_0\)</span>. Here, <span class="math">\(n\)</span> can be a real number,
but is most often an integer. Note that
the sum of the concentrations is constant since</p>
<div class="math">
\[\frac{d[A]}{dt} + \frac{d[B]}{dt} = 0\quad\Rightarrow\quad
[A](t) + [B](t) = \hbox{const} \quad\Rightarrow\quad [A](t) + [B](t) = [A](0) + [B](0) = A_0+B_0\tp\]</div>
</div>
<div class="section" id="reversible-reaction-of-two-substances">
<span id="index-4"></span><h3>Reversible reaction of two substances<a class="headerlink" href="#reversible-reaction-of-two-substances" title="Permalink to this headline">¶</a></h3>
<p>Let the chemical reaction turn substance A into B and substance B into A.
The rate of change of <span class="math">\([A]\)</span> has then two contributions: a loss <span class="math">\(k_A[A]\)</span>
and a gain <span class="math">\(k_B[B]\)</span>:</p>
<div class="math">
\[\frac{d[A]}{dt} = -k_A[A] + k_B[B], \quad t\in (0,T],\ [A](0)=A_0\tp\]</div>
<p>Similarly for substance B,</p>
<div class="math">
\[\frac{d[A]}{dt} = k_A[A] - k_B[B], \quad t\in (0,T],\ [A](0)=A_0\tp\]</div>
<p>Again,</p>
<div class="math">
\[\frac{d[A]}{dt} + \frac{d[B]}{dt} = 0\quad\Rightarrow\quad
[A](t) + [B](t) = A_0+B_0\tp\]</div>
</div>
<div class="section" id="irreversible-reaction-of-two-substances-into-a-third">
<h3>Irreversible reaction of two substances into a third<a class="headerlink" href="#irreversible-reaction-of-two-substances-into-a-third" title="Permalink to this headline">¶</a></h3>
<p>Now we consider two chemical substances, A and B, reacting with each
other and producing a substance C. In a small time interval <span class="math">\(\Delta t\)</span>,
molecules of type A and B are occasionally colliding, and in some
of the collisions, a chemical reaction occurs, which turns A and B into
a molecule of type C. (More generally, <span class="math">\(M_A\)</span> molecules of A and <span class="math">\(M_B\)</span>
molecules of B react to form <span class="math">\(M_C\)</span> molecules of <span class="math">\(C\)</span>.)
The number of possible pairings, and thereby collisions, of A and B is
<span class="math">\(N_AN_B\)</span>, where <span class="math">\(N_A\)</span> is the number of molecules of A, and <span class="math">\(N_B\)</span> is the
number of molecules of <span class="math">\(N_B\)</span>.
A fraction <span class="math">\(k\)</span> of these collisions,
<span class="math">\(\hat k\Delta t N_AN_B\)</span>, features a chemical reaction and produce
<span class="math">\(N_C\)</span> molecules of C. The fraction is thought to be proportional to
<span class="math">\(\Delta t\)</span>: considering a twice as long time interval, twice as many
molecules collide, and twice as many reactions occur.
The increase in molecules of substance C is now found
from the reasoning</p>
<div class="math">
\[N_C(t+\Delta t) = N_C(t) + \hat k\Delta t N_AN_B\tp\]</div>
<p>Dividing by <span class="math">\(\Delta t\)</span>,</p>
<div class="math">
\[\frac{N_C(t+\Delta t) - N_C(t)}{\Delta t} = \hat k N_AN_B,\]</div>
<p>and letting <span class="math">\(\Delta t\rightarrow 0\)</span>, gives the differential equation</p>
<div class="math">
\[\frac{dN_C}{dt} = \hat k N_AN_B\tp\]</div>
<p>(This equation is known as the important &#8220;law of mass action&#8221; discovered by
the Norwegian scientists Cato M.&nbsp;Guldberg and Peter Waage.
A more general form of the right-hand side is <span class="math">\(\hat kN_A^{\alpha}N_B^{\beta}\)</span>.
All the constants <span class="math">\(\hat k\)</span>, <span class="math">\(\alpha\)</span>, and <span class="math">\(\beta\)</span> must be determined from
experiments.)</p>
<p>Working with concentrations instead, we introduce <span class="math">\([C](t)=N_C(t)/N_C(0)\)</span>,
with similar definitions for <span class="math">\([A]\)</span> and <span class="math">\([B]\)</span> we get</p>
<div class="math">
\[\frac{d[C]}{dt} = k [A][B]\tp\]</div>
<p>The constant <span class="math">\(k\)</span> is related to <span class="math">\(\hat k\)</span> by <span class="math">\(k = \hat k N_A(0)N_B(0)/N_C(0)\)</span>.
The gain in C is a loss of A and B:</p>
<div class="math">
\[\frac{d[A]}{dt} = -k[A][B],\]</div>
<div class="math">
\[\frac{d[B]}{dt} = -k[A][B]\tp\]</div>
</div>
<div class="section" id="a-biochemical-reaction">
<h3>A biochemical reaction<a class="headerlink" href="#a-biochemical-reaction" title="Permalink to this headline">¶</a></h3>
<p>A common reaction (known as <a class="reference external" href="https://en.wikipedia.org/wiki/Michaelis-Menten_kinetics">Michaelis-Menton kinetics</a>) turns a substrate S into
a product P with aid of an enzyme E. The reaction is a two-stage process:
first S and E reacts to form a complex ES, where the enzyme and substrate
are bound to each other, and then ES is turned into E and P.
In the first stage, S and E react to produce a growth of ES according
to the law of mass action:</p>
<div class="math">
\[\begin{split}\frac{d[S]}{dt} &amp;= - k_+[E][S],\\
\frac{d[P]}{dt} &amp;= - k_+[E][S],\\
\frac{d[ES]}{dt} &amp;= k_+[E][S]\tp\\\end{split}\]</div>
<p>The complex ES reacts and produces the product <span class="math">\(P\)</span> at rate
<span class="math">\(-k_{v}[ES]\)</span> and E at rate <span class="math">\(-k_-[ES]\)</span>. The total set of reactions can
then be expressed by</p>
<div class="math" id="equation-decay:app:MMK:ES1">
<span id="eq-decay-app-mmk-es1"></span><span class="eqno">(7)</span>\[     \frac{d[ES]}{dt} = k_+[E][S] - k_v[ES] - k_-[ES],\]</div>
<div class="math" id="equation-decay:app:MMK:P1">
<span id="eq-decay-app-mmk-p1"></span><span class="eqno">(8)</span>\[     \frac{d[P]}{dt} = k_v[ES],\]</div>
<div class="math" id="equation-decay:app:MMK:S1">
<span id="eq-decay-app-mmk-s1"></span><span class="eqno">(9)</span>\[     \frac{d[S]}{dt} = -k_+[E][S] + k_-[ES],\]</div>
<div class="math" id="equation-decay:app:MMK:E1">
<span id="eq-decay-app-mmk-e1"></span><span class="eqno">(10)</span>\[     \frac{d[E]}{dt} = -k_+[E][S] + k_-[ES] + k_v[ES]\tp\]</div>
<p>The initial conditions are <span class="math">\([ES](0)=[P](0)=0\)</span>, and <span class="math">\([S]=S_0\)</span>, <span class="math">\([E]=E_0\)</span>.
The constants <span class="math">\(k_+\)</span>, <span class="math">\(k_-\)</span>, and <span class="math">\(k_v\)</span> must be determined from experiments.</p>
</div>
</div>
<div class="section" id="spreading-of-diseases">
<span id="decay-app-sir"></span><h2>Spreading of diseases<a class="headerlink" href="#spreading-of-diseases" title="Permalink to this headline">¶</a></h2>
<p>The modeling of spreading of diseases is very similar to the modeling
of chemical reactions in the section <a class="reference internal" href="#decay-app-kinetics"><span class="std std-ref">Chemical kinetics</span></a>. The field
of epidemiology speaks about susceptibles: people who can get a disease;
infectives: people who are infected and can infect susceptibles; and
recovered: people who have recovered from the disease and
become immune.
Three categories are accordingly defined: S for susceptibles, I for
infectives, and R for recovered. The number in each category is tracked
by the functions <span class="math">\(S(t)\)</span>, <span class="math">\(I(t)\)</span>, and <span class="math">\(R(t)\)</span>.</p>
<p>To model how many people that get infected in a small time interval
<span class="math">\(\Delta t\)</span>, we reason as with reactions in the section <a class="reference internal" href="#decay-app-kinetics"><span class="std std-ref">Chemical kinetics</span></a>.
The possible number of parings (&#8220;collisions&#8221;) between susceptibles
and infected is <span class="math">\(SI\)</span>. A fraction of these, <span class="math">\(\beta\Delta t SI\)</span>,
will actually meet and the infected succeeds of infecting the susceptible,
where <span class="math">\(\beta\)</span> is a parameter to be empirically estimated.
This leads to a loss of susceptibles and a gain of infected:</p>
<div class="math">
\[\begin{split}S(t+\Delta t) &amp;= S(t) - \beta\Delta tSI,\\
I(t+\Delta t) &amp;= I(t) + \beta\Delta tSI\tp\end{split}\]</div>
<p>In the same time interval, a fraction <span class="math">\(\nu\Delta t I\)</span>
of the infected is recovered.
It follows from the section <a class="reference internal" href="#decay-app-waitingtime"><span class="std std-ref">Generalization of the radioactive decay modeling</span></a>
that the parameter <span class="math">\(\nu^{-1}\)</span> has the interpretation as the average
waiting time to leave the I category, i.e., the
average length of the disease.
The <span class="math">\(\nu \Delta tI\)</span> term is a loss for the I category, but a gain for the R
category:</p>
<div class="math">
\[\begin{split}I(t+\Delta t) &amp;= I(t) + \beta\Delta tSI - \nu\Delta t I,
R(t+\Delta t) &amp;= R(t) + \nu\Delta t I\tp\end{split}\]</div>
<p>Dividing these equations by <span class="math">\(\Delta t\)</span> and going to the limit
<span class="math">\(\Delta t\rightarrow 0\)</span>, gives the ODE system</p>
<div class="math" id="equation-decay:app:SIR:S">
<span id="eq-decay-app-sir-s"></span><span class="eqno">(11)</span>\[     \frac{dS}{dt} = -\beta SI,\]</div>
<div class="math" id="equation-decay:app:SIR:I">
<span id="eq-decay-app-sir-i"></span><span class="eqno">(12)</span>\[     \frac{dI}{dt} =  \beta SI - \nu I,\]</div>
<div class="math" id="equation-decay:app:SIR:R">
<span id="eq-decay-app-sir-r"></span><span class="eqno">(13)</span>\[     \frac{dR}{dt} = \nu I,\]</div>
<p>with initial values <span class="math">\(S(0)=S_0\)</span>, <span class="math">\(I(0)=I_0\)</span>, and <span class="math">\(R(0)=0\)</span>.
By adding the equations, we realize that</p>
<div class="math">
\[\frac{dS}{dt}+\frac{dI}{dt}+\frac{dR}{dt}=0\quad\Rightarrow\quad
S+I+R=\hbox{const}=N,\]</div>
<p>where <span class="math">\(N\)</span> is the total number in the population under consideration.
This property can be used as a partial verification during simulations.</p>
<p>Equations <a href="#equation-decay:app:SIR:S">(11)</a>-<a href="#equation-decay:app:SIR:R">(13)</a> are known as
the SIR model in epidemiology. The model can easily be extended to
incorporate vaccination programs, loss immunity after some time, etc.
Typical diseases that can be simulated by the SIR model and its variants
are measles, smallpox, flu, plague, and HIV.</p>
<p>[<strong>hpl 2</strong>: Should include predator-pray too, at least in an exercise.]</p>
</div>
<div class="section" id="decay-of-atmospheric-pressure-with-altitude">
<span id="decay-app-atm"></span><h2>Decay of atmospheric pressure with altitude<a class="headerlink" href="#decay-of-atmospheric-pressure-with-altitude" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-general-model">
<h3>The general model<a class="headerlink" href="#the-general-model" title="Permalink to this headline">¶</a></h3>
<p>Vertical equilibrium of air in the atmosphere is governed by
the equation</p>
<div class="math" id="equation-decay:app:atm:dpdz">
<span id="eq-decay-app-atm-dpdz"></span><span class="eqno">(14)</span>\[     \frac{dp}{dz} = -\varrho g
     \tp\]</div>
<p>Here, <span class="math">\(p(z)\)</span> is the air pressure, <span class="math">\(\varrho\)</span> is the density of
air, and <span class="math">\(g=9.807\hbox{ m/s}^2\)</span> is a standard value of
the acceleration of gravity.
(Equation <a href="#equation-decay:app:atm:dpdz">(14)</a> follows directly from the general
Navier-Stokes equations for fluid motion, with
the assumption that the air does not move.)</p>
<p>The pressure is related to density and temperature through the ideal gas law</p>
<div class="math" id="equation-decay:app:atm:rho">
<span id="eq-decay-app-atm-rho"></span><span class="eqno">(15)</span>\[     \varrho = \frac{Mp}{R^*T},\]</div>
<p>where <span class="math">\(M\)</span> is the molar mass of the Earth&#8217;s air (0.029 kg/mol),
<span class="math">\(R^*\)</span> is the universal
gas constant (<span class="math">\(8.314\)</span> Nm/(mol K)), and <span class="math">\(T\)</span> is the temperature in Kelvin.
All variables <span class="math">\(p\)</span>, <span class="math">\(\varrho\)</span>, and <span class="math">\(T\)</span> vary with the height <span class="math">\(z\)</span>.
Inserting <a href="#equation-decay:app:atm:rho">(15)</a> in <a href="#equation-decay:app:atm:dpdz">(14)</a> results
in an ODE with a variable coefficient:</p>
<div class="math" id="equation-decay:app:atm:ode">
<span id="eq-decay-app-atm-ode"></span><span class="eqno">(16)</span>\[     \frac{dp}{dz} = -\frac{Mg}{R^*T(z)} p\]\[     \thinspace  .\]</div>
</div>
<div class="section" id="multiple-atmospheric-layers">
<h3>Multiple atmospheric layers<a class="headerlink" href="#multiple-atmospheric-layers" title="Permalink to this headline">¶</a></h3>
<p>The atmosphere can be approximately modeled by seven layers.
In each layer, <a href="#equation-decay:app:atm:ode">(16)</a> is applied with
a linear temperature of the form</p>
<div class="math">
\[T(z) = \bar T_i + L_i(z-h_i),\]</div>
<p>where <span class="math">\(z=h_i\)</span> denotes the bottom of layer number <span class="math">\(i\)</span>,
having temperature <span class="math">\(\bar T_i\)</span>,
and <span class="math">\(L_i\)</span> is a constant in layer number <span class="math">\(i\)</span>. The table below
lists <span class="math">\(h_i\)</span> (m), <span class="math">\(\bar T_i\)</span> (K), and <span class="math">\(L_i\)</span> (K/m) for the layers
<span class="math">\(i=0,\ldots,6\)</span>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="23%" />
<col width="34%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><span class="math">\(i\)</span></th>
<th class="head"><span class="math">\(h_i\)</span></th>
<th class="head"><span class="math">\(\bar T_i\)</span></th>
<th class="head"><span class="math">\(L_i\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>0</td>
<td>288</td>
<td>-0.0065</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>11,000</td>
<td>216</td>
<td>0.0</td>
</tr>
<tr class="row-even"><td>2</td>
<td>20,000</td>
<td>216</td>
<td>0.001</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>32,000</td>
<td>228</td>
<td>0.0028</td>
</tr>
<tr class="row-even"><td>4</td>
<td>47,000</td>
<td>270</td>
<td>0.0</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>51,000</td>
<td>270</td>
<td>-0.0028</td>
</tr>
<tr class="row-even"><td>6</td>
<td>71,000</td>
<td>214</td>
<td>-0.002</td>
</tr>
</tbody>
</table>
<p>For implementation it might be convenient to write <a href="#equation-decay:app:atm:ode">(16)</a>
on the form</p>
<div class="math">
\[\frac{dp}{dz} = -\frac{Mg}{R^*(\bar T(z) + L(z)(z-h(z)))} p,\]</div>
<p>where <span class="math">\(\bar T(z)\)</span>, <span class="math">\(L(z)\)</span>, and <span class="math">\(h(z)\)</span> are piecewise constant
functions with values given in the table.
The value of the pressure at the sea level <span class="math">\(z=0\)</span>, <span class="math">\(p_0=p(0)\)</span>, is <span class="math">\(101325\)</span> Pa.</p>
</div>
<div class="section" id="simplifications">
<h3>Simplifications<a class="headerlink" href="#simplifications" title="Permalink to this headline">¶</a></h3>
<div class="section" id="constant-layer-temperature">
<h4>Constant layer temperature<a class="headerlink" href="#constant-layer-temperature" title="Permalink to this headline">¶</a></h4>
<p>One common simplification is to assume that the temperature is
constant within each layer. This means that <span class="math">\(L=0\)</span>.</p>
</div>
<div class="section" id="one-layer-model">
<h4>One-layer model<a class="headerlink" href="#one-layer-model" title="Permalink to this headline">¶</a></h4>
<p>Another commonly used approximation is to work with one layer instead of
seven. This <a class="reference external" href="http://en.wikipedia.org/wiki/Density_of_air">one-layer model</a>
is based on <span class="math">\(T(z)=T_0 - Lz\)</span>, with
sea level standard temperature <span class="math">\(T_0=288\)</span> K and
temperature lapse rate <span class="math">\(L=0.0065\)</span> K/m.</p>
</div>
</div>
</div>
<div class="section" id="compaction-of-sediments">
<span id="decay-app-sediment"></span><h2>Compaction of sediments<a class="headerlink" href="#compaction-of-sediments" title="Permalink to this headline">¶</a></h2>
<p>Sediments, originally made from materials like sand and mud, get
compacted through geological time by the weight of new material that
is deposited on the sea bottom. The porosity <span class="math">\(\phi\)</span> of the sediments
tells how much void (fluid) space there is between the sand and
mud grains. The porosity drops with depth, due to the weight of
the sediments above. This makes the void space shrink, and thereby compaction
increases.</p>
<p>A typical assumption is that the change in <span class="math">\(\phi\)</span> at some depth <span class="math">\(z\)</span>
is negatively proportional to <span class="math">\(\phi\)</span>. This assumption leads to
the differential equation problem</p>
<div class="math" id="equation-decay:app:sediment:phi:eq">
<span id="eq-decay-app-sediment-phi-eq"></span><span class="eqno">(17)</span>\[     \frac{d\phi}{dz} = -c\phi,\quad \phi(0)=\phi_0,\]</div>
<p>where the <span class="math">\(z\)</span> axis points downwards, <span class="math">\(z=0\)</span> is the surface with known
porosity, and <span class="math">\(c&gt;0\)</span> is a constant.</p>
<p>The upper part of the Earth&#8217;s crust consists of many geological layers
stacked on top of each other, as indicated in Figure
<a class="reference internal" href="#decay-app-sediment-fig-layers"><span class="std std-ref">Illustration of the compaction of geological layers (with different colors) through time</span></a>.  The model
<a href="#equation-decay:app:sediment:phi:eq">(17)</a> can be applied for each layer. In
layer number <span class="math">\(i\)</span>, we have the unknown porosity function <span class="math">\(\phi_i(z)\)</span>
fulfilling <span class="math">\(\phi_i^{\prime}(z)=-c_iz\)</span>, since the constant <span class="math">\(c\)</span> in the model
<a href="#equation-decay:app:sediment:phi:eq">(17)</a> depends on the type of sediment in
the layer. Alternatively, we can use <a href="#equation-decay:app:sediment:phi:eq">(17)</a>
to describe the porosity through all layers if <span class="math">\(c\)</span> is taken as a
piecewise constant function of <span class="math">\(z\)</span>, equal to <span class="math">\(c_i\)</span> in layer <span class="math">\(i\)</span>.
From the figure we see that new layers of sediments are
deposited on top of older ones as time progresses. The compaction,
as measured by <span class="math">\(\phi\)</span>, is
rapid in the beginning and then decreases (exponentially) with depth
in each layer.</p>
<div class="figure" id="id4">
<span id="decay-app-sediment-fig-layers"></span><a class="reference internal image-reference" href="_images/Compaction_of_Sediment.png"><img alt="_images/Compaction_of_Sediment.png" src="_images/Compaction_of_Sediment.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Illustration of the compaction of geological layers (with different colors) through time</em></span></p>
</div>
<p>When we drill a well at present time through the right-most column of
sediments in Figure <a class="reference internal" href="#decay-app-sediment-fig-layers"><span class="std std-ref">Illustration of the compaction of geological layers (with different colors) through time</span></a>, we can measure
the thickness of the sediment in (say) the bottom layer. Let <span class="math">\(L_1\)</span> be
this thickness.  Assuming that the volume of sediment remains constant
through time, we have that the initial volume, <span class="math">\(\int_0^{L_{1,0}}
\phi_1 dz\)</span>, must equal the volume seen today,
<span class="math">\(\int_{\ell-L_1}^{\ell}\phi_1 dz\)</span>, where <span class="math">\(\ell\)</span> is the depth of the
bottom of the sediment in the present day configuration.  After having
solved for <span class="math">\(\phi_1\)</span> as a function of <span class="math">\(z\)</span>, we can then find the
original thickness <span class="math">\(L_{1,0}\)</span> of the sediment from the equation</p>
<div class="math">
\[\int_0^{L_{1,0}} \phi_1 dz = \int_{\ell-L_1}^{\ell}\phi_1 dz \tp\]</div>
<p>In hydrocarbon exploration it is important to know <span class="math">\(L_{1,0}\)</span> and the
compaction history of the various layers of sediments.</p>
</div>
<div class="section" id="vertical-motion-of-a-body-in-a-viscous-fluid">
<span id="decay-app-drag"></span><h2>Vertical motion of a body in a viscous fluid<a class="headerlink" href="#vertical-motion-of-a-body-in-a-viscous-fluid" title="Permalink to this headline">¶</a></h2>
<p>A body moving vertically through a fluid (liquid or gas) is subject to
three different types of forces: the gravity force, <a class="reference external" href="http://en.wikipedia.org/wiki/Drag_(physics)">the drag force</a>,
and the buoyancy force.</p>
<div class="section" id="overview-of-forces">
<h3>Overview of forces<a class="headerlink" href="#overview-of-forces" title="Permalink to this headline">¶</a></h3>
<p>Taking the upward direction as positive,
the gravity force is <span class="math">\(F_g= -mg\)</span>, where <span class="math">\(m\)</span> is the mass of the body and
<span class="math">\(g\)</span> is the acceleration of gravity.
The uplift or buoyancy force (&#8220;Archimedes force&#8221;) is <span class="math">\(F_b = \varrho gV\)</span>,
where <span class="math">\(\varrho\)</span> is the density of the fluid and
<span class="math">\(V\)</span> is the volume of the body.</p>
<p>The drag force is of two types, depending on the Reynolds number</p>
<div class="math">
\[\hbox{Re} = \frac{\varrho d|v|}{\mu},\]</div>
<p>where <span class="math">\(d\)</span> is the diameter of the body in
the direction perpendicular to the flow, <span class="math">\(v\)</span> is the velocity of the
body, and <span class="math">\(\mu\)</span> is the dynamic viscosity of the fluid.
When <span class="math">\(\hbox{Re} &lt; 1\)</span>, the drag force is fairly well modeled by
the so-called Stokes&#8217; drag,
which for a spherical body of diameter <span class="math">\(d\)</span> reads</p>
<div class="math">
\[F_d^{(S)} = - 3\pi d\mu v
\tp\]</div>
<p>Quantities are taken as positive in the upwards vertical direction, so
if <span class="math">\(v&gt;0\)</span> and the body moves upwards, the drag force acts downwards and
become negative, in accordance with the minus sign in expression for
<span class="math">\(F_d^{(S)}\)</span>.</p>
<p>For large Re, typically <span class="math">\(\hbox{Re} &gt; 10^3\)</span>, the drag force is quadratic
in the velocity:</p>
<div class="math">
\[F_d^{(q)} = -{1\over2}C_D\varrho A|v|v,\]</div>
<p>where <span class="math">\(C_D\)</span> is a dimensionless drag coefficient depending on the body&#8217;s shape,
and <span class="math">\(A\)</span> is the cross-sectional area as
produced by a cut plane, perpendicular to the motion, through the thickest
part of the body. The superscripts <span class="math">\(\,{}^q\)</span> and <span class="math">\(\,{}^S\)</span> in
<span class="math">\(F_d^{(S)}\)</span> and <span class="math">\(F_d^{(q)}\)</span> indicate Stokes drag and quadratic drag,
respectively.</p>
</div>
<div class="section" id="equation-of-motion">
<h3>Equation of motion<a class="headerlink" href="#equation-of-motion" title="Permalink to this headline">¶</a></h3>
<p>All the mentioned forces act in the vertical direction.
Newton&#8217;s second law of motion applied to the body says that the sum of
these forces must equal the mass of the body times its acceleration
<span class="math">\(a\)</span> in the vertical direction.</p>
<div class="math">
\[ma = F_g + F_d^{(S)} + F_b \tp\]</div>
<p>Here we have chosen to model the fluid resistance by the Stokes drag.
Inserting the expressions for the forces yields</p>
<div class="math">
\[ma = -mg - 3\pi d\mu v + \varrho gV
\tp\]</div>
<p>The unknowns here are <span class="math">\(v\)</span> and <span class="math">\(a\)</span>, i.e., we have two unknowns but only
one equation. From kinematics in physics we know that
the acceleration is the time derivative of the velocity: <span class="math">\(a = dv/dt\)</span>.
This is our second equation.
We can easily eliminate <span class="math">\(a\)</span> and get a single differential equation for <span class="math">\(v\)</span>:</p>
<div class="math">
\[m{dv\over dt} = -mg - 3\pi d\mu v + \varrho gV
\tp\]</div>
<p>A small rewrite of this equation is handy: We express <span class="math">\(m\)</span> as <span class="math">\(\varrho_bV\)</span>,
where <span class="math">\(\varrho_b\)</span> is the density of the body, and we divide by
the mass to get</p>
<div class="math" id="equation-decay:app:fallingbody:model:S">
<span id="eq-decay-app-fallingbody-model-s"></span><span class="eqno">(18)</span>\[     v^{\prime}(t) = - \frac{3\pi d\mu}{\varrho_b V} v + g\left(\frac{\varrho}{\varrho_b} -1\right)\]\[     \tp\]</div>
<p>We may introduce the constants</p>
<div class="math">
\[a = \frac{3\pi d\mu}{\varrho_b V},\quad
b = g\left(\frac{\varrho}{\varrho_b} -1\right),\]</div>
<p>so that the structure of the differential equation becomes obvious:</p>
<div class="math" id="equation-decay:app:fallingbody:gmodel:S">
<span id="eq-decay-app-fallingbody-gmodel-s"></span><span class="eqno">(19)</span>\[     v^{\prime}(t) = -av(t) + b\]\[     \tp\]</div>
<p>The corresponding initial condition is <span class="math">\(v(0)=v_0\)</span> for some prescribed
starting velocity <span class="math">\(v_0\)</span>.</p>
<p>This derivation can be repeated with the quadratic drag force
<span class="math">\(F_d^{(q)}\)</span>, leading to the result</p>
<div class="math" id="equation-decay:app:fallingbody:model:q">
<span id="eq-decay-app-fallingbody-model-q"></span><span class="eqno">(20)</span>\[     v^{\prime}(t) =
     -{1\over2}C_D{\varrho A\over\varrho_b V}|v|v +
     g\left({\varrho\over\varrho_b} - 1\right)
     \tp\]</div>
<p>Defining</p>
<div class="math">
\[a = {1\over2}C_D{\varrho A\over\varrho_b V},\]</div>
<p>and <span class="math">\(b\)</span> as above, we can write <a href="#equation-decay:app:fallingbody:model:q">(20)</a> as</p>
<div class="math" id="equation-decay:app:fallingbody:gmodel:q">
<span id="eq-decay-app-fallingbody-gmodel-q"></span><span class="eqno">(21)</span>\[     v^{\prime}(t) = -a|v|v + b
     \tp\]</div>
</div>
<div class="section" id="terminal-velocity">
<span id="index-5"></span><h3>Terminal velocity<a class="headerlink" href="#terminal-velocity" title="Permalink to this headline">¶</a></h3>
<p>An interesting aspect of <a href="#equation-decay:app:fallingbody:gmodel:S">(19)</a> and
<a href="#equation-decay:app:fallingbody:gmodel:q">(21)</a> is whether <span class="math">\(v\)</span> will approach
a final constant value,
the so-called <em>terminal velocity</em> <span class="math">\(v_T\)</span>, as <span class="math">\(t\rightarrow\infty\)</span>.
A constant <span class="math">\(v\)</span> means that
<span class="math">\(v^{\prime}(t)\rightarrow 0\)</span> as <span class="math">\(t\rightarrow\infty\)</span> and therefore
the terminal velocity <span class="math">\(v_T\)</span> solves</p>
<div class="math">
\[0 = -av_T + b\]</div>
<p>and</p>
<div class="math">
\[0 = -a|v_T|v_T + b\tp\]</div>
<p>The former equation implies <span class="math">\(v_T = b/a\)</span>, while the latter has solutions
<span class="math">\(v_T =-\sqrt{|b|/a}\)</span> for a falling body (<span class="math">\(v_T &lt; 0\)</span>) and
<span class="math">\(v_T = \sqrt{b/a}\)</span> for a rising body (<span class="math">\(v_T&gt;0\)</span>).</p>
</div>
<div class="section" id="a-crank-nicolson-scheme">
<h3>A Crank-Nicolson scheme<a class="headerlink" href="#a-crank-nicolson-scheme" title="Permalink to this headline">¶</a></h3>
<p>Both governing equations, the Stokes&#8217; drag model
<a href="#equation-decay:app:fallingbody:gmodel:S">(19)</a> and the quadratic drag model
<a href="#equation-decay:app:fallingbody:gmodel:q">(21)</a>, can be readily solved
by the Forward Euler scheme. For higher accuracy one can use
the Crank-Nicolson method, but a straightforward application
of this method gives
a nonlinear equation in the new unknown value <span class="math">\(v^{n+1}\)</span> when applied to
<a href="#equation-decay:app:fallingbody:gmodel:q">(21)</a>:</p>
<div class="math" id="equation-decay:app:fallingbody:gmodel:CN">
<span id="eq-decay-app-fallingbody-gmodel-cn"></span><span class="eqno">(22)</span>\[     \frac{v^{n+1}-v^n}{\Delta t}
     = -a\half(|v^{n+1}|v^{n+1} + |v^n|v^n) + b\]\[     \tp\]</div>
<p>The first term on the right-hand side of <a href="#equation-decay:app:fallingbody:gmodel:CN">(22)</a>
is the arithmetic average of <span class="math">\(-|v|v\)</span> evaluated at time levels <span class="math">\(n\)</span> and <span class="math">\(n+1\)</span>.</p>
<p>Instead of approximating the term <span class="math">\(-|v|v\)</span> by an arithmetic
average, we can use a <em>geometric mean</em>:</p>
<span class="target" id="index-6"></span><div class="math" id="index-7">
\[(|v|v)^{n+\half} \approx |v^n|v^{n+1}
\tp\]</div>
<p>The error is of second order in <span class="math">\(\Delta t\)</span>, just as for the arithmetic
average and the centered finite difference approximation in
<a href="#equation-decay:app:fallingbody:gmodel:CN">(22)</a>. With the geometric mean,
the resulting discrete equation</p>
<div class="math">
\[\frac{v^{n+1}-v^n}{\Delta t} = - a|v^{n}|v^{n+1} + b\]</div>
<p>becomes a <em>linear</em> equation in <span class="math">\(v^{n+1}\)</span>, and we can
therefore easily solve for <span class="math">\(v^{n+1}\)</span>:</p>
<div class="math" id="equation-decay:app:fallingbody:gmodel:q:CN">
<span id="eq-decay-app-fallingbody-gmodel-q-cn"></span><span class="eqno">(23)</span>\[     v^{n+1} = \frac{v_n + \Delta t b^{n+\half}}{1 + \Delta t a^{n+\half}|v^{n}|}\tp\]</div>
<p>Using a geometric mean instead of an arithmetic mean in the Crank-Nicolson
scheme is an attractive method for avoiding a nonlinear algebraic
equation when discretizing a nonlinear ODE.</p>
</div>
<div class="section" id="physical-data">
<h3>Physical data<a class="headerlink" href="#physical-data" title="Permalink to this headline">¶</a></h3>
<p>Suitable values of <span class="math">\(\mu\)</span> are <span class="math">\(1.8\cdot 10^{-5}\hbox{ Pa}\, \hbox{s}\)</span> for air
and <span class="math">\(8.9\cdot 10^{-4}\hbox{ Pa}\, \hbox{s}\)</span> for water.
Densities can be taken as <span class="math">\(1.2\hbox{ kg/m}^3\)</span> for air and as
<span class="math">\(1.0\cdot 10^3\hbox{ kg/m}^3\)</span> for water. For considerable vertical
displacement in the atmosphere one should take into account that
the density of air varies with the altitude, see the section <a class="reference internal" href="#decay-app-atm"><span class="std std-ref">Decay of atmospheric pressure with altitude</span></a>.
One possible density variation arises from the one-layer model
in the mentioned section.</p>
<p>Any density variation makes <span class="math">\(b\)</span> time dependent and we need
<span class="math">\(b^{n+\half}\)</span> in <a href="#equation-decay:app:fallingbody:gmodel:q:CN">(23)</a>.
To compute the density that enters
<span class="math">\(b^{n+\half}\)</span> we must also compute the vertical
position <span class="math">\(z(t)\)</span> of the body. Since <span class="math">\(v=dz/dt\)</span>, we can use a centered
difference approximation:</p>
<div class="math">
\[\frac{z^{n+\half} - z^{n-\half}}{\Delta t} = v^n
\quad\Rightarrow\quad z^{n+\half} = z^{n-\half}+\Delta t\, v^n\tp\]</div>
<p>This <span class="math">\(z^{n+\half}\)</span> is used in the expression for <span class="math">\(b\)</span>
to compute <span class="math">\(\varrho(z^{n+\half})\)</span> and then <span class="math">\(b^{n+\half}\)</span>.</p>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/Drag_coefficient">drag coefficient</a> <span class="math">\(C_D\)</span> depends heavily
on the shape of the body.  Some values are: 0.45 for a sphere, 0.42
for a semi-sphere, 1.05 for a cube, 0.82 for a long cylinder (when the
center axis is in the vertical direction), 0.75 for a rocket,
1.0-1.3 for a man in upright position, 1.3 for a flat plate perpendicular
to the flow, and
0.04 for a streamlined, droplet-like body.</p>
</div>
<div class="section" id="verification">
<h3>Verification<a class="headerlink" href="#verification" title="Permalink to this headline">¶</a></h3>
<p>To verify the program, one may assume a heavy body in air such that the <span class="math">\(F_b\)</span>
force can be neglected, and further assume a small velocity such that the
air resistance <span class="math">\(F_d\)</span> can also be neglected. This can be obtained by
setting <span class="math">\(\mu\)</span> and <span class="math">\(\varrho\)</span> to zero. The motion then leads to
the velocity
<span class="math">\(v(t)=v_0 - gt\)</span>, which is linear in <span class="math">\(t\)</span> and therefore should be
reproduced to machine precision (say tolerance <span class="math">\(10^{-15}\)</span>) by any
implementation based on the Crank-Nicolson or Forward Euler schemes.</p>
<p>Another verification, but not as powerful as the one above,
can be based on computing the terminal velocity and comparing with
the exact expressions.
The advantage of this verification is that we can also
test the situation <span class="math">\(\varrho\neq 0\)</span>.</p>
<p>As always, the method of manufactured solutions can be applied to
test the implementation of all terms in the governing equation, but
then the solution has no physical relevance in general.</p>
</div>
<div class="section" id="scaling-2">
<span id="decay-app-drag-scaling"></span><span id="index-8"></span><h3>Scaling  (2)<a class="headerlink" href="#scaling-2" title="Permalink to this headline">¶</a></h3>
<p>Applying scaling, as described in the section <a class="reference internal" href="#decay-app-scaling"><span class="std std-ref">Scaling  (1)</span></a>,
will for the linear case reduce the need to estimate values for
seven parameters down to choosing one value of a single dimensionless parameter</p>
<div class="math">
\[\beta = \frac{\varrho_b gV\left(\frac{\varrho}{\varrho_b} -1\right)}{3\pi d\mu I},\]</div>
<p>provided <span class="math">\(I\neq 0\)</span>. If the motion starts from rest, <span class="math">\(I=0\)</span>, the scaled
problem reads <span class="math">\(\bar u^{\prime}=1-\bar u\)</span>, <span class="math">\(\bar u(0)=0\)</span>, and there is
no need for estimating physical parameters (!).
This means that there is a single universal solution to the problem
of a falling body starting from rest:
<span class="math">\(\bar u(t) = 1 - e^{-\bar t}\)</span>. All real
physical cases correspond to stretching the <span class="math">\(\bar t\)</span> axis and the <span class="math">\(\bar u\)</span>
axis in this dimensionless solution. More precisely, the physical velocity
<span class="math">\(u(t)\)</span> is related to the dimensionless velocity <span class="math">\(\bar u(\bar t)\)</span> through</p>
<div class="math">
\[u = \frac{\varrho_bgV\left(\frac{\varrho}{\varrho_b} -1\right)}{3\pi d\mu}\bar u(t/(g(\varrho/\varrho_b -1))) =
\frac{\varrho_bgV\left(\frac{\varrho}{\varrho_b} -1\right)}{3\pi d\mu}(1 -
e^{t/(g(\varrho/\varrho_b -1))})\tp\]</div>
</div>
</div>
<div class="section" id="decay-odes-from-solving-a-pde-by-fourier-expansions">
<span id="decay-app-diffusion-fourier"></span><h2>Decay ODEs from solving a PDE by Fourier expansions<a class="headerlink" href="#decay-odes-from-solving-a-pde-by-fourier-expansions" title="Permalink to this headline">¶</a></h2>
<p>Suppose we have a partial differential equation</p>
<div class="math">
\[\frac{\partial u}{\partial t} = \alpha\frac{\partial^2u}{\partial x^2}
+ f(x,t),\]</div>
<p>with boundary conditions <span class="math">\(u(0,t)=u(L,t)=0\)</span> and initial condition
<span class="math">\(u(x,0)=I(x)\)</span>. One may express the solution as</p>
<div class="math">
\[u(x,t) = \sum_{k=1}^m A_k(t)e^{ikx\pi/L},\]</div>
<p>for appropriate unknown functions <span class="math">\(A_k\)</span>, <span class="math">\(k=1,\ldots,m\)</span>.
We use the complex exponential <span class="math">\(e^{ikx\pi/L}\)</span> for easy algebra, but
the physical <span class="math">\(u\)</span> is taken as the real part of any complex expression.
Note that the expansion in terms of <span class="math">\(e^{ikx\pi/L}\)</span> is compatible with
the boundary conditions: all functions <span class="math">\(e^{ikx\pi/L}\)</span> vanish for
<span class="math">\(x=0\)</span> and <span class="math">\(x=L\)</span>. Suppose we can express <span class="math">\(I(x)\)</span> as</p>
<div class="math">
\[I(x) = \sum_{k=1}^m I_ke^{ikx\pi/L}
\tp\]</div>
<p>Such an expansion can be computed by well-known Fourier expansion techniques,
but those details are not important here.
Also, suppose we can express the given <span class="math">\(f(x,t)\)</span> as</p>
<div class="math">
\[f(x,t) = \sum_{k=1}^m b_k(t)e^{ikx\pi/L}
\tp\]</div>
<p>Inserting the expansions for <span class="math">\(u\)</span>
and <span class="math">\(f\)</span> in the differential equations demands that all terms corresponding
to a given <span class="math">\(k\)</span> must be equal. The calculations result in the follow
system of ODEs:</p>
<div class="math">
\[A_k^{\prime}(t) = -\alpha\frac{k^2\pi^2}{L^2} + b_k(t),\quad k=1,\ldots,m
\tp\]</div>
<p>From the initial condition</p>
<div class="math">
\[u(x,0)=\sum_k A_k(0)e^{ikx\pi/L}=I(x)=\sum_k I_k e^{(ikx\pi/L)},\]</div>
<p>so it follows that <span class="math">\(A_k(0)=I_k\)</span>, <span class="math">\(k=1,\ldots,m\)</span>. We then have <span class="math">\(m\)</span>
equations of the form <span class="math">\(A_k^{\prime}=-a A_k +b\)</span>, <span class="math">\(A_k(0)=I_k\)</span>, for
appropriate definitions of <span class="math">\(a\)</span> and <span class="math">\(b\)</span>. These ODE problems
are independent of each other such that we can solve one problem
at a time. The outlined technique is a quite common solution approach to
partial differential equations.</p>
<p><strong>Remark.</strong>
Since <span class="math">\(a_k\)</span> depends on <span class="math">\(k\)</span> and the stability of the
Forward Euler scheme demands <span class="math">\(a_k\Delta t \leq 1\)</span>, we get that <span class="math">\(\Delta
t \leq \alpha^{-1}L^2\pi^{-2} k^{-2}\)</span> for this scheme.  Usually, quite
large <span class="math">\(k\)</span> values are needed to accurately represent the given
functions <span class="math">\(I\)</span> and <span class="math">\(f\)</span> so that <span class="math">\(\Delta t\)</span> in the Forward Euler scheme
needs to be very small for these large values of <span class="math">\(k\)</span>.  Therefore, the
Crank-Nicolson and Backward Euler schemes, which allow larger <span class="math">\(\Delta
t\)</span> without any growth in the solutions, are more popular choices when
creating time-stepping algorithms for partial differential equations
of the type considered in this example.</p>
</div>
<div class="section" id="exercises-4">
<h2>Exercises  (4)<a class="headerlink" href="#exercises-4" title="Permalink to this headline">¶</a></h2>
<div class="section" id="exercise-16-radioactive-decay-of-carbon-14">
<span id="decay-app-exer-radio-c14"></span><h3>Exercise 16: Radioactive decay of Carbon-14<a class="headerlink" href="#exercise-16-radioactive-decay-of-carbon-14" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/Carbon-14">Carbon-14</a> isotope,
whose radioactive decay is used extensively in dating organic material
that is tens of thousands of years old, has a half-life of <span class="math">\(5,730\)</span>
years.  Determine the age of an organic material that contains 8.4 percent
of its initial amount of Carbon-14.  Use a time unit of 1 year in the
computations.  The uncertainty in the half time of Carbon-14 is <span class="math">\(\pm
40\)</span> years.  What is the corresponding uncertainty in the estimate of
the age?</p>
<p><strong>Hint 1.</strong>
Let <span class="math">\(A\)</span> be the amount of Carbon-14. The ODE problem is then
<span class="math">\(A^{\prime}(t)=-aA(t)\)</span>, <span class="math">\(A(0)=I\)</span>. Introduced the scaled amount
<span class="math">\(u=A/I\)</span>. The ODE problem for <span class="math">\(u\)</span> is <span class="math">\(u^{\prime}=-au\)</span>, <span class="math">\(u(0)=1\)</span>.
Measure time in years.
Simulate until the first mesh point <span class="math">\(t_m\)</span> such that <span class="math">\(u(t_m)\leq 0.084\)</span>.</p>
<p><strong>Hint 2.</strong>
Use simulations with <span class="math">\(5,730\pm 40\)</span> y as input
and find the corresponding uncertainty interval for the result.</p>
<p><strong>Solution.</strong>
We need a tailored solver function for this exercise:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">u_crit</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=-a*u, u(0)=I, for t in (0,t_m] until u &lt;= u_crit</span>
<span class="sd">    with steps of dt. Return t_m.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Use list for u and t since we do not know how many points</span>
    <span class="c"># that are needed</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>               <span class="c"># avoid integer division</span>
    <span class="n">u</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>                  <span class="c"># assign initial condition</span>
    <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">u_crit</span><span class="p">:</span>
        <span class="n">u_new</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u_new</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


<span class="n">half_life</span> <span class="o">=</span> <span class="mi">5730</span>
<span class="n">a</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">half_life</span>
<span class="k">print</span> <span class="s">&#39;Age:&#39;</span><span class="p">,</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">u_crit</span><span class="o">=</span><span class="mf">0.084</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>Running this code gives an age of 20,480 years.</p>
<p>The uncertainty can be estimated by the following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">half_life_min</span> <span class="o">=</span> <span class="mi">5730</span> <span class="o">-</span> <span class="mi">40</span>
<span class="n">half_life_max</span> <span class="o">=</span> <span class="mi">5730</span> <span class="o">+</span> <span class="mi">40</span>
<span class="n">a_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">half_life_min</span>
<span class="n">a_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">half_life_max</span>
<span class="n">age_min</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a_max</span><span class="p">,</span> <span class="n">u_crit</span><span class="o">=</span><span class="mf">0.084</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">age_max</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a_min</span><span class="p">,</span> <span class="n">u_crit</span><span class="o">=</span><span class="mf">0.084</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;Uncertainty: [</span><span class="si">%g</span><span class="s">, </span><span class="si">%g</span><span class="s">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">age_min</span><span class="p">,</span> <span class="n">age_max</span><span class="p">)</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">carbon14</span></code>.</p>
</div>
<div class="section" id="exercise-17-derive-schemes-for-newton-s-law-of-cooling">
<span id="decay-app-exer-cooling-schemes"></span><h3>Exercise 17: Derive schemes for Newton&#8217;s law of cooling<a class="headerlink" href="#exercise-17-derive-schemes-for-newton-s-law-of-cooling" title="Permalink to this headline">¶</a></h3>
<p>Show in detail how we can apply the ideas of the Forward Euler,
Backward Euler, and Crank-Nicolson
discretizations to derive explicit
computational formulas for new temperature values in Newton&#8217;s law of
cooling (see the section <a class="reference internal" href="#decay-app-newton-cooling"><span class="std std-ref">Newton&#8217;s law of cooling</span></a>):</p>
<div class="math">
\[\frac{dT}{dt} = -k(T-T_s(t)),\quad T(0)=T_0\tp\]</div>
<p>Here, <span class="math">\(T\)</span> is the temperature of the body, <span class="math">\(T_s(t)\)</span> is the temperature
of the surroundings, <span class="math">\(t\)</span> is time, <span class="math">\(k\)</span> is the heat transfer
coefficient, and <span class="math">\(T_0\)</span> is the initial temperature of the body.
Summarize the discretizations in a <span class="math">\(\theta\)</span>-rule
such that you can get the three
schemes from a single formula by varying the <span class="math">\(\theta\)</span> parameter.</p>
<p><strong>Solution.</strong>
The idea of the Forward Euler scheme is to sample the ODE at <span class="math">\(t=t_n\)</span>
and apply a forward difference approximation to the derivative:</p>
<div class="math">
\[\frac{T^{n+1}-T^n}{\Delta t} = -k(T^n - T_s(t_n))\tp\]</div>
<p>The Backward Euler applies a backward difference instead:</p>
<div class="math">
\[\frac{T^{n}-T^{n-1}}{\Delta t} = -k(T^n - T_s(t_n))\tp\]</div>
<p>The Crank-Nicolson scheme samples the ODE at <span class="math">\(t_{n+\half}\)</span>, applies
a centered difference approximation, and an arithmetic mean approximation
to <span class="math">\(T^{n+\half}\)</span>:</p>
<div class="math">
\[\frac{T^{n+1}-T^n}{\Delta t} = -k(T^{n+\half} - T_s(t_{n+\half}))
\approx -k(\half(T^n + T^{n+1}) - T_s(t_{n+\half}))\tp\]</div>
<p>For each scheme we solve with respect to the unknown <span class="math">\(T^{n+1}\)</span> (note
that we switch index from <span class="math">\(n\)</span> to <span class="math">\(n+1\)</span> in the Backward Euler scheme):</p>
<div class="math">
\[\begin{split}T^{n+1} &amp;= T^n - k\Delta t(T^n - T_s(t_n)),\\
T^{n+1} &amp;= \frac{T^n + k\Delta t T_s(t_{n+1})}{1 + k\Delta t},\\
T^{n+1} &amp;= \frac{T^n - \half k\Delta t T^n + k\Delta t T_s(t_{n+\half})}{1 + \half k\Delta t}\tp\end{split}\]</div>
<p>A <span class="math">\(\theta\)</span> scheme can be formulated as</p>
<div class="math">
\[T^{n+1} = \frac{T^n - (1-\theta) k\Delta t T^n + k\Delta t T_s((1-\theta) t_n+ \theta t_{n+1})}{1 + \theta k\Delta t}\]</div>
<p>Filename: <code class="docutils literal"><span class="pre">schemes_cooling</span></code>.</p>
</div>
<div class="section" id="exercise-18-implement-schemes-for-newton-s-law-of-cooling">
<span id="decay-app-exer-cooling-py"></span><h3>Exercise 18: Implement schemes for Newton&#8217;s law of cooling<a class="headerlink" href="#exercise-18-implement-schemes-for-newton-s-law-of-cooling" title="Permalink to this headline">¶</a></h3>
<p>The goal of this exercise is to implement the schemes from
<a class="reference internal" href="#decay-app-exer-cooling-schemes"><span class="std std-ref">Exercise 17: Derive schemes for Newton&#8217;s law of cooling</span></a> and investigate
several approaches for verifying the implementation.</p>
<p><strong>a)</strong>
Implement the <span class="math">\(\theta\)</span>-rule from
<a class="reference internal" href="#decay-app-exer-cooling-schemes"><span class="std std-ref">Exercise 17: Derive schemes for Newton&#8217;s law of cooling</span></a> in a function</p>
<div class="highlight-text"><div class="highlight"><pre>cooling(T0, k, T_s, t_end, dt, theta=0.5)
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">T0</span></code> is the initial temperature, <code class="docutils literal"><span class="pre">k</span></code> is
the heat transfer coefficient, <code class="docutils literal"><span class="pre">T_s</span></code> is a function of <code class="docutils literal"><span class="pre">t</span></code> for
the temperature of the
surroundings, <code class="docutils literal"><span class="pre">t_end</span></code> is the end time of the simulation, <code class="docutils literal"><span class="pre">dt</span></code> is the
time step, and <code class="docutils literal"><span class="pre">theta</span></code> corresponds to <span class="math">\(\theta\)</span>.  The <code class="docutils literal"><span class="pre">cooling</span></code>
function should return the temperature as an array <code class="docutils literal"><span class="pre">T</span></code> of values at
the mesh points and the time mesh <code class="docutils literal"><span class="pre">t</span></code>.</p>
<p><strong>Solution.</strong>
Here is an appropriate function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">cooling</span><span class="p">(</span><span class="n">T0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">T_s</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve T&#39;=-k(T-T_s(t)), T(0)=T0,</span>
<span class="sd">    for t in (0,t_end] with steps of dt.</span>
<span class="sd">    T_s(t) is a Python function of t.</span>
<span class="sd">    theta=0.5 means Crank-Nicolson, 1 is Backward</span>
<span class="sd">    Euler, and 0 is Forward Euler scheme.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>                  <span class="c"># avoid integer division</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">t_end</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>       <span class="c"># no of time intervals</span>
    <span class="n">t_end</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span>                   <span class="c"># adjust to fit time step dt</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>              <span class="c"># array of T[n] values</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c"># time mesh</span>
    <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">T0</span>                       <span class="c"># set initial condition</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>          <span class="c"># n=0,1,...,Nt-1</span>
        <span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> \
        <span class="n">dt</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="n">theta</span><span class="o">*</span><span class="n">T_s</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">T_s</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])))</span><span class="o">/</span> \
        <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">theta</span><span class="o">*</span><span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">T</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p><strong>b)</strong>
In the case <span class="math">\(\lim_{t\rightarrow\infty}T_s(t)=C=\mbox{const}\)</span>,
explain why <span class="math">\(T(t)\rightarrow C\)</span>. Construct an example where you
can illustrate this property in a plot. Implement a corresponding
test function that checks the correctness of the asymptotic
value of the solution.</p>
<p><strong>Solution.</strong>
Apply the limit to the ODE:</p>
<div class="math">
\[\lim_{t\rightarrow\infty}\frac{dT}{dt} = -k(\lim_{t\rightarrow\infty} T
- \lim_{t\rightarrow\infty} T_s)\tp\]</div>
<p>Assuming steady state behavior, <span class="math">\(dT/dt\rightarrow\infty\)</span> as
<span class="math">\(t\rightarrow\infty\)</span>. Then we get</p>
<div class="math">
\[0 = -k(\lim_{t\rightarrow\infty} T
- C),\]</div>
<p>which means</p>
<div class="math">
\[\lim_{t\rightarrow\infty} T = C\tp\]</div>
<p>A corresponding test function takes the form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_asymptotic</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test that ``any&#39;&#39; initial condition leads to</span>
<span class="sd">    the same asymptotic behavior when T_s=constant.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">T_s</span> <span class="o">=</span> <span class="mf">5.</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mf">1.2</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.01</span>  <span class="c"># tolerance for testing asymptotic value</span>
    <span class="n">t_end</span> <span class="o">=</span> <span class="mi">7</span>    <span class="c"># make sure t_end is large enough for tol</span>
    <span class="n">T0_values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span> <span class="c"># test many cases</span>

    <span class="k">for</span> <span class="n">T0</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">]:</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cooling</span><span class="p">(</span><span class="n">T0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">T_s</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">T_s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s"> != </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">T_s</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;T0=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">T0</span> <span class="k">for</span> <span class="n">T0</span> <span class="ow">in</span> <span class="n">T0_values</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Testing asymptotic behavior T_s=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">T_s</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;T&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp1.png&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp1.pdf&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that we have added a plot in the test function for convenience.
Letting test functions perform plotting is, however, not a good idea
if you want to run a large set of tests.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/cooling_asymptotic.png"><img alt="_images/cooling_asymptotic.png" src="_images/cooling_asymptotic.png" style="width: 600px;" /></a>
</div>
<p><strong>c)</strong>
A piecewise constant surrounding temperature,</p>
<div class="math">
\[\begin{split}T_s(t) = \left\lbrace\begin{array}{ll} C_0,&amp; 0\leq t\leq t^*\\
C_1, &amp; t&gt;t^*,\end{array}\right.\end{split}\]</div>
<p>corresponds to a sudden change in the environment
at <span class="math">\(t=t^*\)</span>. Choose <span class="math">\(C_0=2T_0\)</span>, <span class="math">\(C_1=\frac{1}{2}T_0\)</span>, and
<span class="math">\(t^*=3/k\)</span>. Plot the solution <span class="math">\(T(t)\)</span> and explain why it seems physically
reasonable.</p>
<p><strong>Solution.</strong>
First we implement a general tool for piecewise constant functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Piecewise</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for holding a piecewise constant function.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C0</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">t_star</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C1</span> <span class="o">=</span> <span class="n">C0</span><span class="p">,</span> <span class="n">C1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_star</span> <span class="o">=</span> <span class="n">t_star</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return value of piecewise constant function.</span>
<span class="sd">        t can be float or numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_star</span><span class="p">:</span>
                <span class="n">T_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C0</span>
            <span class="k">elif</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_star</span><span class="p">:</span>
                <span class="n">T_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># assume numpy array</span>
            <span class="n">T_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">piecewise</span><span class="p">(</span><span class="n">t</span><span class="p">,</span>
                               <span class="p">[</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_star</span><span class="p">,</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_star</span><span class="p">],</span>
                               <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">C0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C1</span><span class="p">])</span>
            <span class="c"># Alternative</span>
            <span class="c"># T_s = np.where(t &lt;= self.t_star, C0, C1)</span>
        <span class="k">return</span> <span class="n">T_s</span>
</pre></div>
</div>
<p>It is convenient to scale the problem such that we do not need to find
physically relevant values for <span class="math">\(k\)</span>. A common scaling of <span class="math">\(T\)</span> is</p>
<div class="math">
\[\bar T = \frac{T-T_0}{T_s-T_0},\]</div>
<p>when <span class="math">\(T_s\)</span> is constant since then <span class="math">\(\bar T\in [0,1]\)</span>. Here, we may choose
the long-term value of <span class="math">\(T_s\)</span> in the denominator such that <span class="math">\(\lim_{t\rightarrow\infty}\bar T=1\)</span>, i.e.,</p>
<div class="math">
\[\bar T = \frac{T-T_0}{0.5T_0-T_0}= -2\frac{T-T_0}{T_0},\]</div>
<p>but it leads to a shift in the sign of the temperature on the
right-hand side of the ODE, and we cannot reuse the code for the
original problem in the dimensionless case. We therefore avoid the negative
sign and use a temperature scale <span class="math">\(2T_0-T_0\)</span>,</p>
<div class="math">
\[\bar T = \frac{T-T_0}{2T_0-T_0}= \frac{T-T_0}{T_0},\]</div>
<p>which gives <span class="math">\(\bar T\)</span> varying from <span class="math">\(0\)</span> initially to a maximum of
<span class="math">\(1\)</span> and finally to a minimum of <span class="math">\(-\half\)</span>.
We scale <span class="math">\(T_s\)</span> by its maximum value <span class="math">\(2T_0\)</span> so <span class="math">\(\bar T_s\in [0,1]\)</span>:</p>
<div class="math">
\[\begin{split}\bar T_s(\bar t) = \frac{T_s(t)}{\max_t T_s(t)} = \frac{T_s(t_c\bar t)}{2T_0} = \left\lbrace\begin{array}{ll}
1, &amp; \bar t &lt; t^*/t_c,\\
\frac{1}{4},&amp; \bar t \geq t^*/t_c
\end{array}\right.\end{split}\]</div>
<p>where <span class="math">\(t_c\)</span> is the time scale. Inserted in the ODE we get</p>
<div class="math">
\[\frac{T_0}{t_c}\frac{d\bar T}{d\bar t} = -k(T_0\bar T + T_0 -
2T_0\bar T_s,\]</div>
<p>leading to</p>
<div class="math">
\[\frac{d\bar T}{d\bar t} = -kt_c(\bar T + 1 - 2\bar T_s)\tp\]</div>
<p>A natural choice is <span class="math">\(t_c=1/k\)</span> so we get the scaled problem</p>
<div class="math">
\[\frac{d\bar T}{d\bar t} = -(\bar T + 1 - 2\bar T_s) =
-(\bar T -(2\bar T_s - 1)),\quad \bar T(0)=0\tp\]</div>
<p>We can simulate this problem using the code for the original
problem by choosing <span class="math">\(k=1\)</span>, <span class="math">\(T_0=0\)</span>, and
<span class="math">\(T_s= (2-1)=1\)</span> for <span class="math">\(t &lt; 3\)</span> and <span class="math">\(T_s=(2\frac{1}{4}-1)=-\half\)</span>
for <span class="math">\(t &gt; 3\)</span>.</p>
<p>The appropriate code becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">simulate_piecewise_constant_Ts</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulate scaled problem: T&#39; = -(T - (2T_s-1)), T(0)=0,</span>
<span class="sd">    where T_s=1 for t &lt; 3 and -0.5 for t &gt; 3.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">T0</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">t_star</span> <span class="o">=</span> <span class="mf">3.0</span>
    <span class="n">C0</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span>
    <span class="n">T_s</span> <span class="o">=</span> <span class="n">Piecewise</span><span class="p">(</span><span class="n">C0</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">t_star</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t_star</span><span class="o">/</span><span class="mf">100.0</span>
    <span class="n">T</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cooling</span><span class="p">(</span><span class="n">T0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">T_s</span><span class="p">,</span> <span class="n">t_end</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">t_star</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp2.png&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp2.pdf&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The plot looks like this:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/cooling_piecewise.png"><img alt="_images/cooling_piecewise.png" src="_images/cooling_piecewise.png" style="width: 600px;" /></a>
</div>
<p>The result is reasonable because first <span class="math">\(T_s=1\)</span> and the body&#8217;s temperature
will try to rise from <span class="math">\(0\)</span> to <span class="math">\(1\)</span>, and it almost gets there in
the time <span class="math">\([0,3]\)</span>, before <span class="math">\(T_s=-0.5\)</span> and then the body is cooled down
to <span class="math">\(-0.5\)</span> as <span class="math">\(t\)</span> increases, and this is also the asymptotic value.</p>
<p><strong>d)</strong>
We know from the ODE <span class="math">\(u^\prime =-au\)</span> that the Crank-Nicolson scheme
can give non-physical oscillations for <span class="math">\(\Delta t &gt; 2/a\)</span>.
In the present problem, this results indicates
that the Crank-Nicolson scheme give undesired
oscillations for <span class="math">\(\Delta t &gt; 2/k\)</span>.
Discuss if this a potential problem in the physical case from c).</p>
<p><strong>Solution.</strong>
In the unscaled problem, the first stage of the simulation is
covers time interval <span class="math">\([0,t^*]=[0, 3/k]\)</span>. It makes sense to
choose <span class="math">\(\Delta t\)</span> significantly smaller than <span class="math">\(3/k\)</span>, and the
stability limit <span class="math">\(2/k\)</span> is a too large step. The next time level
is then <span class="math">\(4/k\)</span>, and it sounds reasonable to include the point <span class="math">\(t^*=3/k\)</span>
as a mesh point. Oscillations would then occur if we choose
<span class="math">\(\Delta t = 3/k\)</span>, but this means only one step through the first
interval <span class="math">\([0,t^*]\)</span>, which is a very coarse mesh. Halving <span class="math">\(\Delta t\)</span>
is still a coarse mesh, but then there cannot be oscillations.</p>
<p><strong>e)</strong>
Find an expression for the exact solution of
<span class="math">\(T^{\prime} = -k(T-T_s(t))\)</span>, <span class="math">\(T(0)=T_0\)</span>.
Construct a test case and compare the
numerical and exact solution in a plot.</p>
<p>Find a value of the time step
<span class="math">\(\Delta t\)</span> such that the two solution curves cannot (visually) be
distinguished from each other. Many scientists will claim that such a
plot provides evidence for a correct implementation, but point out why
there still may be errors in the code.  Can you introduce bugs in the
<code class="docutils literal"><span class="pre">cooling</span></code> function and still achieve visually coinciding curves?</p>
<p><strong>Hint.</strong>
The exact solution can be derived by multiplying <a href="#equation-decay:Newton:cooling">(5)</a>
by the integrating factor <span class="math">\(e^{kt}\)</span>.</p>
<p><strong>Solution.</strong>
Multiplication of <span class="math">\(e^{kt}\)</span>, using the product rule for differentiation
&#8220;backwards&#8221;, and integrating from 0 to <span class="math">\(t\)</span>, results in</p>
<div class="math">
\[\int_0^t (e^{kt}T)^{\prime}dt = k\int_0^t e^{kt}T_sdt\tp\]</div>
<p>The left-hand side becomes <span class="math">\(e^{kt}T(t)-T_0\)</span>. Multiplying by <span class="math">\(e^{-kt}\)</span>
then gives</p>
<div class="math">
\[T(t) = T_0e^{-kt} + ke^{-kt}\int_0^t e^{k\tau}T_s(\tau)d\tau,\]</div>
<p>which is the general expression for the exact solution.</p>
<p>As a check, we consider the case where <span class="math">\(T_s\)</span> is constant.
That problem can easily be solved by introducing <span class="math">\(u=T-T_s\)</span>, resulting in
<span class="math">\(u^{\prime}=-ku\)</span>, <span class="math">\(u(0)=T_0-T_s\)</span>, with solution <span class="math">\(u(t)=(T_0-T_s)e^{-kt}\)</span>,
and consequently <span class="math">\(T=T_s + (T_0-T_s)e^{-kt}\)</span>. With a constant <span class="math">\(T_s\)</span> in
the general solution above, the solution becomes</p>
<div class="math">
\[\begin{split}T(t) &amp;= T_0e^{-kt} + ke^{-kt}\int_0^t e^{kt}T_sdt\\
&amp; = T_0e^{-kt} + ke^{-kt}T_sk^{-1}(e^{kt} - 1)\\
&amp; = T_0e^{-kt} + T_s - T_se^{-kt}\\
&amp; = T_s + (T_0-T_s)e^{-kt},\end{split}\]</div>
<p>as desired.</p>
<p>We choose the same test problem as in c) and use SymPy to do the
integration. A function doing the integration and returning
Python functions for the formulas for <span class="math">\(t &lt; t^*\)</span> and <span class="math">\(t\geq t^*\)</span>
is convenient:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">symbolic_exact_solution</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the exact solution formula via sympy.&quot;&quot;&quot;</span>
    <span class="c"># sol1: solution for t &lt; t_star,</span>
    <span class="c"># sol2: solution for t &gt; t_star</span>
    <span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
    <span class="n">T0</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;T0&#39;</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;k&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="c"># Piecewise linear T_sunction</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">t_star</span><span class="p">,</span> <span class="n">C0</span><span class="p">,</span> <span class="n">C1</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;t t_star C0 C1&#39;</span><span class="p">)</span>
    <span class="n">T_s</span> <span class="o">=</span> <span class="n">C0</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">T_s</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
    <span class="n">sol1</span> <span class="o">=</span> <span class="n">T0</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">I</span>
    <span class="n">sol1</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">sol1</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="c"># Some debugging print</span>
        <span class="k">print</span> <span class="s">&#39;solution t &lt; t_star:&#39;</span><span class="p">,</span> <span class="n">sol1</span>
        <span class="c">#print sym.latex(sol1)</span>
    <span class="n">T_s</span> <span class="o">=</span> <span class="n">C1</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">C0</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t_star</span><span class="p">))</span> <span class="o">+</span> \
        <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">C1</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t_star</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
    <span class="n">sol2</span> <span class="o">=</span> <span class="n">T0</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">I</span>
    <span class="n">sol2</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">sol2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;solution t &gt; t_star:&#39;</span><span class="p">,</span> <span class="n">sol2</span>
        <span class="c">#print sym.latex(sol2)</span>

    <span class="c"># Convert to numerical functions</span>
    <span class="n">exact0</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">t</span><span class="p">,</span> <span class="n">C0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">T0</span><span class="p">],</span>
                          <span class="n">sol1</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="n">exact1</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">t</span><span class="p">,</span> <span class="n">C0</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">t_star</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">T0</span><span class="p">],</span>
                          <span class="n">sol2</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">exact0</span><span class="p">,</span> <span class="n">exact1</span>
</pre></div>
</div>
<p>Then we need a function that can evaluate the exact solution as
a mesh function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">evaluate_exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span> <span class="n">C0</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">t_star</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return exact (analytical) solution of the problem.</span>
<span class="sd">    Exact solution is produced by sympy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">exact0</span><span class="p">,</span> <span class="n">exact1</span> <span class="o">=</span> <span class="n">symbolic_exact_solution</span><span class="p">()</span>
    <span class="c"># exact0/1 works with t as numpy array</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_star</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">exact0</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">C0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">T0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">exact1</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">C0</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">t_star</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">T0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># assume numpy array</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_star</span><span class="p">,</span>
            <span class="n">exact0</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">C0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">T0</span><span class="p">),</span>
            <span class="n">exact1</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">C0</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">t_star</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">T0</span><span class="p">))</span>
</pre></div>
</div>
<p>Finally we can run the comparison:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">compare_numerical_and_exact_solution</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compare exact and numerical solution with piecewise</span>
<span class="sd">    constant surrounding temperature. Use scaled problem</span>
<span class="sd">    from function simulate_piecewise_constant_Ts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">T0</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">C0</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span>
    <span class="n">t_star</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">t_end</span> <span class="o">=</span> <span class="mi">7</span>

    <span class="n">T_s</span> <span class="o">=</span> <span class="n">Piecewise</span><span class="p">(</span><span class="n">C0</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">t_star</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">dt_values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.025</span><span class="p">]</span>
    <span class="c">#dt_values = [0.025]</span>
    <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">:</span>
        <span class="n">T</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cooling</span><span class="p">(</span><span class="n">T0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">T_s</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>

    <span class="n">t_e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>  <span class="c"># find mesh for T_e</span>
    <span class="c"># Could use sym.Rational(1,2) instead of 0.5, but not necessary</span>
    <span class="c"># when we are not interested in symbolic formulas</span>
    <span class="n">T_e</span> <span class="o">=</span> <span class="n">evaluate_exact_solution</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span> <span class="n">C0</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">t_star</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">T_e</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;CN, dt=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">dt</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s">&#39;exact&#39;</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;T(t) for piecewise constant $T_s(t)$&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;T&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp3.png&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp3.pdf&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The <span class="math">\(\Delta t\)</span> values were found after some trial and error, but they
illustrate crude approximations and one with the biggest possible
<span class="math">\(\Delta t\)</span> such that the exact solution and the numerical solution cannot
be visually distinguished:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/cooling_piecewise_compare.png"><img alt="_images/cooling_piecewise_compare.png" src="_images/cooling_piecewise_compare.png" style="width: 600px;" /></a>
</div>
<p>We can now start to introduce bugs in the <code class="docutils literal"><span class="pre">cooling</span></code> function to
see if it is possible to have some <span class="math">\(\Delta t\)</span> and still find
coinciding curves.</p>
<div class="section" id="bug-1-wrong-time-level-in-the-function">
<h4>Bug 1: Wrong time level in the <span class="math">\(T_s\)</span> function<a class="headerlink" href="#bug-1-wrong-time-level-in-the-function" title="Permalink to this headline">¶</a></h4>
<p>We replace <code class="docutils literal"><span class="pre">T_s[n]</span></code> by <code class="docutils literal"><span class="pre">T_s[n+1]</span></code> in the implementation of the scheme
and rerun the case. Now the lowest <span class="math">\(\Delta t\)</span> is still on top of
the exact solution, but the numerical solution on the two coarser
meshes are more accurate! This is because we lower the surrounding
temperature somewhat earlier in the buggy scheme and this reduces
the &#8220;overshoot&#8221; on the coarsest meshes in the figure above.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/cooling_piecewise_bug1.png"><img alt="_images/cooling_piecewise_bug1.png" src="_images/cooling_piecewise_bug1.png" style="width: 600px;" /></a>
</div>
</div>
<div class="section" id="bug-2-wrong-time-level-in-the-function">
<h4>Bug 2: Wrong time level in the <span class="math">\(T\)</span> function<a class="headerlink" href="#bug-2-wrong-time-level-in-the-function" title="Permalink to this headline">¶</a></h4>
<p>We can replace <code class="docutils literal"><span class="pre">T[n]</span></code> by <code class="docutils literal"><span class="pre">T[n+1]</span></code> on the right-hand side of the scheme.
This is a serious error since <code class="docutils literal"><span class="pre">T[n+1]</span></code> is not yet computed and therefore
equal to zero when <code class="docutils literal"><span class="pre">T</span></code> was made by calling <code class="docutils literal"><span class="pre">np.zeros</span></code>. The results
are also nonsense, and one would immediately look for a bug.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/cooling_piecewise_bug2.png"><img alt="_images/cooling_piecewise_bug2.png" src="_images/cooling_piecewise_bug2.png" style="width: 600px;" /></a>
</div>
</div>
<div class="section" id="bug-3-missing-in-a-term">
<h4>Bug 3: Missing <span class="math">\(\theta\)</span> in a term<a class="headerlink" href="#bug-3-missing-in-a-term" title="Permalink to this headline">¶</a></h4>
<p>Let us forget to multiply by <code class="docutils literal"><span class="pre">theta</span></code> in the nominator of the scheme, i.e.,
we replace</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> \
         <span class="n">dt</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="n">theta</span><span class="o">*</span><span class="n">T_s</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">T_s</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])))</span><span class="o">/</span> \
         <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">theta</span><span class="o">*</span><span class="n">k</span><span class="p">)</span>
</pre></div>
</div>
<p>by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> \
         <span class="n">dt</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="n">T_s</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">T_s</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])))</span><span class="o">/</span> \
         <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">theta</span><span class="o">*</span><span class="n">k</span><span class="p">)</span>
</pre></div>
</div>
<p>This error leads to convergence towards a wrong solution:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/cooling_piecewise_bug3.png"><img alt="_images/cooling_piecewise_bug3.png" src="_images/cooling_piecewise_bug3.png" style="width: 600px;" /></a>
</div>
<p>If we did not have the exact solution, one could be led to think
that the solution was correct, but it is non-physical since we
do not expect the temperature to rise from <span class="math">\(T_0\)</span> to a level
<em>above</em> the surrounding temperature. The plot shows that <span class="math">\(\bar T&gt;1\)</span>,
the value of the (scaled) surrounding temperature.
Note that if we used the Backward Euler scheme instead of the
Crank-Nicolson scheme, this bug would have no effect!</p>
</div>
<div class="section" id="bug-4-missing-k-in-the-updating-formula">
<h4>Bug 4: Missing <code class="docutils literal"><span class="pre">k</span></code> in the updating formula<a class="headerlink" href="#bug-4-missing-k-in-the-updating-formula" title="Permalink to this headline">¶</a></h4>
<p>Obviously, when we solve the scaled problem where <span class="math">\(k=1\)</span> by definition,
such a programming mistake has no effect. Otherwise, <span class="math">\(k\)</span> influences
the time scale, so there will be a stretch of the time axis in the
numerical solution and this should be easily detected in a plot.</p>
</div>
<div class="section" id="bug-5-using-1-theta-instead-of-theta">
<h4>Bug 5: Using <code class="docutils literal"><span class="pre">1-theta</span></code> instead of <code class="docutils literal"><span class="pre">theta</span></code><a class="headerlink" href="#bug-5-using-1-theta-instead-of-theta" title="Permalink to this headline">¶</a></h4>
<p>Such an error is not detectable in the Crank-Nicolson scheme, but
will have a significant effect in the other schemes.
As a test, we replace <code class="docutils literal"><span class="pre">1-theta</span></code> in the nominator by <code class="docutils literal"><span class="pre">theta</span></code>.
This leads to <span class="math">\(T=0\)</span> in the Forward Euler scheme, but a reasonable shape
in the Backward Euler scheme, although the solution becomes larger
than the surrounding temperature (1 in the scaled problem).</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/cooling_piecewise_bug5.png"><img alt="_images/cooling_piecewise_bug5.png" src="_images/cooling_piecewise_bug5.png" style="width: 600px;" /></a>
</div>
<p><strong>f)</strong>
Implement a test function for checking that the solution returned by
the <code class="docutils literal"><span class="pre">cooling</span></code> function is identical to the exact numerical
solution of the problem (to machine precision) when <span class="math">\(T_s\)</span> is constant.</p>
<p><strong>Hint.</strong>
The exact solution of the
discrete equations in the case <span class="math">\(T_s\)</span> is a constant can be found by
introducing <span class="math">\(u=T-T_s\)</span> to get a problem <span class="math">\(u^{\prime}=-ku\)</span>, <span class="math">\(u(0)=T_0-T_s\)</span>.
The solution of the discrete equations is then of the form
<span class="math">\(u^{n}=(T_0-T_s)A^n\)</span> for some amplification factor <span class="math">\(A\)</span>. The
expression for <span class="math">\(T^n\)</span> is then <span class="math">\(T^n = T_s(t_n) + u^n =
T_s + (T_0-T_s)A^n\)</span>.
We find that</p>
<div class="math">
\[A = \frac{1 - (1-\theta) k\Delta t}{1 + \theta k\Delta t}\tp\]</div>
<p>The test function, testing several <span class="math">\(\theta\)</span> values for a quite coarse
mesh, may take the form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_discrete_solution</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compare the numerical solution with an exact solution of the scheme</span>
<span class="sd">    when the T_s is constant.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">T_s</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">T0</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mf">1.2</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span>   <span class="c"># can use any mesh</span>
    <span class="n">N_t</span> <span class="o">=</span> <span class="mi">6</span>    <span class="c"># any no of steps will do</span>
    <span class="n">t_end</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">N_t</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]:</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cooling</span><span class="p">(</span><span class="n">T0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">T_s</span> <span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">u_discrete_exact</span> <span class="o">=</span> <span class="n">T_s</span> <span class="o">+</span> <span class="p">(</span><span class="n">T0</span><span class="o">-</span><span class="n">T_s</span><span class="p">)</span><span class="o">*</span><span class="n">A</span><span class="o">**</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_discrete_exact</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">print</span> <span class="s">&#39;diff computed and exact discrete solution:&#39;</span><span class="p">,</span> <span class="n">diff</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
        <span class="n">success</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>
        <span class="k">assert</span> <span class="n">success</span><span class="p">,</span> <span class="s">&#39;diff=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">diff</span>
</pre></div>
</div>
<p>Running this function shows that the <code class="docutils literal"><span class="pre">diff</span></code> variable is <code class="docutils literal"><span class="pre">3.55E-15</span></code>
as maximum so a tolerance of <span class="math">\(10^{-14}\)</span> is appropriate.
This is a good test that the <code class="docutils literal"><span class="pre">cooling</span></code> function works!</p>
<p>Filename: <code class="docutils literal"><span class="pre">cooling</span></code>.</p>
</div>
</div>
<div class="section" id="exercise-19-find-time-of-murder-from-body-temperature">
<span id="decay-app-exer-cooling-murder"></span><h3>Exercise 19: Find time of murder from body temperature<a class="headerlink" href="#exercise-19-find-time-of-murder-from-body-temperature" title="Permalink to this headline">¶</a></h3>
<p>A detective measures the temperature of a dead body to be 26.7 C at 2
pm. One hour later the temperature is 25.8 C. The question is when
death occurred.</p>
<p>Assume that Newton&#8217;s law of cooling <a href="#equation-decay:Newton:cooling">(5)</a> is an
appropriate mathematical model for the evolution of the temperature in
the body.  First, determine <span class="math">\(k\)</span> in <a href="#equation-decay:Newton:cooling">(5)</a> by
formulating a Forward Euler approximation with one time steep from
time 2 am to time 3 am, where knowing the two temperatures allows for
finding <span class="math">\(k\)</span>. Assume the temperature in the air to be 20 C. Thereafter,
simulate the temperature evolution from the time of murder, taken as
<span class="math">\(t=0\)</span>, when <span class="math">\(T=37\hbox{ C}\)</span>, until the temperature reaches 25.8 C. The
corresponding time allows for answering when death occurred.</p>
<p><strong>Solution.</strong>
A Forward Euler step from <span class="math">\(T^0\)</span> to <span class="math">\(T^1\)</span> reads</p>
<div class="math">
\[T^1 = T_0 + -k\Delta t (T^0 - T_s),\]</div>
<p>and solving with respect to <span class="math">\(k\)</span> results in</p>
<div class="math">
\[k = \frac{T^1 - T^0}{\Delta t(T_s - T_0)}\tp\]</div>
<p>We implement this formula in a function,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">estimate_k</span><span class="p">(</span><span class="n">T0</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">Ts</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">T1</span> <span class="o">-</span> <span class="n">T0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="p">(</span><span class="n">Ts</span> <span class="o">-</span> <span class="n">T0</span><span class="p">))</span>
</pre></div>
</div>
<p>We have <span class="math">\(T_0=26.7\)</span> C, <span class="math">\(T_1=25.8\)</span> C, <span class="math">\(T_s=20\)</span> C, and <span class="math">\(\Delta t = 1\)</span> h,
i.e., <span class="math">\(\Delta t = 3600\)</span> s. The proper call is therefore</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">k</span> <span class="o">=</span> <span class="n">estimate_k</span><span class="p">(</span><span class="mf">26.7</span><span class="p">,</span> <span class="mf">25.8</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">3600</span><span class="p">)</span>
</pre></div>
</div>
<p>For the simulation we use the Forward Euler method,</p>
<div class="math">
\[T^{n+1} = T^n - k\Delta t(T^n - T_s),\]</div>
<p>and simulate as long as <span class="math">\(T &gt; 25.8\)</span> C:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">T</span> <span class="o">=</span> <span class="mi">37</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="mi">20</span>
<span class="kn">from</span> <span class="nn">cooling</span> <span class="kn">import</span> <span class="n">cooling</span>
<span class="k">while</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="mf">25.8</span><span class="p">:</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">T</span> <span class="o">-</span> <span class="n">k</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="p">(</span><span class="n">T</span> <span class="o">-</span> <span class="n">Ts</span><span class="p">)</span>
    <span class="n">t</span><span class="o">+=</span> <span class="n">dt</span>

<span class="n">minutes</span><span class="p">,</span> <span class="n">seconds</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
<span class="n">hours</span><span class="p">,</span> <span class="n">minutes</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">minutes</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">The death occurred </span><span class="si">%d</span><span class="s"> hours, </span><span class="si">%d</span><span class="s"> minutes,</span>
<span class="s">and </span><span class="si">%g</span><span class="s"> seconds before 3am.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">hours</span><span class="p">,</span> <span class="n">minutes</span><span class="p">,</span> <span class="n">seconds</span><span class="p">)</span>
</pre></div>
</div>
<p>The result of running the code becomes</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python detective.py
k=3.73134e-05

The death occurred 8 hours, 0 minutes,
and 19 seconds before 3am.
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">detective</span></code>.</p>
</div>
<div class="section" id="exercise-20-simulate-an-oscillating-cooling-process">
<span id="decay-app-exer-cooling-osc"></span><h3>Exercise 20: Simulate an oscillating cooling process<a class="headerlink" href="#exercise-20-simulate-an-oscillating-cooling-process" title="Permalink to this headline">¶</a></h3>
<p>The surrounding temperature <span class="math">\(T_s\)</span> in Newton&#8217;s law of cooling
<a href="#equation-decay:Newton:cooling">(5)</a> may vary in time. Assume that the
variations are periodic with period <span class="math">\(P\)</span> and amplitude <span class="math">\(a\)</span> around
a constant mean temperature <span class="math">\(T_m\)</span>:</p>
<div class="math">
\[T_s(t) = T_m + a\sin\left(\frac{2\pi}{P}t\right)
\tp\]</div>
<p>Simulate a process with the following data: <span class="math">\(k=0.05 \hbox{ min}^{-1}\)</span>,
<span class="math">\(T(0)=5\)</span> C, <span class="math">\(T_m=25\)</span> C, <span class="math">\(a=2.5\)</span> C, and <span class="math">\(P=1\)</span> h, <span class="math">\(P=10\)</span> min, and <span class="math">\(P=6\)</span> h.
Plot the <span class="math">\(T\)</span> solutions and <span class="math">\(T_s\)</span> in the same plot.</p>
<p><strong>Solution.</strong>
We can reuse the <code class="docutils literal"><span class="pre">cooling</span></code> function from <a class="reference internal" href="#decay-app-exer-cooling-py"><span class="std std-ref">Exercise 18: Implement schemes for Newton&#8217;s law of cooling</span></a>
to do the simulations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">cooling</span><span class="p">(</span><span class="n">T0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">T_s</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve T&#39;=-k(T-T_s(t)), T(0)=T0,</span>
<span class="sd">    for t in (0,t_end] with steps of dt.</span>
<span class="sd">    T_s(t) is a Python function of t.</span>
<span class="sd">    theta=0.5 means Crank-Nicolson, 1 is Backward</span>
<span class="sd">    Euler, and 0 is Forward Euler scheme.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>                  <span class="c"># avoid integer division</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">t_end</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>       <span class="c"># no of time intervals</span>
    <span class="n">t_end</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span>                   <span class="c"># adjust to fit time step dt</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>              <span class="c"># array of T[n] values</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c"># time mesh</span>
    <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">T0</span>                       <span class="c"># set initial condition</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>          <span class="c"># n=0,1,...,Nt-1</span>
        <span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> \
        <span class="n">dt</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="n">theta</span><span class="o">*</span><span class="n">T_s</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">T_s</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])))</span><span class="o">/</span> \
        <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">theta</span><span class="o">*</span><span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">T</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>The challenge is to use the right units
for the input data. We can use Celsius for temperature since it has
the same increments as Kelvin. Time quantities should be measured
in seconds:</p>
<div class="math">
\[\begin{split}k &amp;= 20 \hbox{ min}^{-1} = \frac{20}{60}\hbox{ s}^{-1},\\
P &amp;= (1 \hbox{ h} = 3600\hbox{ s}, 10\hbox{ min} = 600\hbox{ s},
6\hbox{ h}=6\cdot 3600\hbox{ s})\tp\end{split}\]</div>
<p>To achieve reasonable accuracy,
we choose <span class="math">\(\Delta t\)</span> as 40 steps per the
shortest period of the <span class="math">\(T_s\)</span> oscillations:
<span class="math">\(\Delta t = 600/40\)</span>. With some trials we find
an appropriate simulation interval for all three cases to be
<span class="math">\([0,8]\)</span> h.</p>
<p>The code becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">cooling</span> <span class="kn">import</span> <span class="n">cooling</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span>

<span class="k">def</span> <span class="nf">T_s</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Tm</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">P</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="n">Tm</span> <span class="o">=</span> <span class="mi">25</span>
<span class="n">a</span> <span class="o">=</span> <span class="mf">2.5</span>
<span class="n">P_values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3600</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">3600</span><span class="o">*</span><span class="mi">6</span><span class="p">]</span>
<span class="n">k</span> <span class="o">=</span> <span class="mf">0.05</span><span class="o">/</span><span class="mi">60</span>
<span class="n">T0</span> <span class="o">=</span> <span class="mi">5</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">P_values</span><span class="p">:</span>
    <span class="n">T</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cooling</span><span class="p">(</span><span class="n">T0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">T_s</span><span class="p">,</span> <span class="n">t_end</span><span class="o">=</span><span class="mi">8</span><span class="o">*</span><span class="mi">3600</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">600</span><span class="o">/</span><span class="mi">40</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">T_s</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="s">&#39;k--&#39;</span><span class="p">)</span>
<span class="n">legends</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;P=1 h&#39;</span><span class="p">,</span> <span class="s">&#39;P=10 min&#39;</span><span class="p">,</span> <span class="s">&#39;P=6 h&#39;</span><span class="p">,</span> <span class="s">&#39;$T_s$&#39;</span><span class="p">]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legends</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;lower right&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;T&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp.png&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp.pdf&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/osc_cooling.png"><img alt="_images/osc_cooling.png" src="_images/osc_cooling.png" style="width: 700px;" /></a>
</div>
<p><strong>Discussion of the results.</strong>
We see that it takes some time to increase the temperature from <span class="math">\(T_0\)</span>
to oscillations around <span class="math">\(T_m\)</span>. When <span class="math">\(T_s\)</span> oscillates fast (<span class="math">\(P=10\)</span> min),
<span class="math">\(k\)</span> is not large enough so that <span class="math">\(T\)</span> can reach the surrounding temperature
in the time available before the surrounding temperature decreases.
However, for large <span class="math">\(P\)</span> (6 h), there is almost enough time to heat
and cool the object to reach the maximum and minimum temperatures
of the surroundings.</p>
<p>Filename: <code class="docutils literal"><span class="pre">osc_cooling</span></code>.</p>
</div>
<div class="section" id="exercise-21-simulate-stochastic-radioactive-decay">
<span id="decay-app-exer-stoch-nuclear"></span><h3>Exercise 21: Simulate stochastic radioactive decay<a class="headerlink" href="#exercise-21-simulate-stochastic-radioactive-decay" title="Permalink to this headline">¶</a></h3>
<p>The purpose of this exercise is to implement the stochastic model
described in the section <a class="reference internal" href="#decay-app-nuclear"><span class="std std-ref">Radioactive decay</span></a> and show that its
mean behavior approximates the solution of the corresponding
ODE model.</p>
<p>The simulation goes on for a time interval <span class="math">\([0,T]\)</span> divided into
<span class="math">\(N_t\)</span> intervals of length <span class="math">\(\Delta t\)</span>. We start with <span class="math">\(N_0\)</span>
atoms. In some time interval, we have <span class="math">\(N\)</span> atoms that have survived.
Simulate <span class="math">\(N\)</span> Bernoulli trials with probability <span class="math">\(\lambda\Delta t\)</span>
in this interval by drawing <span class="math">\(N\)</span> random numbers, each being 0 (survival)
or 1 (decay), where the probability of getting 1 is <span class="math">\(\lambda\Delta t\)</span>.
We are interested in the number of decays, <span class="math">\(d\)</span>, and the number of
survived atoms in the next interval is then <span class="math">\(N-d\)</span>.
The Bernoulli trials
are simulated by drawing <span class="math">\(N\)</span> uniformly distributed real numbers on
<span class="math">\([0,1]\)</span> and saying that 1 corresponds to a value less than <span class="math">\(\lambda\Delta t\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Given lambda_, dt, N</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">uniform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">Bernoulli_trials</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">uniform</span> <span class="o">&lt;</span> <span class="n">lambda_</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">Bernoulli_trials</span><span class="o">.</span><span class="n">size</span>
</pre></div>
</div>
<p>Observe that <code class="docutils literal"><span class="pre">uniform</span> <span class="pre">&lt;</span> <span class="pre">lambda_*dt</span></code> is a boolean array whose true
and false values become 1 and 0, respectively, when converted to an
integer array.</p>
<p>Repeat the simulation over <span class="math">\([0,T]\)</span> a large number of times, compute the average
value of <span class="math">\(N\)</span> in each interval, and compare with the solution of
the corresponding ODE model.
Filename: <code class="docutils literal"><span class="pre">stochastic_decay</span></code>.</p>
</div>
<div class="section" id="exercise-22-radioactive-decay-of-two-substances">
<span id="decay-app-exer-radio-twosubst"></span><h3>Exercise 22: Radioactive decay of two substances<a class="headerlink" href="#exercise-22-radioactive-decay-of-two-substances" title="Permalink to this headline">¶</a></h3>
<p>Consider two radioactive substances A and B. The nuclei in substance A
decay to form nuclei of type B with a half-life <span class="math">\(A_{1/2}\)</span>, while
substance B decay to form type A nuclei with a half-life <span class="math">\(B_{1/2}\)</span>.
Letting <span class="math">\(u_A\)</span> and <span class="math">\(u_B\)</span> be the fractions of the initial amount of
material in substance A and B, respectively, the following system of
ODEs governs the evolution of <span class="math">\(u_A(t)\)</span> and <span class="math">\(u_B(t)\)</span>:</p>
<div class="math">
\[\frac{1}{\ln 2} u_A^{\prime} = u_B/B_{1/2} - u_A/A_{1/2},\]</div>
<div class="math">
\[\frac{1}{\ln 2} u_B^{\prime} = u_A/A_{1/2} - u_B/B_{1/2},\]</div>
<p>with <span class="math">\(u_A(0)=u_B(0)=1\)</span>.</p>
<p><strong>a)</strong>
Make a simulation program that solves for <span class="math">\(u_A(t)\)</span> and <span class="math">\(u_B(t)\)</span>.</p>
<p><strong>b)</strong>
Verify the implementation by computing analytically
the limiting values of
<span class="math">\(u_A\)</span> and <span class="math">\(u_B\)</span> as <span class="math">\(t\rightarrow \infty\)</span> (assume <span class="math">\(u_A^{\prime},u_B^{\prime}\rightarrow 0\)</span>)
and comparing these with those obtained numerically.</p>
<p><strong>c)</strong>
Run the program for the case of <span class="math">\(A_{1/2}=10\)</span> minutes and <span class="math">\(B_{1/2}=50\)</span> minutes.
Use a time unit of 1 minute. Plot <span class="math">\(u_A\)</span> and <span class="math">\(u_B\)</span> versus time in the same
plot.</p>
<p>Filename: <code class="docutils literal"><span class="pre">radioactive_decay_2subst</span></code>.</p>
</div>
<div class="section" id="exercise-23-simulate-a-simple-chemical-reaction">
<span id="decay-app-exer-kinetics-ab"></span><h3>Exercise 23: Simulate a simple chemical reaction<a class="headerlink" href="#exercise-23-simulate-a-simple-chemical-reaction" title="Permalink to this headline">¶</a></h3>
<p>Consider the simple chemical reaction where a substance A is turned
into a substance B according to</p>
<div class="math">
\[\begin{split}\frac{[A]}{dt} &amp;= -k[A],\\
\frac{[B]}{dt} &amp;= k[A],\\\end{split}\]</div>
<p>where <span class="math">\([A]\)</span> and <span class="math">\([B]\)</span> are the concentrations of A and B, respectively.
It may be a challenge to find appropriate values of <span class="math">\(k\)</span>, but we can avoid
this problem by working with a scaled model (as explained in
the section <a class="reference internal" href="#decay-app-scaling"><span class="std std-ref">Scaling  (1)</span></a>).
Scale the model above, using a time scale <span class="math">\(1/k\)</span>, and use
the initial concentration
of <span class="math">\([A]\)</span> as scale for <span class="math">\([A]\)</span> and <span class="math">\([B]\)</span>. Show that the scaled system
reads</p>
<div class="math">
\[\begin{split}\frac{u}{dt} &amp;= -u,\\
\frac{v}{dt} &amp;= u,\\\end{split}\]</div>
<p>with initial conditions <span class="math">\(u(0)=1\)</span>, and <span class="math">\(v(0)=\alpha\)</span>, where
<span class="math">\(\alpha = [B](0)/[A](0)\)</span> is a dimensionless number, and
<span class="math">\(u\)</span> and <span class="math">\(v\)</span> are the scaled concentrations of <span class="math">\([A]\)</span> and <span class="math">\([B]\)</span>,
respectively. Implement a numerical scheme that can be used to
find the solutions
<span class="math">\(u(t)\)</span> and <span class="math">\(v(t)\)</span>. Visualize <span class="math">\(u\)</span> and <span class="math">\(v\)</span> in the same plot.
Filename: <code class="docutils literal"><span class="pre">chemcial_kinetics_AB</span></code>.</p>
</div>
<div class="section" id="exercise-24-simulate-an-th-order-chemical-reaction">
<span id="decay-app-exer-kinetics-abn"></span><h3>Exercise 24: Simulate an <span class="math">\(n\)</span>-th order chemical reaction<a class="headerlink" href="#exercise-24-simulate-an-th-order-chemical-reaction" title="Permalink to this headline">¶</a></h3>
<p>An <span class="math">\(n\)</span>-order chemical reaction, generalizing the model in
<a class="reference internal" href="#decay-app-exer-kinetics-ab"><span class="std std-ref">Exercise 23: Simulate a simple chemical reaction</span></a>, takes the form</p>
<div class="math">
\[\begin{split}\frac{[A]}{dt} &amp;= -k[A]^n,\\
\frac{[B]}{dt} &amp;= k[A]^n,\\\end{split}\]</div>
<p>where symbols are as defined in <a class="reference internal" href="#decay-app-exer-kinetics-ab"><span class="std std-ref">Exercise 23: Simulate a simple chemical reaction</span></a>.
Bring this model on dimensionless form, using a time scale <span class="math">\([A](0)^{n-1}/k\)</span>,
and show that the dimensionless model simplifies to</p>
<div class="math">
\[\begin{split}\frac{u}{dt} &amp;= -u^n,\\
\frac{v}{dt} &amp;= u^n,\\\end{split}\]</div>
<p>with <span class="math">\(u(0)=1\)</span> and <span class="math">\(v(0)=\alpha = [B](0)/[A](0)\)</span>. Solve numerically for
<span class="math">\(u(t)\)</span> and show a plot with <span class="math">\(u\)</span> for <span class="math">\(n=0.5, 1, 2, 4\)</span>.
Filename: <code class="docutils literal"><span class="pre">chemcial_kinetics_ABn</span></code>.</p>
</div>
<div class="section" id="exercise-25-simulate-spreading-of-a-disease">
<span id="decay-app-exer-sir"></span><h3>Exercise 25: Simulate spreading of a disease<a class="headerlink" href="#exercise-25-simulate-spreading-of-a-disease" title="Permalink to this headline">¶</a></h3>
<p>The SIR model <a href="#equation-decay:app:SIR:S">(11)</a>-<a href="#equation-decay:app:SIR:R">(13)</a> can be used
to simulate spreading of an epidemic disease.</p>
<p><strong>a)</strong>
Estimating the parameter <span class="math">\(\beta\)</span>
is difficult so it can be handy to scale the equations. Use
<span class="math">\(t_c=1/\nu\)</span> as time scale, and scale <span class="math">\(S\)</span>, <span class="math">\(I\)</span>, and <span class="math">\(R\)</span> by
the population size <span class="math">\(N=S(0)+I(0)+R(0)\)</span>. Show that the resulting dimensionless
model becomes</p>
<div class="math" id="equation-decay:app:SIR:S2">
<span id="eq-decay-app-sir-s2"></span><span class="eqno">(24)</span>\[     \frac{d\bar S}{d\bar t} = - R_0\bar S\bar I,\]</div>
<div class="math" id="equation-decay:app:SIR:I2">
<span id="eq-decay-app-sir-i2"></span><span class="eqno">(25)</span>\[     \frac{d\bar I}{d\bar t} = R_0 \bar S\bar I - \bar I,\]</div>
<div class="math" id="equation-decay:SIR:R2">
<span id="eq-decay-sir-r2"></span><span class="eqno">(26)</span>\[     \frac{d\bar R}{d\bar t} = I,\]</div>
<div class="math">
\[\bar S(0) = 1-\alpha,\]</div>
<div class="math">
\[\bar I(0) = \alpha,\]</div>
<div class="math">
\[\bar R(0) = 0,\]</div>
<p>where <span class="math">\(R_0\)</span> and <span class="math">\(\alpha\)</span> are the only parameters in the problem:</p>
<div class="math">
\[R_0 = \frac{N\beta}{\nu}, \quad \alpha = \frac{I(0)}{N}\tp\]</div>
<p><strong>Solution.</strong>
We introduce</p>
<div class="math">
\[\bar t = \frac{t}{\nu^{-1}},\quad \bar S = \frac{S}{N},\quad
\bar I = \frac{I}{N},\quad \bar R = \frac{R}{N}\tp\]</div>
<p>Inserting these expressions in the governing equations and dividing by
<span class="math">\(\nu N\)</span> gives the listed dimensionless ODEs. The scaled initial condition
for <span class="math">\(\bar S(0)\)</span> follows from
<span class="math">\(\bar S(0) = S(0)/N = (N-I(0))/N = 1 - \alpha\)</span>, since initially,
<span class="math">\(R(0)=0\)</span> and therefore <span class="math">\(N=S(0) + I(0)\)</span>.</p>
<p><strong>b)</strong>
Show that the <span class="math">\(R_0\)</span> parameter governs whether the disease will spread
or not at <span class="math">\(t=0\)</span>.</p>
<p><strong>Hint.</strong>
Spreading means <span class="math">\(dI/dt&gt;0\)</span>.</p>
<p><strong>Solution.</strong>
For <span class="math">\(dI/dt\)</span> to be positive, we must have <span class="math">\((R_0 \bar S - 1)\bar I &gt; 0\)</span>, i.e.,
<span class="math">\(R_0 \bar S - 1 &gt; 0\)</span> since <span class="math">\(\bar I\geq 0\)</span>. At <span class="math">\(t=0\)</span>, we get
<span class="math">\(R_0 \bar S(0) &gt; 1\)</span> as the criterion, or</p>
<div class="math">
\[\begin{split}\tilde R_0\bar S(0) = \frac{N\beta}{\nu}\frac{S(0)}{N} = \frac{S(0)\beta}{\nu} &gt;1
\tp\end{split}\]</div>
<p>The dimensionless parameter <span class="math">\(S(0)\beta /\nu\)</span> is denoted by <span class="math">\(R_0\)</span> in
the epidemiology literature and known as the <em>basic reproductive number</em>.</p>
<p><strong>c)</strong>
Implement the scaled SIR model. Check at every time step,
as a verification, that
<span class="math">\(\bar S + \bar I + \bar R = 1\)</span>.</p>
<p><strong>d)</strong>
Simulate the spreading of a disease where <span class="math">\(R_0=1.1\)</span> and 1 percent of
the population is infected at time <span class="math">\(t=0\)</span>.</p>
<p><strong>Solution.</strong>
The given data means that <span class="math">\(\bar I(0)=\alpha = 0.01\)</span> and <span class="math">\(\bar S(0)=0.99\)</span>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">SIR</span></code>.</p>
</div>
<div class="section" id="exercise-26-simulate-a-biochemical-process">
<span id="decay-app-exer-mmk"></span><h3>Exercise 26: Simulate a biochemical process<a class="headerlink" href="#exercise-26-simulate-a-biochemical-process" title="Permalink to this headline">¶</a></h3>
<p>The purpose of this exercise is to simulate the ODE system
<a href="#equation-decay:app:MMK:ES1">(7)</a>-<a href="#equation-decay:app:MMK:E1">(10)</a> modeling a simple
biochemical process.</p>
<p><strong>a)</strong>
Scale <a href="#equation-decay:app:MMK:ES1">(7)</a>-<a href="#equation-decay:app:MMK:E1">(10)</a> such that
we can work with dimensionless parameters, which are easier to prescribe.
Introduce</p>
<div class="math">
\[\bar Q = \frac{[ES]}{Q_c},\quad
\bar P = \frac{P}{P_c},\quad \bar S = \frac{S}{S_0},\quad \bar E = \frac{E}{E_0},\quad \bar t = \frac{t}{t_c},\]</div>
<p>where appropriate scales are</p>
<div class="math">
\[Q_c = \frac{S_0E_0}{K},\quad P_c = Q_c, \quad t_c=\frac{1}{k_+E_0},\]</div>
<p>with <span class="math">\(K=(k_v+k_-)/k_+\)</span> is the Michaelis constant. Show that the scale
system becomes</p>
<div class="math" id="equation-decay:app:MMK:Q2">
<span id="eq-decay-app-mmk-q2"></span><span class="eqno">(27)</span>\[     \frac{d\bar Q}{d\bar t} = \alpha (\bar E\bar S
     - \bar Q),\]</div>
<div class="math" id="equation-decay:app:MMK:P2">
<span id="eq-decay-app-mmk-p2"></span><span class="eqno">(28)</span>\[     \frac{d\bar P}{d\bar t} = \beta\bar Q,\]</div>
<div class="math" id="equation-decay:app:MMK:S2">
<span id="eq-decay-app-mmk-s2"></span><span class="eqno">(29)</span>\[     \frac{d\bar S}{d\bar t} = -\bar E\bar S
     + (1 - \beta\alpha^{-1})\bar Q,\]</div>
<div class="math" id="equation-decay:app:MMK:E2">
<span id="eq-decay-app-mmk-e2"></span><span class="eqno">(30)</span>\[     \epsilon\frac{d\bar E}{d\bar t} = -\bar E\bar S + \bar Q,\]</div>
<p>where we have three dimensionless parameters</p>
<div class="math">
\[\alpha = \frac{K}{E_0},\quad \beta = \frac{k_v}{k_+ E_0},\quad
\epsilon = \frac{E_0}{S_0}\tp\]\[The corresponding initial conditions are $\bar Q=\bar P=0$ and
$\bar S=\bar E=1$.\]</div>
<p><strong>Solution.</strong>
Replacing the unknowns and <span class="math">\(t\)</span> by their dimensionless equivalents
leads to</p>
<div class="math">
\[\begin{split}\frac{d\bar Q}{d\bar t} &amp;= t_ck_+\frac{E_0S_0}{Q_c}\bar E\bar S
- t_c(k_v + k_-)\bar Q,\\
\frac{d\bar P}{d\bar t} &amp;= t_ck_v\frac{Q_c}{P_c}\bar Q,\\
\frac{d\bar S}{d\bar t} &amp;= -t_ck_+E_0\bar E\bar S
+ t_ck_-\frac{Q_c}{S_0}\bar Q,\\
\frac{d\bar E}{d\bar t} &amp;= -t_ck_+S_0\bar E\bar S
+ t_c(k_- + k_v)\frac{Q_c}{E_0}\bar Q\tp\end{split}\]</div>
<p>Inserting the choice of scales brings us to the given equations, after
quite some algebra and identifying coefficients in terms of the
provided dimensionless numbers.</p>
<p><strong>b)</strong>
Implement a function for
solving <a href="#equation-decay:app:MMK:Q2">(27)</a>-<a href="#equation-decay:app:MMK:E2">(30)</a>.</p>
<p><strong>Solution.</strong>
Let us use Odespy to solve the differential equations, although a plain
Forward Euler scheme will be fine.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">odespy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="n">u</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">S</span> <span class="o">-</span> <span class="n">Q</span><span class="p">),</span>
            <span class="n">beta</span><span class="o">*</span><span class="n">Q</span><span class="p">,</span>
            <span class="o">-</span><span class="n">E</span><span class="o">*</span><span class="n">S</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta</span><span class="o">/</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">Q</span><span class="p">,</span>
            <span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="o">*</span><span class="n">S</span> <span class="o">+</span> <span class="n">Q</span><span class="p">)</span><span class="o">/</span><span class="n">epsilon</span><span class="p">,</span>
            <span class="p">]</span>

    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">t_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">solver</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">RK4</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t_mesh</span><span class="p">)</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Q</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">E</span>
</pre></div>
</div>
<p><strong>c)</strong>
There are two conservation equations implied by
<a href="#equation-decay:app:MMK:ES1">(7)</a>-<a href="#equation-decay:app:MMK:E1">(10)</a>:</p>
<div class="math">
\[[ES] + [E] = E_0,\]</div>
<div class="math">
\[[ES] + [S] + [P] = S_0\tp\]</div>
<p>Derive these two equations. Use these properties in the function
in b) to do a partial verification of the solution at each time step.</p>
<p><strong>Solution.</strong>
Adding
<a href="#equation-decay:app:MMK:ES1">(7)</a> and <a href="#equation-decay:app:MMK:E1">(10)</a> shows that</p>
<div class="math">
\[\frac{d[ES]}{dt} + \frac{d[E]}{dt} = 0,\]</div>
<p>and therefore <span class="math">\([ES] + [E]=\hbox{const}\)</span>. Since <span class="math">\([ES](0)=0\)</span> and
<span class="math">\([E](0)=E_0\)</span>, the constant is <span class="math">\(E_0\)</span> at <span class="math">\(t=0\)</span> and will remain so.
Similarly, adding <a href="#equation-decay:app:MMK:ES1">(7)</a>,
<a href="#equation-decay:app:MMK:S1">(9)</a>, and <a href="#equation-decay:app:MMK:P1">(8)</a>
shows that their time derivatives sum up to zero, and therefore
<span class="math">\([ES] + [S] + [P] =\hbox{const}\)</span>. Since <span class="math">\([P](0)=0\)</span>, the constant
must be <span class="math">\(0+S_0+0=S_0\)</span>.</p>
<p>To use the conservation as a consistency check in the software, we need
to find the equivalent dimensionless versions:</p>
<div class="math">
\[[ES] + [E] = E_0\quad\Rightarrow\quad Q_c\bar Q + E_0\bar E = E_0,\]</div>
<p>and from this we get, after a little algebra,</p>
<div class="math">
\[\alpha^{-1}\epsilon^{-1}\bar Q + \bar E = 1\tp\]</div>
<p>The other conservation equation becomes</p>
<div class="math">
\[\bar Q + \alpha\bar S + \bar P  = \alpha\tp\]</div>
<p>The implementation may go like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">computed</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">epsilon</span><span class="p">)</span> <span class="o">+</span> <span class="n">E</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="n">expected</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">diff1</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">computed</span> <span class="o">-</span> <span class="n">expected</span><span class="p">)</span>

<span class="n">computed</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">alpha</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">P</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="n">expected</span> <span class="o">=</span> <span class="n">alpha</span>
<span class="n">diff2</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">computed</span> <span class="o">-</span> <span class="n">expected</span><span class="p">)</span>

<span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
<span class="k">if</span> <span class="n">diff1</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> <span class="n">diff2</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;*** Consistency check failed:&#39;</span><span class="p">,</span> <span class="n">diff1</span><span class="p">,</span> <span class="n">diff2</span>
</pre></div>
</div>
<p><strong>d)</strong>
Simulate a case with <span class="math">\(T=8\)</span>, <span class="math">\(\alpha = 1\)</span>, <span class="math">\(\beta=4\)</span>, and two
<span class="math">\(\epsilon\)</span> values: 0.9 and 0.1.</p>
<p><strong>Solution.</strong></p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">demo</span><span class="p">():</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="k">else</span> <span class="mf">0.1</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;complex&#39;</span><span class="p">,</span> <span class="s">&#39;product&#39;</span><span class="p">,</span> <span class="s">&#39;substrate&#39;</span><span class="p">,</span> <span class="s">&#39;enzyme&#39;</span><span class="p">],</span>
               <span class="n">loc</span><span class="o">=</span><span class="s">&#39;upper right&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;alpha=</span><span class="si">%g</span><span class="s">, beta=</span><span class="si">%g</span><span class="s">, epsilon=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp.png&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp.pdf&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">demo</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/biochem.png"><img alt="_images/biochem.png" src="_images/biochem.png" style="width: 700px;" /></a>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">biochem</span></code>.</p>
</div>
<div class="section" id="exercise-27-simulate-the-pressure-drop-in-the-atmosphere">
<span id="decay-app-exer-atm1"></span><h3>Exercise 27: Simulate the pressure drop in the atmosphere<a class="headerlink" href="#exercise-27-simulate-the-pressure-drop-in-the-atmosphere" title="Permalink to this headline">¶</a></h3>
<p>We consider the models for atmospheric pressure in
the section <a class="reference internal" href="#decay-app-atm"><span class="std std-ref">Decay of atmospheric pressure with altitude</span></a>.
Make a program with three functions,</p>
<blockquote>
<div><ul class="simple">
<li>one computing the pressure <span class="math">\(p(z)\)</span> using a seven-layer model
and varying <span class="math">\(L\)</span>,</li>
<li>one computing <span class="math">\(p(z)\)</span> using a seven-layer model,
but with constant temperature in each layer, and</li>
<li>one computing <span class="math">\(p(z)\)</span> based on the
one-layer model.</li>
</ul>
</div></blockquote>
<p>How can these implementations be verified? Should ease of verification
impact how you code the functions?
Compare the three models in a plot.
Filename: <code class="docutils literal"><span class="pre">atmospheric_pressure</span></code>.</p>
</div>
<div class="section" id="exercise-28-make-a-program-for-vertical-motion-in-a-fluid">
<span id="decay-app-exer-drag-prog"></span><h3>Exercise 28: Make a program for vertical motion in a fluid<a class="headerlink" href="#exercise-28-make-a-program-for-vertical-motion-in-a-fluid" title="Permalink to this headline">¶</a></h3>
<p>Implement the Stokes&#8217; drag model <a href="#equation-decay:app:fallingbody:model:S">(18)</a>
and the quadratic drag model <a href="#equation-decay:app:fallingbody:model:q">(20)</a> from
the section <a class="reference internal" href="#decay-app-drag"><span class="std std-ref">Vertical motion of a body in a viscous fluid</span></a>, using the Crank-Nicolson
scheme and a geometric mean for <span class="math">\(|v|v\)</span> as explained, and assume
constant fluid density.
At each time level, compute the Reynolds number
Re and choose the Stokes&#8217; drag model if <span class="math">\(\hbox{Re} &lt; 1\)</span> and the
quadratic drag model otherwise.</p>
<p>The computation of the numerical solution should take place either in
a stand-alone function or in a solver class that looks up a problem
class for physical data. Create a module and equip it with pytest/nose
compatible test functions for automatically verifying the code.</p>
<p>Verification tests can be based on</p>
<blockquote>
<div><ul class="simple">
<li>the terminal velocity (see the section <a class="reference internal" href="#decay-app-drag"><span class="std std-ref">Vertical motion of a body in a viscous fluid</span></a>),</li>
<li>the exact solution when the drag force is neglected
(see the section <a class="reference internal" href="#decay-app-drag"><span class="std std-ref">Vertical motion of a body in a viscous fluid</span></a>),</li>
<li>the method of manufactured solutions (see the section <a class="reference internal" href="._book007.html#decay-mms"><span class="std std-ref">Verification via manufactured solutions</span></a>)
combined with computing
convergence rates (see the section <a class="reference internal" href="._book007.html#decay-convergence-rate"><span class="std std-ref">Computing convergence rates</span></a>).</li>
</ul>
</div></blockquote>
<p>Use, e.g., a quadratic polynomial for the velocity in the method of
manufactured solutions. The expected error is <span class="math">\(\Oof{\Delta t^2}\)</span>
from the centered finite difference approximation and the geometric
mean approximation for <span class="math">\(|v|v\)</span>.</p>
<p>A solution that is linear in <span class="math">\(t\)</span> will also be an exact solution of the
discrete equations in many problems.  Show that this is true for
linear drag (by adding a source term that depends on <span class="math">\(t\)</span>), but not
for quadratic drag because of the geometric mean approximation.  Use
the method of manufactured solutions to add a source term <em>in the
discrete equations for quadratic drag</em> such that a linear function of
<span class="math">\(t\)</span> is a solution. Add a test function for checking that the linear
function is reproduced to machine precision in the case of both linear
and quadratic drag.</p>
<p>Apply the software to a case where a ball rises in water.  The
buoyancy force is here the driving force, but the drag will be
significant and balance the other forces after a short time.  A soccer
ball has radius 11 cm and mass 0.43 kg.  Start the motion from rest, set
the density of water, <span class="math">\(\varrho\)</span>, to <span class="math">\(1000\hbox{ kg/m}^3\)</span>, set the
dynamic viscosity, <span class="math">\(\mu\)</span>, to <span class="math">\(10^{-3}\hbox{ Pa s}\)</span>, and use a drag
coefficient for a sphere: 0.45. Plot the velocity of the rising ball.
Filename: <code class="docutils literal"><span class="pre">vertical_motion</span></code>.</p>
</div>
<div class="section" id="project-29-simulate-parachuting">
<span id="decay-app-exer-parachute"></span><h3>Project 29: Simulate parachuting<a class="headerlink" href="#project-29-simulate-parachuting" title="Permalink to this headline">¶</a></h3>
<p>The aim of this project is to develop a general solver for the
vertical motion of a body with quadratic air drag, verify the solver,
apply the solver to a skydiver in free fall, and finally apply the
solver to a complete parachute jump.</p>
<p>All the pieces of software implemented in this project should be
realized as Python functions and/or classes and collected in one
module.</p>
<p><strong>a)</strong>
Set up the differential equation problem that governs the velocity
of the motion.
The parachute jumper is subject to the gravity force and a quadratic
drag force. Assume constant density.
Add an extra source term be used for program verification.
Identify the input data to the problem.</p>
<p><strong>b)</strong>
Make a Python module for computing the velocity of the motion.
Also equip the module with functionality for plotting the velocity.</p>
<p><strong>Hint 1.</strong>
Use the Crank-Nicolson scheme with a geometric mean of <span class="math">\(|v|v\)</span> in time to
linearize the equation of motion with quadratic drag.</p>
<p><strong>Hint 2.</strong>
You can either use functions or classes for implementation.
If you choose functions, make a function
<code class="docutils literal"><span class="pre">solver</span></code> that takes all the input data in the problem as
arguments and that returns the velocity (as a mesh function) and
the time mesh. In case of a class-based implementation, introduce
a problem class with the physical data
and a solver class with the numerical data and a <code class="docutils literal"><span class="pre">solve</span></code> method
that stores the velocity and the mesh in the class.</p>
<p>Allow for a time-dependent area and drag coefficient in the
formula for the drag force.</p>
<p><strong>c)</strong>
Show that a linear function of <span class="math">\(t\)</span> does not fulfill the discrete
equations because of the geometric mean approximation
used for the quadratic drag
term.  Fit a source term, as in the method of manufactured solutions,
such that a linear function of <span class="math">\(t\)</span> is a solution of the discrete
equations. Make a test function to check that this solution is reproduced
to machine precision.</p>
<p><strong>d)</strong>
The expected error in this problem goes like <span class="math">\(\Delta t^2\)</span> because we
use a centered finite difference approximation with error <span class="math">\(\Oof{\Delta t^2}\)</span>
and a geometric mean approximation with error <span class="math">\(\Oof{\Delta t^2}\)</span>.
Use the method of manufactured solutions combined with computing
convergence rate to verify the code. Make a test function for checking
that the convergence rate is correct.</p>
<p><strong>e)</strong>
Compute the drag force, the gravity
force, and the buoyancy force as a function of time. Create
a plot with these three forces.</p>
<p><strong>Hint.</strong>
You can either make a function <code class="docutils literal"><span class="pre">forces(v,</span> <span class="pre">t,</span> <span class="pre">plot=None)</span></code>
that returns the forces (as mesh functions) and <code class="docutils literal"><span class="pre">t</span></code>, and shows
a plot on the screen and also saves the plot to a file with name
stored in <code class="docutils literal"><span class="pre">plot</span></code>
if <code class="docutils literal"><span class="pre">plot</span></code> is not <code class="docutils literal"><span class="pre">None</span></code>, or you can extend the solver class with
computation of forces and include plotting of forces in the
visualization class.</p>
<p><strong>f)</strong>
Compute the velocity of
a skydiver in free fall before the parachute opens.</p>
<p><strong>Hint.</strong>
Meade and Struthers <a class="reference internal" href="._book010.html#ref10" id="id2">[Ref10]</a> provide some data relevant
to <a class="reference external" href="http://en.wikipedia.org/wiki/Parachuting">skydiving</a>.
The mass of the human body and equipment
can be set to <span class="math">\(100\)</span> kg.
A skydiver in spread-eagle formation has a cross-section of 0.5 <span class="math">\(\hbox{m}^2\)</span>
in the horizontal plane.
The density of air decreases varies altitude, but can be taken
as constant, 1 <span class="math">\(\hbox{kg/m}^3\)</span>, for altitudes relevant to
skydiving (0-4000 m).
The drag coefficient for a man in upright position can be set to 1.2.
Start with a zero velocity.
A free fall typically has a terminating velocity of 45 m/s. (This value
can be used to tune other parameters.)</p>
<p><strong>g)</strong>
The next task is to simulate
a parachute jumper during free fall and after the parachute opens.
At time <span class="math">\(t_p\)</span>, the parachute opens and
the drag coefficient and the cross-sectional
area change dramatically.
Use the program to simulate a jump from <span class="math">\(z=3000\)</span> m to the ground <span class="math">\(z=0\)</span>.
What is the maximum acceleration, measured in units of <span class="math">\(g\)</span>,
experienced by the jumper?</p>
<p><strong>Hint.</strong>
Following Meade and Struthers <a class="reference internal" href="._book010.html#ref10" id="id3">[Ref10]</a>, one can set the
cross-section area perpendicular to the motion to 44 <span class="math">\(\hbox{m}^2\)</span>
when the parachute is open. Assume that it takes 8 s to increase
the area linearly from the original to the final value.
The drag coefficient for an open
parachute can be taken as 1.8, but tuned using the known value
of the typical terminating velocity reached before landing:
5.3 m/s. One can take the drag coefficient as a piecewise constant
function with an abrupt change at <span class="math">\(t_p\)</span>.
The parachute is typically released after <span class="math">\(t_p=60\)</span> s, but
larger values of <span class="math">\(t_p\)</span> can be used to make plots more illustrative.</p>
<p>Filename: <code class="docutils literal"><span class="pre">parachuting</span></code>.</p>
</div>
<div class="section" id="exercise-30-formulate-vertical-motion-in-the-atmosphere">
<span id="decay-app-exer-drag-atm1"></span><h3>Exercise 30: Formulate vertical motion in the atmosphere<a class="headerlink" href="#exercise-30-formulate-vertical-motion-in-the-atmosphere" title="Permalink to this headline">¶</a></h3>
<p>Vertical motion of a body in the atmosphere needs to take into
account a varying air density if the range of altitudes is
many kilometers. In this case, <span class="math">\(\varrho\)</span> varies with the altitude <span class="math">\(z\)</span>.
The equation of motion for the body is given in
the section <a class="reference internal" href="#decay-app-drag"><span class="std std-ref">Vertical motion of a body in a viscous fluid</span></a>. Let us assume quadratic drag force
(otherwise the body has to be very, very small).
A differential equation problem for the air density, based on
the information for the one-layer atmospheric model in
the section <a class="reference internal" href="#decay-app-atm"><span class="std std-ref">Decay of atmospheric pressure with altitude</span></a>, can be set up as</p>
<div class="math">
\[p^{\prime}(z) = -\frac{Mg}{R^*(T_0+Lz)} p,\]</div>
<div class="math">
\[\varrho = p \frac{M}{R^*T}
\tp\]</div>
<p>To evaluate <span class="math">\(p(z)\)</span> we need the altitude <span class="math">\(z\)</span>. From the principle that the
velocity is the derivative of the position we have that</p>
<div class="math">
\[z^{\prime}(t) = v(t),\]</div>
<p>where <span class="math">\(v\)</span> is the velocity of the body.</p>
<p>Explain in detail how the governing equations can be discretized
by the Forward Euler and the Crank-Nicolson methods.
Discuss pros and cons of the two methods.
Filename: <code class="docutils literal"><span class="pre">falling_in_variable_density</span></code>.</p>
</div>
<div class="section" id="exercise-31-simulate-vertical-motion-in-the-atmosphere">
<span id="decay-app-exer-drag-atm2"></span><h3>Exercise 31: Simulate vertical motion in the atmosphere<a class="headerlink" href="#exercise-31-simulate-vertical-motion-in-the-atmosphere" title="Permalink to this headline">¶</a></h3>
<p>Implement the Forward Euler or the Crank-Nicolson scheme
derived in <a class="reference internal" href="#decay-app-exer-drag-atm1"><span class="std std-ref">Exercise 30: Formulate vertical motion in the atmosphere</span></a>.
Demonstrate the effect of air density variation on a falling
human, e.g., the famous fall of <a class="reference external" href="http://en.wikipedia.org/wiki/Felix_Baumgartner">Felix Baumgartner</a>. The drag coefficient can be set to 1.2.
Filename: <code class="docutils literal"><span class="pre">falling_in_variable_density</span></code>.</p>
</div>
<div class="section" id="exercise-32-compute-by-solving-an-ode">
<span id="decay-app-exer-signum"></span><h3>Exercise 32: Compute <span class="math">\(y=|x|\)</span> by solving an ODE<a class="headerlink" href="#exercise-32-compute-by-solving-an-ode" title="Permalink to this headline">¶</a></h3>
<p>Consider the ODE problem</p>
<div class="math">
\[\begin{split}y^{\prime}(x) = \left\lbrace\begin{array}{ll}
-1, &amp; x &lt; 0,\\
1, &amp; x \geq 0
\end{array}\right.\quad x\in (-1, 1],
\quad y(1-)=1,\end{split}\]</div>
<p>which has the solution <span class="math">\(y(x)=|x|\)</span>.
Using a mesh <span class="math">\(x_0=-1\)</span>, <span class="math">\(x_1=0\)</span>, and <span class="math">\(x_2=1\)</span>, calculate by hand
<span class="math">\(y_1\)</span> and <span class="math">\(y_2\)</span> from the Forward Euler, Backward Euler, Crank-Nicolson,
and Leapfrog methods. Use all of the former three methods for computing
the <span class="math">\(y_1\)</span> value to be used in the Leapfrog calculation of <span class="math">\(y_2\)</span>.
Thereafter, visualize how these schemes perform for a uniformly partitioned
mesh with <span class="math">\(N=10\)</span> and <span class="math">\(N=11\)</span> points.
Filename: <code class="docutils literal"><span class="pre">signum</span></code>.</p>
</div>
<div class="section" id="exercise-33-simulate-fortune-growth-with-random-interest-rate">
<span id="decay-app-exer-interest"></span><h3>Exercise 33: Simulate fortune growth with random interest rate<a class="headerlink" href="#exercise-33-simulate-fortune-growth-with-random-interest-rate" title="Permalink to this headline">¶</a></h3>
<p>The goal of this exercise is to compute the value of a fortune subject
to inflation and a random interest rate.
Suppose that the inflation is constant at <span class="math">\(i\)</span> percent per year and that the
annual interest rate, <span class="math">\(p\)</span>, changes randomly at each time step,
starting at some value <span class="math">\(p_0\)</span> at <span class="math">\(t=0\)</span>.
The random change is from a value <span class="math">\(p^n\)</span> at <span class="math">\(t=t_n\)</span> to
<span class="math">\(p_n +\Delta p\)</span> with probability 0.25 and <span class="math">\(p_n -\Delta p\)</span> with probability 0.25.
No change occurs with probability 0.5. There is also no change if
<span class="math">\(p^{n+1}\)</span> exceeds 15 or becomes below 1.
Use a time step of one month, <span class="math">\(p_0=i\)</span>, initial fortune scaled to 1,
and simulate 1000 scenarios of
length 20 years. Compute the mean evolution of one unit of money and the
corresponding
standard deviation. Plot the mean curve along with the mean plus one
standard deviation and the mean minus one standard deviation. This will
illustrate the uncertainty in the mean curve.</p>
<p><strong>Hint 1.</strong>
The following code snippet computes <span class="math">\(p^{n+1}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">new_interest_rate</span><span class="p">(</span><span class="n">p_n</span><span class="p">,</span> <span class="n">dp</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>  <span class="c"># uniformly distr. random number in [0,1)</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mf">0.25</span><span class="p">:</span>
        <span class="n">p_np1</span> <span class="o">=</span> <span class="n">p_n</span> <span class="o">+</span> <span class="n">dp</span>
    <span class="k">elif</span> <span class="mf">0.25</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
        <span class="n">p_np1</span> <span class="o">=</span> <span class="n">p_n</span> <span class="o">-</span> <span class="n">dp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p_np1</span> <span class="o">=</span> <span class="n">p_n</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">p_np1</span> <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">p_np1</span> <span class="o">&lt;=</span> <span class="mi">15</span> <span class="k">else</span> <span class="n">p_n</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Hint 2.</strong>
If <span class="math">\(u_i(t)\)</span> is the value of the fortune in experiment number <span class="math">\(i\)</span>,
<span class="math">\(i=0,\ldots,N-1\)</span>,
the mean evolution of the fortune is</p>
<div class="math">
\[\bar u(t)= \frac{1}{N}\sum_{i=0}^{N-1} u_i(t),\]</div>
<p>and the standard deviation is</p>
<div class="math">
\[s(t) = \sqrt{\frac{1}{N-1}\left(- (\bar u(t))^2 +
                \sum_{i=0}^{N-1} (u_i(t))^2\right)}
\tp\]</div>
<p>Suppose <span class="math">\(u_i(t)\)</span> is stored in an array <code class="docutils literal"><span class="pre">u</span></code>.
The mean and the standard deviation of the fortune
is most efficiently computed by
using two accumulation arrays, <code class="docutils literal"><span class="pre">sum_u</span></code> and <code class="docutils literal"><span class="pre">sum_u2</span></code>, and
performing <code class="docutils literal"><span class="pre">sum_u</span> <span class="pre">+=</span> <span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">sum_u2</span> <span class="pre">+=</span> <span class="pre">u**2</span></code> after every experiment.
This technique avoids storing all the <span class="math">\(u_i(t)\)</span> time series for
computing the statistics.</p>
<p>Filename: <code class="docutils literal"><span class="pre">random_interest</span></code>.</p>
</div>
<div class="section" id="exercise-34-simulate-a-population-in-a-changing-environment">
<span id="decay-app-exer-pop-at"></span><h3>Exercise 34: Simulate a population in a changing environment<a class="headerlink" href="#exercise-34-simulate-a-population-in-a-changing-environment" title="Permalink to this headline">¶</a></h3>
<p>We shall study a population modeled by <a href="#equation-decay:app:pop:ueq">(1)</a> where
the environment, represented by <span class="math">\(r\)</span> and <span class="math">\(f\)</span>, undergoes changes with time.</p>
<p><strong>a)</strong>
Assume that there is a sudden drop (increase) in the birth (death)
rate at time <span class="math">\(t=t_r\)</span>,
because of limited nutrition or food supply:</p>
<div class="math">
\[\begin{split}r(t) =\left\lbrace\begin{array}{ll}
\varrho, &amp; t &lt; t_r,\\
\varrho - A, &amp; t\geq t_r,\end{array}\right.\end{split}\]</div>
<p>This drop in population growth is compensated by a sudden net immigration
at time <span class="math">\(t_f &gt; t_r\)</span>:</p>
<div class="math">
\[\begin{split}f(t) =\left\lbrace\begin{array}{ll}
0, &amp; t &lt; t_f,\\
f_0, &amp; t\geq t_a,\end{array}\right.\end{split}\]</div>
<p>Start with <span class="math">\(\varrho\)</span> and make <span class="math">\(A &gt; \varrho\)</span>. Experiment with
these and other parameters to
illustrate the interplay of growth and decay in such a problem.</p>
<p><strong>b)</strong>
Now we assume that the environmental conditions changes periodically with
time so that we may take</p>
<div class="math">
\[r(t) = {\varrho} + A\sin\left(\frac{2\pi}{P}t\right)
\tp\]</div>
<p>That is, the combined birth and death rate oscillates around <span class="math">\(\varrho\)</span> with
a maximum change of <span class="math">\(\pm A\)</span> repeating over a period of length <span class="math">\(P\)</span> in time.
Set <span class="math">\(f=0\)</span> and experiment with the other parameters to illustrate typical
features of the solution.</p>
<p>Filename: <code class="docutils literal"><span class="pre">population.py</span></code>.</p>
</div>
<div class="section" id="exercise-35-simulate-logistic-growth">
<span id="decay-app-exer-pop-logistic1"></span><h3>Exercise 35: Simulate logistic growth<a class="headerlink" href="#exercise-35-simulate-logistic-growth" title="Permalink to this headline">¶</a></h3>
<p>Solve the logistic ODE
<a href="#equation-decay:app:pop:logistic">(2)</a> using a Crank-Nicolson scheme where
<span class="math">\((u^{n+\half})^2\)</span> is approximated by a <em>geometric mean</em>:</p>
<div class="math">
\[(u^{n+\half})^2 \approx u^{n+1}u^n
\tp\]</div>
<p>This trick makes the discrete equation linear in <span class="math">\(u^{n+1}\)</span>.
Filename: <code class="docutils literal"><span class="pre">logistic_CN</span></code>.</p>
</div>
<div class="section" id="exercise-36-rederive-the-equation-for-continuous-compound-interest">
<span id="decay-app-exer-interest-derive"></span><h3>Exercise 36: Rederive the equation for continuous compound interest<a class="headerlink" href="#exercise-36-rederive-the-equation-for-continuous-compound-interest" title="Permalink to this headline">¶</a></h3>
<p>The ODE model <a href="#equation-decay:app:interest:eq2">(4)</a> was derived under the assumption
that <span class="math">\(r\)</span> was constant. Perform an alternative derivation without
this assumption: 1) start with <a href="#equation-decay:app:interest:eq1">(3)</a>;
2) introduce a time step <span class="math">\(\Delta t\)</span> instead of <span class="math">\(m\)</span>: <span class="math">\(\Delta t = 1/m\)</span> if
<span class="math">\(t\)</span> is measured in years; 3) divide by <span class="math">\(\Delta t\)</span> and take the
limit <span class="math">\(\Delta t\rightarrow 0\)</span>. Simulate a case where the inflation is
at a constant level <span class="math">\(I\)</span> percent per year and the interest rate oscillates:
<span class="math">\(r=-I/2 + r_0\sin(2\pi t)\)</span>.
Compare solutions for <span class="math">\(r_0=I, 3I/2, 2I\)</span>.
Filename: <code class="docutils literal"><span class="pre">interest_modeling</span></code>.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Models</a><ul>
<li><a class="reference internal" href="#scaling-1">Scaling  (1)</a><ul>
<li><a class="reference internal" href="#dimensionless-variables">Dimensionless variables</a></li>
<li><a class="reference internal" href="#dimensionless-numbers">Dimensionless numbers</a></li>
<li><a class="reference internal" href="#a-scaling-for-vanishing-initial-condition">A scaling for vanishing initial condition</a></li>
</ul>
</li>
<li><a class="reference internal" href="#evolution-of-a-population">Evolution of a population</a><ul>
<li><a class="reference internal" href="#exponential-growth">Exponential growth</a></li>
<li><a class="reference internal" href="#logistic-growth">Logistic growth</a></li>
</ul>
</li>
<li><a class="reference internal" href="#compound-interest-and-inflation">Compound interest and inflation</a></li>
<li><a class="reference internal" href="#newton-s-law-of-cooling">Newton&#8217;s law of cooling</a></li>
<li><a class="reference internal" href="#radioactive-decay">Radioactive decay</a><ul>
<li><a class="reference internal" href="#deterministic-model">Deterministic model</a></li>
<li><a class="reference internal" href="#stochastic-model">Stochastic model</a></li>
<li><a class="reference internal" href="#relation-between-stochastic-and-deterministic-models">Relation between stochastic and deterministic models</a></li>
<li><a class="reference internal" href="#generalization-of-the-radioactive-decay-modeling">Generalization of the radioactive decay modeling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#chemical-kinetics">Chemical kinetics</a><ul>
<li><a class="reference internal" href="#irreversible-reaction-of-two-substances">Irreversible reaction of two substances</a></li>
<li><a class="reference internal" href="#reversible-reaction-of-two-substances">Reversible reaction of two substances</a></li>
<li><a class="reference internal" href="#irreversible-reaction-of-two-substances-into-a-third">Irreversible reaction of two substances into a third</a></li>
<li><a class="reference internal" href="#a-biochemical-reaction">A biochemical reaction</a></li>
</ul>
</li>
<li><a class="reference internal" href="#spreading-of-diseases">Spreading of diseases</a></li>
<li><a class="reference internal" href="#decay-of-atmospheric-pressure-with-altitude">Decay of atmospheric pressure with altitude</a><ul>
<li><a class="reference internal" href="#the-general-model">The general model</a></li>
<li><a class="reference internal" href="#multiple-atmospheric-layers">Multiple atmospheric layers</a></li>
<li><a class="reference internal" href="#simplifications">Simplifications</a><ul>
<li><a class="reference internal" href="#constant-layer-temperature">Constant layer temperature</a></li>
<li><a class="reference internal" href="#one-layer-model">One-layer model</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#compaction-of-sediments">Compaction of sediments</a></li>
<li><a class="reference internal" href="#vertical-motion-of-a-body-in-a-viscous-fluid">Vertical motion of a body in a viscous fluid</a><ul>
<li><a class="reference internal" href="#overview-of-forces">Overview of forces</a></li>
<li><a class="reference internal" href="#equation-of-motion">Equation of motion</a></li>
<li><a class="reference internal" href="#terminal-velocity">Terminal velocity</a></li>
<li><a class="reference internal" href="#a-crank-nicolson-scheme">A Crank-Nicolson scheme</a></li>
<li><a class="reference internal" href="#physical-data">Physical data</a></li>
<li><a class="reference internal" href="#verification">Verification</a></li>
<li><a class="reference internal" href="#scaling-2">Scaling  (2)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#decay-odes-from-solving-a-pde-by-fourier-expansions">Decay ODEs from solving a PDE by Fourier expansions</a></li>
<li><a class="reference internal" href="#exercises-4">Exercises  (4)</a><ul>
<li><a class="reference internal" href="#exercise-16-radioactive-decay-of-carbon-14">Exercise 16: Radioactive decay of Carbon-14</a></li>
<li><a class="reference internal" href="#exercise-17-derive-schemes-for-newton-s-law-of-cooling">Exercise 17: Derive schemes for Newton&#8217;s law of cooling</a></li>
<li><a class="reference internal" href="#exercise-18-implement-schemes-for-newton-s-law-of-cooling">Exercise 18: Implement schemes for Newton&#8217;s law of cooling</a><ul>
<li><a class="reference internal" href="#bug-1-wrong-time-level-in-the-function">Bug 1: Wrong time level in the <span class="math">\(T_s\)</span> function</a></li>
<li><a class="reference internal" href="#bug-2-wrong-time-level-in-the-function">Bug 2: Wrong time level in the <span class="math">\(T\)</span> function</a></li>
<li><a class="reference internal" href="#bug-3-missing-in-a-term">Bug 3: Missing <span class="math">\(\theta\)</span> in a term</a></li>
<li><a class="reference internal" href="#bug-4-missing-k-in-the-updating-formula">Bug 4: Missing <code class="docutils literal"><span class="pre">k</span></code> in the updating formula</a></li>
<li><a class="reference internal" href="#bug-5-using-1-theta-instead-of-theta">Bug 5: Using <code class="docutils literal"><span class="pre">1-theta</span></code> instead of <code class="docutils literal"><span class="pre">theta</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercise-19-find-time-of-murder-from-body-temperature">Exercise 19: Find time of murder from body temperature</a></li>
<li><a class="reference internal" href="#exercise-20-simulate-an-oscillating-cooling-process">Exercise 20: Simulate an oscillating cooling process</a></li>
<li><a class="reference internal" href="#exercise-21-simulate-stochastic-radioactive-decay">Exercise 21: Simulate stochastic radioactive decay</a></li>
<li><a class="reference internal" href="#exercise-22-radioactive-decay-of-two-substances">Exercise 22: Radioactive decay of two substances</a></li>
<li><a class="reference internal" href="#exercise-23-simulate-a-simple-chemical-reaction">Exercise 23: Simulate a simple chemical reaction</a></li>
<li><a class="reference internal" href="#exercise-24-simulate-an-th-order-chemical-reaction">Exercise 24: Simulate an <span class="math">\(n\)</span>-th order chemical reaction</a></li>
<li><a class="reference internal" href="#exercise-25-simulate-spreading-of-a-disease">Exercise 25: Simulate spreading of a disease</a></li>
<li><a class="reference internal" href="#exercise-26-simulate-a-biochemical-process">Exercise 26: Simulate a biochemical process</a></li>
<li><a class="reference internal" href="#exercise-27-simulate-the-pressure-drop-in-the-atmosphere">Exercise 27: Simulate the pressure drop in the atmosphere</a></li>
<li><a class="reference internal" href="#exercise-28-make-a-program-for-vertical-motion-in-a-fluid">Exercise 28: Make a program for vertical motion in a fluid</a></li>
<li><a class="reference internal" href="#project-29-simulate-parachuting">Project 29: Simulate parachuting</a></li>
<li><a class="reference internal" href="#exercise-30-formulate-vertical-motion-in-the-atmosphere">Exercise 30: Formulate vertical motion in the atmosphere</a></li>
<li><a class="reference internal" href="#exercise-31-simulate-vertical-motion-in-the-atmosphere">Exercise 31: Simulate vertical motion in the atmosphere</a></li>
<li><a class="reference internal" href="#exercise-32-compute-by-solving-an-ode">Exercise 32: Compute <span class="math">\(y=|x|\)</span> by solving an ODE</a></li>
<li><a class="reference internal" href="#exercise-33-simulate-fortune-growth-with-random-interest-rate">Exercise 33: Simulate fortune growth with random interest rate</a></li>
<li><a class="reference internal" href="#exercise-34-simulate-a-population-in-a-changing-environment">Exercise 34: Simulate a population in a changing environment</a></li>
<li><a class="reference internal" href="#exercise-35-simulate-logistic-growth">Exercise 35: Simulate logistic growth</a></li>
<li><a class="reference internal" href="#exercise-36-rederive-the-equation-for-continuous-compound-interest">Exercise 36: Rederive the equation for continuous compound interest</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book007.html"
                        title="previous chapter">Generalizations</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book009.html"
                        title="next chapter">Scientific software engineering</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/._book008.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book009.html" title="Scientific software engineering"
             >next</a> |</li>
        <li class="right" >
          <a href="._book007.html" title="Generalizations"
             >previous</a> |</li>
        <li><a href="index.html">Finite Difference Computing with Exponential Decay Models</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
  <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
  </div>
</div>

  </body>
</html>