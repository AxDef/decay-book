.. !split

.. _ch:preface:

Preface
%%%%%%%

This book grew out of a need to ensure that students in graduate level
courses had some knowledge of the basic components in the scientific
computing pipeline: modeling, differential equations, numerical
algorithms, programming, and software testing. As our classes in
computational science topics turned out to be more and more
heterogeneous with respect to the students' undergraduate backgrounds,
we frequently got students who could be strong in mathematics, but
weak in programming, and vice versa. This situation called for some
documentation of the expected basic competence in modern computing
that graduate courses could build on.

I decided to write a set of example-driven notes that illustrated the
components in the scientific computing pipeline using the simple
differential equation for exponential decay:
:math:`u^{\prime}(t)=-au(t)`, where
:math:`a>0` is a parameter. Such models arise in a wide range througout
the sciences.
The plan was to go through the ideas of finite
differences, how such methods are programmed and tested, why such
methods may fail, and how mathematical models of this kind arises
from physics and biology. Many students lack knowledge about useful software
engineering topics such as modules, user interfaces, testing
frameworks, and class programming, so I added basic introductions to
these themes as well. Our courses are multi-disciplinary and
emphasizes how to turn theory into practice, so computer
implementations are key.  As students requested generalizations and
expanded explanations, the notes quickly grew in size and into the
present booklet.

The writing style is gentle and aims at a broad audience.
Prerequisite knowlege is basic one-dimensional calculus and preferably
some experience with computer programming in Python or MATLAB.
The material features
comprehensive explanations since it was intended for self study. For
some students it may act as an overview and refresher of traditional
mathematical topics and likely a first introduction to some of the
many software topics. The text can also be used in an undergraduate
course setting as a case-based introduction to modern
multi-disciplinary problem solving with computers, using the wide
range of applications in the chapter :ref:`decay:app`
as motivation and then treating the details of
the mathematical and computer science aspects from the other
chapters.  Another upcoming
audience is students and scientists with little mathematics and
computing background, who need a foundation for entering into
computer-based differential equation modeling.

The choice of topics in this book are motivated from what is needed in
more advanced courses on finite difference methods for partial
differential equations (PDEs).  It turns out that a range of concepts
and tools needed for PDEs can be introduced and illustrated by very
simple ordinary differential equation (ODE) examples. The goal of the
text is therefore to lay a foundation for understanding numerical
methods for PDEs by first meeting the fundamental ideas in a simpler
ODE setting. Compared to other books, the present one has a much
stronger focus on how to turn mathematics into working code.
It also explains the mathematics and programming in more detail.

There is a more advanced companion book in the works that treat finite
difference methods for PDEs using the same writing style and having
the same focus on turning mathematical algorithms into reliable
software.

Although the main example in the present book is
:math:`u^{\prime}=-au`,
we also address the more general model problem :math:`u'=-a(t)u + b(t)`
and the completely general, nonlinear problem :math:`u'=f(u,t)`, both for
scalar and vector :math:`u(t)`.
The following list of topics will be elaborated on.

 * How to think when constructing finite difference methods, with special focus
   on the Forward Euler, Backward Euler, and Crank-Nicolson (midpoint)
   schemes.

 * How to formulate a computational algorithm and translate it into
   Python code.

 * How to make curve plots of the solutions.

 * How to compute numerical errors.

 * How to compute convergence rates.

 * How to test that an implementation is correct (verification) and how
   to automate tests through *test functions* and *unit testing*.

 * How to work with Python concepts such as arrays, lists, dictionaries,
   lambda functions, functions in functions (closures).

 * How to perform array computing and understand the difference from
   scalar computing.

 * How to uncover numerical artifacts in the computed solution.

 * How to analyze the numerical schemes mathematically to understand
   why artifacts occur.

 * How to derive mathematical expressions for various measures of
   the error in numerical methods, frequently by using the ``sympy`` software
   for symbolic computations.

 * How to understand concepts such as finite difference operators,
   mesh (grid), mesh functions,
   stability, truncation error, consistency, and convergence.

 * How to solve the general nonlinear ODE :math:`u'=f(u,t)`,
   which is either a scalar ODE or a system of ODEs (i.e., :math:`u` and :math:`f`
   can either be a function or a vector of functions).

 * How to access professional packages for solving ODEs.

 * How the model equation :math:`u'=-au` arises in a wide range
   of phenomena in physics, biology, chemistry, and finance.

 * How to structure a code in terms of functions.

 * How to make reusable modules.

 * How to read input data flexibly from the command line.

 * How to create graphical/web user interfaces.

 * How to use test frameworks for automatic unit testing.

 * How to refactor code in terms of classes (instead of functions).

 * How to conduct and automate large-scale numerical experiments.

 * How to write scientific reports in various formats (LaTeX, HTML).

The book contains a set of exercises in most of the chapters.
The exercises are divided into three categories: *exercises*
refer to the text (usually variations or extensions of examples
in the text), *problems* are stand-alone exercises without
references to the text, and *projects* are larger problems.
Exercises, problems, and projects share the same numbering to
avoid confusion between Exercise 4.3 and Problem 4.3.


.. admonition:: The exposition in a nutshell

   Everything we cover is put into a practical, hands-on context. All
   mathematics is translated into working computing codes, and all the
   mathematical theory of finite difference methods presented here is
   motivated from a strong need to understand why we occasionally obtain
   strange results from the programs.
   Two fundamental questions saturate the text:
   
    * How do we solve a differential equation problem and produce numbers?
   
    * How do we know that the numbers are correct?
   
   Besides answering these two questions, one will learn a
   lot about mathematical modeling in general and the interplay between
   physics, mathematics, numerical methods, and computer science.




Acknowledgments
~~~~~~~~~~~~~~~

Professor Svein Linge has provided very detailed and constructive feedback
on this text, and all his efforts are highly appreciated. I also want to thank a
number of students who have pointed out weaknesses and
found errors.

[**hpl 1**: The present version features solutions to a subset of the exercises. These solutions are likely to be removed, or solutions to all exercises are to be included.]

