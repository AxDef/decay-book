
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Finite difference methods for 2D and 3D wave equations</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Finite Difference Computing with Partial Differential Equations" href="index.html" />
    <link rel="next" title="Applications of wave equations" href="._book006.html" />
    <link rel="prev" title="Analysis of the difference equations" href="._book004.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book006.html" title="Applications of wave equations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book004.html" title="Analysis of the difference equations"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with Partial Differential Equations</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="finite-difference-methods-for-2d-and-3d-wave-equations">
<span id="wave-2d3d"></span><h1>Finite difference methods for 2D and 3D wave equations<a class="headerlink" href="#finite-difference-methods-for-2d-and-3d-wave-equations" title="Permalink to this headline">¶</a></h1>
<p>A natural next step is to consider extensions of the methods for
various
variants of the one-dimensional wave equation to two-dimensional (2D) and
three-dimensional (3D) versions of the wave equation.</p>
<div class="section" id="multi-dimensional-wave-equations">
<span id="wave-2d3d-models"></span><h2>Multi-dimensional wave equations<a class="headerlink" href="#multi-dimensional-wave-equations" title="Permalink to this headline">¶</a></h2>
<p>The general wave equation in <span class="math">\(d\)</span> space dimensions, with constant
wave velocity <span class="math">\(c\)</span>,
can be written in the compact form</p>
<div class="math" id="eq-wave-2d3d-model1">
\[\tag{184}
\frac{\partial^2 u}{\partial t^2} = c^2\nabla^2 u\hbox{ for }\xpoint\in\Omega\subset\Real^d,\ t\in (0,T] ,\]</div>
<p>where</p>
<div class="math">
\[\nabla^2 u = \frac{\partial^2 u}{\partial x^2} +
\frac{\partial^2 u}{\partial y^2} ,\]</div>
<p>in a 2D problem (<span class="math">\(d=2\)</span>) and</p>
<div class="math">
\[\nabla^2 u = \frac{\partial^2 u}{\partial x^2} +
\frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2},\]</div>
<p>in three space dimensions <span class="math">\(d=3\)</span>).</p>
<p>Many applications involve variable coefficients, and the general
wave equation in <span class="math">\(d\)</span> dimensions is in this case written as</p>
<div class="math" id="eq-wave-2d3d-model2">
\[\tag{185}
\varrho\frac{\partial^2 u}{\partial t^2} = \nabla\cdot (q\nabla u) + f\hbox{ for }\xpoint\in\Omega\subset\Real^d,\ t\in (0,T],\]</div>
<p>which in, e.g.,  2D becomes</p>
<div class="math" id="eq-auto64">
\[\tag{186}
\varrho(x,y)
    \frac{\partial^2 u}{\partial t^2} =
    \frac{\partial}{\partial x}\left( q(x,y)
    \frac{\partial u}{\partial x}\right)
    +
    \frac{\partial}{\partial y}\left( q(x,y)
    \frac{\partial u}{\partial y}\right)
    + f(x,y,t)
    \tp\]</div>
<p>To save some writing and space we may use the index notation, where
subscript <span class="math">\(t\)</span>, <span class="math">\(x\)</span>, or <span class="math">\(y\)</span> means differentiation with respect
to that coordinate. For example,</p>
<div class="math">
\[\begin{split}\frac{\partial^2 u}{\partial t^2} &amp;= u_{tt},\\
\frac{\partial}{\partial y}\left( q(x,y)
\frac{\partial u}{\partial y}\right) &amp;= (q u_y)_y
\tp\end{split}\]</div>
<p>These comments extend straightforwardly to 3D, which means that
the 3D versions of the
two wave PDEs, with and without variable coefficients,
can with be stated as</p>
<div class="math" id="eq-wave-2d3d-model1-v2">
\[\tag{187}
u_{tt} = c^2(u_{xx} + u_{yy} + u_{zz}) + f,\]</div>
<div class="math" id="eq-wave-2d3d-model2-v2">
\[\tag{188}
\varrho u_{tt} = (q u_x)_x + (q u_z)_z + (q u_z)_z + f,\]</div>
<p>where the index notation for differentiation has been used.</p>
<p>At <em>each point</em> of the boundary <span class="math">\(\partial\Omega\)</span> (of <span class="math">\(\Omega\)</span>) we need
<em>one</em> boundary condition involving the unknown <span class="math">\(u\)</span>.
The boundary conditions are of three principal types:</p>
<blockquote>
<div><ol class="arabic simple">
<li><span class="math">\(u\)</span> is prescribed (<span class="math">\(u=0\)</span> or a known time variation of <span class="math">\(u\)</span> at
the boundary points, e.g.,
modeling an incoming wave),</li>
<li><span class="math">\(\partial u/\partial n = \normalvec\cdot\nabla u\)</span> is prescribed
(zero for reflecting boundaries),</li>
<li>an open boundary condition (also called radiation condition)
is specified to let waves travel undisturbed out of the domain,
see <a class="reference internal" href="._book003.html#wave-app-exer-radiationbc"><span class="std std-ref">Problem 28: Implement open boundary conditions</span></a> for details.</li>
</ol>
</div></blockquote>
<p>All the listed wave equations with <em>second-order</em> derivatives in
time need <em>two</em> initial conditions:</p>
<blockquote>
<div><ol class="arabic simple">
<li><span class="math">\(u=I\)</span>,</li>
<li><span class="math">\(u_t = V\)</span>.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="mesh">
<span id="wave-2d3d-mesh"></span><h2>Mesh<a class="headerlink" href="#mesh" title="Permalink to this headline">¶</a></h2>
<p>We introduce a mesh in time and in space. The mesh in time consists
of time points</p>
<div class="math">
\[\begin{split}t_0=0 &lt; t_1 &lt;\cdots &lt; t_{N_t},\end{split}\]</div>
<p>often with a constant
spacing <span class="math">\(\Delta t= t_{n+1}-t_{n}\)</span>, <span class="math">\(n\in\setl{\It}\)</span>.</p>
<p>Finite difference methods are easy to implement on simple
rectangle- or box-shaped
domains. More complicated shapes of the domain
require substantially more advanced techniques and
implementational efforts. On a rectangle- or box-shaped domain,
mesh points are introduced separately in the various space directions:</p>
<div class="math">
\[\begin{split}&amp;x_0 &lt; x_1 &lt;\cdots &lt; x_{N_x}  \hbox{ in the }x \hbox{ direction},\\
&amp;y_0 &lt; y_1 &lt;\cdots &lt; y_{N_y}  \hbox{ in the }y \hbox{ direction},\\
&amp;z_0 &lt; z_1 &lt;\cdots &lt; z_{N_z}  \hbox{ in the }z \hbox{ direction}\tp\end{split}\]</div>
<p>We can write a general mesh point as <span class="math">\((x_i,y_j,z_k,t_n)\)</span>, with
<span class="math">\(i\in\Ix\)</span>, <span class="math">\(j\in\Iy\)</span>, <span class="math">\(k\in\Iz\)</span>, and <span class="math">\(n\in\It\)</span>.</p>
<p>It is a very common choice to use constant mesh spacings:
<span class="math">\(\Delta x = x_{i+1}-x_{i}\)</span>, <span class="math">\(i\in\setl{\Ix}\)</span>,
<span class="math">\(\Delta y = y_{j+1}-y_{j}\)</span>, <span class="math">\(j\in\setl{\Iy}\)</span>, and
<span class="math">\(\Delta z = z_{k+1}-z_{k}\)</span>, <span class="math">\(k\in\setl{\Iz}\)</span>.
With equal mesh spacings one often introduces
<span class="math">\(h = \Delta x = \Delta y =\Delta z\)</span>.</p>
<p>The unknown <span class="math">\(u\)</span> at mesh point <span class="math">\((x_i,y_j,z_k,t_n)\)</span> is denoted by
<span class="math">\(u^{n}_{i,j,k}\)</span>. In 2D problems we just skip the <span class="math">\(z\)</span> coordinate
(by assuming no variation in that direction: <span class="math">\(\partial/\partial z=0\)</span>)
and write <span class="math">\(u^n_{i,j}\)</span>.</p>
</div>
<div class="section" id="discretization">
<span id="wave-2d3d-discretization"></span><h2>Discretization<a class="headerlink" href="#discretization" title="Permalink to this headline">¶</a></h2>
<p>Two- and three-dimensional wave equations are easily discretized by
assembling building blocks for discretization of
1D wave equations, because the multi-dimensional versions just contain
terms of the same type as those in 1D.</p>
<div class="section" id="discretizing-the-pdes">
<h3>Discretizing the PDEs<a class="headerlink" href="#discretizing-the-pdes" title="Permalink to this headline">¶</a></h3>
<p>Equation <a class="reference internal" href="#eq-wave-2d3d-model1-v2"><span class="std std-ref">(187)</span></a> can be discretized as</p>
<div class="math" id="eq-auto65">
\[\tag{189}
[D_tD_t u = c^2(D_xD_x u + D_yD_yu + D_zD_z u) + f]^n_{i,j,k}
    \tp\]</div>
<p>A 2D version might be instructive to write out in detail:</p>
<div class="math">
\[[D_tD_t u = c^2(D_xD_x u + D_yD_yu) + f]^n_{i,j,k},\]</div>
<p>which becomes</p>
<div class="math">
\[\frac{u^{n+1}_{i,j} - 2u^{n}_{i,j} + u^{n-1}_{i,j}}{\Delta t^2}
= c^2
\frac{u^{n}_{i+1,j} - 2u^{n}_{i,j} + u^{n}_{i-1,j}}{\Delta x^2}
+ c^2
\frac{u^{n}_{i,j+1} - 2u^{n}_{i,j} + u^{n}_{i,j-1}}{\Delta y^2}
+ f^n_{i,j},\]</div>
<p>Assuming, as usual, that all values at time levels <span class="math">\(n\)</span> and <span class="math">\(n-1\)</span>
are known, we can solve for the only unknown <span class="math">\(u^{n+1}_{i,j}\)</span>. The
result can be compactly written as</p>
<div class="math" id="eq-wave-2d3d-models-unp1">
\[\tag{190}
u^{n+1}_{i,j} = 2u^n_{i,j} + u^{n-1}_{i,j} + c^2\Delta t^2[D_xD_x u + D_yD_y u]^n_{i,j}\tp\]</div>
<p>As in the 1D case, we need to develop a special formula for <span class="math">\(u^1_{i,j}\)</span>
where we combine the general scheme for <span class="math">\(u^{n+1}_{i,j}\)</span>, when <span class="math">\(n=0\)</span>,
with the discretization of the initial condition:</p>
<div class="math">
\[[D_{2t}u = V]^0_{i,j}\quad\Rightarrow\quad u^{-1}_{i,j} = u^1_{i,j} - 2\Delta t V_{i,j}
\tp\]</div>
<p>The result becomes, in compact form,</p>
<div class="math" id="eq-wave-2d3d-models-u1">
\[\tag{191}
u^{n+1}_{i,j} = u^n_{i,j} -2\Delta V_{i,j} + {\half}
    c^2\Delta t^2[D_xD_x u + D_yD_y u]^n_{i,j}\tp\]</div>
<p>The PDE <a class="reference internal" href="#eq-wave-2d3d-model2-v2"><span class="std std-ref">(188)</span></a>
with variable coefficients is discretized term by term using
the corresponding elements from the 1D case:</p>
<div class="math" id="eq-auto66">
\[\tag{192}
[\varrho D_tD_t u = (D_x\overline{q}^x D_x u +
    D_y\overline{q}^y D_yu + D_z\overline{q}^z D_z u) + f]^n_{i,j,k}
    \tp\]</div>
<p>When written out and solved for the unknown <span class="math">\(u^{n+1}_{i,j,k}\)</span>, one gets the
scheme</p>
<div class="math">
\[\begin{split}u^{n+1}_{i,j,k} &amp;= - u^{n-1}_{i,j,k}  + 2u^{n}_{i,j,k} + \\
&amp;\quad \frac{1}{\varrho_{i,j,k}}\frac{1}{\Delta x^2} ( \half(q_{i,j,k} + q_{i+1,j,k})(u^{n}_{i+1,j,k} - u^{n}_{i,j,k}) - \\
&amp;\qquad\qquad \half(q_{i-1,j,k} + q_{i,j,k})(u^{n}_{i,j,k} - u^{n}_{i-1,j,k})) + \\
&amp;\quad \frac{1}{\varrho_{i,j,k}}\frac{1}{\Delta x^2} ( \half(q_{i,j,k} + q_{i,j+1,k})(u^{n}_{i,j+1,k} - u^{n}_{i,j,k}) - \\
&amp;\qquad\qquad\half(q_{i,j-1,k} + q_{i,j,k})(u^{n}_{i,j,k} - u^{n}_{i,j-1,k})) + \\
&amp;\quad \frac{1}{\varrho_{i,j,k}}\frac{1}{\Delta x^2} ( \half(q_{i,j,k} + q_{i,j,k+1})(u^{n}_{i,j,k+1} - u^{n}_{i,j,k}) -\\
&amp;\qquad\qquad \half(q_{i,j,k-1} + q_{i,j,k})(u^{n}_{i,j,k} - u^{n}_{i,j,k-1})) + \\
&amp;\quad \Delta t^2 f^n_{i,j,k}
\tp\end{split}\]</div>
<p>Also here we need to develop a special formula for <span class="math">\(u^1_{i,j,k}\)</span>
by combining the scheme for <span class="math">\(n=0\)</span> with the discrete initial condition,
which is just a matter of inserting
<span class="math">\(u^{-1}_{i,j,k}=u^1_{i,j,k} - 2\Delta tV_{i,j,k}\)</span> in the scheme
and solving for <span class="math">\(u^1_{i,j,k}\)</span>.</p>
</div>
<div class="section" id="handling-boundary-conditions-where-is-known">
<h3>Handling boundary conditions where <span class="math">\(u\)</span> is known<a class="headerlink" href="#handling-boundary-conditions-where-is-known" title="Permalink to this headline">¶</a></h3>
<p>The schemes listed above are valid for the internal points in the mesh.
After updating these, we need to visit all the mesh points at the
boundaries and set the prescribed <span class="math">\(u\)</span> value.</p>
</div>
<div class="section" id="discretizing-the-neumann-condition">
<h3>Discretizing the Neumann condition<a class="headerlink" href="#discretizing-the-neumann-condition" title="Permalink to this headline">¶</a></h3>
<p>The condition <span class="math">\(\partial u/\partial n = 0\)</span> was implemented in 1D by
discretizing it with a <span class="math">\(D_{2x}u\)</span> centered difference, followed by
eliminating the fictitious <span class="math">\(u\)</span> point outside the mesh by using the
general scheme at the boundary point. Alternatively, one can introduce
ghost cells and update a ghost value for use in the Neumann
condition. Exactly the same ideas are reused in multiple dimensions.</p>
<p>Consider the condition  <span class="math">\(\partial u/\partial n = 0\)</span>
at a boundary <span class="math">\(y=0\)</span> of a rectangular domain <span class="math">\([0, L_x]\times [0,L_y]\)</span> in 2D.
The normal direction is then in <span class="math">\(-y\)</span> direction,
so</p>
<div class="math">
\[\frac{\partial u}{\partial n} = -\frac{\partial u}{\partial y},\]</div>
<p>and we set</p>
<div class="math">
\[[-D_{2y} u = 0]^n_{i,0}\quad\Rightarrow\quad \frac{u^n_{i,1}-u^n_{i,-1}}{2\Delta y} = 0
\tp\]</div>
<p>From this it follows that <span class="math">\(u^n_{i,-1}=u^n_{i,1}\)</span>.
The discretized PDE at the boundary point <span class="math">\((i,0)\)</span> reads</p>
<div class="math">
\[\frac{u^{n+1}_{i,0} - 2u^{n}_{i,0} + u^{n-1}_{i,0}}{\Delta t^2}
= c^2
\frac{u^{n}_{i+1,0} - 2u^{n}_{i,0} + u^{n}_{i-1,0}}{\Delta x^2}
+ c^2
\frac{u^{n}_{i,1} - 2u^{n}_{i,0} + u^{n}_{i,-1}}{\Delta y^2}
+ f^n_{i,j},\]</div>
<p>We can then just insert <span class="math">\(u^n_{i,1}\)</span> for <span class="math">\(u^n_{i,-1}\)</span> in this equation
and solve for the boundary value <span class="math">\(u^{n+1}_{i,0}\)</span>, just as was done in 1D.</p>
<p>From these calculations, we see a pattern:
the general scheme applies at the boundary <span class="math">\(j=0\)</span> too if we just
replace <span class="math">\(j-1\)</span> by <span class="math">\(j+1\)</span>. Such a pattern is particularly useful for
implementations. The details follow from the explained 1D case
in the section <a class="reference internal" href="._book003.html#wave-pde2-neumann-impl"><span class="std std-ref">Implementation of Neumann conditions</span></a>.</p>
<p>The alternative approach to eliminating fictitious values outside the
mesh is to have <span class="math">\(u^n_{i,-1}\)</span> available as a ghost value.  The mesh is
extended with one extra line (2D) or plane (3D) of ghost cells at a
Neumann boundary. In the present example it means that we need a line
with ghost cells below the <span class="math">\(y\)</span> axis.  The ghost values must be updated
according to <span class="math">\(u^{n+1}_{i,-1}=u^{n+1}_{i,1}\)</span>.</p>
</div>
</div>
</div>
<div class="section" id="implementation-6">
<span id="wave-2d3d-impl"></span><h1>Implementation<a class="headerlink" href="#implementation-6" title="Permalink to this headline">¶</a></h1>
<p id="index-0">We shall now describe in detail various Python implementations
for solving a standard 2D, linear wave equation with constant
wave velocity and <span class="math">\(u=0\)</span> on the
boundary. The wave equation is to be solved
in the space-time domain <span class="math">\(\Omega\times (0,T]\)</span>,
where <span class="math">\(\Omega = (0,L_x)\times (0,L_y)\)</span> is a rectangular spatial
domain. More precisely,
the complete initial-boundary value problem is defined by</p>
<div class="math" id="eq-auto67">
\[\tag{193}
u_{tt} = c^2(u_{xx} + u_{yy}) + f(x,y,t),\quad (x,y)\in \Omega,\ t\in (0,T],\]</div>
<div class="math" id="eq-auto68">
\[\tag{194}
u(x,y,0) = I(x,y),\quad (x,y)\in\Omega,\]</div>
<div class="math" id="eq-auto69">
\[\tag{195}
u_t(x,y,0) = V(x,y),\quad (x,y)\in\Omega,\]</div>
<div class="math" id="eq-auto70">
\[\tag{196}
u = 0,\quad (x,y)\in\partial\Omega,\ t\in (0,T],\]</div>
<p>where <span class="math">\(\partial\Omega\)</span> is the boundary of <span class="math">\(\Omega\)</span>, in this case
the four sides of the rectangle <span class="math">\(\Omega = [0,L_x]\times [0,L_y]\)</span>:
<span class="math">\(x=0\)</span>, <span class="math">\(x=L_x\)</span>, <span class="math">\(y=0\)</span>, and <span class="math">\(y=L_y\)</span>.</p>
<p>The PDE is discretized as</p>
<div class="math">
\[[D_t D_t u = c^2(D_xD_x u + D_yD_y u) + f]^n_{i,j},\]</div>
<p>which leads to an explicit updating formula to be implemented in a
program:</p>
<div class="math">
\[u^{n+1} = -u^{n-1}_{i,j} + 2u^n_{i,j} + \nonumber\]</div>
<div class="math" id="eq-wave-2d3d-impl1-2du0-ueq-discrete">
\[\tag{197}
\quad C_x^2(
    u^{n}_{i+1,j} - 2u^{n}_{i,j} + u^{n}_{i-1,j}) + C_y^2
    (u^{n}_{i,j+1} - 2u^{n}_{i,j} + u^{n}_{i,j-1}) + \Delta t^2 f_{i,j}^n,\]</div>
<p>for all interior mesh points <span class="math">\(i\in\seti{\Ix}\)</span> and
<span class="math">\(j\in\seti{\Iy}\)</span>, and for <span class="math">\(n\in\setr{\It}\)</span>.
The constants <span class="math">\(C_x\)</span> and <span class="math">\(C_y\)</span> are defined as</p>
<div class="math">
\[C_x = c\frac{\Delta t}{\Delta x},\quad C_x = c\frac{\Delta t}{\Delta y}
\tp\]</div>
<p>At the boundary, we simply set <span class="math">\(u^{n+1}_{i,j}=0\)</span> for
<span class="math">\(i=0\)</span>, <span class="math">\(j=0,\ldots,N_y\)</span>; <span class="math">\(i=N_x\)</span>, <span class="math">\(j=0,\ldots,N_y\)</span>;
<span class="math">\(j=0\)</span>, <span class="math">\(i=0,\ldots,N_x\)</span>; and <span class="math">\(j=N_y\)</span>, <span class="math">\(i=0,\ldots,N_x\)</span>.
For the first step, <span class="math">\(n=0\)</span>, <a class="reference internal" href="#eq-wave-2d3d-impl1-2du0-ueq-discrete"><span class="std std-ref">(197)</span></a>
is combined with the discretization of the initial condition <span class="math">\(u_t=V\)</span>,
<span class="math">\([D_{2t} u = V]^0_{i,j}\)</span> to obtain a special formula for
<span class="math">\(u^1_{i,j}\)</span> at the interior mesh points:</p>
<div class="math">
\[u^{1} = u^0_{i,j} + \Delta t V_{i,j} + \nonumber\]</div>
<div class="math" id="eq-wave-2d3d-impl1-2du0-ueq-n0-discrete">
\[\tag{198}
\quad {\half}C_x^2(
    u^{0}_{i+1,j} - 2u^{0}_{i,j} + u^{0}_{i-1,j}) + {\half}C_y^2
    (u^{0}_{i,j+1} - 2u^{0}_{i,j} + u^{0}_{i,j-1}) + \half\Delta t^2f_{i,j}^n,\]</div>
<p>The algorithm is very similar to the one in 1D:</p>
<ol class="arabic simple">
<li>Set initial condition <span class="math">\(u^0_{i,j}=I(x_i,y_j)\)</span></li>
<li>Compute <span class="math">\(u^1_{i,j}\)</span> from <a class="reference internal" href="#eq-wave-2d3d-impl1-2du0-ueq-discrete"><span class="std std-ref">(197)</span></a></li>
<li>Set <span class="math">\(u^1_{i,j}=0\)</span> for the boundaries <span class="math">\(i=0,N_x\)</span>, <span class="math">\(j=0,N_y\)</span></li>
<li>For <span class="math">\(n=1,2,\ldots,N_t\)</span>:</li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li>Find <span class="math">\(u^{n+1}_{i,j}\)</span> from <a class="reference internal" href="#eq-wave-2d3d-impl1-2du0-ueq-discrete"><span class="std std-ref">(197)</span></a>
for all internal mesh points, <span class="math">\(i\in\seti{\Ix}\)</span>, <span class="math">\(j\in\seti{\Iy}\)</span></li>
<li>Set <span class="math">\(u^{n+1}_{i,j}=0\)</span> for the boundaries <span class="math">\(i=0,N_x\)</span>, <span class="math">\(j=0,N_y\)</span></li>
</ol>
</div></blockquote>
<div class="section" id="scalar-computations">
<span id="wave2d3d-impl-scalar"></span><h2>Scalar computations<a class="headerlink" href="#scalar-computations" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">solver</span></code> function for a 2D case with constant wave velocity and
boundary condition <span class="math">\(u=0\)</span> is analogous to the 1D case with similar parameter
values (see <code class="docutils literal"><span class="pre">wave1D_u0.py</span></code>), apart from a few necessary
extensions. The code is found in the program
<a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave2D_u0/wave2D_u0.py">wave2D_u0.py</a>.</p>
<div class="section" id="domain-and-mesh">
<h3>Domain and mesh<a class="headerlink" href="#domain-and-mesh" title="Permalink to this headline">¶</a></h3>
<p>The spatial domain is now <span class="math">\([0,L_x]\times [0,L_y]\)</span>, specified
by the arguments <code class="docutils literal"><span class="pre">Lx</span></code> and <code class="docutils literal"><span class="pre">Ly</span></code>. Similarly, the number of mesh
points in the <span class="math">\(x\)</span> and <span class="math">\(y\)</span> directions,
<span class="math">\(N_x\)</span> and <span class="math">\(N_y\)</span>, become the arguments <code class="docutils literal"><span class="pre">Nx</span></code> and <code class="docutils literal"><span class="pre">Ny</span></code>.
In multi-dimensional problems it makes less sense to specify a
Courant number since the wave velocity is a vector and mesh spacings
may differ in the various spatial directions.
We therefore give <span class="math">\(\Delta t\)</span> explicitly. The signature of
the <code class="docutils literal"><span class="pre">solver</span></code> function is then</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
           <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&#39;scalar&#39;</span><span class="p">):</span>
</pre></div>
</div>
<p>Key parameters used in the calculations are created as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>                  <span class="c"># mesh points in x dir</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>                  <span class="c"># mesh points in y dir</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">dy</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>                 <span class="c"># mesh points in time</span>
<span class="n">Cx2</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">;</span>  <span class="n">Cy2</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>    <span class="c"># help variables</span>
<span class="n">dt2</span> <span class="o">=</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="section" id="solution-arrays">
<h3>Solution arrays<a class="headerlink" href="#solution-arrays" title="Permalink to this headline">¶</a></h3>
<p>We store <span class="math">\(u^{n+1}_{i,j}\)</span>, <span class="math">\(u^{n}_{i,j}\)</span>, and
<span class="math">\(u^{n-1}_{i,j}\)</span> in three two-dimensional arrays,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span>   <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>   <span class="c"># solution array</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>   <span class="c"># solution at t-dt</span>
<span class="n">u_2</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>   <span class="c"># solution at t-2*dt</span>
</pre></div>
</div>
<p>where <span class="math">\(u^{n+1}_{i,j}\)</span> corresponds to <code class="docutils literal"><span class="pre">u[i,j]</span></code>,
<span class="math">\(u^{n}_{i,j}\)</span> to <code class="docutils literal"><span class="pre">u_1[i,j]</span></code>, and
<span class="math">\(u^{n-1}_{i,j}\)</span> to <code class="docutils literal"><span class="pre">u_2[i,j]</span></code></p>
</div>
<div class="section" id="index-sets">
<span id="index-1"></span><h3>Index sets<a class="headerlink" href="#index-sets" title="Permalink to this headline">¶</a></h3>
<p>It is also convenient to introduce the index sets (cf. The section <a class="reference internal" href="._book003.html#wave-indexset"><span class="std std-ref">Index set notation</span></a>)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Ix</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">Iy</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">It</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="computing-the-solution">
<h3>Computing the solution<a class="headerlink" href="#computing-the-solution" title="Permalink to this headline">¶</a></h3>
<p>Inserting the initial
condition <code class="docutils literal"><span class="pre">I</span></code> in <code class="docutils literal"><span class="pre">u_1</span></code> and making a callback to the user in terms of
the <code class="docutils literal"><span class="pre">user_action</span></code> function is a straightforward generalization of
the 1D code from the section <a class="reference internal" href="._book003.html#wave-string-impl"><span class="std std-ref">Sketch of an implementation</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">:</span>
        <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

<span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">user_action</span><span class="p">(</span><span class="n">u_1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xv</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">user_action</span></code> function has additional arguments compared to the
1D case. The arguments <code class="docutils literal"><span class="pre">xv</span></code> and <code class="docutils literal"><span class="pre">yv</span></code> will be commented
upon in the section <a class="reference internal" href="#wave2d3d-impl-vectorized"><span class="std std-ref">Vectorized computations</span></a>.</p>
<p>The key finite difference formula <a class="reference internal" href="#eq-wave-2d3d-models-unp1"><span class="std std-ref">(190)</span></a>
for updating the solution at
a time level is implemented in a separate function as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">advance_scalar</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u_2</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">Cx2</span><span class="p">,</span> <span class="n">Cy2</span><span class="p">,</span> <span class="n">dt2</span><span class="p">,</span>
                   <span class="n">V</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">step1</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">Ix</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>  <span class="n">Iy</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">step1</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt2</span><span class="p">)</span>  <span class="c"># save</span>
        <span class="n">Cx2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">Cx2</span><span class="p">;</span>  <span class="n">Cy2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">Cy2</span><span class="p">;</span> <span class="n">dt2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt2</span>  <span class="c"># redefine</span>
        <span class="n">D1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="n">D2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">D1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="n">D2</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">u_xx</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="n">u_yy</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">D1</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">D2</span><span class="o">*</span><span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> \
                     <span class="n">Cx2</span><span class="o">*</span><span class="n">u_xx</span> <span class="o">+</span> <span class="n">Cy2</span><span class="o">*</span><span class="n">u_yy</span> <span class="o">+</span> <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">step1</span><span class="p">:</span>
                <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="c"># Boundary condition u=0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">Iy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">Iy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">:</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">:</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">step1</span></code> variable has been introduced to allow the formula to be
reused for first step <span class="math">\(u^1_{i,j}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">advance_scalar</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u_2</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                   <span class="n">n</span><span class="p">,</span> <span class="n">Cx2</span><span class="p">,</span> <span class="n">Cy2</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">step1</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Below, we will make many alternative implementations of the
<code class="docutils literal"><span class="pre">advance_scalar</span></code> function to speed up the code since most of
the CPU time in simulations is spent in this function.</p>
<p>Finally, we remark that the <code class="docutils literal"><span class="pre">solver</span></code> function in the <code class="docutils literal"><span class="pre">wave2D_u0.py</span></code> code
updates arrays for the next time step by switching references as
described in the section <a class="reference internal" href="._book003.html#wave-pde1-impl-ref-switch"><span class="std std-ref">Remark on the updating of arrays</span></a>. If the solution
<code class="docutils literal"><span class="pre">u</span></code> is returned from <code class="docutils literal"><span class="pre">solver</span></code>, which it is not, it is important to
set <code class="docutils literal"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">u_1</span></code> after the time loop, otherwise <code class="docutils literal"><span class="pre">u</span></code> actually contains <code class="docutils literal"><span class="pre">u_2</span></code>.</p>
</div>
</div>
<div class="section" id="vectorized-computations">
<span id="wave2d3d-impl-vectorized"></span><h2>Vectorized computations<a class="headerlink" href="#vectorized-computations" title="Permalink to this headline">¶</a></h2>
<p>The scalar code above turns out to be extremely slow for large 2D
meshes, and probably useless in 3D beyond debugging of small test cases.
Vectorization is therefore a must for multi-dimensional
finite difference computations in Python. For example,
with a mesh consisting of <span class="math">\(30\times 30\)</span> cells, vectorization
brings down the CPU time by a factor of 70 (!).</p>
<p>In the vectorized case, we must be able to evaluate user-given functions
like <span class="math">\(I(x,y)\)</span> and <span class="math">\(f(x,y,t)\)</span> for the entire mesh in one operation (without
loops). These user-given functions are
provided as Python functions <code class="docutils literal"><span class="pre">I(x,y)</span></code>
and <code class="docutils literal"><span class="pre">f(x,y,t)</span></code>, respectively.
Having the one-dimensional coordinate arrays <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> is not
sufficient when calling <code class="docutils literal"><span class="pre">I</span></code> and <code class="docutils literal"><span class="pre">f</span></code> in a vectorized way.
We must extend <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> to their vectorized versions <code class="docutils literal"><span class="pre">xv</span></code> and <code class="docutils literal"><span class="pre">yv</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">newaxis</span>
<span class="n">xv</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span>
<span class="n">yv</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,:]</span>
<span class="c"># or</span>
<span class="n">xv</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">yv</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
</pre></div>
</div>
<p>This is a standard required technique when evaluating functions over
a 2D mesh, say <code class="docutils literal"><span class="pre">sin(xv)*cos(xv)</span></code>, which then gives a result with shape
<code class="docutils literal"><span class="pre">(Nx+1,Ny+1)</span></code>. Calling <code class="docutils literal"><span class="pre">I(xv,</span> <span class="pre">yv)</span></code> and <code class="docutils literal"><span class="pre">f(xv,</span> <span class="pre">yv,</span> <span class="pre">t[n])</span></code> will now
return <code class="docutils literal"><span class="pre">I</span></code> and <code class="docutils literal"><span class="pre">f</span></code> values for the entire set of mesh points.</p>
<p>With the <code class="docutils literal"><span class="pre">xv</span></code> and <code class="docutils literal"><span class="pre">yv</span></code> arrays for vectorized computing,
setting the initial condition is just a matter of</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_1</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">)</span>
</pre></div>
</div>
<p>One could also have written <code class="docutils literal"><span class="pre">u_1</span> <span class="pre">=</span> <span class="pre">I(xv,</span> <span class="pre">yv)</span></code> and let <code class="docutils literal"><span class="pre">u_1</span></code> point
to a new object, but vectorized operations often make use of
direct insertion in the original array through <code class="docutils literal"><span class="pre">u_1[:,:]</span></code>, because
sometimes not all of the array is to be filled by such a function
evaluation. This is the case with the computational scheme for <span class="math">\(u^{n+1}_{i,j}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">advance_vectorized</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u_2</span><span class="p">,</span> <span class="n">f_a</span><span class="p">,</span> <span class="n">Cx2</span><span class="p">,</span> <span class="n">Cy2</span><span class="p">,</span> <span class="n">dt2</span><span class="p">,</span>
                       <span class="n">V</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">step1</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">step1</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt2</span><span class="p">)</span>  <span class="c"># save</span>
        <span class="n">Cx2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">Cx2</span><span class="p">;</span>  <span class="n">Cy2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">Cy2</span><span class="p">;</span> <span class="n">dt2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt2</span>  <span class="c"># redefine</span>
        <span class="n">D1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="n">D2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">D1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="n">D2</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">u_xx</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">u_yy</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">D1</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">D2</span><span class="o">*</span><span class="n">u_2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                   <span class="n">Cx2</span><span class="o">*</span><span class="n">u_xx</span> <span class="o">+</span> <span class="n">Cy2</span><span class="o">*</span><span class="n">u_yy</span> <span class="o">+</span> <span class="n">dt2</span><span class="o">*</span><span class="n">f_a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">step1</span><span class="p">:</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c"># Boundary condition u=0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">u</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">u</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">u</span>

<span class="k">def</span> <span class="nf">quadratic</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">version</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Exact discrete solution of the scheme.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">exact_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">Lx</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="n">Ly</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">V</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">exact_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="n">Ly</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">Lx</span> <span class="o">-</span> <span class="n">x</span><span class="p">))</span>

    <span class="n">Lx</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>  <span class="n">Ly</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">1.5</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c"># use longest possible steps</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">18</span>

    <span class="k">def</span> <span class="nf">assert_no_error</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xv</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-12</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;diff=</span><span class="si">%g</span><span class="s">, step </span><span class="si">%d</span><span class="s">, time=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">msg</span>

    <span class="n">new_dt</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span>
        <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
        <span class="n">user_action</span><span class="o">=</span><span class="n">assert_no_error</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="n">version</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_dt</span><span class="p">,</span> <span class="n">cpu</span>


<span class="k">def</span> <span class="nf">test_quadratic</span><span class="p">():</span>
    <span class="c"># Test a series of meshes where Nx &gt; Ny and Nx &lt; Ny</span>
    <span class="n">versions</span> <span class="o">=</span> <span class="s">&#39;scalar&#39;</span><span class="p">,</span> <span class="s">&#39;vectorized&#39;</span><span class="p">,</span> <span class="s">&#39;cython&#39;</span><span class="p">,</span> <span class="s">&#39;f77&#39;</span><span class="p">,</span> <span class="s">&#39;c_cy&#39;</span><span class="p">,</span> <span class="s">&#39;c_f2py&#39;</span>
    <span class="k">for</span> <span class="n">Nx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">Ny</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">version</span> <span class="ow">in</span> <span class="n">versions</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;testing&#39;</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="s">&#39;for </span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s"> mesh&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
                <span class="n">quadratic</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">run_efficiency</span><span class="p">(</span><span class="n">nrefinements</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">Lx</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span><span class="o">/</span><span class="n">Ly</span><span class="p">)</span>

    <span class="n">Lx</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="n">Ly</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">1.5</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">versions</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;scalar&#39;</span><span class="p">,</span> <span class="s">&#39;vectorized&#39;</span><span class="p">,</span> <span class="s">&#39;cython&#39;</span><span class="p">,</span> <span class="s">&#39;f77&#39;</span><span class="p">,</span>
               <span class="s">&#39;c_f2py&#39;</span><span class="p">,</span> <span class="s">&#39;c_cy&#39;</span><span class="p">]</span>
    <span class="k">print</span> <span class="s">&#39; &#39;</span><span class="o">*</span><span class="mi">15</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;</span><span class="si">%-13s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">versions</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">Nx</span> <span class="ow">in</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">120</span><span class="p">:</span>
        <span class="n">cpu</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">version</span> <span class="ow">in</span> <span class="n">versions</span><span class="p">:</span>
            <span class="n">dt</span><span class="p">,</span> <span class="n">cpu_</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span>
                              <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                              <span class="n">version</span><span class="o">=</span><span class="n">version</span><span class="p">)</span>
            <span class="n">cpu</span><span class="p">[</span><span class="n">version</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_</span>
        <span class="n">cpu_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cpu</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">cpu_min</span> <span class="o">&lt;</span> <span class="mf">1E-6</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Ignored </span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s"> grid (too small execution time)&#39;</span> \
                  <span class="o">%</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Nx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cpu</span> <span class="o">=</span> <span class="p">{</span><span class="n">version</span><span class="p">:</span> <span class="n">cpu</span><span class="p">[</span><span class="n">version</span><span class="p">]</span><span class="o">/</span><span class="n">cpu_min</span> <span class="k">for</span> <span class="n">version</span> <span class="ow">in</span> <span class="n">cpu</span><span class="p">}</span>
            <span class="k">print</span> <span class="s">&#39;</span><span class="si">%-15s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="s">&#39;</span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Nx</span><span class="p">),</span>
            <span class="k">print</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;</span><span class="si">%13.1f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">cpu</span><span class="p">[</span><span class="n">version</span><span class="p">]</span> <span class="k">for</span> <span class="n">version</span> <span class="ow">in</span> <span class="n">versions</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">gaussian</span><span class="p">(</span><span class="n">plot_method</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&#39;vectorized&#39;</span><span class="p">,</span> <span class="n">save_plot</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initial Gaussian bell in the middle of the domain.</span>
<span class="sd">    plot_method=1 applies mesh function, =2 means surf, =0 means no plot.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Clean up plot files</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">glob</span><span class="p">(</span><span class="s">&#39;tmp_*.png&#39;</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="n">Lx</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">Ly</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gaussian peak at (Lx/2, Ly/2).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">Lx</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">Ly</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_method</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">axes3d</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">u_surf</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">plot_u</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xv</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot_method</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mesh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;t=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">zlim</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                 <span class="n">caxis</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">plot_method</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">surfc</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;t=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">zlim</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                  <span class="n">colorbar</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">colormap</span><span class="o">=</span><span class="n">hot</span><span class="p">(),</span> <span class="n">caxis</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                  <span class="n">shading</span><span class="o">=</span><span class="s">&#39;flat&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">plot_method</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Experimental 3D matplotlib...under development...&#39;</span>
            <span class="c">#plt.clf()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s">&#39;3d&#39;</span><span class="p">)</span>
            <span class="n">u_surf</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
            <span class="c">#ax.contourf(xv, yv, u, zdir=&#39;z&#39;, offset=-100, cmap=cm.coolwarm)</span>
            <span class="c">#ax.set_zlim(-1, 1)</span>
            <span class="c"># Remove old surface before drawing</span>
            <span class="k">if</span> <span class="n">u_surf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">u_surf</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot_method</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c"># pause between frames</span>
            <span class="k">if</span> <span class="n">save_plot</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s">&#39;tmp_</span><span class="si">%04d</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="n">n</span>
                <span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>  <span class="c"># time consuming!</span>

    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span> <span class="n">Ny</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span> <span class="n">T</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">dt</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
                     <span class="n">user_action</span><span class="o">=</span><span class="n">plot_u</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="n">version</span><span class="p">)</span>



<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">test_quadratic</span><span class="p">()</span>
</pre></div>
</div>
<p>Array slices in 2D are more complicated to understand than those in
1D, but the logic from 1D applies to each dimension separately.
For example, when doing <span class="math">\(u^{n}_{i,j} - u^{n}_{i-1,j}\)</span> for <span class="math">\(i\in\setr{\Ix}\)</span>,
we just keep <code class="docutils literal"><span class="pre">j</span></code> constant and make a slice in the first index:
<code class="docutils literal"><span class="pre">u_1[1:,j]</span> <span class="pre">-</span> <span class="pre">u_1[:-1,j]</span></code>, exactly as in 1D. The <code class="docutils literal"><span class="pre">1:</span></code> slice
specifies all the indices <span class="math">\(i=1,2,\ldots,N_x\)</span> (up to the last
valid index),
while <code class="docutils literal"><span class="pre">:-1</span></code> specifies the relevant indices for the second term:
<span class="math">\(0,1,\ldots,N_x-1\)</span> (up to, but not including the last index).</p>
<p>In the above code segment, the situation is slightly more complicated,
because each displaced slice in one direction is
accompanied by a <code class="docutils literal"><span class="pre">1:-1</span></code> slice in the other direction. The reason is
that we only work with the internal points for the index that is
kept constant in a difference.</p>
<p>The boundary conditions along the four sides makes use of
a slice consisting of all indices along a boundary:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[:</span> <span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">u</span><span class="p">[:,</span><span class="n">Ny</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">u</span><span class="p">[</span><span class="mi">0</span> <span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>In the vectorized update of <code class="docutils literal"><span class="pre">u</span></code> (above), the function <code class="docutils literal"><span class="pre">f</span></code> is first computed
as an array over all mesh points:</p>
<div class="highlight-text"><div class="highlight"><pre>f_a = f(xv, yv, t[n])
</pre></div>
</div>
<p>We could, alternatively, have used the call <code class="docutils literal"><span class="pre">f(xv,</span> <span class="pre">yv,</span> <span class="pre">t[n])[1:-1,1:-1]</span></code>
in the last term of the update statement, but other implementations
in compiled languages benefit from having <code class="docutils literal"><span class="pre">f</span></code> available in an array
rather than calling our Python function <code class="docutils literal"><span class="pre">f(x,y,t)</span></code> for
every point.</p>
<p>Also in the <code class="docutils literal"><span class="pre">advance_vectorized</span></code> function we have introduced a
boolean <code class="docutils literal"><span class="pre">step1</span></code> to reuse the formula for the first time step
in the same way as we did with <code class="docutils literal"><span class="pre">advance_scalar</span></code>.
We refer to the <code class="docutils literal"><span class="pre">solver</span></code> function in <code class="docutils literal"><span class="pre">wave2D_u0.py</span></code>
for the details on how the overall algorithm is implemented.</p>
<p>The callback function now has the arguments
<code class="docutils literal"><span class="pre">u,</span> <span class="pre">x,</span> <span class="pre">xv,</span> <span class="pre">y,</span> <span class="pre">yv,</span> <span class="pre">t,</span> <span class="pre">n</span></code>. The inclusion of <code class="docutils literal"><span class="pre">xv</span></code> and <code class="docutils literal"><span class="pre">yv</span></code> makes it
easy to, e.g., compute an exact 2D solution in the callback function
and compute errors, through an expression like
<code class="docutils literal"><span class="pre">u</span> <span class="pre">-</span> <span class="pre">u_exact(xv,</span> <span class="pre">yv,</span> <span class="pre">t[n])</span></code>.</p>
</div>
<div class="section" id="verification-5">
<span id="wave2d3d-impl-verify"></span><h2>Verification<a class="headerlink" href="#verification-5" title="Permalink to this headline">¶</a></h2>
<div class="section" id="testing-a-quadratic-solution">
<h3>Testing a quadratic solution<a class="headerlink" href="#testing-a-quadratic-solution" title="Permalink to this headline">¶</a></h3>
<p>The 1D solution from the section <a class="reference internal" href="._book003.html#wave-pde2-fd-verify-quadratic"><span class="std std-ref">Constructing an exact solution of the discrete equations</span></a> can be
generalized to multi-dimensions and provides a test case where the
exact solution also fulfills the discrete equations, such that we know
(to machine precision) what numbers the solver function should
produce. In 2D we use the following generalization of
<a class="reference internal" href="._book003.html#eq-wave-pde2-fd-verify-quadratic-uex"><span class="std std-ref">(110)</span></a>:</p>
<div class="math" id="eq-wave2d3d-impl-verify-quadratic">
\[\tag{199}
\uex(x,y,t) = x(L_x-x)y(L_y-y)(1+{\half}t)
    \tp\]</div>
<p>This solution fulfills the PDE problem if <span class="math">\(I(x,y)=\uex(x,y,0)\)</span>,
<span class="math">\(V=\half\uex(x,y,0)\)</span>, and <span class="math">\(f=2c^2(1+{\half}t)(y(L_y-y) +
x(L_x-x))\)</span>. To show that <span class="math">\(\uex\)</span> also solves the discrete equations,
we start with the general results <span class="math">\([D_t D_t 1]^n=0\)</span>, <span class="math">\([D_t D_t t]^n=0\)</span>,
and <span class="math">\([D_t D_t t^2]=2\)</span>, and use these to compute</p>
<div class="math">
\[\begin{split}[D_xD_x \uex]^n_{i,j} &amp;= [y(L_y-y)(1+{\half}t) D_xD_x x(L_x-x)]^n_{i,j}\\
&amp;= y_j(L_y-y_j)(1+{\half}t_n)(-2)\tp\end{split}\]</div>
<p>A similar calculation must be carried out for the <span class="math">\([D_yD_y
\uex]^n_{i,j}\)</span> and <span class="math">\([D_tD_t \uex]^n_{i,j}\)</span> terms.  One must also show
that the quadratic solution fits the special formula for
<span class="math">\(u^1_{i,j}\)</span>. The details are left as <a class="reference internal" href="#wave-exer-quadratic-2d"><span class="std std-ref">Exercise 32: Check that a solution fulfills the discrete model</span></a>.
The <code class="docutils literal"><span class="pre">test_quadratic</span></code> function in the
<a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave2D_u0/wave2D_u0.py">wave2D_u0.py</a>
program implements this verification as a nose test.</p>
</div>
</div>
</div>
<div class="section" id="using-classes-to-implement-a-simulator">
<h1>Using classes to implement a simulator<a class="headerlink" href="#using-classes-to-implement-a-simulator" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><ul class="simple">
<li>Introduce classes <code class="docutils literal"><span class="pre">Mesh</span></code>, <code class="docutils literal"><span class="pre">Function</span></code>, <code class="docutils literal"><span class="pre">Problem</span></code>, <code class="docutils literal"><span class="pre">Solver</span></code>, <code class="docutils literal"><span class="pre">Visualizer</span></code>,
<code class="docutils literal"><span class="pre">File</span></code></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="exercises-3">
<h1>Exercises<a class="headerlink" href="#exercises-3" title="Permalink to this headline">¶</a></h1>
<div class="section" id="exercise-32-check-that-a-solution-fulfills-the-discrete-model">
<span id="wave-exer-quadratic-2d"></span><h2>Exercise 32: Check that a solution fulfills the discrete model<a class="headerlink" href="#exercise-32-check-that-a-solution-fulfills-the-discrete-model" title="Permalink to this headline">¶</a></h2>
<p>Carry out all mathematical details to show that
<a class="reference internal" href="#eq-wave2d3d-impl-verify-quadratic"><span class="std std-ref">(199)</span></a> is indeed a solution of the
discrete model for a 2D wave equation with <span class="math">\(u=0\)</span> on the boundary.
One must check the boundary conditions, the initial conditions,
the general discrete equation at a time level and the special
version of this equation for the first time level.
Filename: <code class="docutils literal"><span class="pre">check_quadratic_solution</span></code>.</p>
</div>
<div class="section" id="project-33-calculus-with-2d-mesh-functions">
<span id="wave-exer-mesh3d-calculus"></span><h2>Project 33: Calculus with 2D mesh functions<a class="headerlink" href="#project-33-calculus-with-2d-mesh-functions" title="Permalink to this headline">¶</a></h2>
<p>The goal of this project is to redo
<a class="reference internal" href="._book003.html#wave-exer-mesh1d-calculus"><span class="std std-ref">Project 22: Calculus with 1D mesh functions</span></a> with 2D
mesh functions (<span class="math">\(f_{i,j}\)</span>).</p>
<p><strong>Differentiation.</strong>
The differentiation results in a discrete gradient
function, which in the 2D case can be represented by a three-dimensional
array <code class="docutils literal"><span class="pre">df[d,i,j]</span></code> where <code class="docutils literal"><span class="pre">d</span></code> represents the direction of
the derivative, and <code class="docutils literal"><span class="pre">i,j</span></code> is a mesh point in 2D.
Use centered differences for
the derivative at inner points and one-sided forward or backward
differences at the boundary points. Construct unit tests and
write a corresponding test function.</p>
<p><strong>Integration.</strong>
The integral of a 2D mesh function <span class="math">\(f_{i,j}\)</span> is defined as</p>
<div class="math">
\[F_{i,j} = \int_{y_0}^{y_j} \int_{x_0}^{x_i} f(x,y)dxdy,\]</div>
<p>where <span class="math">\(f(x,y)\)</span> is a function that takes on the values of the
discrete mesh function <span class="math">\(f_{i,j}\)</span> at the mesh points, but can also
be evaluated in between the mesh points. The particular variation
between mesh points can be taken as bilinear, but this is not
important as we will use a product Trapezoidal rule to approximate
the integral over a cell in the mesh and then we only need to
evaluate <span class="math">\(f(x,y)\)</span> at the mesh points.</p>
<p>Suppose <span class="math">\(F_{i,j}\)</span> is computed. The calculation of <span class="math">\(F_{i+1,j}\)</span>
is then</p>
<div class="math">
\[\begin{split}F_{i+1,j} &amp;= F_{i,j} + \int_{x_i}^{x_{i+1}}\int_{y_0}^{y_j} f(x,y)dydx\\
&amp; \approx \Delta x \half\left(
\int_{y_0}^{y_j} f(x_{i},y)dy
+ \int_{y_0}^{y_j} f(x_{i+1},y)dy\right)\end{split}\]</div>
<p>The integrals in the <span class="math">\(y\)</span> direction can be approximated by a Trapezoidal
rule. A similar idea can be used to compute <span class="math">\(F_{i,j+1}\)</span>. Thereafter,
<span class="math">\(F_{i+1,j+1}\)</span> can be computed by adding the integral over the final
corner cell to <span class="math">\(F_{i+1,j} + F_{i,j+1} - F_{i,j}\)</span>. Carry out the
details of these computations and implement a function that can
return <span class="math">\(F_{i,j}\)</span> for all mesh indices <span class="math">\(i\)</span> and <span class="math">\(j\)</span>. Use the
fact that the Trapezoidal rule is exact for linear functions and
write a test function.
Filename: <code class="docutils literal"><span class="pre">mesh_calculus_2D</span></code>.</p>
</div>
<div class="section" id="exercise-34-implement-neumann-conditions-in-2d">
<span id="wave-app-exer-wave2d-neumann"></span><h2>Exercise 34: Implement Neumann conditions in 2D<a class="headerlink" href="#exercise-34-implement-neumann-conditions-in-2d" title="Permalink to this headline">¶</a></h2>
<p>Modify the <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave2D_u0/wave2D_u0.py">wave2D_u0.py</a>
program, which solves the 2D wave equation <span class="math">\(u_{tt}=c^2(u_{xx}+u_{yy})\)</span>
with constant wave velocity <span class="math">\(c\)</span> and <span class="math">\(u=0\)</span> on the boundary, to have
Neumann boundary conditions: <span class="math">\(\partial u/\partial n=0\)</span>.
Include both scalar code (for debugging and reference) and
vectorized code (for speed).</p>
<p>To test the code, use <span class="math">\(u=1.2\)</span> as solution (<span class="math">\(I(x,y)=1.2\)</span>, <span class="math">\(V=f=0\)</span>, and
<span class="math">\(c\)</span> arbitrary), which should be exactly reproduced with any mesh
as long as the stability criterion is satisfied.
Another test is to use the plug-shaped pulse
in the <code class="docutils literal"><span class="pre">pulse</span></code> function from the section <a class="reference internal" href="._book003.html#wave-pde2-software"><span class="std std-ref">Building a general 1D wave equation solver</span></a>
and the <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_dn_vc.py">wave1D_dn_vc.py</a>
program. This pulse
is exactly propagated in 1D if <span class="math">\(c\Delta t/\Delta x=1\)</span>. Check
that also the 2D program can propagate this pulse exactly
in <span class="math">\(x\)</span> direction (<span class="math">\(c\Delta t/\Delta x=1\)</span>, <span class="math">\(\Delta y\)</span> arbitrary)
and <span class="math">\(y\)</span> direction (<span class="math">\(c\Delta t/\Delta y=1\)</span>, <span class="math">\(\Delta x\)</span> arbitrary).
Filename: <code class="docutils literal"><span class="pre">wave2D_dn</span></code>.</p>
</div>
<div class="section" id="exercise-35-test-the-efficiency-of-compiled-loops-in-3d">
<span id="wave-exer-3d-f77-cy-efficiency"></span><h2>Exercise 35: Test the efficiency of compiled loops in 3D<a class="headerlink" href="#exercise-35-test-the-efficiency-of-compiled-loops-in-3d" title="Permalink to this headline">¶</a></h2>
<p>Extend the <code class="docutils literal"><span class="pre">wave2D_u0.py</span></code> code and the Cython, Fortran, and C versions to 3D.
Set up an efficiency experiment to determine the relative efficiency of
pure scalar Python code, vectorized code, Cython-compiled loops,
Fortran-compiled loops, and C-compiled loops.
Normalize the CPU time for each mesh by the fastest version.
Filename: <code class="docutils literal"><span class="pre">wave3D_u0</span></code>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Finite difference methods for 2D and 3D wave equations</a><ul>
<li><a class="reference internal" href="#multi-dimensional-wave-equations">Multi-dimensional wave equations</a></li>
<li><a class="reference internal" href="#mesh">Mesh</a></li>
<li><a class="reference internal" href="#discretization">Discretization</a><ul>
<li><a class="reference internal" href="#discretizing-the-pdes">Discretizing the PDEs</a></li>
<li><a class="reference internal" href="#handling-boundary-conditions-where-is-known">Handling boundary conditions where <span class="math">\(u\)</span> is known</a></li>
<li><a class="reference internal" href="#discretizing-the-neumann-condition">Discretizing the Neumann condition</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-6">Implementation</a><ul>
<li><a class="reference internal" href="#scalar-computations">Scalar computations</a><ul>
<li><a class="reference internal" href="#domain-and-mesh">Domain and mesh</a></li>
<li><a class="reference internal" href="#solution-arrays">Solution arrays</a></li>
<li><a class="reference internal" href="#index-sets">Index sets</a></li>
<li><a class="reference internal" href="#computing-the-solution">Computing the solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vectorized-computations">Vectorized computations</a></li>
<li><a class="reference internal" href="#verification-5">Verification</a><ul>
<li><a class="reference internal" href="#testing-a-quadratic-solution">Testing a quadratic solution</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#using-classes-to-implement-a-simulator">Using classes to implement a simulator</a></li>
<li><a class="reference internal" href="#exercises-3">Exercises</a><ul>
<li><a class="reference internal" href="#exercise-32-check-that-a-solution-fulfills-the-discrete-model">Exercise 32: Check that a solution fulfills the discrete model</a></li>
<li><a class="reference internal" href="#project-33-calculus-with-2d-mesh-functions">Project 33: Calculus with 2D mesh functions</a></li>
<li><a class="reference internal" href="#exercise-34-implement-neumann-conditions-in-2d">Exercise 34: Implement Neumann conditions in 2D</a></li>
<li><a class="reference internal" href="#exercise-35-test-the-efficiency-of-compiled-loops-in-3d">Exercise 35: Test the efficiency of compiled loops in 3D</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book004.html"
                        title="previous chapter">Analysis of the difference equations</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book006.html"
                        title="next chapter">Applications of wave equations</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book005.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book006.html" title="Applications of wave equations"
             >next</a> |</li>
        <li class="right" >
          <a href="._book004.html" title="Analysis of the difference equations"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with Partial Differential Equations</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2015, Hans Petter Langtangen. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>