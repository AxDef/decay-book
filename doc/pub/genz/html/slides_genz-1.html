<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study guide: Generalizations of exponential decay models">
<meta name="keywords" content="lambda functions,method of manufactured solutions,MMS (method of manufactured solutions),implicit schemes,explicit schemes,theta-rule,$\theta$-rule,backward scheme, 2-step,BDF2 scheme,Leapfrog scheme,Leapfrog scheme, filtered,Heun's method,Runge-Kutta, 2nd-order scheme,Adams-Bashforth scheme, 2nd order,Adams-Bashforth scheme, 3rd order">

<title>Study guide: Generalizations of exponential decay models</title>


<style type="text/css">
/* bloodish style */

body {
  font-family: Helvetica, Verdana, Arial, Sans-serif;
  color: #404040;
  background: #ffffff;
}
h1 { font-size: 1.8em;  color: #8A0808; }
h2 { font-size: 1.6em;  color: #8A0808; }
h3 { font-size: 1.4em;  color: #8A0808; }
h4 { color: #8A0808; }
a { color: #8A0808; text-decoration:none; }
tt { font-family: "Courier New", Courier; }
/* pre style removed because it will interfer with pygments */
p { text-indent: 0px; }
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-style: normal; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Model extensions',
               1,
               'decay:generalizations',
               'decay:generalizations'),
              ('Extension to a variable coefficient; Forward and Backward Euler',
               2,
               None,
               '___sec1'),
              ('Extension to a variable coefficient; Crank-Nicolson',
               2,
               None,
               '___sec2'),
              ('Extension to a variable coefficient; $\\theta$-rule',
               2,
               None,
               '___sec3'),
              ('Extension to a variable coefficient; operator notation',
               2,
               None,
               '___sec4'),
              ('Extension to a source term',
               2,
               'decay:source',
               'decay:source'),
              ('Implementation of the generalized model problem',
               2,
               'decay:general',
               'decay:general'),
              ('Implementations of variable coefficients; functions',
               2,
               None,
               '___sec7'),
              ('Implementations of variable coefficients; classes',
               2,
               None,
               '___sec8'),
              ('Implementations of variable coefficients; lambda function',
               2,
               None,
               '___sec9'),
              ('Verification via trivial solutions',
               2,
               'decay:verify:trivial',
               'decay:verify:trivial'),
              ('Verification via trivial solutions; test function',
               2,
               None,
               '___sec11'),
              ('Verification via manufactured solutions',
               2,
               'decay:MMS',
               'decay:MMS'),
              ('Linear manufactured solution', 2, None, '___sec13'),
              ('Test function for linear manufactured solution',
               2,
               None,
               '___sec14'),
              ('Extension to systems of ODEs', 2, None, '___sec15'),
              ('The Backward Euler method gives a system of algebraic equations',
               2,
               None,
               '___sec16'),
              ('Methods for general first-order ODEs',
               1,
               'decay:1stODEs',
               'decay:1stODEs'),
              ('Generic form', 2, None, '___sec18'),
              ('The $\\theta$-rule', 2, None, '___sec19'),
              ('Implicit 2-step backward scheme', 2, None, '___sec20'),
              ('The Leapfrog scheme', 2, None, '___sec21'),
              ('The filtered Leapfrog scheme', 2, None, '___sec22'),
              ('2nd-order Runge-Kutta scheme', 2, None, '___sec23'),
              ('4th-order Runge-Kutta scheme',
               2,
               'decay:fd2:RK4',
               'decay:fd2:RK4'),
              ('2nd-order Adams-Bashforth scheme', 2, None, '___sec25'),
              ('3rd-order Adams-Bashforth scheme', 2, None, '___sec26'),
              ('The Odespy software', 2, None, '___sec27'),
              ('Example: Runge-Kutta methods', 2, None, '___sec28'),
              ('Plots from the experiments', 2, None, '___sec29'),
              ('Example: Adaptive Runge-Kutta methods', 2, None, '___sec30')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
$$




    
<!-- ------------------- main content ---------------------- -->



<center><h1>Study guide: Generalizations of exponential decay models</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>

<p>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>
<p>
<center><h4>Aug 4, 2015</h4></center> <!-- date -->
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Table of contents</h2>

<p>
<a href="#decay:generalizations"> Model extensions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec1"> Extension to a variable coefficient; Forward and Backward Euler </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec2"> Extension to a variable coefficient; Crank-Nicolson </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec3"> Extension to a variable coefficient; \( \theta \)-rule </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec4"> Extension to a variable coefficient; operator notation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:source"> Extension to a source term </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:general"> Implementation of the generalized model problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec7"> Implementations of variable coefficients; functions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec8"> Implementations of variable coefficients; classes </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec9"> Implementations of variable coefficients; lambda function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:verify:trivial"> Verification via trivial solutions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec11"> Verification via trivial solutions; test function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:MMS"> Verification via manufactured solutions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec13"> Linear manufactured solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec14"> Test function for linear manufactured solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec15"> Extension to systems of ODEs </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec16"> The Backward Euler method gives a system of algebraic equations </a><br>
<a href="#decay:1stODEs"> Methods for general first-order ODEs </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec18"> Generic form </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec19"> The \( \theta \)-rule </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec20"> Implicit 2-step backward scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec21"> The Leapfrog scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec22"> The filtered Leapfrog scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec23"> 2nd-order Runge-Kutta scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:fd2:RK4"> 4th-order Runge-Kutta scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec25"> 2nd-order Adams-Bashforth scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec26"> 3rd-order Adams-Bashforth scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec27"> The Odespy software </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec28"> Example: Runge-Kutta methods  </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec29"> Plots from the experiments </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec30"> Example: Adaptive Runge-Kutta methods  </a><br>
</p>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="decay:generalizations">Model extensions</h1>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec1">Extension to a variable coefficient; Forward and Backward Euler </h2>

$$
\begin{equation}
u'(t) = -a(t)u(t),\quad t\in (0,T],\quad u(0)=I
\label{decay:problem:a}
\end{equation}
$$

<p>
The Forward Euler scheme:

$$
\begin{equation}
\frac{u^{n+1} - u^n}{\Delta t} = -a(t_n)u^n
\end{equation}
$$

<p>
The Backward Euler scheme:
$$
\begin{equation}
\frac{u^{n} - u^{n-1}}{\Delta t} = -a(t_n)u^n
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec2">Extension to a variable coefficient; Crank-Nicolson </h2>

<p>
Eevaluting \( a(t_{n+\half}) \) and
using an average for \( u \):
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -a(t_{n+\half})\half(u^n + u^{n+1})
\end{equation}
$$

<p>
Using an average for \( a \) and \( u \):
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -\half(a(t_n)u^n + a(t_{n+1})u^{n+1})
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec3">Extension to a variable coefficient; \( \theta \)-rule </h2>

<p>
The \( \theta \)-rule unifies the three mentioned schemes,

$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -a((1-\theta)t_n + \theta t_{n+1})((1-\theta) u^n + \theta u^{n+1})
\end{equation}
$$

or,
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -(1-\theta) a(t_n)u^n - \theta
a(t_{n+1})u^{n+1}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec4">Extension to a variable coefficient; operator notation </h2>

$$
\begin{align*}
\lbrack D^+_t u &= -au\rbrack^n,\\ 
\lbrack D^-_t u &= -au\rbrack^n,\\ 
\lbrack D_t u &= -a\overline{u}^t\rbrack^{n+\half},\\ 
\lbrack D_t u &= -\overline{au}^t\rbrack^{n+\half}\\ 
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="decay:source">Extension to a source term</h2>

$$
\begin{equation}
u'(t) = -a(t)u(t) + b(t),\quad t\in (0,T],\quad u(0)=I
\label{decay:problem:ab}
\end{equation}
$$


$$
\begin{align*}
\lbrack D^+_t u &= -au + b\rbrack^n,\\ 
\lbrack D^-_t u &= -au + b\rbrack^n,\\ 
\lbrack D_t u   &= -a\overline{u}^t + b\rbrack^{n+\half},\\ 
\lbrack D_t u   &= \overline{-au+b}^t\rbrack^{n+\half}
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="decay:general">Implementation of the generalized model problem</h2>

$$
\begin{equation}
u^{n+1} = ((1 - \Delta t(1-\theta)a^n)u^n
+ \Delta t(\theta b^{n+1} + (1-\theta)b^n))(1 + \Delta t\theta a^{n+1})^{-1}
\end{equation}
$$

<p>
Implementation where \( a(t) \) and \( b(t) \) are given as
Python functions (see file <a href="http://tinyurl.com/ofkw6kc/genz/decay_vc.py" target="_self"><tt>decay_vc.py</tt></a>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(I, a, b, T, dt, theta):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve u&#39;=-a(t)*u + b(t), u(0)=I,</span>
<span style="color: #BA2121; font-style: italic">    for t in (0,T] with steps of dt.</span>
<span style="color: #BA2121; font-style: italic">    a and b are Python functions of t.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(dt)            <span style="color: #408080; font-style: italic"># avoid integer division</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))     <span style="color: #408080; font-style: italic"># no of time intervals</span>
    T <span style="color: #666666">=</span> Nt<span style="color: #666666">*</span>dt                 <span style="color: #408080; font-style: italic"># adjust T to fit time step dt</span>
    u <span style="color: #666666">=</span> zeros(Nt<span style="color: #666666">+1</span>)           <span style="color: #408080; font-style: italic"># array of u[n] values</span>
    t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, Nt<span style="color: #666666">+1</span>)  <span style="color: #408080; font-style: italic"># time mesh</span>

    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I                  <span style="color: #408080; font-style: italic"># assign initial condition</span>
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):    <span style="color: #408080; font-style: italic"># n=0,1,...,Nt-1</span>
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> ((<span style="color: #666666">1</span> <span style="color: #666666">-</span> dt<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a(t[n]))<span style="color: #666666">*</span>u[n] <span style="color: #666666">+</span> \ 
                  dt<span style="color: #666666">*</span>(theta<span style="color: #666666">*</span>b(t[n<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>b(t[n])))<span style="color: #666666">/</span>\ 
                  (<span style="color: #666666">1</span> <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>theta<span style="color: #666666">*</span>a(t[n<span style="color: #666666">+1</span>]))
    <span style="color: #008000; font-weight: bold">return</span> u, t
</pre></div>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec7">Implementations of variable coefficients; functions </h2>

<p>
Plain functions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">a</span>(t):
    <span style="color: #008000; font-weight: bold">return</span> a_0 <span style="color: #008000; font-weight: bold">if</span> t <span style="color: #666666">&lt;</span> tp <span style="color: #008000; font-weight: bold">else</span> k<span style="color: #666666">*</span>a_0

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">b</span>(t):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1</span>
</pre></div>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec8">Implementations of variable coefficients; classes </h2>

<p>
Better implementation: class with the parameters <code>a0</code>, <code>tp</code>, and <code>k</code>
as attributes and a <em>special method</em> <code>__call__</code> for evaluating \( a(t) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">A</span>:
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, a0<span style="color: #666666">=1</span>, k<span style="color: #666666">=2</span>):
        <span style="color: #008000">self</span><span style="color: #666666">.</span>a0, <span style="color: #008000">self</span><span style="color: #666666">.</span>k <span style="color: #666666">=</span> a0, k

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__call__</span>(<span style="color: #008000">self</span>, t):
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>a0 <span style="color: #008000; font-weight: bold">if</span> t <span style="color: #666666">&lt;</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>tp <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>k<span style="color: #666666">*</span><span style="color: #008000">self</span><span style="color: #666666">.</span>a0

a <span style="color: #666666">=</span> A(a0<span style="color: #666666">=2</span>, k<span style="color: #666666">=1</span>)  <span style="color: #408080; font-style: italic"># a behaves as a function a(t)</span>
</pre></div>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec9">Implementations of variable coefficients; lambda function </h2>

<p>
Quick writing: a one-liner <em>lambda function</em>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> t: a_0 <span style="color: #008000; font-weight: bold">if</span> t <span style="color: #666666">&lt;</span> tp <span style="color: #008000; font-weight: bold">else</span> k<span style="color: #666666">*</span>a_0
</pre></div>
<p>
In general,
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> arg1, arg2, <span style="color: #666666">...</span>: expressin
</pre></div>
<p>
is equivalent to
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(arg1, arg2, <span style="color: #666666">...</span>):
    <span style="color: #008000; font-weight: bold">return</span> expression
</pre></div>
<p>
One can use lambda functions directly in calls:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u, t <span style="color: #666666">=</span> solver(<span style="color: #666666">1</span>, <span style="color: #008000; font-weight: bold">lambda</span> t: <span style="color: #666666">1</span>, <span style="color: #008000; font-weight: bold">lambda</span> t: <span style="color: #666666">1</span>, T, dt, theta)
</pre></div>
<p>
for a problem \( u'=-u+1 \), \( u(0)=1 \).

<p>
A lambda function can appear anywhere where a variable can appear.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="decay:verify:trivial">Verification via trivial solutions</h2>

<ul>
 <p><li> Start debugging of a new code with trying a problem
   where \( u=\hbox{const} \neq 0 \).</li>
 <p><li> Choose \( u=C \) (a constant). Choose any \( a(t) \) and set
   \( b=a(t)C \) and
   \( I=C \).</li>
 <p><li> "All" numerical methods will reproduce \( u=_{\hbox{const}} \)
   exactly (machine precision).</li>
 <p><li> Often \( u=C \) eases debugging.</li>
 <p><li> In this example: <em>any error</em> in the formula for \( u^{n+1} \)
   make \( u\neq C \)!</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec11">Verification via trivial solutions; test function </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_constant_solution</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Test problem where u=u_const is the exact solution, to be</span>
<span style="color: #BA2121; font-style: italic">    reproduced (to machine precision) by any relevant method.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">exact_solution</span>(t):
        <span style="color: #008000; font-weight: bold">return</span> u_const

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">a</span>(t):
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">2.5*</span>(<span style="color: #666666">1+</span>t<span style="color: #666666">**3</span>)  <span style="color: #408080; font-style: italic"># can be arbitrary</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">b</span>(t):
        <span style="color: #008000; font-weight: bold">return</span> a(t)<span style="color: #666666">*</span>u_const

    u_const <span style="color: #666666">=</span> <span style="color: #666666">2.15</span>
    theta <span style="color: #666666">=</span> <span style="color: #666666">0.4</span>; I <span style="color: #666666">=</span> u_const; dt <span style="color: #666666">=</span> <span style="color: #666666">4</span>
    Nt <span style="color: #666666">=</span> <span style="color: #666666">4</span>  <span style="color: #408080; font-style: italic"># enough with a few steps</span>
    u, t <span style="color: #666666">=</span> solver(I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, b<span style="color: #666666">=</span>b, T<span style="color: #666666">=</span>Nt<span style="color: #666666">*</span>dt, dt<span style="color: #666666">=</span>dt, theta<span style="color: #666666">=</span>theta)
    <span style="color: #008000; font-weight: bold">print</span> u
    u_e <span style="color: #666666">=</span> exact_solution(t)
    difference <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_e <span style="color: #666666">-</span> u)<span style="color: #666666">.</span>max()  <span style="color: #408080; font-style: italic"># max deviation</span>
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">assert</span> difference <span style="color: #666666">&lt;</span> tol
</pre></div>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="decay:MMS">Verification via manufactured solutions</h2>

<ul>
 <p><li> Choose <em>any</em> formula for \( u(t) \).</li>
 <p><li> Fit \( I \), \( a(t) \), and \( b(t) \) in \( u'=-au+b \), \( u(0)=I \),
   to make the chosen formula a solution of the ODE problem.</li>
 <p><li> Then we can always have an analytical solution (!).</li>
 <p><li> Ideal for verification: testing convergence rates.</li>
 <p><li> Called the <em>method of manufactured solutions</em> (MMS)</li>
 <p><li> Special case: \( u \) linear in \( t \), because all sound numerical
   methods will reproduce a linear \( u \) exactly (machine precision).</li>
 <p><li> \( u(t) = ct + d \). \( u(0)=0 \) means \( d=I \).</li>
 <p><li> ODE implies \( c = -a(t)u + b(t) \).</li>
 <p><li> Choose \( a(t) \) and \( c \), and set \( b(t) = c + a(t)(ct + I) \).</li>
 <p><li> Any error in the formula for \( u^{n+1} \) makes \( u\neq ct+I \)!</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec13">Linear manufactured solution </h2>

<p>
\( u^n = ct_n+I \) fulfills the discrete
equations!

<p>
First,
$$
\begin{align}
\lbrack D_t^+ t\rbrack^n &= \frac{t_{n+1}-t_n}{\Delta t}=1,
\label{decay:fd2:Dop:tn:fw}\\ 
\lbrack D_t^- t\rbrack^n &= \frac{t_{n}-t_{n-1}}{\Delta t}=1,
\label{decay:fd2:Dop:tn:bw}\\ 
\lbrack D_t t\rbrack^n &= \frac{t_{n+\half}-t_{n-\half}}{\Delta t}=\frac{(n+\half)\Delta t - (n-\half)\Delta t}{\Delta t}=1\label{decay:fd2:Dop:tn:cn}
\end{align}
$$

<p>
Forward Euler:

$$ [D^+ u = -au + b]^n $$

<p>
\( a^n=a(t_n) \), \( b^n=c + a(t_n)(ct_n + I) \), and \( u^n=ct_n + I \)
results in

$$ c = -a(t_n)(ct_n+I) + c + a(t_n)(ct_n + I) = c $$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec14">Test function for linear manufactured solution </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_linear_solution</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Test problem where u=c*t+I is the exact solution, to be</span>
<span style="color: #BA2121; font-style: italic">    reproduced (to machine precision) by any relevant method.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">exact_solution</span>(t):
        <span style="color: #008000; font-weight: bold">return</span> c<span style="color: #666666">*</span>t <span style="color: #666666">+</span> I

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">a</span>(t):
        <span style="color: #008000; font-weight: bold">return</span> t<span style="color: #666666">**0.5</span>  <span style="color: #408080; font-style: italic"># can be arbitrary</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">b</span>(t):
        <span style="color: #008000; font-weight: bold">return</span> c <span style="color: #666666">+</span> a(t)<span style="color: #666666">*</span>exact_solution(t)

    theta <span style="color: #666666">=</span> <span style="color: #666666">0.4</span>; I <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>; dt <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>; c <span style="color: #666666">=</span> <span style="color: #666666">-0.5</span>
    T <span style="color: #666666">=</span> <span style="color: #666666">4</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(T<span style="color: #666666">/</span>dt)  <span style="color: #408080; font-style: italic"># no of steps</span>
    u, t <span style="color: #666666">=</span> solver(I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, b<span style="color: #666666">=</span>b, T<span style="color: #666666">=</span>Nt<span style="color: #666666">*</span>dt, dt<span style="color: #666666">=</span>dt, theta<span style="color: #666666">=</span>theta)
    u_e <span style="color: #666666">=</span> exact_solution(t)
    difference <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_e <span style="color: #666666">-</span> u)<span style="color: #666666">.</span>max()  <span style="color: #408080; font-style: italic"># max deviation</span>
    <span style="color: #008000; font-weight: bold">print</span> difference
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>  <span style="color: #408080; font-style: italic"># depends on c!</span>
    <span style="color: #008000; font-weight: bold">assert</span> difference <span style="color: #666666">&lt;</span> tol
</pre></div>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec15">Extension to systems of ODEs </h2>

<p>
Sample system:

$$
\begin{align}
u' &= a u + bv\\ 
v' &= cu +  dv
\end{align}
$$

<p>
The Forward Euler method:

$$
\begin{align}
u^{n+1} &= u^n + \Delta t (a u^n + b v^n)\\ 
v^{n+1} &= u^n + \Delta t (cu^n + dv^n)
\end{align}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec16">The Backward Euler method gives a system of algebraic equations </h2>

<p>
The Backward Euler scheme:

$$
\begin{align}
u^{n+1} &= u^n + \Delta t (a u^{n+1} + b v^{n+1})\\ 
v^{n+1} &= v^n + \Delta t (c u^{n+1} + d v^{n+1})
\end{align}
$$

which is a \( 2\times 2 \) linear system:

$$
\begin{align}
(1 - \Delta t a)u^{n+1} + bv^{n+1} &= u^n \\ 
c u^{n+1} + (1 - \Delta t d) v^{n+1} &= v^n
\end{align}
$$

<p>
Crank-Nicolson also gives a \( 2\times 2 \) linear system.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="decay:1stODEs">Methods for general first-order ODEs</h1>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec18">Generic form </h2>

<p>
The standard form for ODEs:
$$
\begin{equation}
u' = f(u,t),\quad u(0)=I
\label{decay:ode:general}
\end{equation}
$$

<p>
\( u \) and \( f \): scalar or vector.

<p>
Vectors in case of ODE systems:
$$ u(t) = (u^{(0)}(t),u^{(1)}(t),\ldots,u^{(m-1)}(t))   $$


$$
\begin{align*}
f(u, t) = ( & f^{(0)}(u^{(0)},\ldots,u^{(m-1)})\\ 
            & f^{(1)}(u^{(0)},\ldots,u^{(m-1)}),\\ 
            & \vdots\\ 
            & f^{(m-1)}(u^{(0)}(t),\ldots,u^{(m-1)}(t)))
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec19">The \( \theta \)-rule </h2>

$$
\begin{equation}
\frac{u^{n+1}-u^n}{\Delta t} = \theta f(u^{n+1},t_{n+1}) +
(1-\theta)f(u^n, t_n)
\label{decay:fd2:theta}
\end{equation}
$$

Bringing the unknown \( u^{n+1} \) to the left-hand side and the known terms
on the right-hand side gives

$$
\begin{equation}
u^{n+1} - \Delta t \theta f(u^{n+1},t_{n+1}) =
u^n + \Delta t(1-\theta)f(u^n, t_n)
\end{equation}
$$

This is a <em>nonlinear</em> equation in \( u^{n+1} \) (unless \( f \) is linear in \( u \))!

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec20">Implicit 2-step backward scheme </h2>

$$ u'(t_{n+1}) \approx \frac{3u^{n+1} - 4u^{n} + u^{n-1}}{2\Delta t}$$

<p>
Scheme:
$$ u^{n+1} = \frac{4}{3}u^n - \frac{1}{3}u^{n-1} +
\frac{2}{3}\Delta t f(u^{n+1}, t_{n+1})
\label{decay:fd2:bw:2step}
$$

Nonlinear equation for \( u^{n+1} \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec21">The Leapfrog scheme </h2>

<p>
Idea:
$$
\begin{equation}
u'(t_n)\approx \frac{u^{n+1}-u^{n-1}}{2\Delta t} = [D_{2t} u]^n
\end{equation}
$$

<p>
Scheme:

$$ [D_{2t} u = f(u,t)]^n$$

or written out,
$$
\begin{equation}
u^{n+1} = u^{n-1} + \Delta t f(u^n, t_n)
\label{decay:fd2:leapfrog}
\end{equation}
$$


<ul>
 <p><li> Some other scheme must be used as starter (\( u^1 \)).</li>
 <p><li> Explicit scheme - a nonlinear \( f \) (in \( u \)) is trivial to handle.</li>
 <p><li> Downside: Leapfrog is always unstable after some time.</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec22">The filtered Leapfrog scheme </h2>

<p>
After computing \( u^{n+1} \), stabilize Leapfrog by
$$
\begin{equation}
u^n\ \leftarrow\ u^n + \gamma (u^{n-1} - 2u^n + u^{n+1})
\label{decay:fd2:leapfrog:filtered}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec23">2nd-order Runge-Kutta scheme </h2>

<p>
Forward-Euler + approximate Crank-Nicolson:
$$
\begin{align}
u^* &= u^n + \Delta t f(u^n, t_n),
\label{decay:fd2:RK2:s1}\\ 
u^{n+1} &= u^n + \Delta t \half \left( f(u^n, t_n) + f(u^*, t_{n+1})
\right)
\label{decay:fd2:RK2:s2}
\end{align}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="decay:fd2:RK4">4th-order Runge-Kutta scheme</h2>

<ul>
 <p><li> The most famous and widely used ODE method</li>
 <p><li> 4 evaluations of \( f \) per time step</li>
 <p><li> Its <a href="http://tinyurl.com/nclmcng/pub/sphinx-decay/._main_decay007.html#th-order-runge-kutta-scheme" target="_self">derivation</a> is a very good illustration of numerical thinking!</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec25">2nd-order Adams-Bashforth scheme </h2>

$$
\begin{equation}
u^{n+1} = u^n + \half\Delta t\left( 3f(u^n, t_n) - f(u^{n-1}, t_{n-1})
\right)
\label{decay:fd2:AB2}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec26">3rd-order Adams-Bashforth scheme </h2>

$$
\begin{equation}
u^{n+1} = u^n + \frac{1}{12}\left( 23f(u^n, t_n) - 16 f(u^{n-1},t_{n-1})
+ 5f(u^{n-2}, t_{n-2})\right)
\label{decay:fd2:AB3}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec27">The Odespy software </h2>

<p>
<a href="https://github.com/hplgit/odespy" target="_self">Odespy</a>
features simple Python implementations of the most fundamental
schemes as well as Python interfaces to several famous packages for
solving ODEs: <a href="https://computation.llnl.gov/casc/odepack/odepack_home.html" target="_self">ODEPACK</a>,
<a href="https://computation.llnl.gov/casc/odepack/odepack_home.html" target="_self">Vode</a>,
<a href="http://www.netlib.org/ode/rkc.f" target="_self">rkc.f</a>,
<a href="http://www.netlib.org/ode/rkf45.f" target="_self">rkf45.f</a>,
<a href="http://www.unige.ch/~hairer/software.html" target="_self">Radau5</a>, as well
as the ODE solvers in
<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.html" target="_self">SciPy</a>,
<a href="http://docs.sympy.org/dev/modules/mpmath/calculus/odes.html" target="_self">SymPy</a>, and
<a href="http://olivierverdier.github.com/odelab/" target="_self">odelab</a>.

<p>
Typical usage:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"># Define right-hand side of ODE
def f(u, t):
    return -a*u

import odespy
import numpy as np

# Set parameters and time mesh
I = 1; a = 2; T = 6; dt = 1.0
Nt = int(round(T/dt))
t_mesh = np.linspace(0, T, Nt+1)

# Use a 4th-order Runge-Kutta method
solver = odespy.RK4(f)
solver.set_initial_condition(I)
u, t = solver.solve(t_mesh)
</pre></div>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec28">Example: Runge-Kutta methods  </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">solvers <span style="color: #666666">=</span> [odespy<span style="color: #666666">.</span>RK2(f),
           odespy<span style="color: #666666">.</span>RK3(f),
           odespy<span style="color: #666666">.</span>RK4(f),
           odespy<span style="color: #666666">.</span>BackwardEuler(f, nonlinear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Newton&#39;</span>)]

<span style="color: #008000; font-weight: bold">for</span> solver <span style="color: #AA22FF; font-weight: bold">in</span> solvers:
    solver<span style="color: #666666">.</span>set_initial_condition(I)
    u, t <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>solve(t)

<span style="color: #408080; font-style: italic"># + lots of plot code...</span>
</pre></div>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec29">Plots from the experiments </h2>

<p>
<center><p><img src="fig-genz/decay_odespy1_png.png" align="bottom" width=800></p></center>

<p>
The 4-th order Runge-Kutta method (<code>RK4</code>) is the method of choice!

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec30">Example: Adaptive Runge-Kutta methods  </h2>

<ul>
 <p><li> Adaptive methods find "optimal" locations of the mesh points
   to ensure that the error is less than a given tolerance.</li>
 <p><li> Downside: approximate error estimation, not always optimal
   location of points.</li>
 <p><li> "Industry standard ODE solver": Dormand-Prince 4/5-th order
   Runge-Kutta (MATLAB's famous <code>ode45</code>).</li>
</ul>

<center><p><img src="fig-genz/decay_DormandPrince_adaptivity.png" align="bottom" width=800></p></center>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

