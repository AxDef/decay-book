<!DOCTYPE html>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study guide: Generalizations of exponential decay models">
<meta name="keywords" content="lambda functions,method of manufactured solutions,MMS (method of manufactured solutions),implicit schemes,explicit schemes,theta-rule,$\theta$-rule,backward scheme, 2-step,BDF2 scheme,Leapfrog scheme,Leapfrog scheme, filtered,Heun's method,Runge-Kutta, 2nd-order scheme,Adams-Bashforth scheme, 2nd order,Adams-Bashforth scheme, 3rd order">

<title>Study guide: Generalizations of exponential decay models</title>







<!-- reveal.js: http://lab.hakim.se/reveal-js/ -->

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<!--
<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/beigesmall.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/serif.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/moon.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/sky.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/darkgray.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/cbc.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simula.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
-->

<!-- For syntax highlighting -->
<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<style type="text/css">
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .reveal .alert-text-small   { font-size: 80%;  }
    .reveal .alert-text-large   { font-size: 130%; }
    .reveal .alert-text-normal  { font-size: 90%;  }
    .reveal .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:5px solid #bababa;
             -webkit-border-radius: 14px; -moz-border-radius: 14px;
             border-radius:14px;
             background-position: 10px 10px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 30px; /* 55px; if icon */
     }
     .reveal .alert-block {padding-top:14px; padding-bottom:14px}
     .reveal .alert-block > p, .alert-block > ul {margin-bottom:1em}
     /*.reveal .alert li {margin-top: 1em}*/
     .reveal .alert-block p+p {margin-top:5px}
     /*.reveal .alert-notice { background-image: url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_notice.png); }
     .reveal .alert-summary  { background-image:url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_summary.png); }
     .reveal .alert-warning { background-image: url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_warning.png); }
     .reveal .alert-question {background-image:url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */

</style>



<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>

<body>
<div class="reveal">

<!-- Any section element inside the <div class="slides"> container
     is displayed as a slide -->

<div class="slides">





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
$$




    



<section>
<!-- ------------------- main content ---------------------- -->



<center><h1 style="text-align: center;">Study guide: Generalizations of exponential decay models</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>

<p>&nbsp;<br>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>
<br>
<p>&nbsp;<br>
<center><h4>Feb 12, 2016</h4></center> <!-- date -->
<br>
</section>


<section>
<h1 id="decay:generalizations">Model extensions</h1>
</section>


<section>
<h2 id="___sec1">Extension to a variable coefficient; Forward and Backward Euler </h2>

<p>&nbsp;<br>
$$
\begin{equation}
u'(t) = -a(t)u(t),\quad t\in (0,T],\quad u(0)=I
\tag{1}
\end{equation}
$$
<p>&nbsp;<br>

<p>
The Forward Euler scheme:

<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n+1} - u^n}{\Delta t} = -a(t_n)u^n
\tag{2}
\end{equation}
$$
<p>&nbsp;<br>

<p>
The Backward Euler scheme:
<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n} - u^{n-1}}{\Delta t} = -a(t_n)u^n
\tag{3}
\end{equation}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="___sec2">Extension to a variable coefficient; Crank-Nicolson </h2>

<p>
Eevaluting \( a(t_{n+\half}) \) and
using an average for \( u \):
<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -a(t_{n+\half})\half(u^n + u^{n+1})
\tag{4}
\end{equation}
$$
<p>&nbsp;<br>

<p>
Using an average for \( a \) and \( u \):
<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -\half(a(t_n)u^n + a(t_{n+1})u^{n+1})
\tag{5}
\end{equation}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="___sec3">Extension to a variable coefficient; \( \theta \)-rule </h2>

<p>
The \( \theta \)-rule unifies the three mentioned schemes,

<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -a((1-\theta)t_n + \theta t_{n+1})((1-\theta) u^n + \theta u^{n+1})
\tag{6}
\end{equation}
$$
<p>&nbsp;<br>

or,
<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -(1-\theta) a(t_n)u^n - \theta
a(t_{n+1})u^{n+1}
\tag{7}
\end{equation}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="___sec4">Extension to a variable coefficient; operator notation </h2>

<p>&nbsp;<br>
$$
\begin{align*}
\lbrack D^+_t u &= -au\rbrack^n,\\ 
\lbrack D^-_t u &= -au\rbrack^n,\\ 
\lbrack D_t u &= -a\overline{u}^t\rbrack^{n+\half},\\ 
\lbrack D_t u &= -\overline{au}^t\rbrack^{n+\half}\\ 
\end{align*}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="decay:source">Extension to a source term</h2>

<p>&nbsp;<br>
$$
\begin{equation}
u'(t) = -a(t)u(t) + b(t),\quad t\in (0,T],\quad u(0)=I
\tag{8}
\end{equation}
$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$
\begin{align*}
\lbrack D^+_t u &= -au + b\rbrack^n,\\ 
\lbrack D^-_t u &= -au + b\rbrack^n,\\ 
\lbrack D_t u   &= -a\overline{u}^t + b\rbrack^{n+\half},\\ 
\lbrack D_t u   &= \overline{-au+b}^t\rbrack^{n+\half}
\end{align*}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="decay:general">Implementation of the generalized model problem</h2>

<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1} = ((1 - \Delta t(1-\theta)a^n)u^n
+ \Delta t(\theta b^{n+1} + (1-\theta)b^n))(1 + \Delta t\theta a^{n+1})^{-1}
\tag{9}
\end{equation}
$$
<p>&nbsp;<br>

<p>
Implementation where \( a(t) \) and \( b(t) \) are given as
Python functions (see file <a href="http://tinyurl.com/ofkw6kc/genz/decay_vc.py" target="_self"><tt>decay_vc.py</tt></a>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, a, b, T, dt, theta):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Solve u&#39;=-a(t)*u + b(t), u(0)=I,</span>
<span style="color: #CD5555">    for t in (0,T] with steps of dt.</span>
<span style="color: #CD5555">    a and b are Python functions of t.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    dt = <span style="color: #658b00">float</span>(dt)            <span style="color: #228B22"># avoid integer division</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))     <span style="color: #228B22"># no of time intervals</span>
    T = Nt*dt                 <span style="color: #228B22"># adjust T to fit time step dt</span>
    u = zeros(Nt+<span style="color: #B452CD">1</span>)           <span style="color: #228B22"># array of u[n] values</span>
    t = linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># time mesh</span>

    u[<span style="color: #B452CD">0</span>] = I                  <span style="color: #228B22"># assign initial condition</span>
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):    <span style="color: #228B22"># n=0,1,...,Nt-1</span>
        u[n+<span style="color: #B452CD">1</span>] = ((<span style="color: #B452CD">1</span> - dt*(<span style="color: #B452CD">1</span>-theta)*a(t[n]))*u[n] + \ 
                  dt*(theta*b(t[n+<span style="color: #B452CD">1</span>]) + (<span style="color: #B452CD">1</span>-theta)*b(t[n])))/\ 
                  (<span style="color: #B452CD">1</span> + dt*theta*a(t[n+<span style="color: #B452CD">1</span>]))
    <span style="color: #8B008B; font-weight: bold">return</span> u, t
</pre></div>
</section>


<section>
<h2 id="___sec7">Implementations of variable coefficients; functions </h2>

<p>
Plain functions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">a</span>(t):
    <span style="color: #8B008B; font-weight: bold">return</span> a_0 <span style="color: #8B008B; font-weight: bold">if</span> t &lt; tp <span style="color: #8B008B; font-weight: bold">else</span> k*a_0

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">b</span>(t):
    <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">1</span>
</pre></div>
</section>


<section>
<h2 id="___sec8">Implementations of variable coefficients; classes </h2>

<p>
Better implementation: class with the parameters <code>a0</code>, <code>tp</code>, and <code>k</code>
as attributes and a <em>special method</em> <code>__call__</code> for evaluating \( a(t) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">A</span>:
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__init__</span>(<span style="color: #658b00">self</span>, a0=<span style="color: #B452CD">1</span>, k=<span style="color: #B452CD">2</span>):
        <span style="color: #658b00">self</span>.a0, <span style="color: #658b00">self</span>.k = a0, k

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__call__</span>(<span style="color: #658b00">self</span>, t):
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #658b00">self</span>.a0 <span style="color: #8B008B; font-weight: bold">if</span> t &lt; <span style="color: #658b00">self</span>.tp <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #658b00">self</span>.k*<span style="color: #658b00">self</span>.a0

a = A(a0=<span style="color: #B452CD">2</span>, k=<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># a behaves as a function a(t)</span>
</pre></div>
</section>


<section>
<h2 id="___sec9">Implementations of variable coefficients; lambda function </h2>

<p>
Quick writing: a one-liner <em>lambda function</em>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%">a = <span style="color: #8B008B; font-weight: bold">lambda</span> t: a_0 <span style="color: #8B008B; font-weight: bold">if</span> t &lt; tp <span style="color: #8B008B; font-weight: bold">else</span> k*a_0
</pre></div>
<p>
In general,
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%">f = <span style="color: #8B008B; font-weight: bold">lambda</span> arg1, arg2, ...: expressin
</pre></div>
<p>
is equivalent to
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">f</span>(arg1, arg2, ...):
    <span style="color: #8B008B; font-weight: bold">return</span> expression
</pre></div>
<p>
One can use lambda functions directly in calls:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%">u, t = solver(<span style="color: #B452CD">1</span>, <span style="color: #8B008B; font-weight: bold">lambda</span> t: <span style="color: #B452CD">1</span>, <span style="color: #8B008B; font-weight: bold">lambda</span> t: <span style="color: #B452CD">1</span>, T, dt, theta)
</pre></div>
<p>
for a problem \( u'=-u+1 \), \( u(0)=1 \).

<p>
A lambda function can appear anywhere where a variable can appear.
</section>


<section>
<h2 id="decay:verify:trivial">Verification via trivial solutions</h2>

<ul>
 <p><li> Start debugging of a new code with trying a problem
   where \( u=\hbox{const} \neq 0 \).</li>
 <p><li> Choose \( u=C \) (a constant). Choose any \( a(t) \) and set
   \( b=a(t)C \) and
   \( I=C \).</li>
 <p><li> "All" numerical methods will reproduce \( u=_{\hbox{const}} \)
   exactly (machine precision).</li>
 <p><li> Often \( u=C \) eases debugging.</li>
 <p><li> In this example: <em>any error</em> in the formula for \( u^{n+1} \)
   make \( u\neq C \)!</li>
</ul>
</section>


<section>
<h2 id="___sec11">Verification via trivial solutions; test function </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_constant_solution</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Test problem where u=u_const is the exact solution, to be</span>
<span style="color: #CD5555">    reproduced (to machine precision) by any relevant method.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">u_exact</span>(t):
        <span style="color: #8B008B; font-weight: bold">return</span> u_const

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">a</span>(t):
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">2.5</span>*(<span style="color: #B452CD">1</span>+t**<span style="color: #B452CD">3</span>)  <span style="color: #228B22"># can be arbitrary</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">b</span>(t):
        <span style="color: #8B008B; font-weight: bold">return</span> a(t)*u_const

    u_const = <span style="color: #B452CD">2.15</span>
    theta = <span style="color: #B452CD">0.4</span>; I = u_const; dt = <span style="color: #B452CD">4</span>
    Nt = <span style="color: #B452CD">4</span>  <span style="color: #228B22"># enough with a few steps</span>
    u, t = solver(I=I, a=a, b=b, T=Nt*dt, dt=dt, theta=theta)
    <span style="color: #8B008B; font-weight: bold">print</span> u
    u_e = u_exact(t)
    difference = <span style="color: #658b00">abs</span>(u_e - u).max()  <span style="color: #228B22"># max deviation</span>
    tol = <span style="color: #B452CD">1E-14</span>
    <span style="color: #8B008B; font-weight: bold">assert</span> difference &lt; tol
</pre></div>
</section>


<section>
<h2 id="decay:MMS">Verification via manufactured solutions</h2>

<ul>
 <p><li> Choose <em>any</em> formula for \( u(t) \)</li>
 <p><li> Fit \( I \), \( a(t) \), and \( b(t) \) in \( u'=-au+b \), \( u(0)=I \),
   to make the chosen formula a solution of the ODE problem</li>
 <p><li> Then we can always have an analytical solution (!)</li>
 <p><li> Ideal for verification: testing convergence rates</li>
 <p><li> Called the <em>method of manufactured solutions</em> (MMS)</li>
 <p><li> Special case: \( u \) linear in \( t \), because all sound numerical
   methods will reproduce a linear \( u \) exactly (machine precision)</li>
 <p><li> \( u(t) = ct + d \). \( u(0)=0 \) means \( d=I \)</li>
 <p><li> ODE implies \( c = -a(t)u + b(t) \)</li>
 <p><li> Choose \( a(t) \) and \( c \), and set \( b(t) = c + a(t)(ct + I) \)</li>
 <p><li> Any error in the formula for \( u^{n+1} \) makes \( u\neq ct+I \)!</li>
</ul>
</section>


<section>
<h2 id="___sec13">Linear manufactured solution </h2>

<p>
\( u^n = ct_n+I \) fulfills the discrete
equations!

<p>
First,
<p>&nbsp;<br>
$$
\begin{align}
\lbrack D_t^+ t\rbrack^n &= \frac{t_{n+1}-t_n}{\Delta t}=1,
\tag{10}\\ 
\lbrack D_t^- t\rbrack^n &= \frac{t_{n}-t_{n-1}}{\Delta t}=1,
\tag{11}\\ 
\lbrack D_t t\rbrack^n &= \frac{t_{n+\half}-t_{n-\half}}{\Delta t}=\frac{(n+\half)\Delta t - (n-\half)\Delta t}{\Delta t}=1\tag{12}
\end{align}
$$
<p>&nbsp;<br>

<p>
Forward Euler:

<p>&nbsp;<br>
$$ [D^+ u = -au + b]^n $$
<p>&nbsp;<br>

<p>
\( a^n=a(t_n) \), \( b^n=c + a(t_n)(ct_n + I) \), and \( u^n=ct_n + I \)
results in

<p>&nbsp;<br>
$$ c = -a(t_n)(ct_n+I) + c + a(t_n)(ct_n + I) = c $$
<p>&nbsp;<br>
</section>


<section>
<h2 id="___sec14">Test function for linear manufactured solution </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_linear_solution</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Test problem where u=c*t+I is the exact solution, to be</span>
<span style="color: #CD5555">    reproduced (to machine precision) by any relevant method.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">u_exact</span>(t):
        <span style="color: #8B008B; font-weight: bold">return</span> c*t + I

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">a</span>(t):
        <span style="color: #8B008B; font-weight: bold">return</span> t**<span style="color: #B452CD">0.5</span>  <span style="color: #228B22"># can be arbitrary</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">b</span>(t):
        <span style="color: #8B008B; font-weight: bold">return</span> c + a(t)*u_exact(t)

    theta = <span style="color: #B452CD">0.4</span>; I = <span style="color: #B452CD">0.1</span>; dt = <span style="color: #B452CD">0.1</span>; c = -<span style="color: #B452CD">0.5</span>
    T = <span style="color: #B452CD">4</span>
    Nt = <span style="color: #658b00">int</span>(T/dt)  <span style="color: #228B22"># no of steps</span>
    u, t = solver(I=I, a=a, b=b, T=Nt*dt, dt=dt, theta=theta)
    u_e = u_exact(t)
    difference = <span style="color: #658b00">abs</span>(u_e - u).max()  <span style="color: #228B22"># max deviation</span>
    <span style="color: #8B008B; font-weight: bold">print</span> difference
    tol = <span style="color: #B452CD">1E-14</span>  <span style="color: #228B22"># depends on c!</span>
    <span style="color: #8B008B; font-weight: bold">assert</span> difference &lt; tol
</pre></div>
</section>


<section>
<h1 id="decay:convrates">Computing convergence rates</h1>

<p>
Frequent assumption on the relation between the numerical error \( E \) and
some discretization parameter \( \Delta t \):

<p>&nbsp;<br>
$$
\begin{equation}
E = C\Delta t^r,
\tag{13}
\end{equation}
$$
<p>&nbsp;<br>


<ul>
 <p><li> Unknown: \( C \) and \( r \).</li>
 <p><li> Goal: estimate \( r \) (and \( C \)) from numerical experiments</li>
</ul>
</section>


<section>
<h2 id="___sec16">Estimating the convergence rate \( r \) </h2>

<p>
Perform numerical experiments: \( (\Delta t_i, E_i) \), \( i=0,\ldots,m-1 \).
Two methods for finding \( r \) (and \( C \)):

<ol>
 <p><li> Take the logarithm of <a href="#mjx-eqn-13">(13)</a>, \( \ln E = r\ln \Delta t + \ln C \),
    and fit a straight line to the data points \( (\Delta t_i, E_i) \),
    \( i=0,\ldots,m-1 \).</li>
 <p><li> Consider two consecutive experiments, \( (\Delta t_i, E_i) \) and
    \( (\Delta t_{i-1}, E_{i-1}) \). Dividing the equation
    \( E_{i-1}=C\Delta t_{i-1}^r \) by \( E_{i}=C\Delta t_{i}^r \) and solving
    for \( r \) yields</li>
</ol>
<p>&nbsp;<br>
$$
\begin{equation}
r_{i-1} = \frac{\ln (E_{i-1}/E_i)}{\ln (\Delta t_{i-1}/\Delta t_i)}
\tag{14}
\end{equation}
$$
<p>&nbsp;<br>

for \( i=1,=\ldots,m-1 \).

<p>
Method 2 is best.
</section>


<section>
<h2 id="___sec17">Brief implementation </h2>

<p>
Compute \( r_0, r_1, \ldots, r_{m-2} \) from \( E_i \) and \( \Delta t_i \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">compute_rates</span>(dt_values, E_values):
    m = <span style="color: #658b00">len</span>(dt_values)
    r = [log(E_values[i-<span style="color: #B452CD">1</span>]/E_values[i])/
         log(dt_values[i-<span style="color: #B452CD">1</span>]/dt_values[i])
         <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, m, <span style="color: #B452CD">1</span>)]
    <span style="color: #228B22"># Round to two decimals</span>
    r = [<span style="color: #658b00">round</span>(r_, <span style="color: #B452CD">2</span>) <span style="color: #8B008B; font-weight: bold">for</span> r_ <span style="color: #8B008B">in</span> r]
    <span style="color: #8B008B; font-weight: bold">return</span> r
</pre></div>
</section>


<section>
<h2 id="___sec18">We embed the code in a real test function </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_convergence_rates</span>():
    <span style="color: #228B22"># Create a manufactured solution</span>
    <span style="color: #228B22"># define u_exact(t), a(t), b(t)</span>

    dt_values = [<span style="color: #B452CD">0.1</span>*<span style="color: #B452CD">2</span>**(-i) <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">7</span>)]
    I = u_exact(<span style="color: #B452CD">0</span>)

    <span style="color: #8B008B; font-weight: bold">for</span> theta <span style="color: #8B008B">in</span> (<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">0.5</span>):
        E_values = []
        <span style="color: #8B008B; font-weight: bold">for</span> dt <span style="color: #8B008B">in</span> dt_values:
            u, t = solver(I=I, a=a, b=b, T=<span style="color: #B452CD">6</span>, dt=dt, theta=theta)
            u_e = u_exact(t)
            e = u_e - u
            E = sqrt(dt*<span style="color: #658b00">sum</span>(e**<span style="color: #B452CD">2</span>))
            E_values.append(E)
        r = compute_rates(dt_values, E_values)
        <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;theta=%g, r: %s&#39;</span> % (theta, r)
        expected_rate = <span style="color: #B452CD">2</span> <span style="color: #8B008B; font-weight: bold">if</span> theta == <span style="color: #B452CD">0.5</span> <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #B452CD">1</span>
        tol = <span style="color: #B452CD">0.1</span>
        diff = <span style="color: #658b00">abs</span>(expected_rate - r[-<span style="color: #B452CD">1</span>])
        <span style="color: #8B008B; font-weight: bold">assert</span> diff &lt; tol
</pre></div>
</section>


<section>
<h2 id="___sec19">The manufactured solution can be computed by sympy </h2>

<p>
We choose \( \uex(t) = \sin(t)e^{-2t} \), \( a(t)=t^2 \), fit \( b(t)=u'(t)-a(t) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"><span style="color: #228B22"># Create a manufactured solution with sympy</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sym</span>
t = sym.symbols(<span style="color: #CD5555">&#39;t&#39;</span>)
u_exact = sym.sin(t)*sym.exp(-<span style="color: #B452CD">2</span>*t)
a = t**<span style="color: #B452CD">2</span>
b = sym.diff(u_exact, t) + a*u_exact

<span style="color: #228B22"># Turn sympy expressions into Python function</span>
u_exact = sym.lambdify([t], u_exact, modules=<span style="color: #CD5555">&#39;numpy&#39;</span>)
a = sym.lambdify([t], a, modules=<span style="color: #CD5555">&#39;numpy&#39;</span>)
b = sym.lambdify([t], b, modules=<span style="color: #CD5555">&#39;numpy&#39;</span>)
</pre></div>
<p>
Complete code: <a href="http://tinyurl.com/ofkw6kc/genz/decay_vc.py" target="_self"><tt>decay_vc.py</tt></a>.
</section>


<section>
<h2 id="___sec20">Execution </h2>

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%">Terminal&gt; python decay_vc.py
...
theta=0, r: [1.06, 1.03, 1.01, 1.01, 1.0, 1.0]
theta=1, r: [0.94, 0.97, 0.99, 0.99, 1.0, 1.0]
theta=0.5, r: [2.0, 2.0, 2.0, 2.0, 2.0, 2.0]
</pre></div>
</section>


<section>
<h2 id="___sec21">Debugging via convergence rates </h2>

<p>
Potential bug: missing <code>a</code> in the denominator,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%">u[n+<span style="color: #B452CD">1</span>] = (<span style="color: #B452CD">1</span> - (<span style="color: #B452CD">1</span>-theta)*a*dt)/(<span style="color: #B452CD">1</span> + theta*dt)*u[n]
</pre></div>
<p>
Running <code>decay_convrate.py</code> gives same rates.

<p>
Why? The value of \( a \)... (\( a=1 \))

<p>
0 and 1 are <em>bad values</em> in tests!

<p>
Better:
<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%">Terminal&gt; python decay_convrate.py --a 2.1 --I 0.1  \ 
          --dt 0.5 0.25 0.1 0.05 0.025 0.01
...
Pairwise convergence rates for theta=0:
1.49 1.18 1.07 1.04 1.02

Pairwise convergence rates for theta=0.5:
-1.42 -0.22 -0.07 -0.03 -0.01

Pairwise convergence rates for theta=1:
0.21 0.12 0.06 0.03 0.01
</pre></div>
<p>
Forward Euler works...because \( \theta=0 \) hides the bug.

<p>
This bug gives \( r\approx 0 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%">u[n+<span style="color: #B452CD">1</span>] = ((<span style="color: #B452CD">1</span>-theta)*a*dt)/(<span style="color: #B452CD">1</span> + theta*dt*a)*u[n]
</pre></div>
</section>


<section>
<h2 id="___sec22">Extension to systems of ODEs </h2>

<p>
Sample system:

<p>&nbsp;<br>
$$
\begin{align}
u' &= a u + bv
\tag{15}\\ 
v' &= cu +  dv
\tag{16}
\end{align}
$$
<p>&nbsp;<br>

<p>
The Forward Euler method:

<p>&nbsp;<br>
$$
\begin{align}
u^{n+1} &= u^n + \Delta t (a u^n + b v^n)
\tag{17}\\ 
v^{n+1} &= u^n + \Delta t (cu^n + dv^n)
\tag{18}
\end{align}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="___sec23">The Backward Euler method gives a system of algebraic equations </h2>

<p>
The Backward Euler scheme:

<p>&nbsp;<br>
$$
\begin{align}
u^{n+1} &= u^n + \Delta t (a u^{n+1} + b v^{n+1})
\tag{19}\\ 
v^{n+1} &= v^n + \Delta t (c u^{n+1} + d v^{n+1})
\tag{20}
\end{align}
$$
<p>&nbsp;<br>

which is a \( 2\times 2 \) linear system:

<p>&nbsp;<br>
$$
\begin{align}
(1 - \Delta t a)u^{n+1} + bv^{n+1} &= u^n 
\tag{21}\\ 
c u^{n+1} + (1 - \Delta t d) v^{n+1} &= v^n
\tag{22}
\end{align}
$$
<p>&nbsp;<br>

<p>
Crank-Nicolson also gives a \( 2\times 2 \) linear system.
</section>


<section>
<h1 id="decay:1stODEs">Methods for general first-order ODEs</h1>
</section>


<section>
<h2 id="___sec25">Generic form </h2>

<p>
The standard form for ODEs:
<p>&nbsp;<br>
$$
\begin{equation}
u' = f(u,t),\quad u(0)=I
\tag{23}
\end{equation}
$$
<p>&nbsp;<br>

<p>
\( u \) and \( f \): scalar or vector.

<p>
Vectors in case of ODE systems:
<p>&nbsp;<br>
$$ u(t) = (u^{(0)}(t),u^{(1)}(t),\ldots,u^{(m-1)}(t))   $$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$
\begin{align*}
f(u, t) = ( & f^{(0)}(u^{(0)},\ldots,u^{(m-1)})\\ 
            & f^{(1)}(u^{(0)},\ldots,u^{(m-1)}),\\ 
            & \vdots\\ 
            & f^{(m-1)}(u^{(0)}(t),\ldots,u^{(m-1)}(t)))
\end{align*}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="___sec26">The \( \theta \)-rule </h2>

<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n+1}-u^n}{\Delta t} = \theta f(u^{n+1},t_{n+1}) +
(1-\theta)f(u^n, t_n)
\tag{24}
\end{equation}
$$
<p>&nbsp;<br>

Bringing the unknown \( u^{n+1} \) to the left-hand side and the known terms
on the right-hand side gives

<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1} - \Delta t \theta f(u^{n+1},t_{n+1}) =
u^n + \Delta t(1-\theta)f(u^n, t_n)
\tag{25}
\end{equation}
$$
<p>&nbsp;<br>

This is a <em>nonlinear</em> equation in \( u^{n+1} \) (unless \( f \) is linear in \( u \))!
</section>


<section>
<h2 id="___sec27">Implicit 2-step backward scheme </h2>

<p>&nbsp;<br>
$$ u'(t_{n+1}) \approx \frac{3u^{n+1} - 4u^{n} + u^{n-1}}{2\Delta t}$$
<p>&nbsp;<br>

<p>
Scheme:
<p>&nbsp;<br>
$$ u^{n+1} = \frac{4}{3}u^n - \frac{1}{3}u^{n-1} +
\frac{2}{3}\Delta t f(u^{n+1}, t_{n+1})
\tag{26}
$$
<p>&nbsp;<br>

Nonlinear equation for \( u^{n+1} \).
</section>


<section>
<h2 id="___sec28">The Leapfrog scheme </h2>

<p>
Idea:
<p>&nbsp;<br>
$$
\begin{equation}
u'(t_n)\approx \frac{u^{n+1}-u^{n-1}}{2\Delta t} = [D_{2t} u]^n
\tag{27}
\end{equation}
$$
<p>&nbsp;<br>

<p>
Scheme:

<p>&nbsp;<br>
$$ [D_{2t} u = f(u,t)]^n$$
<p>&nbsp;<br>

or written out,
<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1} = u^{n-1} + \Delta t f(u^n, t_n)
\tag{28}
\end{equation}
$$
<p>&nbsp;<br>


<ul>
 <p><li> Some other scheme must be used as starter (\( u^1 \)).</li>
 <p><li> Explicit scheme - a nonlinear \( f \) (in \( u \)) is trivial to handle.</li>
 <p><li> Downside: Leapfrog is always unstable after some time.</li>
</ul>
</section>


<section>
<h2 id="___sec29">The filtered Leapfrog scheme </h2>

<p>
After computing \( u^{n+1} \), stabilize Leapfrog by
<p>&nbsp;<br>
$$
\begin{equation}
u^n\ \leftarrow\ u^n + \gamma (u^{n-1} - 2u^n + u^{n+1})
\tag{29}
\end{equation}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="___sec30">2nd-order Runge-Kutta scheme </h2>

<p>
Forward-Euler + approximate Crank-Nicolson:
<p>&nbsp;<br>
$$
\begin{align}
u^* &= u^n + \Delta t f(u^n, t_n),
\tag{30}\\ 
u^{n+1} &= u^n + \Delta t \half \left( f(u^n, t_n) + f(u^*, t_{n+1})
\right)
\tag{31}
\end{align}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="decay:fd2:RK4">4th-order Runge-Kutta scheme</h2>

<ul>
 <p><li> The most famous and widely used ODE method</li>
 <p><li> 4 evaluations of \( f \) per time step</li>
 <p><li> Its <a href="http://tinyurl.com/nclmcng/pub/sphinx-decay/._main_decay007.html#th-order-runge-kutta-scheme" target="_self">derivation</a> is a very good illustration of numerical thinking!</li>
</ul>
</section>


<section>
<h2 id="___sec32">2nd-order Adams-Bashforth scheme </h2>

<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1} = u^n + \half\Delta t\left( 3f(u^n, t_n) - f(u^{n-1}, t_{n-1})
\right)
\tag{32}
\end{equation}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="___sec33">3rd-order Adams-Bashforth scheme </h2>

<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1} = u^n + \frac{1}{12}\left( 23f(u^n, t_n) - 16 f(u^{n-1},t_{n-1})
+ 5f(u^{n-2}, t_{n-2})\right)
\tag{33}
\end{equation}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="___sec34">The Odespy software </h2>

<p>
<a href="https://github.com/hplgit/odespy" target="_self">Odespy</a>
features simple Python implementations of the most fundamental
schemes as well as Python interfaces to several famous packages for
solving ODEs: <a href="https://computation.llnl.gov/casc/odepack/odepack_home.html" target="_self">ODEPACK</a>,
<a href="https://computation.llnl.gov/casc/odepack/odepack_home.html" target="_self">Vode</a>,
<a href="http://www.netlib.org/ode/rkc.f" target="_self">rkc.f</a>,
<a href="http://www.netlib.org/ode/rkf45.f" target="_self">rkf45.f</a>,
<a href="http://www.unige.ch/~hairer/software.html" target="_self">Radau5</a>, as well
as the ODE solvers in
<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.html" target="_self">SciPy</a>,
<a href="http://docs.sympy.org/dev/modules/mpmath/calculus/odes.html" target="_self">SymPy</a>, and
<a href="http://olivierverdier.github.com/odelab/" target="_self">odelab</a>.

<p>
Typical usage:

<p>

<!-- code=text typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%"># Define right-hand side of ODE
def f(u, t):
    return -a*u

import odespy
import numpy as np

# Set parameters and time mesh
I = 1; a = 2; T = 6; dt = 1.0
Nt = int(round(T/dt))
t_mesh = np.linspace(0, T, Nt+1)

# Use a 4th-order Runge-Kutta method
solver = odespy.RK4(f)
solver.set_initial_condition(I)
u, t = solver.solve(t_mesh)
</pre></div>
</section>


<section>
<h2 id="___sec35">Example: Runge-Kutta methods  </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="font-size: 80%; line-height: 125%">solvers = [odespy.RK2(f),
           odespy.RK3(f),
           odespy.RK4(f),
           odespy.BackwardEuler(f, nonlinear_solver=<span style="color: #CD5555">&#39;Newton&#39;</span>)]

<span style="color: #8B008B; font-weight: bold">for</span> solver <span style="color: #8B008B">in</span> solvers:
    solver.set_initial_condition(I)
    u, t = solver.solve(t)

<span style="color: #228B22"># + lots of plot code...</span>
</pre></div>
</section>


<section>
<h2 id="___sec36">Plots from the experiments </h2>

<p>
<center><p><img src="fig-genz/decay_odespy1_png.png" align="bottom" width=800></p></center>

<p>
The 4-th order Runge-Kutta method (<code>RK4</code>) is the method of choice!
</section>


<section>
<h2 id="___sec37">Example: Adaptive Runge-Kutta methods  </h2>

<ul>
 <p><li> Adaptive methods find "optimal" locations of the mesh points
   to ensure that the error is less than a given tolerance.</li>
 <p><li> Downside: approximate error estimation, not always optimal
   location of points.</li>
 <p><li> "Industry standard ODE solver": Dormand-Prince 4/5-th order
   Runge-Kutta (MATLAB's famous <code>ode45</code>).</li>
</ul>
<p>

<center><p><img src="fig-genz/decay_DormandPrince_adaptivity.png" align="bottom" width=800></p></center>
</section>



</div> <!-- class="slides" -->
</div> <!-- class="reveal" -->

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

    // Display navigation controls in the bottom right corner
    controls: true,

    // Display progress bar (below the horiz. slider)
    progress: true,

    // Display the page number of the current slide
    slideNumber: true,

    // Push each slide change to the browser history
    history: false,

    // Enable keyboard shortcuts for navigation
    keyboard: true,

    // Enable the slide overview mode
    overview: true,

    // Vertical centering of slides
    //center: true,
    center: false,

    // Enables touch navigation on devices with touch input
    touch: true,

    // Loop the presentation
    loop: false,

    // Change the presentation direction to be RTL
    rtl: false,

    // Turns fragments on and off globally
    fragments: true,

    // Flags if the presentation is running in an embedded mode,
    // i.e. contained within a limited portion of the screen
    embedded: false,

    // Number of milliseconds between automatically proceeding to the
    // next slide, disabled when set to 0, this value can be overwritten
    // by using a data-autoslide attribute on your slides
    autoSlide: 0,

    // Stop auto-sliding after user input
    autoSlideStoppable: true,

    // Enable slide navigation via mouse wheel
    mouseWheel: false,

    // Hides the address bar on mobile devices
    hideAddressBar: true,

    // Opens links in an iframe preview overlay
    previewLinks: false,

    // Transition style
    transition: 'default', // default/cube/page/concave/zoom/linear/fade/none

    // Transition speed
    transitionSpeed: 'default', // default/fast/slow

    // Transition style for full page slide backgrounds
    backgroundTransition: 'default', // default/none/slide/concave/convex/zoom

    // Number of slides away from the current that are visible
    viewDistance: 3,

    // Parallax background image
    //parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

    // Parallax background size
    //parallaxBackgroundSize: '' // CSS syntax, e.g. "2100px 900px"

    theme: Reveal.getQueryHash().theme, // available themes are in reveal.js/css/theme
    transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/none

});

Reveal.initialize({
    dependencies: [
        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },

        // Interpret Markdown in <section> elements
        { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

        // Syntax highlight for <code> elements
        { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

        // Zoom in and out with Alt+click
        { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

        // Speaker notes
        { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

        // Remote control your reveal.js presentation using a touch device
        //{ src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } },

        // MathJax
        //{ src: 'reveal.js/plugin/math/math.js', async: true }
    ]
});

Reveal.initialize({

    // The "normal" size of the presentation, aspect ratio will be preserved
    // when the presentation is scaled to fit different resolutions. Can be
    // specified using percentage units.
    width: 1170,  // original: 960,
    height: 700,

    // Factor of the display size that should remain empty around the content
    margin: 0.1,

    // Bounds for smallest/largest possible scale to apply to content
    minScale: 0.2,
    maxScale: 1.0

});
</script>

<!-- begin footer logo
<div style="position: absolute; bottom: 0px; left: 0; margin-left: 0px">
<img src="somelogo.png">
</div>
     end footer logo -->



</body>
</html>
