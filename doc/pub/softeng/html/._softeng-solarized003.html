<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Software engineering with exponential decay models">
<meta name="keywords" content="refactoring,importing modules,list comprehension,command-line arguments,option-value pairs (command line),command-line arguments,reading the command line,doctests,software testing doctests,unit testing,software testing nose,software testing pytest,test function,software testing test function,doctest in test function,unit testing,software testing unit testing (class-based),Distutils,GitHub,importing modules,problem class,solver class,wrapper (code),reproducibility,replicability,Unix wildcard notation,wildcard notation (Unix),Word (Microsoft),LibreOffice,OpenOffice,Google Docs,HTML,MathJax,LaTeX,Sphinx (typesetting tool),Markdown,IPython notebooks,Jupyter notebooks,DocOnce,replicability">

<title>Software engineering with exponential decay models</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Basic implementations',
               1,
               'softeng1:basic',
               'softeng1:basic'),
              ('Mathematical problem and solution technique',
               2,
               'softeng1:basic:math',
               'softeng1:basic:math'),
              ('A first, quick implementation',
               2,
               'softeng1:basic:impl1',
               'softeng1:basic:impl1'),
              ('A more decent program',
               2,
               'softeng1:basic:impl2',
               'softeng1:basic:impl2'),
              ('Comments in a program', 3, None, '___sec4'),
              ('Refactoring into functions', 3, None, '___sec5'),
              ('Program file vs IDE vs notebook', 3, None, '___sec6'),
              ('Prefixing imported functions by the module name',
               2,
               'softeng1:basic:modprefix',
               'softeng1:basic:modprefix'),
              ('Implementing the numerical algorithm in a function',
               2,
               'softeng1:basic:func',
               'softeng1:basic:func'),
              ('Do not have several versions of a code', 2, None, '___sec9'),
              ('Making a module',
               2,
               'softeng1:basic:module',
               'softeng1:basic:module'),
              ('Example on extending the module code',
               2,
               'softeng1:basic:experiment2',
               'softeng1:basic:experiment2'),
              ('Documenting functions and modules',
               2,
               'softeng1:basic:docstring',
               'softeng1:basic:docstring'),
              ('User interfaces',
               1,
               'softeng1:basic:UI',
               'softeng1:basic:UI'),
              ('Command-line arguments', 2, None, '___sec14'),
              ('Positional command-line arguments', 2, None, '___sec15'),
              ('Option-value pairs on the command line', 2, None, '___sec16'),
              ('Creating a graphical web user interface',
               2,
               None,
               '___sec17'),
              ('Making a compute function', 3, None, '___sec18'),
              ('Generating the user interface', 3, None, '___sec19'),
              ('Running the web application', 3, None, '___sec20'),
              ('Tests for verifying implementations', 1, None, '___sec21'),
              ('Doctests', 2, None, '___sec22'),
              ('Unit tests and test functions', 2, None, '___sec23'),
              ('Two Python test frameworks: nose and pytest',
               3,
               None,
               '___sec24'),
              ('Test function requirements', 3, None, '___sec25'),
              ('Comparison of real numbers', 3, None, '___sec26'),
              ('Special assert functions from nose', 3, None, '___sec27'),
              ('Locating test functions', 3, None, '___sec28'),
              ('Running tests', 3, None, '___sec29'),
              ('Embedding doctests in a test function', 3, None, '___sec30'),
              ('Installing nose and pytest', 3, None, '___sec31'),
              ('Test function for the solver', 2, None, '___sec32'),
              ('Test function for reading positional command-line arguments',
               2,
               None,
               '___sec33'),
              ('Test function for reading option-value pairs',
               2,
               None,
               '___sec34'),
              ('Classical class-based unit testing',
               2,
               'softeng1:basic:unittest',
               'softeng1:basic:unittest'),
              ('Sharing the software with other users',
               1,
               'softeng1:prog:se:git',
               'softeng1:prog:se:git'),
              ('Organizing the software directory tree', 2, None, '___sec37'),
              ('Distributing just a module file', 3, None, '___sec38'),
              ('Distributing a package', 3, None, '___sec39'),
              ('Publishing the software at GitHub', 2, None, '___sec40'),
              ('Downloading and installing the software',
               2,
               None,
               '___sec41'),
              ('Installing just a module file', 3, None, '___sec42'),
              ('Installing a package', 3, None, '___sec43'),
              ('Classes for problem and solution method',
               1,
               'softeng1:prog:se:class',
               'softeng1:prog:se:class'),
              ('The problem class', 2, None, '___sec45'),
              ('The solver class', 2, None, '___sec46'),
              ('Combining the objects', 3, None, '___sec47'),
              ('Improving the problem and solver classes',
               2,
               'softeng1:prog:se:class2',
               'softeng1:prog:se:class2'),
              ('A generic class for parameters', 3, None, '___sec49'),
              ('Automating scientific experiments',
               1,
               'softeng1:experiments',
               'softeng1:experiments'),
              ('Available software', 2, None, '___sec51'),
              ('The results we want to produce', 2, None, '___sec52'),
              ('Combining plot files', 2, None, '___sec53'),
              ('Running a program from Python', 2, None, '___sec54'),
              ('The automating script', 2, None, '___sec55'),
              ('Making a report',
               2,
               'softeng1:exper:report',
               'softeng1:exper:report'),
              ('Word, OpenOffice, GoogleDocs', 3, None, '___sec57'),
              ('HTML with MathJax', 3, None, '___sec58'),
              ('LaTeX', 3, None, '___sec59'),
              ('Sphinx', 3, None, '___sec60'),
              ('Markdown', 3, None, '___sec61'),
              ('IPython/Jupyter notebooks', 3, None, '___sec62'),
              ('Wiki formats', 3, None, '___sec63'),
              ('DocOnce', 3, None, '___sec64'),
              ('Publishing a complete project',
               2,
               'softeng1:exper:github',
               'softeng1:exper:github'),
              ('Exercises', 1, None, '___sec66'),
              ('Problem 1: Make a tool for differentiating curves',
               2,
               'softeng1:exer:derivative',
               'softeng1:exer:derivative'),
              ('Problem 2: Make solid software for the Trapezoidal rule',
               2,
               'softeng1:exer:integral:flat',
               'softeng1:exer:integral:flat'),
              ('Problem 3: Implement classes for the Trapezoidal rule',
               2,
               'softeng1:exer:integral:flat2',
               'softeng1:exer:integral:flat2'),
              ('Problem 4: Write a doctest and a test function',
               2,
               'softeng1:exer:doctest1',
               'softeng1:exer:doctest1'),
              ('Problem 5: Experiment with tolerances in comparisons',
               2,
               'softeng1:exer:tol',
               'softeng1:exer:tol'),
              ('Remarks', 3, None, '___sec72'),
              ('Exercise 6: Make use of a class implementation',
               2,
               'softeng1:exer:class:dts',
               'softeng1:exer:class:dts'),
              ('Exercise 7: Make solid software for a difference equation',
               2,
               'softeng1:exer:logistic',
               'softeng1:exer:logistic'),
              ('Bibliography', 1, None, '___sec75')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\tp}{\thinspace .}
$$




    
<a name="part0003"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._softeng-solarized002.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._softeng-solarized004.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="softeng1:basic:UI">User interfaces</h1>

<p>
It is good programming practice to let programs read input from
some <em>user interface</em>, rather than requiring users to <em>edit</em>
parameter values in the source code. With effective user interfaces
it becomes easier and safer to apply the code for scientific investigations and
in particular to automate large-scale investigations by other programs
(see the section <a href="._softeng-solarized007.html#softeng1:experiments">Automating scientific experiments</a>).

<p>
Reading input data can be done in many ways. We have to decide on the
functionality of the user interface, i.e., how we want to operate the
program when providing input. Thereafter, we use appropriate tools to
implement that particular user interface. There are four basic types
of user interface, listed here according to implementational
complexity, from lowest to highest:

<ol>
<li> Questions and answers in the terminal window</li>
<li> Command-line arguments</li>
<li> Reading data from files</li>
<li> Graphical user interfaces (GUIs)</li>
</ol>

Personal preferences of user interfaces differ substantially, and it is
difficult to present recommendations or pros and cons.
Alternatives 2 and 4 are most popular and will be addressed next.
The goal is to make it easy for the user to
set physical and numerical parameters in
our <code>decay.py</code> program. We use  a little toy program, called
<code>prog.py</code>, as introductory
example:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">delta = <span style="color: #B452CD">0.5</span>
p = <span style="color: #B452CD">2</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> exp
result = delta*exp(-p)
<span style="color: #8B008B; font-weight: bold">print</span> result
</pre></div>
<p>
The essential content is that <code>prog.py</code> has two input parameters: <code>delta</code>
and <code>p</code>. A user interface will replace the first two assignments to
<code>delta</code> and <code>p</code>.

<h2 id="___sec14">Command-line arguments </h2>

<p>
The command-line arguments are all the words that appear on the
command line after the program name. Running a program <code>prog.py</code>
as <code>python prog.py arg1 arg2</code> means that there are two command-line arguments
(separated by white space): <code>arg1</code> and <code>arg2</code>.
Python stores all command-line arguments in
a special list <code>sys.argv</code>. (The name <code>argv</code> stems from the C language and
stands for &quot;argument values&quot;. In C there is also an integer variable
called <code>argc</code> reflecting the number of arguments, or &quot;argument counter&quot;.
A lot of programming languages have adopted the variable name <code>argv</code> for
the command-line arguments.)
Here is an example on a
program <code>what_is_sys_argv.py</code> that can show us what the command-line arguments
are

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sys</span>
<span style="color: #8B008B; font-weight: bold">print</span> sys.argv
</pre></div>
<p>
A sample run goes like

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python what_is_sys_argv.py 5.0 &#39;two words&#39; -1E+4
[&#39;what_is_sys_argv.py&#39;, &#39;5.0&#39;, &#39;two words&#39;, &#39;-1E+4&#39;]
</pre></div>
<p>
We make two observations:

<ul>
 <li> <code>sys.argv[0]</code> is the name of the program,
   and the sublist <code>sys.argv[1:]</code> contains all the command-line arguments.</li>
 <li> Each command-line argument is available as a string. A conversion to
   <code>float</code> is necessary if we want to compute with the numbers 5.0 and
   \( 10^4 \).</li>
</ul>

There are, in principle, two ways of programming with
command-line arguments in Python:

<ul>
 <li> <b>Positional arguments:</b> Decide upon a sequence of parameters
   on the command line and read
   their values directly from the <code>sys.argv[1:]</code> list.</li>
 <li> <b>Option-value pairs:</b>  Use <code>--option value</code> on
   the command line to replace the default value of an input parameter
   <code>option</code> by <code>value</code> (and utilize the <code>argparse.ArgumentParser</code> tool
   for implementation).</li>
</ul>

Suppose we want to run some program <code>prog.py</code> with
specification of two parameters <code>p</code> and <code>delta</code> on the command line.
With positional command-line arguments we write

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python prog.py 2 0.5
</pre></div>
<p>
and must know that the first argument <code>2</code> represents <code>p</code> and the
next <code>0.5</code> is the value of <code>delta</code>.
With option-value pairs we can run

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python prog.py --delta 0.5 --p 2
</pre></div>
<p>
Now, both <code>p</code> and <code>delta</code> are supposed to have default values in the program,
so we need to specify only the parameter that is to be changed from
its default value, e.g.,

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python prog.py --p 2         # p=2, default delta
Terminal&gt; python prog.py --delta 0.7   # delta-0.7, default a
Terminal&gt; python prog.py               # default a and delta
</pre></div>
<p>
How do we extend the <code>prog.py</code> code for positional arguments
and option-value pairs? Positional arguments require very simple
code:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sys</span>
p = <span style="color: #658b00">float</span>(sys.argv[<span style="color: #B452CD">1</span>])
delta = <span style="color: #658b00">float</span>(sys.argv[<span style="color: #B452CD">2</span>])

<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> exp
result = delta*exp(-p)
<span style="color: #8B008B; font-weight: bold">print</span> result
</pre></div>
<p>
If the user forgets to supply two command-line arguments, Python will
raise an <code>IndexError</code> exception and produce a long error message.
To avoid that, we should use a <code>try-except</code> construction:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sys</span>
<span style="color: #8B008B; font-weight: bold">try</span>:
    p = <span style="color: #658b00">float</span>(sys.argv[<span style="color: #B452CD">1</span>])
    delta = <span style="color: #658b00">float</span>(sys.argv[<span style="color: #B452CD">2</span>])
<span style="color: #8B008B; font-weight: bold">except</span> <span style="color: #008b45; font-weight: bold">IndexError</span>:
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Usage: %s p delta&#39;</span> % sys.argv[<span style="color: #B452CD">0</span>]
    sys.exit(<span style="color: #B452CD">1</span>)

<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> exp
result = delta*exp(-p)
<span style="color: #8B008B; font-weight: bold">print</span> result
</pre></div>
<p>
Using <code>sys.exit(1)</code> aborts the program. The value 1 (actually any
value different from 0) notifies the operating system that the
program failed.

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Command-line arguments are strings!</b>
<p>
Note that all elements in <code>sys.argv</code> are string objects.
If the values will enter mathematical computations, we need
to explicitly convert the strings to numbers.
</div>


<p>
Option-value pairs requires more programming and is actually
better explained in a more comprehensive example below.
Minimal code for our <code>prog.py</code> program reads

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">argparse</span>
parser = argparse.ArgumentParser()
parser.add_argument(<span style="color: #CD5555">&#39;--p&#39;</span>, default=<span style="color: #B452CD">1.0</span>)
parser.add_argument(<span style="color: #CD5555">&#39;--delta&#39;</span>, default=<span style="color: #B452CD">0.1</span>)

args = parser.parse_args()
p = args.p
delta = args.delta

<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> exp
result = delta*exp(-p)
<span style="color: #8B008B; font-weight: bold">print</span> result
</pre></div>
<p>
Because the default values of <code>delta</code> and <code>p</code> are float numbers,
the <code>args.delta</code> and <code>args.p</code> variable are automatically of type <code>float</code>.

<p>
Our next task is to use these basic code constructs to equip our
<code>decay.py</code> module with command-line interfaces.

<h2 id="___sec15">Positional command-line arguments </h2>

<p>
For our <code>decay.py</code> module file, we want include functionality such
that we can read \( I \), \( a \), \( T \), \( \theta \), and a range of \( \Delta t \)
values from the command line.  A plot is then to be made, comparing
the different numerical solutions for different \( \Delta t \) values
against the exact solution. The technical details of getting the
command-line information into the program is covered in the next
two sections.

<p>
The simplest way of reading the input parameters is to
decide on their sequence on the command line and just index
the <code>sys.argv</code> list accordingly.
Say the sequence of input data for some functionality in
<code>decay.py</code> is \( I \), \( a \), \( T \), \( \theta \) followed by an
arbitrary number of \( \Delta t \) values. This code extracts
these <em>positional</em> command-line arguments:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">read_command_line_positional</span>():
    <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">len</span>(sys.argv) &lt; <span style="color: #B452CD">6</span>:
        <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Usage: %s I a T on/off BE/FE/CN dt1 dt2 dt3 ...&#39;</span> % \ 
              sys.argv[<span style="color: #B452CD">0</span>]; sys.exit(<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># abort</span>

    I = <span style="color: #658b00">float</span>(sys.argv[<span style="color: #B452CD">1</span>])
    a = <span style="color: #658b00">float</span>(sys.argv[<span style="color: #B452CD">2</span>])
    T = <span style="color: #658b00">float</span>(sys.argv[<span style="color: #B452CD">3</span>])
    theta = <span style="color: #658b00">float</span>(sys.argv[<span style="color: #B452CD">4</span>])
    dt_values = [<span style="color: #658b00">float</span>(arg) <span style="color: #8B008B; font-weight: bold">for</span> arg <span style="color: #8B008B">in</span> sys.argv[<span style="color: #B452CD">5</span>:]]

    <span style="color: #8B008B; font-weight: bold">return</span> I, a, T, theta, dt_values
</pre></div>
<p>
Note that we may use a <code>try-except</code> construction instead of the if test.

<p>
A run like

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay.py 1 0.5 4 0.5 1.5 0.75 0.1
</pre></div>
<p>
results in

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">sys.argv = [<span style="color: #CD5555">&#39;decay.py&#39;</span>, <span style="color: #CD5555">&#39;1&#39;</span>, <span style="color: #CD5555">&#39;0.5&#39;</span>, <span style="color: #CD5555">&#39;4&#39;</span>, <span style="color: #CD5555">&#39;0.5&#39;</span>, <span style="color: #CD5555">&#39;1.5&#39;</span>, <span style="color: #CD5555">&#39;0.75&#39;</span>, <span style="color: #CD5555">&#39;0.1&#39;</span>]
</pre></div>
<p>
and consequently the assignments <code>I=1.0</code>, <code>a=0.5</code>, <code>T=4.0</code>, <code>thet=0.5</code>,
and <code>dt_values = [1.5, 0.75, 0.1]</code>.

<p>
Instead of specifying the \( \theta \) value, we could be a bit more
sophisticated and let the user write the name of the scheme:
<code>BE</code> for Backward Euler, <code>FE</code> for Forward Euler, and <code>CN</code>
for Crank-Nicolson. Then we must map this string to the proper
\( \theta \) value, an operation elegantly done by a dictionary:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">scheme = sys.argv[<span style="color: #B452CD">4</span>]
scheme2theta = {<span style="color: #CD5555">&#39;BE&#39;</span>: <span style="color: #B452CD">1</span>, <span style="color: #CD5555">&#39;CN&#39;</span>: <span style="color: #B452CD">0.5</span>, <span style="color: #CD5555">&#39;FE&#39;</span>: <span style="color: #B452CD">0</span>}
<span style="color: #8B008B; font-weight: bold">if</span> scheme <span style="color: #8B008B">in</span> scheme2theta:
    theta = scheme2theta[scheme]
<span style="color: #8B008B; font-weight: bold">else</span>:
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Invalid scheme name:&#39;</span>, scheme; sys.exit(<span style="color: #B452CD">1</span>)
</pre></div>
<p>
Now we can do

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay.py 1 0.5 4 CN 1.5 0.75 0.1
</pre></div>
<p>
and get `theta=0.5`in the code.

<h2 id="___sec16">Option-value pairs on the command line </h2>

<p>
Now we want to specify option-value pairs on the command line,
using <code>--I</code> for <code>I</code> (\( I \)), <code>--a</code> for <code>a</code> (\( a \)), <code>--T</code> for <code>T</code> (\( T \)),
<code>--scheme</code> for the scheme name (<code>BE</code>, <code>FE</code>, <code>CN</code>),
and <code>--dt</code> for the sequence of <code>dt</code> (\( \Delta t \)) values.
Each parameter must have a sensible default value so
that we specify the option on the command line only when the default
value is not suitable. Here is a typical run:

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay.py --I 2.5 --dt 0.1 0.2 0.01 --a 0.4
</pre></div>
<p>
Observe the major advantage over positional command-line arguments:
the input is much easier to read and much easier to write.
With positional arguments it is easy to mess up the sequence of
the input parameters and quite challenging to detect errors too,
unless there are just a couple of arguments.

<p>
Python's <code>ArgumentParser</code> tool in the <code>argparse</code> module makes it easy
to create a professional command-line interface to any program. The
documentation of <a href="http://docs.python.org/library/argparse.html" target="_self"><tt>ArgumentParser</tt></a> demonstrates its
versatile applications, so we shall here just list an example
containing the most basic features. It always pays off to use <code>ArgumentParser</code>
rather than trying to manually inspect and interpret option-value pairs
in <code>sys.argv</code>!

<p>
The use of <code>ArgumentParser</code> typically involves three steps:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">argparse</span>
parser = argparse.ArgumentParser()

<span style="color: #228B22"># Step 1: add arguments</span>
parser.add_argument(<span style="color: #CD5555">&#39;--option_name&#39;</span>, ...)

<span style="color: #228B22"># Step 2: interpret the command line</span>
args = parser.parse_args()

<span style="color: #228B22"># Step 3: extract values</span>
value = args.option_name
</pre></div>
<p>
A function for setting up all the options is handy:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">define_command_line_options</span>():
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">argparse</span>
    parser = argparse.ArgumentParser()
    parser.add_argument(
        <span style="color: #CD5555">&#39;--I&#39;</span>, <span style="color: #CD5555">&#39;--initial_condition&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>,
        default=<span style="color: #B452CD">1.0</span>, help=<span style="color: #CD5555">&#39;initial condition, u(0)&#39;</span>,
        metavar=<span style="color: #CD5555">&#39;I&#39;</span>)
    parser.add_argument(
        <span style="color: #CD5555">&#39;--a&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">1.0</span>,
        help=<span style="color: #CD5555">&#39;coefficient in ODE&#39;</span>, metavar=<span style="color: #CD5555">&#39;a&#39;</span>)
    parser.add_argument(
        <span style="color: #CD5555">&#39;--T&#39;</span>, <span style="color: #CD5555">&#39;--stop_time&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>,
        default=<span style="color: #B452CD">1.0</span>, help=<span style="color: #CD5555">&#39;end time of simulation&#39;</span>,
        metavar=<span style="color: #CD5555">&#39;T&#39;</span>)
    parser.add_argument(
        <span style="color: #CD5555">&#39;--scheme&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">str</span>, default=<span style="color: #CD5555">&#39;CN&#39;</span>,
        help=<span style="color: #CD5555">&#39;FE, BE, or CN&#39;</span>)
    parser.add_argument(
        <span style="color: #CD5555">&#39;--dt&#39;</span>, <span style="color: #CD5555">&#39;--time_step_values&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>,
        default=[<span style="color: #B452CD">1.0</span>], help=<span style="color: #CD5555">&#39;time step values&#39;</span>,
        metavar=<span style="color: #CD5555">&#39;dt&#39;</span>, nargs=<span style="color: #CD5555">&#39;+&#39;</span>, dest=<span style="color: #CD5555">&#39;dt_values&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">return</span> parser
</pre></div>
<p>
Each command-line option is defined through the <code>parser.add_argument</code>
method [<a id="link_footnote_1" href="#def_footnote_1">1</a>]. Alternative options, like the short <code>--I</code> and the more
explaining version <code>--initial_condition</code> can be defined. Other arguments
are <code>type</code> for the Python object type, a default value, and a help
string, which gets printed if the command-line argument <code>-h</code> or <code>--help</code> is
included. The <code>metavar</code> argument specifies the value associated with
the option when the help string is printed. For example, the option for
\( I \) has this help output:

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay.py -h
  ...
  --I I, --initial_condition I
                        initial condition, u(0)
  ...
</pre></div>
<p>
The structure of this output is

<p>

<!-- code=text typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">  --I metavar, --initial_condition metavar
                        help-string
</pre></div>
<p id="def_footnote_1"><a href="#link_footnote_1"><b>1:</b></a> We use the expression <em>method</em> here, because <code>parser</code>
is a class variable and functions in classes are known as methods in Python
and many other languages.
Readers not familiar with class programming can just substitute
this use of <em>method</em> by <em>function</em>.</p>

<p>
Finally, the <code>--dt</code> option demonstrates how to allow for more than one
value (separated by blanks) through the <code>nargs='+'</code> keyword argument.
After the command line is parsed, we get an object where the values of
the options are stored as attributes. The attribute name is specified
by the <code>dist</code> keyword argument, which for the <code>--dt</code> option is
<code>dt_values</code>. Without the <code>dest</code> argument, the value of an option <code>--opt</code>
is stored as the attribute <code>opt</code>.

<p>
The code below demonstrates how to read the command line and extract
the values for each option:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">read_command_line_argparse</span>():
    parser = define_command_line_options()
    args = parser.parse_args()
    scheme2theta = {<span style="color: #CD5555">&#39;BE&#39;</span>: <span style="color: #B452CD">1</span>, <span style="color: #CD5555">&#39;CN&#39;</span>: <span style="color: #B452CD">0.5</span>, <span style="color: #CD5555">&#39;FE&#39;</span>: <span style="color: #B452CD">0</span>}
    data = (args.I, args.a, args.T, scheme2theta[args.scheme],
            args.dt_values)
    <span style="color: #8B008B; font-weight: bold">return</span> data
</pre></div>
<p>
As seen, the values of the command-line options are available as
attributes in <code>args</code>: <code>args.opt</code> holds the value of option <code>--opt</code>, unless
we used the <code>dest</code> argument (as for <code>--dt_values</code>) for specifying the
attribute name. The <code>args.opt</code> attribute has the object type specified
by <code>type</code> (<code>str</code> by default).

<p>
The making of the plot is not dependent on whether we read data from
the command line as positional arguments or option-value pairs:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">experiment_compare_dt</span>(option_value_pairs=<span style="color: #658b00">False</span>):
    I, a, T, theta, dt_values = \ 
       read_command_line_argparse() <span style="color: #8B008B; font-weight: bold">if</span> option_value_pairs <span style="color: #8B008B; font-weight: bold">else</span> \ 
       read_command_line_positional()

    legends = []
    <span style="color: #8B008B; font-weight: bold">for</span> dt <span style="color: #8B008B">in</span> dt_values:
        u, t = solver(I, a, T, dt, theta)
        plt.plot(t, u)
        legends.append(<span style="color: #CD5555">&#39;dt=%g&#39;</span> % dt)
    t_e = np.linspace(<span style="color: #B452CD">0</span>, T, <span style="color: #B452CD">1001</span>)       <span style="color: #228B22"># very fine mesh for u_e</span>
    u_e = exact_solution(t_e, I, a)
    plt.plot(t_e, u_e, <span style="color: #CD5555">&#39;--&#39;</span>)
    legends.append(<span style="color: #CD5555">&#39;exact&#39;</span>)
    plt.legend(legends, loc=<span style="color: #CD5555">&#39;upper right&#39;</span>)
    plt.title(<span style="color: #CD5555">&#39;theta=%g&#39;</span> % theta)
    plotfile = <span style="color: #CD5555">&#39;tmp&#39;</span>
    plt.savefig(plotfile + <span style="color: #CD5555">&#39;.png&#39;</span>);  plt.savefig(plotfile + <span style="color: #CD5555">&#39;.pdf&#39;</span>)
</pre></div>

<h2 id="___sec17">Creating a graphical web user interface </h2>

<p>
The Python package <a href="https://github.com/hplgit/parampool" target="_self">Parampool</a>
can be used to automatically generate a web-based <em>graphical user interface</em>
(GUI) for our simulation program. Although the programming technique
dramatically simplifies the efforts to create a GUI, the forthcoming
material on equipping our <code>decay</code> module with a GUI is quite technical
and of significantly less importance than knowing how to make
a command-line interface.

<h3 id="___sec18">Making a compute function </h3>

<p>
The first step is to identify a function
that performs the computations and that takes the necessary input
variables as arguments. This is called the <em>compute function</em> in
Parampool terminology. The purpose of this function is to take
values of \( I \), \( a \), \( T \) together with a sequence of \( \Delta t \) values
and a sequence of \( \theta \) and plot the numerical against the
exact solution for each pair of \( (\theta, \Delta t) \).
The plots can be arranged as a table with the columns being scheme type
(\( \theta \) value) and the rows reflecting the discretization parameter
(\( \Delta t \) value). Figure <a href="#softeng1:fig:GUI">3</a> displays what the
graphical web interface may look like after results are computed
(there are \( 3\times 3 \) plots in the GUI, but only \( 2\times 2 \) are
visible in the figure).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Automatically generated graphical web interface. <div id="softeng1:fig:GUI"></div> </p></center>
<p><img src="fig-softeng/web_GUI.png" align="bottom" width=800></p>
</center>

<p>
To tell Parampool what type of input data we have,
we assign default values of the right type to all arguments in the
compute function, here called <code>main_GUI</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">main_GUI</span>(I=<span style="color: #B452CD">1.0</span>, a=.<span style="color: #B452CD">2</span>, T=<span style="color: #B452CD">4.0</span>,
             dt_values=[<span style="color: #B452CD">1.25</span>, <span style="color: #B452CD">0.75</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">0.1</span>],
             theta_values=[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1</span>]):
</pre></div>
<p>
The compute function must return the HTML code we want for displaying
the result in a web page. Here we want to show a
table of plots.
Assume for now that the HTML code for one plot and the value of the
norm of the error can be computed by some other function <code>compute4web</code>.
The <code>main_GUI</code> function can then loop over \( \Delta t \) and \( \theta \)
values and put each plot in an HTML table. Appropriate code goes like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">main_GUI</span>(I=<span style="color: #B452CD">1.0</span>, a=.<span style="color: #B452CD">2</span>, T=<span style="color: #B452CD">4.0</span>,
             dt_values=[<span style="color: #B452CD">1.25</span>, <span style="color: #B452CD">0.75</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">0.1</span>],
             theta_values=[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1</span>]):
    <span style="color: #228B22"># Build HTML code for web page. Arrange plots in columns</span>
    <span style="color: #228B22"># corresponding to the theta values, with dt down the rows</span>
    theta2name = {<span style="color: #B452CD">0</span>: <span style="color: #CD5555">&#39;FE&#39;</span>, <span style="color: #B452CD">1</span>: <span style="color: #CD5555">&#39;BE&#39;</span>, <span style="color: #B452CD">0.5</span>: <span style="color: #CD5555">&#39;CN&#39;</span>}
    html_text = <span style="color: #CD5555">&#39;&lt;table&gt;\n&#39;</span>
    <span style="color: #8B008B; font-weight: bold">for</span> dt <span style="color: #8B008B">in</span> dt_values:
        html_text += <span style="color: #CD5555">&#39;&lt;tr&gt;\n&#39;</span>
        <span style="color: #8B008B; font-weight: bold">for</span> theta <span style="color: #8B008B">in</span> theta_values:
            E, html = compute4web(I, a, T, dt, theta)
            html_text += <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">&lt;td&gt;</span>
<span style="color: #CD5555">&lt;center&gt;&lt;b&gt;%s, dt=%g, error: %.3E&lt;/b&gt;&lt;/center&gt;&lt;br&gt;</span>
<span style="color: #CD5555">%s</span>
<span style="color: #CD5555">&lt;/td&gt;</span>
<span style="color: #CD5555">&quot;&quot;&quot;</span> % (theta2name[theta], dt, E, html)
        html_text += <span style="color: #CD5555">&#39;&lt;/tr&gt;\n&#39;</span>
    html_text += <span style="color: #CD5555">&#39;&lt;/table&gt;\n&#39;</span>
    <span style="color: #8B008B; font-weight: bold">return</span> html_text
</pre></div>
<p>
Making one plot is done in <code>compute4web</code>. The statements should be
straightforward from earlier examples, but there is one new feature:
we use a tool in Parampool to embed the PNG code for a plot file
directly in an HTML image tag. The details are hidden from the
programmer, who can just rely on
relevant HTML code in the string <code>html_text</code>. The function looks like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">compute4web</span>(I, a, T, dt, theta=<span style="color: #B452CD">0.5</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Run a case with the solver, compute error measure,</span>
<span style="color: #CD5555">    and plot the numerical and exact solutions in a PNG</span>
<span style="color: #CD5555">    plot whose data are embedded in an HTML image tag.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    u, t = solver(I, a, T, dt, theta)
    u_e = exact_solution(t, I, a)
    e = u_e - u
    E = np.sqrt(dt*np.sum(e**<span style="color: #B452CD">2</span>))

    plt.figure()
    t_e = np.linspace(<span style="color: #B452CD">0</span>, T, <span style="color: #B452CD">1001</span>)    <span style="color: #228B22"># fine mesh for u_e</span>
    u_e = exact_solution(t_e, I, a)
    plt.plot(t,   u,   <span style="color: #CD5555">&#39;r--o&#39;</span>)
    plt.plot(t_e, u_e, <span style="color: #CD5555">&#39;b-&#39;</span>)
    plt.legend([<span style="color: #CD5555">&#39;numerical&#39;</span>, <span style="color: #CD5555">&#39;exact&#39;</span>])
    plt.xlabel(<span style="color: #CD5555">&#39;t&#39;</span>)
    plt.ylabel(<span style="color: #CD5555">&#39;u&#39;</span>)
    plt.title(<span style="color: #CD5555">&#39;theta=%g, dt=%g&#39;</span> % (theta, dt))
    <span style="color: #228B22"># Save plot to HTML img tag with PNG code as embedded data</span>
    <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">parampool.utils</span> <span style="color: #8B008B; font-weight: bold">import</span> save_png_to_str
    html_text = save_png_to_str(plt, plotwidth=<span style="color: #B452CD">400</span>)

    <span style="color: #8B008B; font-weight: bold">return</span> E, html_text
</pre></div>

<h3 id="___sec19">Generating the user interface </h3>

<p>
The web GUI is automatically generated by
the following code, placed in the file <a href="http://tinyurl.com/ofkw6kc/softeng/decay_GUI_generate.py" target="_self"><tt>decay_GUI_generate.py</tt></a>.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">parampool.generator.flask</span> <span style="color: #8B008B; font-weight: bold">import</span> generate
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">decay</span> <span style="color: #8B008B; font-weight: bold">import</span> main_GUI
generate(main_GUI,
         filename_controller=<span style="color: #CD5555">&#39;decay_GUI_controller.py&#39;</span>,
         filename_template=<span style="color: #CD5555">&#39;decay_GUI_view.py&#39;</span>,
         filename_model=<span style="color: #CD5555">&#39;decay_GUI_model.py&#39;</span>)
</pre></div>
<p>
Running the <code>decay_GUI_generate.py</code> program results in three new
files whose names are specified in the call to <code>generate</code>:

<ol>
 <li> <code>decay_GUI_model.py</code> defines HTML widgets to be used to set
    input data in the web interface,</li>
 <li> <code>templates/decay_GUI_views.py</code> defines the layout of the web page,</li>
 <li> <code>decay_GUI_controller.py</code> runs the web application.</li>
</ol>

We only need to run the last program, and there is no need to look into
these files.

<h3 id="___sec20">Running the web application </h3>

<p>
The web GUI is started by

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay_GUI_controller.py
</pre></div>
<p>
Open a web browser at the location <code>127.0.0.1:5000</code>. Input fields for
<code>I</code>, <code>a</code>, <code>T</code>, <code>dt_values</code>, and <code>theta_values</code> are presented.  Figure
<a href="#softeng1:fig:GUI">3</a> shows a part of the resulting page if we run
with the default values for the input parameters.
With the techniques demonstrated here, one can
easily create a tailored web GUI for a particular type of application
and use it to interactively explore physical and numerical effects.

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._softeng-solarized002.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._softeng-solarized004.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

