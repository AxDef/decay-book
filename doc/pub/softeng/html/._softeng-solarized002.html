<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Software engineering with exponential decay models">
<meta name="keywords" content="refactoring,importing modules,list comprehension,command-line arguments,option-value pairs (command line),command-line arguments,reading the command line,doctests,software testing doctests,unit testing,software testing nose,software testing pytest,test function,software testing test function,doctest in test function,unit testing,software testing unit testing (class-based),Distutils,GitHub,importing modules,problem class,solver class,wrapper (code),reproducibility,replicability,Unix wildcard notation,wildcard notation (Unix),Word (Microsoft),LibreOffice,OpenOffice,Google Docs,HTML,MathJax,LaTeX,Sphinx (typesetting tool),Markdown,IPython notebooks,Jupyter notebooks,DocOnce,replicability">

<title>Software engineering with exponential decay models</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Basic implementations',
               1,
               'softeng1:basic',
               'softeng1:basic'),
              ('Mathematical problem and solution technique',
               2,
               'softeng1:basic:math',
               'softeng1:basic:math'),
              ('A first, quick implementation',
               2,
               'softeng1:basic:impl1',
               'softeng1:basic:impl1'),
              ('A more decent program',
               2,
               'softeng1:basic:impl2',
               'softeng1:basic:impl2'),
              ('Comments in a program', 3, None, '___sec4'),
              ('Refactoring into functions', 3, None, '___sec5'),
              ('Program file vs IDE vs notebook', 3, None, '___sec6'),
              ('Prefixing imported functions by the module name',
               2,
               'softeng1:basic:modprefix',
               'softeng1:basic:modprefix'),
              ('Implementing the numerical algorithm in a function',
               2,
               'softeng1:basic:func',
               'softeng1:basic:func'),
              ('Do not have several versions of a code', 2, None, '___sec9'),
              ('Making a module',
               2,
               'softeng1:basic:module',
               'softeng1:basic:module'),
              ('Example on extending the module code',
               2,
               'softeng1:basic:experiment2',
               'softeng1:basic:experiment2'),
              ('Documenting functions and modules',
               2,
               'softeng1:basic:docstring',
               'softeng1:basic:docstring'),
              ('User interfaces',
               1,
               'softeng1:basic:UI',
               'softeng1:basic:UI'),
              ('Command-line arguments', 2, None, '___sec14'),
              ('Positional command-line arguments', 2, None, '___sec15'),
              ('Option-value pairs on the command line', 2, None, '___sec16'),
              ('Creating a graphical web user interface',
               2,
               None,
               '___sec17'),
              ('Making a compute function', 3, None, '___sec18'),
              ('Generating the user interface', 3, None, '___sec19'),
              ('Running the web application', 3, None, '___sec20'),
              ('Tests for verifying implementations', 1, None, '___sec21'),
              ('Doctests', 2, None, '___sec22'),
              ('Unit tests and test functions', 2, None, '___sec23'),
              ('Two Python test frameworks: nose and pytest',
               3,
               None,
               '___sec24'),
              ('Test function requirements', 3, None, '___sec25'),
              ('Comparison of real numbers', 3, None, '___sec26'),
              ('Special assert functions from nose', 3, None, '___sec27'),
              ('Locating test functions', 3, None, '___sec28'),
              ('Running tests', 3, None, '___sec29'),
              ('Embedding doctests in a test function', 3, None, '___sec30'),
              ('Installing nose and pytest', 3, None, '___sec31'),
              ('Test function for the solver', 2, None, '___sec32'),
              ('Test function for reading positional command-line arguments',
               2,
               None,
               '___sec33'),
              ('Test function for reading option-value pairs',
               2,
               None,
               '___sec34'),
              ('Classical class-based unit testing',
               2,
               'softeng1:basic:unittest',
               'softeng1:basic:unittest'),
              ('Sharing the software with other users',
               1,
               'softeng1:prog:se:git',
               'softeng1:prog:se:git'),
              ('Organizing the software directory tree', 2, None, '___sec37'),
              ('Distributing just a module file', 3, None, '___sec38'),
              ('Distributing a package', 3, None, '___sec39'),
              ('Publishing the software at GitHub', 2, None, '___sec40'),
              ('Downloading and installing the software',
               2,
               None,
               '___sec41'),
              ('Installing just a module file', 3, None, '___sec42'),
              ('Installing a package', 3, None, '___sec43'),
              ('Classes for problem and solution method',
               1,
               'softeng1:prog:se:class',
               'softeng1:prog:se:class'),
              ('The problem class', 2, None, '___sec45'),
              ('The solver class', 2, None, '___sec46'),
              ('Combining the objects', 3, None, '___sec47'),
              ('Improving the problem and solver classes',
               2,
               'softeng1:prog:se:class2',
               'softeng1:prog:se:class2'),
              ('A generic class for parameters', 3, None, '___sec49'),
              ('Automating scientific experiments',
               1,
               'softeng1:experiments',
               'softeng1:experiments'),
              ('Available software', 2, None, '___sec51'),
              ('The results we want to produce', 2, None, '___sec52'),
              ('Combining plot files', 2, None, '___sec53'),
              ('Running a program from Python', 2, None, '___sec54'),
              ('The automating script', 2, None, '___sec55'),
              ('Making a report',
               2,
               'softeng1:exper:report',
               'softeng1:exper:report'),
              ('Word, OpenOffice, GoogleDocs', 3, None, '___sec57'),
              ('HTML with MathJax', 3, None, '___sec58'),
              ('LaTeX', 3, None, '___sec59'),
              ('Sphinx', 3, None, '___sec60'),
              ('Markdown', 3, None, '___sec61'),
              ('IPython/Jupyter notebooks', 3, None, '___sec62'),
              ('Wiki formats', 3, None, '___sec63'),
              ('DocOnce', 3, None, '___sec64'),
              ('Publishing a complete project',
               2,
               'softeng1:exper:github',
               'softeng1:exper:github'),
              ('Exercises', 1, None, '___sec66'),
              ('Problem 1: Make a tool for differentiating curves',
               2,
               'softeng1:exer:derivative',
               'softeng1:exer:derivative'),
              ('Problem 2: Make solid software for the Trapezoidal rule',
               2,
               'softeng1:exer:integral:flat',
               'softeng1:exer:integral:flat'),
              ('Problem 3: Implement classes for the Trapezoidal rule',
               2,
               'softeng1:exer:integral:flat2',
               'softeng1:exer:integral:flat2'),
              ('Problem 4: Write a doctest and a test function',
               2,
               'softeng1:exer:doctest1',
               'softeng1:exer:doctest1'),
              ('Problem 5: Experiment with tolerances in comparisons',
               2,
               'softeng1:exer:tol',
               'softeng1:exer:tol'),
              ('Remarks', 3, None, '___sec72'),
              ('Exercise 6: Make use of a class implementation',
               2,
               'softeng1:exer:class:dts',
               'softeng1:exer:class:dts'),
              ('Exercise 7: Make solid software for a difference equation',
               2,
               'softeng1:exer:logistic',
               'softeng1:exer:logistic'),
              ('Bibliography', 1, None, '___sec75')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\tp}{\thinspace .}
$$




    
<a name="part0002"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._softeng-solarized001.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._softeng-solarized003.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="softeng1:basic">Basic implementations</h1>

<p>
All previous examples in this book have implemented numerical
algorithms as Python functions. This is a good style that readers
are expected to adopt. However, this author has experienced that
many students and engineers are inclined to make &quot;flat&quot; programs,
i.e., a sequence of statements without any use of functions, just to
get the problem solved as quickly as possible. Since this programming
style is so widespread, especially among people with MATLAB experience,
we shall look at the weaknesses of flat programs and show how they
can be <em>refactored</em> into more reusable programs based on functions.

<h2 id="softeng1:basic:math">Mathematical problem and solution technique</h2>

<p>
We address the differential equation problem

$$
\begin{align}
u'(t) &= -au(t), \quad t \in (0,T], \tag{1}\\ 
u(0)  &= I,                         \tag{2}
\end{align}
$$

where \( a \), \( I \), and \( T \) are prescribed parameters, and \( u(t) \) is
the unknown function to be estimated. This mathematical model
is relevant for physical phenomena featuring exponential decay
in time, e.g., vertical pressure variation in the atmosphere,
cooling of an object, and radioactive decay.

<p>
The
time domain is discretized with points \( 0 = t_0 < t_1 \cdots < t_{N_t}=T \),
here with a constant spacing \( \Delta t \) between the
mesh points: \( \Delta t = t_{n}-t_{n-1} \), \( n=1,\ldots,N_t \). Let
\( u^n \) be the numerical approximation to the exact solution at \( t_n \).
A family of popular numerical methods are provided by the \( \theta \) scheme,

$$
\begin{equation}
u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,
\tag{3}
\end{equation}
$$

for \( n=0,1,\ldots,N_t-1 \). This formula produces
the Forward Euler
scheme when \( \theta=0 \),
the Backward Euler
scheme when \( \theta=1 \),
and the Crank-Nicolson
scheme when \( \theta=1/2 \).

<h2 id="softeng1:basic:impl1">A first, quick implementation</h2>

<p>
Solving <a href="#mjx-eqn-3">(3)</a> in a program is very straightforward:
just make a loop over \( n \) and evaluate the formula. The \( u(t_n \))
values for discrete \( n \) can be stored in an array. This makes it easy
to also plot the solution. It would be natural to also add
the exact
solution curve \( u(t)=Ie^{-at} \) to the plot.

<p>
Many have programming habits that would lead them
to write a simple program like this:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">import</span> *

A = <span style="color: #B452CD">1</span>
a = <span style="color: #B452CD">2</span>
T = <span style="color: #B452CD">4</span>
dt = <span style="color: #B452CD">0.2</span>
N = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))
y = zeros(N+<span style="color: #B452CD">1</span>)
t = linspace(<span style="color: #B452CD">0</span>, T, N+<span style="color: #B452CD">1</span>)
theta = <span style="color: #B452CD">1</span>
y[<span style="color: #B452CD">0</span>] = A
<span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, N):
    y[n+<span style="color: #B452CD">1</span>] = (<span style="color: #B452CD">1</span> - (<span style="color: #B452CD">1</span>-theta)*a*dt)/(<span style="color: #B452CD">1</span> + theta*dt*a)*y[n]

y_e = A*exp(-a*t) - y
error = y_e - y
E = sqrt(dt*<span style="color: #658b00">sum</span>(error**<span style="color: #B452CD">2</span>))
<span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Norm of the error: %.3E&#39;</span> % E
plot(t, y, <span style="color: #CD5555">&#39;r--o&#39;</span>)
t_e = linspace(<span style="color: #B452CD">0</span>, T, <span style="color: #B452CD">1001</span>)
y_e = A*exp(-a*t_e)
plot(t_e, y_e, <span style="color: #CD5555">&#39;b-&#39;</span>)
legend([<span style="color: #CD5555">&#39;numerical, theta=%g&#39;</span> % theta, <span style="color: #CD5555">&#39;exact&#39;</span>])
xlabel(<span style="color: #CD5555">&#39;t&#39;</span>)
ylabel(<span style="color: #CD5555">&#39;y&#39;</span>)
show()
</pre></div>
<p>
This program is easy to read, and as long it is correct, many will
claim that it has sufficient quality. Nevertheless, the program suffers
from two serious flaws:

<ol>
<li> The notation in the program does not correspond <em>exactly</em> to
   the notation in the mathematical problem: the solution is called
   <code>y</code> and corresponds to \( u \) in the mathematical description,
   the variable <code>A</code> corresponds to the mathematical parameter \( I \),
   <code>N</code> in the program is called \( N_t \) in the mathematics.</li>
<li> There are no comments in the program.</li>
</ol>

These kind of flaws quickly become crucial if present in code for complicated
mathematical problems and code that is meant to be extended to other problems.

<p>
We also note that the program is <em>flat</em> in the sense that it does
not contain functions. Usually, this is a bad habit, but let us
first correct the two mentioned flaws.

<h2 id="softeng1:basic:impl2">A more decent program</h2>

<p>
A code of better quality arises from
fixing the notation and adding comments:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">import</span> *

I = <span style="color: #B452CD">1</span>
a = <span style="color: #B452CD">2</span>
T = <span style="color: #B452CD">4</span>
dt = <span style="color: #B452CD">0.2</span>
Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))     <span style="color: #228B22"># no of time intervals</span>
u = zeros(Nt+<span style="color: #B452CD">1</span>)           <span style="color: #228B22"># array of u[n] values</span>
t = linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># time mesh</span>
theta = <span style="color: #B452CD">1</span>                 <span style="color: #228B22"># Backward Euler method</span>

u[<span style="color: #B452CD">0</span>] = I                  <span style="color: #228B22"># assign initial condition</span>
<span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):    <span style="color: #228B22"># n=0,1,...,Nt-1</span>
    u[n+<span style="color: #B452CD">1</span>] = (<span style="color: #B452CD">1</span> - (<span style="color: #B452CD">1</span>-theta)*a*dt)/(<span style="color: #B452CD">1</span> + theta*dt*a)*u[n]

<span style="color: #228B22"># Compute norm of the error</span>
u_e = I*exp(-a*t) - u     <span style="color: #228B22"># exact u at the mesh points</span>
error = u_e - u
E = sqrt(dt*<span style="color: #658b00">sum</span>(error**<span style="color: #B452CD">2</span>))
<span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Norm of the error: %.3E&#39;</span> % E

<span style="color: #228B22"># Compare numerical (u) and exact solution (u_e) in a plot</span>
plot(t, u, <span style="color: #CD5555">&#39;r--o&#39;</span>)
t_e = linspace(<span style="color: #B452CD">0</span>, T, <span style="color: #B452CD">1001</span>)       <span style="color: #228B22"># very fine mesh for u_e</span>
u_e = I*exp(-a*t_e)
plot(t_e, u_e, <span style="color: #CD5555">&#39;b-&#39;</span>)
legend([<span style="color: #CD5555">&#39;numerical, theta=%g&#39;</span> % theta, <span style="color: #CD5555">&#39;exact&#39;</span>])
xlabel(<span style="color: #CD5555">&#39;t&#39;</span>)
ylabel(<span style="color: #CD5555">&#39;u&#39;</span>)
show()
</pre></div>

<h3 id="___sec4">Comments in a program </h3>

<p>
There is obviously not just one way to comment a program, and opinions
may differ as to what code should be accomplished by comments.
The guiding principle is, however, that comments should make the
program easy to understand for human eye. Do not comment obvious
constructions, but focus on ideas and (&quot;what happens in the next
statements?&quot;) and on explaining code that can be interpreted as
complicated.

<h3 id="___sec5">Refactoring into functions </h3>

<p>
At first sight, our updated program seems like
a good starting point for playing around
with the mathematical problem: we can just change parameters and rerun.
Although such edit-and-rerun sessions are good for initial exploration,
one will soon extend the experiments and start developing the code
further. Say we want to compare \( \theta =0,1,0.5 \) in the same
plot. This extension requires changes all over the code and quickly
leads to errors. To do something serious with this program, we have to
break it into smaller pieces and make sure each piece is well tested,
and ensure that the program is sufficiently general and can be reused in
new contexts without changes.  The
next natural step is therefore to isolate the numerical computations
and the visualization in separate Python functions.
Such a rewrite of a code, without essentially changing the functionality,
but just improve the quality of the code, is known as <em>refactoring</em>.
After one has quickly put some code down and tested it, it is a common
step to refactor it so it is better prepared for extensions.

<h3 id="___sec6">Program file vs IDE vs notebook </h3>

<p>
There are basically three different ways of working with Python code:

<ol>
<li> One writes the code in a file, using a text editor (such as
   Emacs or Vim) and runs it in a terminal window.</li>
<li> One applies an <em>Integrated Development Environment</em> (the simplest is IDLE, which comes with standard Python) containing a graphical user interface with an editor and an element where Python code can be run.</li>
<li> One applies the Jupyter Notebook (previously known as IPython Notebook),
   which offers an interactive environment for Python code where
   plots are automatically inserted after the code, see Figure <a href="#softeng1:ipynb">1</a>.</li>
</ol>

It appears that method 1 and 2 are quite equivalent, but the notebook
encourages more experimental code and therefore also flat programs.
Consequently, notebook users will normally need to think more about
refactoring code and increase the use of functions after initial
experimentation.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Experimental code in a notebook. <div id="softeng1:ipynb"></div> </p></center>
<p><img src="fig-softeng/ipynb_flat.png" align="bottom" width=700></p>
</center>

<h2 id="softeng1:basic:modprefix">Prefixing imported functions by the module name</h2>

<p>
Import statements of the form <code>from module import *</code> import
<em>all</em> functions and variables in <code>module.py</code> into the current file.
This is often referred to as &quot;import star&quot;, and
many find this convenient, but it is not considered as a good
programming style in Python.
For example, when doing

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">import</span> *
</pre></div>
<p>
we get mathematical functions like <code>sin</code> and <code>exp</code> as well as
MATLAB-style functions like <code>linspace</code> and <code>plot</code>, which can be called
by these well-known names.  Unfortunately, it sometimes becomes
confusing to know where a particular function comes from, i.e., what
modules you need to import. Is a desired function from <code>numpy</code> or
<code>matplotlib.pyplot</code>? Or is it our own function?  These questions are
easy to answer if functions in modules are prefixed by the module
name. Doing an additional <code>from math import *</code> is really crucial: now
<code>sin</code>, <code>cos</code>, and other mathematical functions are imported and their
names hide those previously imported from <code>numpy</code>.  That is, <code>sin</code> is
now a sine function that accepts a <code>float</code> argument, not an array.

<p>
Doing the import such that module functions must have a prefix
is generally recommended:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span>

t = numpy.linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)
u_e = I*numpy.exp(-a*t)
matplotlib.pyplot.plot(t, u_e)
</pre></div>
<p>
The modules <code>numpy</code> and <code>matplotlib.pyplot</code> are frequently used,
and since their full names are quite tedious to write,
two standard abbreviations
have evolved in the Python scientific computing community:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>

t = np.linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)
u_e = I*np.exp(-a*t)
plt.plot(t, u_e)
</pre></div>
<p>
The downside of prefixing functions by the module name is that
mathematical expressions like \( e^{-at}\sin(2\pi t) \) get
cluttered with module names,
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">numpy.exp(-a*t)*numpy.sin(<span style="color: #B452CD">2</span>(numpy.pi*t)
<span style="color: #228B22"># or</span>
np.exp(-a*t)*np.sin(<span style="color: #B452CD">2</span>*np.pi*t)
</pre></div>
<p>
Such an expression looks like <code>exp(-a*t)*sin(2*pi*t)</code> in most other
programming languages. Similarly, <code>np.linspace</code> and <code>plt.plot</code> look
less familiar to people who are used to MATLAB and who have not
adopted Python's prefix style.  Whether to do <code>from module import *</code>
or <code>import module</code> depends on personal taste and the problem at
hand. In these writings we use <code>from module import *</code> in more basic,
shorter programs where similarity with MATLAB could be an
advantage. However, in reusable modules we prefix calls to module
functions by their function name, <em>or</em> do explicit import of the
needed functions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> exp, <span style="color: #658b00">sum</span>, sqrt

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">exact_solution</span>(t, I, a):
    <span style="color: #8B008B; font-weight: bold">return</span> I*exp(-a*t)

error = exact_solution(t, I, a) - u
E = sqrt(dt*<span style="color: #658b00">sum</span>(error**<span style="color: #B452CD">2</span>))
</pre></div>
<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Prefixing module functions or not?</b>
<p>
It can be advantageous to do a combination: mathematical functions
in formulas are imported without prefix, while module functions
in general are called with a prefix. For the <code>numpy</code> package we
can do

<p>

<!-- code=text typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eee8d5"><pre style="line-height: 125%">import numpy as np
from numpy import exp, sum, sqrt
</pre></div>
<p>
such that mathematical expression can apply <code>exp</code>, <code>sum</code>, and <code>sqrt</code>
and hence look as close to the mathematical formulas as possible
(without a disturbing prefix).
Other calls to <code>numpy</code> function are done with the prefix, as in
<code>np.linspace</code>.
</div>


<h2 id="softeng1:basic:func">Implementing the numerical algorithm in a function</h2>

<p>
The solution formula <a href="#mjx-eqn-3">(3)</a> is completely general and
should be available as a Python function <code>solver</code> with all input data as
function arguments and all output data returned to the calling code.
With this <code>solver</code> function we can solve all types of problems
<a href="#mjx-eqn-1">(1)</a>-<a href="#mjx-eqn-2">(2)</a>
by an easy-to-read one-line statement:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u, t = solver(I=<span style="color: #B452CD">1</span>, a=<span style="color: #B452CD">2</span>, T=<span style="color: #B452CD">4</span>, dt=<span style="color: #B452CD">0.2</span>, theta=<span style="color: #B452CD">0.5</span>)
</pre></div>
<p>
Refactoring the numerical method in the previous flat program
in terms of a <code>solver</code> function and prefixing calls to
module functions by the module name leads to this code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, a, T, dt, theta):
    <span style="color: #CD5555">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    dt = <span style="color: #658b00">float</span>(dt)               <span style="color: #228B22"># avoid integer division</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))        <span style="color: #228B22"># no of time intervals</span>
    T = Nt*dt                    <span style="color: #228B22"># adjust T to fit time step dt</span>
    u = np.zeros(Nt+<span style="color: #B452CD">1</span>)           <span style="color: #228B22"># array of u[n] values</span>
    t = np.linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># time mesh</span>

    u[<span style="color: #B452CD">0</span>] = I                  <span style="color: #228B22"># assign initial condition</span>
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):    <span style="color: #228B22"># n=0,1,...,Nt-1</span>
        u[n+<span style="color: #B452CD">1</span>] = (<span style="color: #B452CD">1</span> - (<span style="color: #B452CD">1</span>-theta)*a*dt)/(<span style="color: #B452CD">1</span> + theta*dt*a)*u[n]
    <span style="color: #8B008B; font-weight: bold">return</span> u, t
</pre></div>
<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Tip: Always use a doc string to document a function!</b>
<p>
Python has a convention for documenting the purpose and usage of
a function in a <em>doc string</em>: simply place the documentation
in a one- or multi-line triple-quoted string right after the
function header.
</div>


<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Be careful with unintended integer division!</b>
<p>
Note that we in the <code>solver</code> function explicitly covert <code>dt</code> to a
<code>float</code> object. If not, the updating formula for <code>u[n+1]</code> may evaluate
to zero because of integer division when <code>theta</code>, <code>a</code>, and <code>dt</code> are integers!
</div>


<h2 id="___sec9">Do not have several versions of a code </h2>

<p>
One of the most serious flaws in computational work is to have several
slightly different implementations of the same computational algorithms
lying around in various program files. This is very likely to happen,
because busy scientists often want to test a slight variation of a code to see
what happens. A quick copy-and-edit does the task, but such quick hacks tend
to survive. When a real correction is needed in the implementation,
it is difficult to ensure that the correction is done in all relevant files.
In fact, this is a general problem in programming, which has led to
an important principle.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>The DRY principle: Don't repeat yourself!</b>
<p>
When implementing a particular functionality in a computer program, make sure
this functionality and its variations are implemented in just one piece
of code. That is, if you need to revise the implementation, there should be
<em>one and only one</em> place to edit. It follows that you should never
duplicate code (don't repeat yourself!), and code snippets that are
similar should be factored into one piece (function) and parameterized (by
function arguments).
</div>


<p>
The DRY principle means that our <code>solver</code> function should not be
copied to a new file if we need some modifications. Instead, we
should try to extend <code>solver</code> such that the new and old needs are
met by a single function. Sometimes this process requires a new
refactoring, but having a numerical method in one and only one place
is a great advantage.

<h2 id="softeng1:basic:module">Making a module</h2>

<p>
As soon as you start making Python functions in a program, you should
make sure the program file fulfills the requirement of a module.
This means that you can import and reuse your functions in other
programs too. For example, if our <code>solver</code> function resides in a
module file <code>decay.py</code>, another program may reuse of the
function either by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">decay</span> <span style="color: #8B008B; font-weight: bold">import</span> solver
u, t = solver(I=<span style="color: #B452CD">1</span>, a=<span style="color: #B452CD">2</span>, T=<span style="color: #B452CD">4</span>, dt=<span style="color: #B452CD">0.2</span>, theta=<span style="color: #B452CD">0.5</span>)
</pre></div>
<p>
or by a slightly different import statement, combined with a subsequent
prefix of the function name by the name of the module:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">decay</span>
u, t = decay.solver(I=<span style="color: #B452CD">1</span>, a=<span style="color: #B452CD">2</span>, T=<span style="color: #B452CD">4</span>, dt=<span style="color: #B452CD">0.2</span>, theta=<span style="color: #B452CD">0.5</span>)
</pre></div>
<p>
The requirements for a program file to also qualify for a module are simple:

<ol>
<li> The filename without <code>.py</code> must be a valid Python variable name.</li>
<li> The main program must be executed (through statements or
   a function call) in the <em>test block</em>.</li>
</ol>

The <em>test block</em> is normally placed at the end of a module file:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">if</span> __name__ == <span style="color: #CD5555">&#39;__main__&#39;</span>:
    <span style="color: #228B22"># Statements</span>
</pre></div>
<p>
When the module file is executed as a stand-alone program, the if test
is true and the indented statements are run. If the module file
is imported, however, <code>__name__</code> equals the module name and the test block
is not executed.

<p>
To demonstrate the difference, consider the trivial module
file <code>hello.py</code> with one function and a call to this function as main program:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">hello</span>(arg=<span style="color: #CD5555">&#39;World!&#39;</span>):
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Hello, &#39;</span> + arg

<span style="color: #8B008B; font-weight: bold">if</span> __name__ == <span style="color: #CD5555">&#39;__main__&#39;</span>:
    hello()
</pre></div>
<p>
Without the test block, the code reads

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">hello</span>(arg=<span style="color: #CD5555">&#39;World!&#39;</span>):
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Hello, &#39;</span> + arg

hello()
</pre></div>
<p>
With this latter version of the file, any attempt to import <code>hello</code>
will, at the same time, execute the call <code>hello()</code> and hence write
&quot;Hello, World!&quot; to the screen.  Such output is not desired when
importing a module!  To make import and execution of code independent
for another program that wants to use the function <code>hello</code>, the module
<code>hello</code> must be written with a test block. Furthermore, running the
file itself as <code>python hello.py</code> will make the block active and lead
to the desired printing.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>All coming functions are placed in a module!</b>
<p>
The many functions to be explained in the following text are
put in one module file <a href="http://tinyurl.com/ofkw6kc/softeng/decay.py" target="_self"><tt>decay.py</tt></a>.
</div>


<p>
What more than the <code>solver</code> function is needed in our <code>decay</code> module
to do everything we did in the previous, flat program?  We need import
statements for <code>numpy</code> and <code>matplotlib</code> as well as another function
for producing the plot. It can also be convenient to put the exact
solution in a Python function.  Our module <code>decay.py</code> then looks like
this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, a, T, dt, theta):
    ...

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">exact_solution</span>(t, I, a):
    <span style="color: #8B008B; font-weight: bold">return</span> I*np.exp(-a*t)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">experiment_compare_numerical_and_exact</span>():
    I = <span style="color: #B452CD">1</span>;  a = <span style="color: #B452CD">2</span>;  T = <span style="color: #B452CD">4</span>;  dt = <span style="color: #B452CD">0.4</span>;  theta = <span style="color: #B452CD">1</span>
    u, t = solver(I, a, T, dt, theta)

    t_e = np.linspace(<span style="color: #B452CD">0</span>, T, <span style="color: #B452CD">1001</span>)       <span style="color: #228B22"># very fine mesh for u_e</span>
    u_e = exact_solution(t_e, I, a)

    plt.plot(t,   u,   <span style="color: #CD5555">&#39;r--o&#39;</span>)       <span style="color: #228B22"># dashed red line with circles</span>
    plt.plot(t_e, u_e, <span style="color: #CD5555">&#39;b-&#39;</span>)         <span style="color: #228B22"># blue line for u_e</span>
    plt.legend([<span style="color: #CD5555">&#39;numerical, theta=%g&#39;</span> % theta, <span style="color: #CD5555">&#39;exact&#39;</span>])
    plt.xlabel(<span style="color: #CD5555">&#39;t&#39;</span>)
    plt.ylabel(<span style="color: #CD5555">&#39;u&#39;</span>)
    plotfile = <span style="color: #CD5555">&#39;tmp&#39;</span>
    plt.savefig(plotfile + <span style="color: #CD5555">&#39;.png&#39;</span>);  plt.savefig(plotfile + <span style="color: #CD5555">&#39;.pdf&#39;</span>)

    error = exact_solution(t, I, a) - u
    E = np.sqrt(dt*np.sum(error**<span style="color: #B452CD">2</span>))
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Error norm:&#39;</span>, E

<span style="color: #8B008B; font-weight: bold">if</span> __name__ == <span style="color: #CD5555">&#39;__main__&#39;</span>:
    experiment_compare_numerical_and_exact()
</pre></div>
<p>
We could consider doing <code>from numpy import exp, sqrt, sum</code> to make
the mathematical expressions with these functions closer to the
mathematical formulas, but here we employed the prefix since the
formulas are so simple and easy to read.

<p>
This module file does exactly the same as the previous, flat program,
but now it becomes much easier to extend the code with more functions
that produce other plots, other experiments, etc. Even more important, though,
is that the numerical
algorithm is coded and tested once and for all in the <code>solver</code>
function, and any need to solve the mathematical problem is a matter
of one function call.
<!-- (not copying initialization statements and a loop -->
<!-- to a new program for ad hoc editing!). -->

<h2 id="softeng1:basic:experiment2">Example on extending the module code</h2>

<p>
Let us specifically demonstrate one extension of the flat program in
the section <a href="#softeng1:basic:impl1">A first, quick implementation</a> that would require substantial
editing of the flat code (the section <a href="#softeng1:basic:impl2">A more decent program</a>), while in
a structured module (the section <a href="#softeng1:basic:module">Making a module</a>), we can
simply add a new function without affecting the existing code.

<p>
Our example that illustrates the extension
is to make a comparison between the numerical solutions
for various schemes (\( \theta \) values) and the exact solution:

<p>
<center><p><img src="fig-softeng/compare.png" align="bottom" width=600></p></center>

<p>
<div class="alert alert-block alert-question alert-text-normal">
<b>Wait a minute!</b>
<p>
Look at the flat program in
the section <a href="#softeng1:basic:impl1">A first, quick implementation</a>,
and try to imagine which edits that are required to solve this new problem.
</div>


<p>
With the <code>solver</code> function at hand, we can simply create a function
with a loop over <code>theta</code> values and add the necessary plot statements:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">experiment_compare_schemes</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;Compare theta=0,1,0.5 in the same plot.&quot;&quot;&quot;</span>
    I = <span style="color: #B452CD">1</span>;  a = <span style="color: #B452CD">2</span>;  T = <span style="color: #B452CD">4</span>;  dt = <span style="color: #B452CD">0.4</span>
    legends = []
    <span style="color: #8B008B; font-weight: bold">for</span> theta <span style="color: #8B008B">in</span> [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">0.5</span>]:
        u, t = solver(I, a, T, dt, theta)
        plt.plot(t, u, <span style="color: #CD5555">&#39;--o&#39;</span>)
        legends.append(<span style="color: #CD5555">&#39;theta=%g&#39;</span> % theta)
    t_e = np.linspace(<span style="color: #B452CD">0</span>, T, <span style="color: #B452CD">1001</span>)        <span style="color: #228B22"># very fine mesh for u_e</span>
    u_e = exact_solution(t_e, I, a)
    plt.plot(t_e, u_e, <span style="color: #CD5555">&#39;b-&#39;</span>)
    legends.append(<span style="color: #CD5555">&#39;exact&#39;</span>)
    plt.legend(legends, loc=<span style="color: #CD5555">&#39;upper right&#39;</span>)
    plotfile = <span style="color: #CD5555">&#39;tmp&#39;</span>
    plt.savefig(plotfile + <span style="color: #CD5555">&#39;.png&#39;</span>);  plt.savefig(plotfile + <span style="color: #CD5555">&#39;.pdf&#39;</span>)
</pre></div>
<p>
A call to this <code>experiment_compare_schemes</code> function must be placed
in the test block, or you can run the program from IPython instead:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">In[<span style="color: #B452CD">1</span>]: <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">decay</span> <span style="color: #8B008B; font-weight: bold">import</span> *

In[<span style="color: #B452CD">2</span>]: experiment_compare_schemes()
</pre></div>
<p>
We do not present how the flat program from
the section <a href="#softeng1:basic:impl2">A more decent program</a> must be refactored to produce the
desired plots, but simply state that the danger of introducing bugs
is significantly larger than when just writing an additional function
in the <code>decay</code> module.

<h2 id="softeng1:basic:docstring">Documenting functions and modules</h2>

<p>
We have already emphasized the importance of documenting functions with
a doc string (see the section <a href="#softeng1:basic:func">Implementing the numerical algorithm in a function</a>). Now it is time
to show how doc strings should be structured in order to take advantage
of the documentation utilities in the <code>numpy</code> module. The idea is
to follow a convention that in itself makes a good pure text doc string
in the terminal window
and at the same time can be translated to beautiful HTML manuals for
the web.

<p>
The conventions for <code>numpy</code> style doc strings are well
<a href="https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt" target="_self">documented</a>, so here we just present a basic example that the reader can adopt.
Input arguments to a function are listed under the heading <code>Parameters</code>,
while returned values are listed under <code>Returns</code>. It is a good idea to
also add an <code>Examples</code> section on the usage of the function.
More complicated software may have additional sections, see <code>pydoc numpy.load</code>
for an example. The markup language available for doc strings is
Sphinx-extended reStructuredText. The example below shows typical
constructs: 1) how inline
mathematics is written with the <code>:math:</code> directive, 2) how arguments
to the functions are referred to using single backticks
(inline monospace font for code applies double backticks), and 3) how
arguments and return values are listed with types and explanation.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, a, T, dt, theta):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Solve :math:`u&#39;=-au` with :math:`u(0)=I` for :math:`t \in (0,T]`</span>
<span style="color: #CD5555">    with steps of `dt` and the method implied by `theta`.</span>

<span style="color: #CD5555">    Parameters</span>
<span style="color: #CD5555">    ----------</span>
<span style="color: #CD5555">    I: float</span>
<span style="color: #CD5555">        Initial condition.</span>
<span style="color: #CD5555">    a: float</span>
<span style="color: #CD5555">        Parameter in the differential equation.</span>
<span style="color: #CD5555">    T: float</span>
<span style="color: #CD5555">        Total simulation time.</span>
<span style="color: #CD5555">    theta: float, int</span>
<span style="color: #CD5555">        Parameter in the numerical scheme. 0 gives</span>
<span style="color: #CD5555">        Forward Euler, 1 Backward Euler, and 0.5</span>
<span style="color: #CD5555">        the centered Crank-Nicolson scheme.</span>

<span style="color: #CD5555">    Returns</span>
<span style="color: #CD5555">    -------</span>
<span style="color: #CD5555">    `u`: array</span>
<span style="color: #CD5555">        Solution array.</span>
<span style="color: #CD5555">    `t`: array</span>
<span style="color: #CD5555">        Array with time points corresponding to `u`.</span>

<span style="color: #CD5555">    Examples</span>
<span style="color: #CD5555">    --------</span>
<span style="color: #CD5555">    Solve :math:`u&#39; = -\\frac{1}{2}u, u(0)=1.5`</span>
<span style="color: #CD5555">    with the Crank-Nicolson method:</span>

<span style="color: #CD5555">    &gt;&gt;&gt; u, t = solver(I=1.5, a=0.5, T=9, theta=0.5)</span>
<span style="color: #CD5555">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span style="color: #CD5555">    &gt;&gt;&gt; plt.plot(t, u)</span>
<span style="color: #CD5555">    &gt;&gt;&gt; plt.show()</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
</pre></div>
<p>
If you follow such doc string conventions in your software, you can
easily produce nice manuals that meet the standard expected within
the Python scientific computing community.

<p>
<a href="http://sphinx-doc.org/" target="_self">Sphinx</a> requires quite a number of manual steps to
prepare a manual, so it is
recommended to use a <a href="http://tinyurl.com/ofkw6kc/softeng/make_sphinx_api.py" target="_self">premade script</a> to automate the steps. (By default,
the script generates documentation for all <code>*.py</code> files in the
current directory.
You need to do a <code>pip install</code> of <code>sphinx</code> and <code>numpydoc</code> to make the
script work.)
Figure <a href="#softeng1:basic:docstring:fig">2</a> provides an example of what
the above doc strings look like when Sphinx has transformed them to HTML.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Example on Sphinx API manual in HTML. <div id="softeng1:basic:docstring:fig"></div> </p></center>
<p><img src="fig-softeng/selfdoc_numpy.png" align="bottom" width=700></p>
</center>

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._softeng-solarized001.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._softeng-solarized003.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

