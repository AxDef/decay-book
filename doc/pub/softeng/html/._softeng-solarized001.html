<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Software engineering with exponential decay models">
<meta name="keywords" content="refactoring,importing modules,logger,debugging,list comprehension,command-line arguments,option-value pairs (command line),command-line arguments,reading the command line,doctests,software testing doctests,unit testing,software testing nose,software testing pytest,test function,software testing test function,doctest in test function,unit testing,software testing unit testing (class-based),Distutils,GitHub,importing modules,problem class,solver class,wrapper (code),reproducibility,replicability,Unix wildcard notation,wildcard notation (Unix),Word (Microsoft),LibreOffice,OpenOffice,Google Docs,HTML,MathJax,LaTeX,Sphinx (typesetting tool),Markdown,IPython notebooks,Jupyter notebooks,DocOnce,replicability">

<title>Software engineering with exponential decay models</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Implementations with functions and modules',
               1,
               'softeng1:basic',
               'softeng1:basic'),
              ('Mathematical problem and solution technique',
               2,
               'softeng1:basic:math',
               'softeng1:basic:math'),
              ('A first, quick implementation',
               2,
               'softeng1:basic:impl1',
               'softeng1:basic:impl1'),
              ('A more decent program',
               2,
               'softeng1:basic:impl2',
               'softeng1:basic:impl2'),
              ('Comments in a program', 3, None, '___sec4'),
              ('Refactoring into functions', 3, None, '___sec5'),
              ('Program file vs IDE vs notebook', 3, None, '___sec6'),
              ('Prefixing imported functions by the module name',
               2,
               'softeng1:basic:modprefix',
               'softeng1:basic:modprefix'),
              ('Implementing the numerical algorithm in a function',
               2,
               'softeng1:basic:func',
               'softeng1:basic:func'),
              ('Do not have several versions of a code', 2, None, '___sec9'),
              ('Making a module',
               2,
               'softeng1:basic:module',
               'softeng1:basic:module'),
              ('Example on extending the module code',
               2,
               'softeng1:basic:experiment2',
               'softeng1:basic:experiment2'),
              ('Documenting functions and modules',
               2,
               'softeng1:basic:docstring',
               'softeng1:basic:docstring'),
              ('Logging intermediate results',
               2,
               'softeng1:basic:logging',
               'softeng1:basic:logging'),
              ('Introductory example', 3, None, '___sec14'),
              ('Using a logger in our solver function', 3, None, '___sec15'),
              ('User interfaces',
               1,
               'softeng1:basic:UI',
               'softeng1:basic:UI'),
              ('Command-line arguments', 2, None, '___sec17'),
              ('Positional command-line arguments', 2, None, '___sec18'),
              ('Option-value pairs on the command line', 2, None, '___sec19'),
              ('Creating a graphical web user interface',
               2,
               None,
               '___sec20'),
              ('Making a compute function', 3, None, '___sec21'),
              ('Generating the user interface', 3, None, '___sec22'),
              ('Running the web application', 3, None, '___sec23'),
              ('Tests for verifying implementations', 1, None, '___sec24'),
              ('Doctests', 2, None, '___sec25'),
              ('Unit tests and test functions', 2, None, '___sec26'),
              ('Two Python test frameworks: nose and pytest',
               3,
               None,
               '___sec27'),
              ('Test function requirements', 3, None, '___sec28'),
              ('Comparison of real numbers', 3, None, '___sec29'),
              ('Special assert functions from nose', 3, None, '___sec30'),
              ('Locating test functions', 3, None, '___sec31'),
              ('Running tests', 3, None, '___sec32'),
              ('Embedding doctests in a test function', 3, None, '___sec33'),
              ('Installing nose and pytest', 3, None, '___sec34'),
              ('Test function for the solver', 2, None, '___sec35'),
              ('Test function for reading positional command-line arguments',
               2,
               None,
               '___sec36'),
              ('Test function for reading option-value pairs',
               2,
               None,
               '___sec37'),
              ('Classical class-based unit testing',
               2,
               'softeng1:basic:unittest',
               'softeng1:basic:unittest'),
              ('Sharing the software with other users',
               1,
               'softeng1:prog:se:git',
               'softeng1:prog:se:git'),
              ('Organizing the software directory tree', 2, None, '___sec40'),
              ('Distributing just a module file', 3, None, '___sec41'),
              ('Distributing a package', 3, None, '___sec42'),
              ('Publishing the software at GitHub', 2, None, '___sec43'),
              ('Downloading and installing the software',
               2,
               None,
               '___sec44'),
              ('Installing just a module file', 3, None, '___sec45'),
              ('Installing a package', 3, None, '___sec46'),
              ('Classes for problem and solution method',
               1,
               'softeng1:prog:se:class',
               'softeng1:prog:se:class'),
              ('The problem class', 2, None, '___sec48'),
              ('The solver class', 2, None, '___sec49'),
              ('Combining the objects', 3, None, '___sec50'),
              ('Improving the problem and solver classes',
               2,
               'softeng1:prog:se:class2',
               'softeng1:prog:se:class2'),
              ('A generic class for parameters', 3, None, '___sec52'),
              ('Automating scientific experiments',
               1,
               'softeng1:experiments',
               'softeng1:experiments'),
              ('Available software', 2, None, '___sec54'),
              ('The results we want to produce', 2, None, '___sec55'),
              ('Combining plot files', 2, None, '___sec56'),
              ('Running a program from Python', 2, None, '___sec57'),
              ('The automating script', 2, None, '___sec58'),
              ('Making a report',
               2,
               'softeng1:exper:report',
               'softeng1:exper:report'),
              ('Word, OpenOffice, GoogleDocs', 3, None, '___sec60'),
              ('HTML with MathJax', 3, None, '___sec61'),
              ('LaTeX', 3, None, '___sec62'),
              ('Sphinx', 3, None, '___sec63'),
              ('Markdown', 3, None, '___sec64'),
              ('IPython/Jupyter notebooks', 3, None, '___sec65'),
              ('Wiki formats', 3, None, '___sec66'),
              ('DocOnce', 3, None, '___sec67'),
              ('Publishing a complete project',
               2,
               'softeng1:exper:github',
               'softeng1:exper:github'),
              ('Exercises', 1, None, '___sec69'),
              ('Problem 1: Make a tool for differentiating curves',
               2,
               'softeng1:exer:derivative',
               'softeng1:exer:derivative'),
              ('Problem 2: Make solid software for the Trapezoidal rule',
               2,
               'softeng1:exer:integral:flat',
               'softeng1:exer:integral:flat'),
              ('Problem 3: Implement classes for the Trapezoidal rule',
               2,
               'softeng1:exer:integral:flat2',
               'softeng1:exer:integral:flat2'),
              ('Problem 4: Write a doctest and a test function',
               2,
               'softeng1:exer:doctest1',
               'softeng1:exer:doctest1'),
              ('Problem 5: Experiment with tolerances in comparisons',
               2,
               'softeng1:exer:tol',
               'softeng1:exer:tol'),
              ('Remarks', 3, None, '___sec75'),
              ('Exercise 6: Make use of a class implementation',
               2,
               'softeng1:exer:class:dts',
               'softeng1:exer:class:dts'),
              ('Problem 7: Make solid software for a difference equation',
               2,
               'softeng1:exer:logistic',
               'softeng1:exer:logistic'),
              ('Bibliography', 1, None, '___sec78')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\tp}{\thinspace .}
$$




    
<a name="part0001"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._softeng-solarized000.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._softeng-solarized002.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<p>
Teaching material on scientific computing has traditionally been very
focused on the mathematics and the applications, while details on how
the computer is programmed to solve the problems have received little attention.
Many end up writing as simple programs as possible, without being
aware of much useful computer science technology that would increase
the fun, efficiency, and reliability of the their scientific computing
activities.

<p>
This chapter demonstrates a series of good practices and tools
from modern computer science, using the simple mathematical problem
\( u^{\prime}=-au \), \( u(0)=I \), such that we minimize the
mathematical details and can go more in depth with implementations.
The goal is to increase the technological
quality of computer programming and make it match the more
well-established quality of the mathematics of scientific computing.

<p>
The conventions and techniques outlined here will save you a lot of time
when you incrementally extend software over time from simpler to more
complicated problems. In particular, you will benefit from
many good habits:

<ul>
 <li> new code is added in a modular fashion to a library (modules),</li>
 <li> programs are run through convenient user interfaces,</li>
 <li> it takes one quick command to let all your code undergo heavy testing,</li>
 <li> tedious manual work with running programs is automated,</li>
 <li> your scientific investigations are reproducible,</li>
 <li> scientific reports with top quality typesetting are produced both
   for paper and electronic devices.</li>
</ul>

<h1 id="softeng1:basic">Implementations with functions and modules</h1>

<p>
All previous examples in this book have implemented numerical
algorithms as Python functions. This is a good style that readers
are expected to adopt. However, this author has experienced that
many students and engineers are inclined to make &quot;flat&quot; programs,
i.e., a sequence of statements without any use of functions, just to
get the problem solved as quickly as possible. Since this programming
style is so widespread, especially among people with MATLAB experience,
we shall look at the weaknesses of flat programs and show how they
can be <em>refactored</em> into more reusable programs based on functions.

<h2 id="softeng1:basic:math">Mathematical problem and solution technique</h2>

<p>
We address the differential equation problem

$$
\begin{align}
u'(t) &= -au(t), \quad t \in (0,T], \tag{1}\\ 
u(0)  &= I,                         \tag{2}
\end{align}
$$

where \( a \), \( I \), and \( T \) are prescribed parameters, and \( u(t) \) is
the unknown function to be estimated. This mathematical model
is relevant for physical phenomena featuring exponential decay
in time, e.g., vertical pressure variation in the atmosphere,
cooling of an object, and radioactive decay.

<p>
The
time domain is discretized with points \( 0 = t_0 < t_1 \cdots < t_{N_t}=T \),
here with a constant spacing \( \Delta t \) between the
mesh points: \( \Delta t = t_{n}-t_{n-1} \), \( n=1,\ldots,N_t \). Let
\( u^n \) be the numerical approximation to the exact solution at \( t_n \).
A family of popular numerical methods are provided by the \( \theta \) scheme,

$$
\begin{equation}
u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,
\tag{3}
\end{equation}
$$

for \( n=0,1,\ldots,N_t-1 \). This formula produces
the Forward Euler
scheme when \( \theta=0 \),
the Backward Euler
scheme when \( \theta=1 \),
and the Crank-Nicolson
scheme when \( \theta=1/2 \).

<h2 id="softeng1:basic:impl1">A first, quick implementation</h2>

<p>
Solving <a href="#mjx-eqn-3">(3)</a> in a program is very straightforward:
just make a loop over \( n \) and evaluate the formula. The \( u(t_n \))
values for discrete \( n \) can be stored in an array. This makes it easy
to also plot the solution. It would be natural to also add
the exact
solution curve \( u(t)=Ie^{-at} \) to the plot.

<p>
Many have programming habits that would lead them
to write a simple program like this:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">import</span> *

A = <span style="color: #B452CD">1</span>
a = <span style="color: #B452CD">2</span>
T = <span style="color: #B452CD">4</span>
dt = <span style="color: #B452CD">0.2</span>
N = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))
y = zeros(N+<span style="color: #B452CD">1</span>)
t = linspace(<span style="color: #B452CD">0</span>, T, N+<span style="color: #B452CD">1</span>)
theta = <span style="color: #B452CD">1</span>
y[<span style="color: #B452CD">0</span>] = A
<span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, N):
    y[n+<span style="color: #B452CD">1</span>] = (<span style="color: #B452CD">1</span> - (<span style="color: #B452CD">1</span>-theta)*a*dt)/(<span style="color: #B452CD">1</span> + theta*dt*a)*y[n]

y_e = A*exp(-a*t) - y
error = y_e - y
E = sqrt(dt*<span style="color: #658b00">sum</span>(error**<span style="color: #B452CD">2</span>))
<span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Norm of the error: %.3E&#39;</span> % E
plot(t, y, <span style="color: #CD5555">&#39;r--o&#39;</span>)
t_e = linspace(<span style="color: #B452CD">0</span>, T, <span style="color: #B452CD">1001</span>)
y_e = A*exp(-a*t_e)
plot(t_e, y_e, <span style="color: #CD5555">&#39;b-&#39;</span>)
legend([<span style="color: #CD5555">&#39;numerical, theta=%g&#39;</span> % theta, <span style="color: #CD5555">&#39;exact&#39;</span>])
xlabel(<span style="color: #CD5555">&#39;t&#39;</span>)
ylabel(<span style="color: #CD5555">&#39;y&#39;</span>)
show()
</pre></div>
<p>
This program is easy to read, and as long it is correct, many will
claim that it has sufficient quality. Nevertheless, the program suffers
from two serious flaws:

<ol>
<li> The notation in the program does not correspond <em>exactly</em> to
   the notation in the mathematical problem: the solution is called
   <code>y</code> and corresponds to \( u \) in the mathematical description,
   the variable <code>A</code> corresponds to the mathematical parameter \( I \),
   <code>N</code> in the program is called \( N_t \) in the mathematics.</li>
<li> There are no comments in the program.</li>
</ol>

These kind of flaws quickly become crucial if present in code for complicated
mathematical problems and code that is meant to be extended to other problems.

<p>
We also note that the program is <em>flat</em> in the sense that it does
not contain functions. Usually, this is a bad habit, but let us
first correct the two mentioned flaws.

<h2 id="softeng1:basic:impl2">A more decent program</h2>

<p>
A code of better quality arises from
fixing the notation and adding comments:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">import</span> *

I = <span style="color: #B452CD">1</span>
a = <span style="color: #B452CD">2</span>
T = <span style="color: #B452CD">4</span>
dt = <span style="color: #B452CD">0.2</span>
Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))     <span style="color: #228B22"># no of time intervals</span>
u = zeros(Nt+<span style="color: #B452CD">1</span>)           <span style="color: #228B22"># array of u[n] values</span>
t = linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># time mesh</span>
theta = <span style="color: #B452CD">1</span>                 <span style="color: #228B22"># Backward Euler method</span>

u[<span style="color: #B452CD">0</span>] = I                  <span style="color: #228B22"># assign initial condition</span>
<span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):    <span style="color: #228B22"># n=0,1,...,Nt-1</span>
    u[n+<span style="color: #B452CD">1</span>] = (<span style="color: #B452CD">1</span> - (<span style="color: #B452CD">1</span>-theta)*a*dt)/(<span style="color: #B452CD">1</span> + theta*dt*a)*u[n]

<span style="color: #228B22"># Compute norm of the error</span>
u_e = I*exp(-a*t) - u     <span style="color: #228B22"># exact u at the mesh points</span>
error = u_e - u
E = sqrt(dt*<span style="color: #658b00">sum</span>(error**<span style="color: #B452CD">2</span>))
<span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Norm of the error: %.3E&#39;</span> % E

<span style="color: #228B22"># Compare numerical (u) and exact solution (u_e) in a plot</span>
plot(t, u, <span style="color: #CD5555">&#39;r--o&#39;</span>)
t_e = linspace(<span style="color: #B452CD">0</span>, T, <span style="color: #B452CD">1001</span>)       <span style="color: #228B22"># very fine mesh for u_e</span>
u_e = I*exp(-a*t_e)
plot(t_e, u_e, <span style="color: #CD5555">&#39;b-&#39;</span>)
legend([<span style="color: #CD5555">&#39;numerical, theta=%g&#39;</span> % theta, <span style="color: #CD5555">&#39;exact&#39;</span>])
xlabel(<span style="color: #CD5555">&#39;t&#39;</span>)
ylabel(<span style="color: #CD5555">&#39;u&#39;</span>)
show()
</pre></div>

<h3 id="___sec4">Comments in a program </h3>

<p>
There is obviously not just one way to comment a program, and opinions
may differ as to what code should be accomplished by comments.
The guiding principle is, however, that comments should make the
program easy to understand for human eye. Do not comment obvious
constructions, but focus on ideas and (&quot;what happens in the next
statements?&quot;) and on explaining code that can be interpreted as
complicated.

<h3 id="___sec5">Refactoring into functions </h3>

<p>
At first sight, our updated program seems like
a good starting point for playing around
with the mathematical problem: we can just change parameters and rerun.
Although such edit-and-rerun sessions are good for initial exploration,
one will soon extend the experiments and start developing the code
further. Say we want to compare \( \theta =0,1,0.5 \) in the same
plot. This extension requires changes all over the code and quickly
leads to errors. To do something serious with this program, we have to
break it into smaller pieces and make sure each piece is well tested,
and ensure that the program is sufficiently general and can be reused in
new contexts without changes.  The
next natural step is therefore to isolate the numerical computations
and the visualization in separate Python functions.
Such a rewrite of a code, without essentially changing the functionality,
but just improve the quality of the code, is known as <em>refactoring</em>.
After one has quickly put some code down and tested it, it is a common
step to refactor it so it is better prepared for extensions.

<h3 id="___sec6">Program file vs IDE vs notebook </h3>

<p>
There are basically three different ways of working with Python code:

<ol>
<li> One writes the code in a file, using a text editor (such as
   Emacs or Vim) and runs it in a terminal window.</li>
<li> One applies an <em>Integrated Development Environment</em> (the simplest is IDLE, which comes with standard Python) containing a graphical user interface with an editor and an element where Python code can be run.</li>
<li> One applies the Jupyter Notebook (previously known as IPython Notebook),
   which offers an interactive environment for Python code where
   plots are automatically inserted after the code, see Figure <a href="#softeng1:ipynb">1</a>.</li>
</ol>

It appears that method 1 and 2 are quite equivalent, but the notebook
encourages more experimental code and therefore also flat programs.
Consequently, notebook users will normally need to think more about
refactoring code and increase the use of functions after initial
experimentation.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Experimental code in a notebook. <div id="softeng1:ipynb"></div> </p></center>
<p><img src="fig-softeng/ipynb_flat.png" align="bottom" width=700></p>
</center>

<h2 id="softeng1:basic:modprefix">Prefixing imported functions by the module name</h2>

<p>
Import statements of the form <code>from module import *</code> import
<em>all</em> functions and variables in <code>module.py</code> into the current file.
This is often referred to as &quot;import star&quot;, and
many find this convenient, but it is not considered as a good
programming style in Python.
For example, when doing

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">import</span> *
</pre></div>
<p>
we get mathematical functions like <code>sin</code> and <code>exp</code> as well as
MATLAB-style functions like <code>linspace</code> and <code>plot</code>, which can be called
by these well-known names.  Unfortunately, it sometimes becomes
confusing to know where a particular function comes from, i.e., what
modules you need to import. Is a desired function from <code>numpy</code> or
<code>matplotlib.pyplot</code>? Or is it our own function?  These questions are
easy to answer if functions in modules are prefixed by the module
name. Doing an additional <code>from math import *</code> is really crucial: now
<code>sin</code>, <code>cos</code>, and other mathematical functions are imported and their
names hide those previously imported from <code>numpy</code>.  That is, <code>sin</code> is
now a sine function that accepts a <code>float</code> argument, not an array.

<p>
Doing the import such that module functions must have a prefix
is generally recommended:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span>

t = numpy.linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)
u_e = I*numpy.exp(-a*t)
matplotlib.pyplot.plot(t, u_e)
</pre></div>
<p>
The modules <code>numpy</code> and <code>matplotlib.pyplot</code> are frequently used,
and since their full names are quite tedious to write,
two standard abbreviations
have evolved in the Python scientific computing community:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>

t = np.linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)
u_e = I*np.exp(-a*t)
plt.plot(t, u_e)
</pre></div>
<p>
The downside of prefixing functions by the module name is that
mathematical expressions like \( e^{-at}\sin(2\pi t) \) get
cluttered with module names,
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">numpy.exp(-a*t)*numpy.sin(<span style="color: #B452CD">2</span>(numpy.pi*t)
<span style="color: #228B22"># or</span>
np.exp(-a*t)*np.sin(<span style="color: #B452CD">2</span>*np.pi*t)
</pre></div>
<p>
Such an expression looks like <code>exp(-a*t)*sin(2*pi*t)</code> in most other
programming languages. Similarly, <code>np.linspace</code> and <code>plt.plot</code> look
less familiar to people who are used to MATLAB and who have not
adopted Python's prefix style.  Whether to do <code>from module import *</code>
or <code>import module</code> depends on personal taste and the problem at
hand. In these writings we use <code>from module import *</code> in more basic,
shorter programs where similarity with MATLAB could be an
advantage. However, in reusable modules we prefix calls to module
functions by their function name, <em>or</em> do explicit import of the
needed functions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> exp, <span style="color: #658b00">sum</span>, sqrt

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">u_exact</span>(t, I, a):
    <span style="color: #8B008B; font-weight: bold">return</span> I*exp(-a*t)

error = u_exact(t, I, a) - u
E = sqrt(dt*<span style="color: #658b00">sum</span>(error**<span style="color: #B452CD">2</span>))
</pre></div>
<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Prefixing module functions or not?</b>
<p>
It can be advantageous to do a combination: mathematical functions
in formulas are imported without prefix, while module functions
in general are called with a prefix. For the <code>numpy</code> package we
can do

<p>

<!-- code=text typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eee8d5"><pre style="line-height: 125%">import numpy as np
from numpy import exp, sum, sqrt
</pre></div>
<p>
such that mathematical expression can apply <code>exp</code>, <code>sum</code>, and <code>sqrt</code>
and hence look as close to the mathematical formulas as possible
(without a disturbing prefix).
Other calls to <code>numpy</code> function are done with the prefix, as in
<code>np.linspace</code>.
</div>


<h2 id="softeng1:basic:func">Implementing the numerical algorithm in a function</h2>

<p>
The solution formula <a href="#mjx-eqn-3">(3)</a> is completely general and
should be available as a Python function <code>solver</code> with all input data as
function arguments and all output data returned to the calling code.
With this <code>solver</code> function we can solve all types of problems
<a href="#mjx-eqn-1">(1)</a>-<a href="#mjx-eqn-2">(2)</a>
by an easy-to-read one-line statement:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u, t = solver(I=<span style="color: #B452CD">1</span>, a=<span style="color: #B452CD">2</span>, T=<span style="color: #B452CD">4</span>, dt=<span style="color: #B452CD">0.2</span>, theta=<span style="color: #B452CD">0.5</span>)
</pre></div>
<p>
Refactoring the numerical method in the previous flat program
in terms of a <code>solver</code> function and prefixing calls to
module functions by the module name leads to this code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, a, T, dt, theta):
    <span style="color: #CD5555">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    dt = <span style="color: #658b00">float</span>(dt)               <span style="color: #228B22"># avoid integer division</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))        <span style="color: #228B22"># no of time intervals</span>
    T = Nt*dt                    <span style="color: #228B22"># adjust T to fit time step dt</span>
    u = np.zeros(Nt+<span style="color: #B452CD">1</span>)           <span style="color: #228B22"># array of u[n] values</span>
    t = np.linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># time mesh</span>

    u[<span style="color: #B452CD">0</span>] = I                  <span style="color: #228B22"># assign initial condition</span>
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):    <span style="color: #228B22"># n=0,1,...,Nt-1</span>
        u[n+<span style="color: #B452CD">1</span>] = (<span style="color: #B452CD">1</span> - (<span style="color: #B452CD">1</span>-theta)*a*dt)/(<span style="color: #B452CD">1</span> + theta*dt*a)*u[n]
    <span style="color: #8B008B; font-weight: bold">return</span> u, t
</pre></div>
<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Tip: Always use a doc string to document a function!</b>
<p>
Python has a convention for documenting the purpose and usage of
a function in a <em>doc string</em>: simply place the documentation
in a one- or multi-line triple-quoted string right after the
function header.
</div>


<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Be careful with unintended integer division!</b>
<p>
Note that we in the <code>solver</code> function explicitly covert <code>dt</code> to a
<code>float</code> object. If not, the updating formula for <code>u[n+1]</code> may evaluate
to zero because of integer division when <code>theta</code>, <code>a</code>, and <code>dt</code> are integers!
</div>


<h2 id="___sec9">Do not have several versions of a code </h2>

<p>
One of the most serious flaws in computational work is to have several
slightly different implementations of the same computational algorithms
lying around in various program files. This is very likely to happen,
because busy scientists often want to test a slight variation of a code to see
what happens. A quick copy-and-edit does the task, but such quick hacks tend
to survive. When a real correction is needed in the implementation,
it is difficult to ensure that the correction is done in all relevant files.
In fact, this is a general problem in programming, which has led to
an important principle.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>The DRY principle: Don't repeat yourself!</b>
<p>
When implementing a particular functionality in a computer program, make sure
this functionality and its variations are implemented in just one piece
of code. That is, if you need to revise the implementation, there should be
<em>one and only one</em> place to edit. It follows that you should never
duplicate code (don't repeat yourself!), and code snippets that are
similar should be factored into one piece (function) and parameterized (by
function arguments).
</div>


<p>
The DRY principle means that our <code>solver</code> function should not be
copied to a new file if we need some modifications. Instead, we
should try to extend <code>solver</code> such that the new and old needs are
met by a single function. Sometimes this process requires a new
refactoring, but having a numerical method in one and only one place
is a great advantage.

<h2 id="softeng1:basic:module">Making a module</h2>

<p>
As soon as you start making Python functions in a program, you should
make sure the program file fulfills the requirement of a module.
This means that you can import and reuse your functions in other
programs too. For example, if our <code>solver</code> function resides in a
module file <code>decay.py</code>, another program may reuse of the
function either by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">decay</span> <span style="color: #8B008B; font-weight: bold">import</span> solver
u, t = solver(I=<span style="color: #B452CD">1</span>, a=<span style="color: #B452CD">2</span>, T=<span style="color: #B452CD">4</span>, dt=<span style="color: #B452CD">0.2</span>, theta=<span style="color: #B452CD">0.5</span>)
</pre></div>
<p>
or by a slightly different import statement, combined with a subsequent
prefix of the function name by the name of the module:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">decay</span>
u, t = decay.solver(I=<span style="color: #B452CD">1</span>, a=<span style="color: #B452CD">2</span>, T=<span style="color: #B452CD">4</span>, dt=<span style="color: #B452CD">0.2</span>, theta=<span style="color: #B452CD">0.5</span>)
</pre></div>
<p>
The requirements for a program file to also qualify for a module are simple:

<ol>
<li> The filename without <code>.py</code> must be a valid Python variable name.</li>
<li> The main program must be executed (through statements or
   a function call) in the <em>test block</em>.</li>
</ol>

The <em>test block</em> is normally placed at the end of a module file:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">if</span> __name__ == <span style="color: #CD5555">&#39;__main__&#39;</span>:
    <span style="color: #228B22"># Statements</span>
</pre></div>
<p>
When the module file is executed as a stand-alone program, the if test
is true and the indented statements are run. If the module file
is imported, however, <code>__name__</code> equals the module name and the test block
is not executed.

<p>
To demonstrate the difference, consider the trivial module
file <code>hello.py</code> with one function and a call to this function as main program:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">hello</span>(arg=<span style="color: #CD5555">&#39;World!&#39;</span>):
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Hello, &#39;</span> + arg

<span style="color: #8B008B; font-weight: bold">if</span> __name__ == <span style="color: #CD5555">&#39;__main__&#39;</span>:
    hello()
</pre></div>
<p>
Without the test block, the code reads

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">hello</span>(arg=<span style="color: #CD5555">&#39;World!&#39;</span>):
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Hello, &#39;</span> + arg

hello()
</pre></div>
<p>
With this latter version of the file, any attempt to import <code>hello</code>
will, at the same time, execute the call <code>hello()</code> and hence write
&quot;Hello, World!&quot; to the screen.  Such output is not desired when
importing a module!  To make import and execution of code independent
for another program that wants to use the function <code>hello</code>, the module
<code>hello</code> must be written with a test block. Furthermore, running the
file itself as <code>python hello.py</code> will make the block active and lead
to the desired printing.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>All coming functions are placed in a module!</b>
<p>
The many functions to be explained in the following text are
put in one module file <a href="http://tinyurl.com/ofkw6kc/softeng/decay.py" target="_self"><tt>decay.py</tt></a>.
</div>


<p>
What more than the <code>solver</code> function is needed in our <code>decay</code> module
to do everything we did in the previous, flat program?  We need import
statements for <code>numpy</code> and <code>matplotlib</code> as well as another function
for producing the plot. It can also be convenient to put the exact
solution in a Python function.  Our module <code>decay.py</code> then looks like
this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, a, T, dt, theta):
    ...

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">u_exact</span>(t, I, a):
    <span style="color: #8B008B; font-weight: bold">return</span> I*np.exp(-a*t)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">experiment_compare_numerical_and_exact</span>():
    I = <span style="color: #B452CD">1</span>;  a = <span style="color: #B452CD">2</span>;  T = <span style="color: #B452CD">4</span>;  dt = <span style="color: #B452CD">0.4</span>;  theta = <span style="color: #B452CD">1</span>
    u, t = solver(I, a, T, dt, theta)

    t_e = np.linspace(<span style="color: #B452CD">0</span>, T, <span style="color: #B452CD">1001</span>)       <span style="color: #228B22"># very fine mesh for u_e</span>
    u_e = u_exact(t_e, I, a)

    plt.plot(t,   u,   <span style="color: #CD5555">&#39;r--o&#39;</span>)       <span style="color: #228B22"># dashed red line with circles</span>
    plt.plot(t_e, u_e, <span style="color: #CD5555">&#39;b-&#39;</span>)         <span style="color: #228B22"># blue line for u_e</span>
    plt.legend([<span style="color: #CD5555">&#39;numerical, theta=%g&#39;</span> % theta, <span style="color: #CD5555">&#39;exact&#39;</span>])
    plt.xlabel(<span style="color: #CD5555">&#39;t&#39;</span>)
    plt.ylabel(<span style="color: #CD5555">&#39;u&#39;</span>)
    plotfile = <span style="color: #CD5555">&#39;tmp&#39;</span>
    plt.savefig(plotfile + <span style="color: #CD5555">&#39;.png&#39;</span>);  plt.savefig(plotfile + <span style="color: #CD5555">&#39;.pdf&#39;</span>)

    error = u_exact(t, I, a) - u
    E = np.sqrt(dt*np.sum(error**<span style="color: #B452CD">2</span>))
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Error norm:&#39;</span>, E

<span style="color: #8B008B; font-weight: bold">if</span> __name__ == <span style="color: #CD5555">&#39;__main__&#39;</span>:
    experiment_compare_numerical_and_exact()
</pre></div>
<p>
We could consider doing <code>from numpy import exp, sqrt, sum</code> to make
the mathematical expressions with these functions closer to the
mathematical formulas, but here we employed the prefix since the
formulas are so simple and easy to read.

<p>
This module file does exactly the same as the previous, flat program,
but now it becomes much easier to extend the code with more functions
that produce other plots, other experiments, etc. Even more important, though,
is that the numerical
algorithm is coded and tested once and for all in the <code>solver</code>
function, and any need to solve the mathematical problem is a matter
of one function call.
<!-- (not copying initialization statements and a loop -->
<!-- to a new program for ad hoc editing!). -->

<h2 id="softeng1:basic:experiment2">Example on extending the module code</h2>

<p>
Let us specifically demonstrate one extension of the flat program in
the section <a href="#softeng1:basic:impl1">A first, quick implementation</a> that would require substantial
editing of the flat code (the section <a href="#softeng1:basic:impl2">A more decent program</a>), while in
a structured module (the section <a href="#softeng1:basic:module">Making a module</a>), we can
simply add a new function without affecting the existing code.

<p>
Our example that illustrates the extension
is to make a comparison between the numerical solutions
for various schemes (\( \theta \) values) and the exact solution:

<p>
<center><p><img src="fig-softeng/compare.png" align="bottom" width=600></p></center>

<p>
<div class="alert alert-block alert-question alert-text-normal">
<b>Wait a minute!</b>
<p>
Look at the flat program in
the section <a href="#softeng1:basic:impl1">A first, quick implementation</a>,
and try to imagine which edits that are required to solve this new problem.
</div>


<p>
With the <code>solver</code> function at hand, we can simply create a function
with a loop over <code>theta</code> values and add the necessary plot statements:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">experiment_compare_schemes</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;Compare theta=0,1,0.5 in the same plot.&quot;&quot;&quot;</span>
    I = <span style="color: #B452CD">1</span>;  a = <span style="color: #B452CD">2</span>;  T = <span style="color: #B452CD">4</span>;  dt = <span style="color: #B452CD">0.4</span>
    legends = []
    <span style="color: #8B008B; font-weight: bold">for</span> theta <span style="color: #8B008B">in</span> [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">0.5</span>]:
        u, t = solver(I, a, T, dt, theta)
        plt.plot(t, u, <span style="color: #CD5555">&#39;--o&#39;</span>)
        legends.append(<span style="color: #CD5555">&#39;theta=%g&#39;</span> % theta)
    t_e = np.linspace(<span style="color: #B452CD">0</span>, T, <span style="color: #B452CD">1001</span>)        <span style="color: #228B22"># very fine mesh for u_e</span>
    u_e = u_exact(t_e, I, a)
    plt.plot(t_e, u_e, <span style="color: #CD5555">&#39;b-&#39;</span>)
    legends.append(<span style="color: #CD5555">&#39;exact&#39;</span>)
    plt.legend(legends, loc=<span style="color: #CD5555">&#39;upper right&#39;</span>)
    plotfile = <span style="color: #CD5555">&#39;tmp&#39;</span>
    plt.savefig(plotfile + <span style="color: #CD5555">&#39;.png&#39;</span>);  plt.savefig(plotfile + <span style="color: #CD5555">&#39;.pdf&#39;</span>)
</pre></div>
<p>
A call to this <code>experiment_compare_schemes</code> function must be placed
in the test block, or you can run the program from IPython instead:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">In[<span style="color: #B452CD">1</span>]: <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">decay</span> <span style="color: #8B008B; font-weight: bold">import</span> *

In[<span style="color: #B452CD">2</span>]: experiment_compare_schemes()
</pre></div>
<p>
We do not present how the flat program from
the section <a href="#softeng1:basic:impl2">A more decent program</a> must be refactored to produce the
desired plots, but simply state that the danger of introducing bugs
is significantly larger than when just writing an additional function
in the <code>decay</code> module.

<h2 id="softeng1:basic:docstring">Documenting functions and modules</h2>

<p>
We have already emphasized the importance of documenting functions with
a doc string (see the section <a href="#softeng1:basic:func">Implementing the numerical algorithm in a function</a>). Now it is time
to show how doc strings should be structured in order to take advantage
of the documentation utilities in the <code>numpy</code> module. The idea is
to follow a convention that in itself makes a good pure text doc string
in the terminal window
and at the same time can be translated to beautiful HTML manuals for
the web.

<p>
The conventions for <code>numpy</code> style doc strings are well
<a href="https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt" target="_self">documented</a>, so here we just present a basic example that the reader can adopt.
Input arguments to a function are listed under the heading <code>Parameters</code>,
while returned values are listed under <code>Returns</code>. It is a good idea to
also add an <code>Examples</code> section on the usage of the function.
More complicated software may have additional sections, see <code>pydoc numpy.load</code>
for an example. The markup language available for doc strings is
Sphinx-extended reStructuredText. The example below shows typical
constructs: 1) how inline
mathematics is written with the <code>:math:</code> directive, 2) how arguments
to the functions are referred to using single backticks
(inline monospace font for code applies double backticks), and 3) how
arguments and return values are listed with types and explanation.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, a, T, dt, theta):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Solve :math:`u&#39;=-au` with :math:`u(0)=I` for :math:`t \in (0,T]`</span>
<span style="color: #CD5555">    with steps of `dt` and the method implied by `theta`.</span>

<span style="color: #CD5555">    Parameters</span>
<span style="color: #CD5555">    ----------</span>
<span style="color: #CD5555">    I: float</span>
<span style="color: #CD5555">        Initial condition.</span>
<span style="color: #CD5555">    a: float</span>
<span style="color: #CD5555">        Parameter in the differential equation.</span>
<span style="color: #CD5555">    T: float</span>
<span style="color: #CD5555">        Total simulation time.</span>
<span style="color: #CD5555">    theta: float, int</span>
<span style="color: #CD5555">        Parameter in the numerical scheme. 0 gives</span>
<span style="color: #CD5555">        Forward Euler, 1 Backward Euler, and 0.5</span>
<span style="color: #CD5555">        the centered Crank-Nicolson scheme.</span>

<span style="color: #CD5555">    Returns</span>
<span style="color: #CD5555">    -------</span>
<span style="color: #CD5555">    `u`: array</span>
<span style="color: #CD5555">        Solution array.</span>
<span style="color: #CD5555">    `t`: array</span>
<span style="color: #CD5555">        Array with time points corresponding to `u`.</span>

<span style="color: #CD5555">    Examples</span>
<span style="color: #CD5555">    --------</span>
<span style="color: #CD5555">    Solve :math:`u&#39; = -\\frac{1}{2}u, u(0)=1.5`</span>
<span style="color: #CD5555">    with the Crank-Nicolson method:</span>

<span style="color: #CD5555">    &gt;&gt;&gt; u, t = solver(I=1.5, a=0.5, T=9, theta=0.5)</span>
<span style="color: #CD5555">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span style="color: #CD5555">    &gt;&gt;&gt; plt.plot(t, u)</span>
<span style="color: #CD5555">    &gt;&gt;&gt; plt.show()</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
</pre></div>
<p>
If you follow such doc string conventions in your software, you can
easily produce nice manuals that meet the standard expected within
the Python scientific computing community.

<p>
<a href="http://sphinx-doc.org/" target="_self">Sphinx</a> requires quite a number of manual steps to
prepare a manual, so it is
recommended to use a <a href="http://tinyurl.com/ofkw6kc/softeng/make_sphinx_api.py" target="_self">premade script</a> to automate the steps. (By default,
the script generates documentation for all <code>*.py</code> files in the
current directory.
You need to do a <code>pip install</code> of <code>sphinx</code> and <code>numpydoc</code> to make the
script work.)
Figure <a href="#softeng1:basic:docstring:fig">2</a> provides an example of what
the above doc strings look like when Sphinx has transformed them to HTML.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Example on Sphinx API manual in HTML. <div id="softeng1:basic:docstring:fig"></div> </p></center>
<p><img src="fig-softeng/selfdoc_numpy.png" align="bottom" width=700></p>
</center>

<h2 id="softeng1:basic:logging">Logging intermediate results</h2>

<p>
Sometimes one may wish that a simulation program could write out
intermediate results for inspection. This could be accomplished by
a (global) <code>verbose</code> variable and code like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">if</span> verbose &gt;= <span style="color: #B452CD">2</span>:
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;u[%d]=%g&#39;</span> % (i, u[i])
</pre></div>
<p>
The professional way to do report intermediate results and problems is,
however, to use a <em>logger</em>. This is an object that writes messages
to a log file. The messages are classified as debug, info, and warning.

<h3 id="___sec14">Introductory example </h3>

<p>
Here is a simple example using defining a logger, using Python's <code>logging</code>
module:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">logging</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">logging</span>
logging.basicConfig(
    filename=<span style="color: #CD5555">&#39;myprog.log&#39;</span>, filemode=<span style="color: #CD5555">&#39;w&#39;</span>, level=logging.WARNING,
    format=<span style="color: #CD5555">&#39;%(asctime)s - %(levelname)s - %(message)s&#39;</span>,
    datefmt=<span style="color: #CD5555">&#39;%m/%d/%Y %I:%M:%S %p&#39;</span>)
logging.info(<span style="color: #CD5555">&#39;Here is some general info.&#39;</span>)
logging.warning(<span style="color: #CD5555">&#39;Here is a warning.&#39;</span>)
logging.debug(<span style="color: #CD5555">&#39;Here is some debugging info.&#39;</span>)
logging.critical(<span style="color: #CD5555">&#39;Dividing by zero!&#39;</span>)
logging.error(<span style="color: #CD5555">&#39;Encountered an error.&#39;</span>)
</pre></div>
<p>
Running this program gives the following output in the log file <code>myprog.log</code>:

<p>

<!-- code=text (!bc dat) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">09/26/2015 09:25:10 AM - INFO - Here is some general info.
09/26/2015 09:25:10 AM - WARNING - Here is a warning.
09/26/2015 09:25:10 AM - CRITICAL - Dividing by zero!
09/26/2015 09:25:10 AM - ERROR - Encountered an error.
</pre></div>
<p>
The logger has different <em>levels</em> of messages, ordered as
<em>critical</em>, <em>error</em>, <em>warning</em>, <em>info</em>, and <em>debug</em>.
The <code>level</code> argument to <code>logging.basicConfig</code> sets the level
and thereby determines what the logger will print to the file:
all messages at the specified <em>and lower</em> levels are printed.
For example, in the above example we set the level to be
<em>info</em>, and therefore the critical, error, warning, and info
messages were printed, but not the debug message.
Setting level to debug (<code>logging.DEBUG</code>) prints all messages,
while level <em>critical</em> prints only the critical messages.

<p>
The <code>filemode</code> argument is set to <code>w</code> such that any existing
log file is overwritten (the default is <code>a</code>, which means append
new messages to an existing log file, but this is seldom what
you want in mathematical computations).

<p>
The messages are preceded by the date and time and the level of
the message. This output is governed by the <code>format</code> argument:
<code>asctime</code> is the date and time, <code>levelname</code> is the name of
the message level, and <code>message</code> is the message itself.
Setting <code>format='%(message)s'</code> ensures that just the message and
nothing more is printed on each line. The <code>datefmt</code> string
specifies the formatting of the date and time, using the
rules of the <a href="https://docs.python.org/2/library/time.html#time.strftime" target="_self"><tt>time.strftime</tt></a> function.

<h3 id="___sec15">Using a logger in our solver function </h3>

<p>
Let us let a logger write out intermediate results and some debugging
results in the <code>solver</code> function. Such messages are useful for
monitoring the simulation and for debugging it, respectively.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">logging</span>
logging.basicConfig(
    filename=<span style="color: #CD5555">&#39;decay.log&#39;</span>, filemode=<span style="color: #CD5555">&#39;w&#39;</span>, level=logging.DEBUG,
    format=<span style="color: #CD5555">&#39;%(asctime)s - %(levelname)s - %(message)s&#39;</span>,
    datefmt=<span style="color: #CD5555">&#39;%Y.%m.%d %I:%M:%S %p&#39;</span>)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver_with_logging</span>(I, a, T, dt, theta):
    <span style="color: #CD5555">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    dt = <span style="color: #658b00">float</span>(dt)               <span style="color: #228B22"># avoid integer division</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))        <span style="color: #228B22"># no of time intervals</span>
    T = Nt*dt                    <span style="color: #228B22"># adjust T to fit time step dt</span>
    u = np.zeros(Nt+<span style="color: #B452CD">1</span>)           <span style="color: #228B22"># array of u[n] values</span>
    t = np.linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># time mesh</span>
    logging.debug(<span style="color: #CD5555">&#39;solver: dt=%g, Nt=%g, T=%g&#39;</span> % (dt, Nt, T))

    u[<span style="color: #B452CD">0</span>] = I                  <span style="color: #228B22"># assign initial condition</span>
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):    <span style="color: #228B22"># n=0,1,...,Nt-1</span>
        u[n+<span style="color: #B452CD">1</span>] = (<span style="color: #B452CD">1</span> - (<span style="color: #B452CD">1</span>-theta)*a*dt)/(<span style="color: #B452CD">1</span> + theta*dt*a)*u[n]

        logging.info(<span style="color: #CD5555">&#39;u[%d]=%g&#39;</span> % (n, u[n]))
        logging.debug(<span style="color: #CD5555">&#39;1 - (1-theta)*a*dt: %g, %s&#39;</span> %
                      (<span style="color: #B452CD">1</span>-(<span style="color: #B452CD">1</span>-theta)*a*dt,
                       <span style="color: #658b00">str</span>(<span style="color: #658b00">type</span>(<span style="color: #B452CD">1</span>-(<span style="color: #B452CD">1</span>-theta)*a*dt))[<span style="color: #B452CD">7</span>:-<span style="color: #B452CD">2</span>]))
        logging.debug(<span style="color: #CD5555">&#39;1 + theta*dt*a: %g, %s&#39;</span> %
                      (<span style="color: #B452CD">1</span> + theta*dt*a,
                       <span style="color: #658b00">str</span>(<span style="color: #658b00">type</span>(<span style="color: #B452CD">1</span> + theta*dt*a))[<span style="color: #B452CD">7</span>:-<span style="color: #B452CD">2</span>]))
    <span style="color: #8B008B; font-weight: bold">return</span> u, t
</pre></div>
<p>
We can run this new solver function in a shell:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">decay</span>
&gt;&gt;&gt; u, t = decay.solver_with_logging(I=<span style="color: #B452CD">1</span>, a=<span style="color: #B452CD">0.5</span>, T=<span style="color: #B452CD">10</span>, \ 
           dt=<span style="color: #B452CD">0.5</span>, theta=<span style="color: #B452CD">0.5</span>)
</pre></div>
<p>
During this execution, each logging message is appended to the log file.
Suppose we add some pause (<code>time.sleep(2)</code>) at each time level such that
the execution takes some time. In another terminal window we can then
monitor the evolution of <code>decay.log</code> and the simulation
by the <code>tail -f</code> Unix command:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; tail -f decay.log
<span style="color: #B452CD">2015.09</span>.<span style="color: #B452CD">26</span> <span style="color: #B452CD">05</span>:<span style="color: #B452CD">37</span>:<span style="color: #B452CD">41</span> AM - INFO - u[<span style="color: #B452CD">0</span>]=<span style="color: #B452CD">1</span>
<span style="color: #B452CD">2015.09</span>.<span style="color: #B452CD">26</span> <span style="color: #B452CD">05</span>:<span style="color: #B452CD">37</span>:<span style="color: #B452CD">41</span> AM - INFO - u[<span style="color: #B452CD">1</span>]=<span style="color: #B452CD">0.777778</span>
<span style="color: #B452CD">2015.09</span>.<span style="color: #B452CD">26</span> <span style="color: #B452CD">05</span>:<span style="color: #B452CD">37</span>:<span style="color: #B452CD">41</span> AM - INFO - u[<span style="color: #B452CD">2</span>]=<span style="color: #B452CD">0.604938</span>
<span style="color: #B452CD">2015.09</span>.<span style="color: #B452CD">26</span> <span style="color: #B452CD">05</span>:<span style="color: #B452CD">37</span>:<span style="color: #B452CD">41</span> AM - INFO - u[<span style="color: #B452CD">3</span>]=<span style="color: #B452CD">0.470508</span>
<span style="color: #B452CD">2015.09</span>.<span style="color: #B452CD">26</span> <span style="color: #B452CD">05</span>:<span style="color: #B452CD">37</span>:<span style="color: #B452CD">41</span> AM - INFO - u[<span style="color: #B452CD">4</span>]=<span style="color: #B452CD">0.36595</span>
<span style="color: #B452CD">2015.09</span>.<span style="color: #B452CD">26</span> <span style="color: #B452CD">05</span>:<span style="color: #B452CD">37</span>:<span style="color: #B452CD">41</span> AM - INFO - u[<span style="color: #B452CD">5</span>]=<span style="color: #B452CD">0.284628</span>
</pre></div>
<p>
Especially in simulation where each time step demands considerable
CPU time (minutes, hours), it can be handy to monitor such a log file
to see the evolution of the simulation.

<p>
If we want to look more closely into the numerator and denominator of
the formula for \( u^{n+1} \), we can change the logging level to
<code>level=logging.DEBUG</code> and get output in <code>decay.log</code> like

<p>

<!-- code=text (!bc dat) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">2015.09.26 05:40:01 AM - DEBUG - solver: dt=0.5, Nt=20, T=10
2015.09.26 05:40:01 AM - INFO - u[0]=1
2015.09.26 05:40:01 AM - DEBUG - 1 - (1-theta)*a*dt: 0.875, float
2015.09.26 05:40:01 AM - DEBUG - 1 + theta*dt*a: 1.125, float
2015.09.26 05:40:01 AM - INFO - u[1]=0.777778
2015.09.26 05:40:01 AM - DEBUG - 1 - (1-theta)*a*dt: 0.875, float
2015.09.26 05:40:01 AM - DEBUG - 1 + theta*dt*a: 1.125, float
2015.09.26 05:40:01 AM - INFO - u[2]=0.604938
2015.09.26 05:40:01 AM - DEBUG - 1 - (1-theta)*a*dt: 0.875, float
2015.09.26 05:40:01 AM - DEBUG - 1 + theta*dt*a: 1.125, float
2015.09.26 05:40:01 AM - INFO - u[3]=0.470508
2015.09.26 05:40:01 AM - DEBUG - 1 - (1-theta)*a*dt: 0.875, float
2015.09.26 05:40:01 AM - DEBUG - 1 + theta*dt*a: 1.125, float
2015.09.26 05:40:01 AM - INFO - u[4]=0.36595
2015.09.26 05:40:01 AM - DEBUG - 1 - (1-theta)*a*dt: 0.875, float
2015.09.26 05:40:01 AM - DEBUG - 1 + theta*dt*a: 1.125, float
</pre></div>

<h1 id="softeng1:basic:UI">User interfaces</h1>

<p>
It is good programming practice to let programs read input from
some <em>user interface</em>, rather than requiring users to <em>edit</em>
parameter values in the source code. With effective user interfaces
it becomes easier and safer to apply the code for scientific investigations and
in particular to automate large-scale investigations by other programs
(see the section <a href="#softeng1:experiments">Automating scientific experiments</a>).

<p>
Reading input data can be done in many ways. We have to decide on the
functionality of the user interface, i.e., how we want to operate the
program when providing input. Thereafter, we use appropriate tools to
implement that particular user interface. There are four basic types
of user interface, listed here according to implementational
complexity, from lowest to highest:

<ol>
<li> Questions and answers in the terminal window</li>
<li> Command-line arguments</li>
<li> Reading data from files</li>
<li> Graphical user interfaces (GUIs)</li>
</ol>

Personal preferences of user interfaces differ substantially, and it is
difficult to present recommendations or pros and cons.
Alternatives 2 and 4 are most popular and will be addressed next.
The goal is to make it easy for the user to
set physical and numerical parameters in
our <code>decay.py</code> program. We use  a little toy program, called
<code>prog.py</code>, as introductory
example:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">delta = <span style="color: #B452CD">0.5</span>
p = <span style="color: #B452CD">2</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> exp
result = delta*exp(-p)
<span style="color: #8B008B; font-weight: bold">print</span> result
</pre></div>
<p>
The essential content is that <code>prog.py</code> has two input parameters: <code>delta</code>
and <code>p</code>. A user interface will replace the first two assignments to
<code>delta</code> and <code>p</code>.

<h2 id="___sec17">Command-line arguments </h2>

<p>
The command-line arguments are all the words that appear on the
command line after the program name. Running a program <code>prog.py</code>
as <code>python prog.py arg1 arg2</code> means that there are two command-line arguments
(separated by white space): <code>arg1</code> and <code>arg2</code>.
Python stores all command-line arguments in
a special list <code>sys.argv</code>. (The name <code>argv</code> stems from the C language and
stands for &quot;argument values&quot;. In C there is also an integer variable
called <code>argc</code> reflecting the number of arguments, or &quot;argument counter&quot;.
A lot of programming languages have adopted the variable name <code>argv</code> for
the command-line arguments.)
Here is an example on a
program <code>what_is_sys_argv.py</code> that can show us what the command-line arguments
are

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sys</span>
<span style="color: #8B008B; font-weight: bold">print</span> sys.argv
</pre></div>
<p>
A sample run goes like

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python what_is_sys_argv.py 5.0 &#39;two words&#39; -1E+4
[&#39;what_is_sys_argv.py&#39;, &#39;5.0&#39;, &#39;two words&#39;, &#39;-1E+4&#39;]
</pre></div>
<p>
We make two observations:

<ul>
 <li> <code>sys.argv[0]</code> is the name of the program,
   and the sublist <code>sys.argv[1:]</code> contains all the command-line arguments.</li>
 <li> Each command-line argument is available as a string. A conversion to
   <code>float</code> is necessary if we want to compute with the numbers 5.0 and
   \( 10^4 \).</li>
</ul>

There are, in principle, two ways of programming with
command-line arguments in Python:

<ul>
 <li> <b>Positional arguments:</b> Decide upon a sequence of parameters
   on the command line and read
   their values directly from the <code>sys.argv[1:]</code> list.</li>
 <li> <b>Option-value pairs:</b>  Use <code>--option value</code> on
   the command line to replace the default value of an input parameter
   <code>option</code> by <code>value</code> (and utilize the <code>argparse.ArgumentParser</code> tool
   for implementation).</li>
</ul>

Suppose we want to run some program <code>prog.py</code> with
specification of two parameters <code>p</code> and <code>delta</code> on the command line.
With positional command-line arguments we write

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python prog.py 2 0.5
</pre></div>
<p>
and must know that the first argument <code>2</code> represents <code>p</code> and the
next <code>0.5</code> is the value of <code>delta</code>.
With option-value pairs we can run

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python prog.py --delta 0.5 --p 2
</pre></div>
<p>
Now, both <code>p</code> and <code>delta</code> are supposed to have default values in the program,
so we need to specify only the parameter that is to be changed from
its default value, e.g.,

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python prog.py --p 2         # p=2, default delta
Terminal&gt; python prog.py --delta 0.7   # delta-0.7, default a
Terminal&gt; python prog.py               # default a and delta
</pre></div>
<p>
How do we extend the <code>prog.py</code> code for positional arguments
and option-value pairs? Positional arguments require very simple
code:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sys</span>
p = <span style="color: #658b00">float</span>(sys.argv[<span style="color: #B452CD">1</span>])
delta = <span style="color: #658b00">float</span>(sys.argv[<span style="color: #B452CD">2</span>])

<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> exp
result = delta*exp(-p)
<span style="color: #8B008B; font-weight: bold">print</span> result
</pre></div>
<p>
If the user forgets to supply two command-line arguments, Python will
raise an <code>IndexError</code> exception and produce a long error message.
To avoid that, we should use a <code>try-except</code> construction:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sys</span>
<span style="color: #8B008B; font-weight: bold">try</span>:
    p = <span style="color: #658b00">float</span>(sys.argv[<span style="color: #B452CD">1</span>])
    delta = <span style="color: #658b00">float</span>(sys.argv[<span style="color: #B452CD">2</span>])
<span style="color: #8B008B; font-weight: bold">except</span> <span style="color: #008b45; font-weight: bold">IndexError</span>:
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Usage: %s p delta&#39;</span> % sys.argv[<span style="color: #B452CD">0</span>]
    sys.exit(<span style="color: #B452CD">1</span>)

<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> exp
result = delta*exp(-p)
<span style="color: #8B008B; font-weight: bold">print</span> result
</pre></div>
<p>
Using <code>sys.exit(1)</code> aborts the program. The value 1 (actually any
value different from 0) notifies the operating system that the
program failed.

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Command-line arguments are strings!</b>
<p>
Note that all elements in <code>sys.argv</code> are string objects.
If the values will enter mathematical computations, we need
to explicitly convert the strings to numbers.
</div>


<p>
Option-value pairs requires more programming and is actually
better explained in a more comprehensive example below.
Minimal code for our <code>prog.py</code> program reads

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">argparse</span>
parser = argparse.ArgumentParser()
parser.add_argument(<span style="color: #CD5555">&#39;--p&#39;</span>, default=<span style="color: #B452CD">1.0</span>)
parser.add_argument(<span style="color: #CD5555">&#39;--delta&#39;</span>, default=<span style="color: #B452CD">0.1</span>)

args = parser.parse_args()
p = args.p
delta = args.delta

<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> exp
result = delta*exp(-p)
<span style="color: #8B008B; font-weight: bold">print</span> result
</pre></div>
<p>
Because the default values of <code>delta</code> and <code>p</code> are float numbers,
the <code>args.delta</code> and <code>args.p</code> variable are automatically of type <code>float</code>.

<p>
Our next task is to use these basic code constructs to equip our
<code>decay.py</code> module with command-line interfaces.

<h2 id="___sec18">Positional command-line arguments </h2>

<p>
For our <code>decay.py</code> module file, we want include functionality such
that we can read \( I \), \( a \), \( T \), \( \theta \), and a range of \( \Delta t \)
values from the command line.  A plot is then to be made, comparing
the different numerical solutions for different \( \Delta t \) values
against the exact solution. The technical details of getting the
command-line information into the program is covered in the next
two sections.

<p>
The simplest way of reading the input parameters is to
decide on their sequence on the command line and just index
the <code>sys.argv</code> list accordingly.
Say the sequence of input data for some functionality in
<code>decay.py</code> is \( I \), \( a \), \( T \), \( \theta \) followed by an
arbitrary number of \( \Delta t \) values. This code extracts
these <em>positional</em> command-line arguments:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">read_command_line_positional</span>():
    <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">len</span>(sys.argv) &lt; <span style="color: #B452CD">6</span>:
        <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Usage: %s I a T on/off BE/FE/CN dt1 dt2 dt3 ...&#39;</span> % \ 
              sys.argv[<span style="color: #B452CD">0</span>]; sys.exit(<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># abort</span>

    I = <span style="color: #658b00">float</span>(sys.argv[<span style="color: #B452CD">1</span>])
    a = <span style="color: #658b00">float</span>(sys.argv[<span style="color: #B452CD">2</span>])
    T = <span style="color: #658b00">float</span>(sys.argv[<span style="color: #B452CD">3</span>])
    theta = <span style="color: #658b00">float</span>(sys.argv[<span style="color: #B452CD">4</span>])
    dt_values = [<span style="color: #658b00">float</span>(arg) <span style="color: #8B008B; font-weight: bold">for</span> arg <span style="color: #8B008B">in</span> sys.argv[<span style="color: #B452CD">5</span>:]]

    <span style="color: #8B008B; font-weight: bold">return</span> I, a, T, theta, dt_values
</pre></div>
<p>
Note that we may use a <code>try-except</code> construction instead of the if test.

<p>
A run like

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay.py 1 0.5 4 0.5 1.5 0.75 0.1
</pre></div>
<p>
results in

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">sys.argv = [<span style="color: #CD5555">&#39;decay.py&#39;</span>, <span style="color: #CD5555">&#39;1&#39;</span>, <span style="color: #CD5555">&#39;0.5&#39;</span>, <span style="color: #CD5555">&#39;4&#39;</span>, <span style="color: #CD5555">&#39;0.5&#39;</span>, <span style="color: #CD5555">&#39;1.5&#39;</span>, <span style="color: #CD5555">&#39;0.75&#39;</span>, <span style="color: #CD5555">&#39;0.1&#39;</span>]
</pre></div>
<p>
and consequently the assignments <code>I=1.0</code>, <code>a=0.5</code>, <code>T=4.0</code>, <code>thet=0.5</code>,
and <code>dt_values = [1.5, 0.75, 0.1]</code>.

<p>
Instead of specifying the \( \theta \) value, we could be a bit more
sophisticated and let the user write the name of the scheme:
<code>BE</code> for Backward Euler, <code>FE</code> for Forward Euler, and <code>CN</code>
for Crank-Nicolson. Then we must map this string to the proper
\( \theta \) value, an operation elegantly done by a dictionary:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">scheme = sys.argv[<span style="color: #B452CD">4</span>]
scheme2theta = {<span style="color: #CD5555">&#39;BE&#39;</span>: <span style="color: #B452CD">1</span>, <span style="color: #CD5555">&#39;CN&#39;</span>: <span style="color: #B452CD">0.5</span>, <span style="color: #CD5555">&#39;FE&#39;</span>: <span style="color: #B452CD">0</span>}
<span style="color: #8B008B; font-weight: bold">if</span> scheme <span style="color: #8B008B">in</span> scheme2theta:
    theta = scheme2theta[scheme]
<span style="color: #8B008B; font-weight: bold">else</span>:
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Invalid scheme name:&#39;</span>, scheme; sys.exit(<span style="color: #B452CD">1</span>)
</pre></div>
<p>
Now we can do

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay.py 1 0.5 4 CN 1.5 0.75 0.1
</pre></div>
<p>
and get `theta=0.5`in the code.

<h2 id="___sec19">Option-value pairs on the command line </h2>

<p>
Now we want to specify option-value pairs on the command line,
using <code>--I</code> for <code>I</code> (\( I \)), <code>--a</code> for <code>a</code> (\( a \)), <code>--T</code> for <code>T</code> (\( T \)),
<code>--scheme</code> for the scheme name (<code>BE</code>, <code>FE</code>, <code>CN</code>),
and <code>--dt</code> for the sequence of <code>dt</code> (\( \Delta t \)) values.
Each parameter must have a sensible default value so
that we specify the option on the command line only when the default
value is not suitable. Here is a typical run:

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay.py --I 2.5 --dt 0.1 0.2 0.01 --a 0.4
</pre></div>
<p>
Observe the major advantage over positional command-line arguments:
the input is much easier to read and much easier to write.
With positional arguments it is easy to mess up the sequence of
the input parameters and quite challenging to detect errors too,
unless there are just a couple of arguments.

<p>
Python's <code>ArgumentParser</code> tool in the <code>argparse</code> module makes it easy
to create a professional command-line interface to any program. The
documentation of <a href="http://docs.python.org/library/argparse.html" target="_self"><tt>ArgumentParser</tt></a> demonstrates its
versatile applications, so we shall here just list an example
containing the most basic features. It always pays off to use <code>ArgumentParser</code>
rather than trying to manually inspect and interpret option-value pairs
in <code>sys.argv</code>!

<p>
The use of <code>ArgumentParser</code> typically involves three steps:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">argparse</span>
parser = argparse.ArgumentParser()

<span style="color: #228B22"># Step 1: add arguments</span>
parser.add_argument(<span style="color: #CD5555">&#39;--option_name&#39;</span>, ...)

<span style="color: #228B22"># Step 2: interpret the command line</span>
args = parser.parse_args()

<span style="color: #228B22"># Step 3: extract values</span>
value = args.option_name
</pre></div>
<p>
A function for setting up all the options is handy:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">define_command_line_options</span>():
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">argparse</span>
    parser = argparse.ArgumentParser()
    parser.add_argument(
        <span style="color: #CD5555">&#39;--I&#39;</span>, <span style="color: #CD5555">&#39;--initial_condition&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>,
        default=<span style="color: #B452CD">1.0</span>, help=<span style="color: #CD5555">&#39;initial condition, u(0)&#39;</span>,
        metavar=<span style="color: #CD5555">&#39;I&#39;</span>)
    parser.add_argument(
        <span style="color: #CD5555">&#39;--a&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">1.0</span>,
        help=<span style="color: #CD5555">&#39;coefficient in ODE&#39;</span>, metavar=<span style="color: #CD5555">&#39;a&#39;</span>)
    parser.add_argument(
        <span style="color: #CD5555">&#39;--T&#39;</span>, <span style="color: #CD5555">&#39;--stop_time&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>,
        default=<span style="color: #B452CD">1.0</span>, help=<span style="color: #CD5555">&#39;end time of simulation&#39;</span>,
        metavar=<span style="color: #CD5555">&#39;T&#39;</span>)
    parser.add_argument(
        <span style="color: #CD5555">&#39;--scheme&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">str</span>, default=<span style="color: #CD5555">&#39;CN&#39;</span>,
        help=<span style="color: #CD5555">&#39;FE, BE, or CN&#39;</span>)
    parser.add_argument(
        <span style="color: #CD5555">&#39;--dt&#39;</span>, <span style="color: #CD5555">&#39;--time_step_values&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>,
        default=[<span style="color: #B452CD">1.0</span>], help=<span style="color: #CD5555">&#39;time step values&#39;</span>,
        metavar=<span style="color: #CD5555">&#39;dt&#39;</span>, nargs=<span style="color: #CD5555">&#39;+&#39;</span>, dest=<span style="color: #CD5555">&#39;dt_values&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">return</span> parser
</pre></div>
<p>
Each command-line option is defined through the <code>parser.add_argument</code>
method [<a id="link_footnote_1" href="#def_footnote_1">1</a>]. Alternative options, like the short <code>--I</code> and the more
explaining version <code>--initial_condition</code> can be defined. Other arguments
are <code>type</code> for the Python object type, a default value, and a help
string, which gets printed if the command-line argument <code>-h</code> or <code>--help</code> is
included. The <code>metavar</code> argument specifies the value associated with
the option when the help string is printed. For example, the option for
\( I \) has this help output:

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay.py -h
  ...
  --I I, --initial_condition I
                        initial condition, u(0)
  ...
</pre></div>
<p>
The structure of this output is

<p>

<!-- code=text typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">  --I metavar, --initial_condition metavar
                        help-string
</pre></div>
<p id="def_footnote_1"><a href="#link_footnote_1"><b>1:</b></a> We use the expression <em>method</em> here, because <code>parser</code>
is a class variable and functions in classes are known as methods in Python
and many other languages.
Readers not familiar with class programming can just substitute
this use of <em>method</em> by <em>function</em>.</p>

<p>
Finally, the <code>--dt</code> option demonstrates how to allow for more than one
value (separated by blanks) through the <code>nargs='+'</code> keyword argument.
After the command line is parsed, we get an object where the values of
the options are stored as attributes. The attribute name is specified
by the <code>dist</code> keyword argument, which for the <code>--dt</code> option is
<code>dt_values</code>. Without the <code>dest</code> argument, the value of an option <code>--opt</code>
is stored as the attribute <code>opt</code>.

<p>
The code below demonstrates how to read the command line and extract
the values for each option:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">read_command_line_argparse</span>():
    parser = define_command_line_options()
    args = parser.parse_args()
    scheme2theta = {<span style="color: #CD5555">&#39;BE&#39;</span>: <span style="color: #B452CD">1</span>, <span style="color: #CD5555">&#39;CN&#39;</span>: <span style="color: #B452CD">0.5</span>, <span style="color: #CD5555">&#39;FE&#39;</span>: <span style="color: #B452CD">0</span>}
    data = (args.I, args.a, args.T, scheme2theta[args.scheme],
            args.dt_values)
    <span style="color: #8B008B; font-weight: bold">return</span> data
</pre></div>
<p>
As seen, the values of the command-line options are available as
attributes in <code>args</code>: <code>args.opt</code> holds the value of option <code>--opt</code>, unless
we used the <code>dest</code> argument (as for <code>--dt_values</code>) for specifying the
attribute name. The <code>args.opt</code> attribute has the object type specified
by <code>type</code> (<code>str</code> by default).

<p>
The making of the plot is not dependent on whether we read data from
the command line as positional arguments or option-value pairs:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">experiment_compare_dt</span>(option_value_pairs=<span style="color: #658b00">False</span>):
    I, a, T, theta, dt_values = \ 
       read_command_line_argparse() <span style="color: #8B008B; font-weight: bold">if</span> option_value_pairs <span style="color: #8B008B; font-weight: bold">else</span> \ 
       read_command_line_positional()

    legends = []
    <span style="color: #8B008B; font-weight: bold">for</span> dt <span style="color: #8B008B">in</span> dt_values:
        u, t = solver(I, a, T, dt, theta)
        plt.plot(t, u)
        legends.append(<span style="color: #CD5555">&#39;dt=%g&#39;</span> % dt)
    t_e = np.linspace(<span style="color: #B452CD">0</span>, T, <span style="color: #B452CD">1001</span>)       <span style="color: #228B22"># very fine mesh for u_e</span>
    u_e = u_exact(t_e, I, a)
    plt.plot(t_e, u_e, <span style="color: #CD5555">&#39;--&#39;</span>)
    legends.append(<span style="color: #CD5555">&#39;exact&#39;</span>)
    plt.legend(legends, loc=<span style="color: #CD5555">&#39;upper right&#39;</span>)
    plt.title(<span style="color: #CD5555">&#39;theta=%g&#39;</span> % theta)
    plotfile = <span style="color: #CD5555">&#39;tmp&#39;</span>
    plt.savefig(plotfile + <span style="color: #CD5555">&#39;.png&#39;</span>);  plt.savefig(plotfile + <span style="color: #CD5555">&#39;.pdf&#39;</span>)
</pre></div>

<h2 id="___sec20">Creating a graphical web user interface </h2>

<p>
The Python package <a href="https://github.com/hplgit/parampool" target="_self">Parampool</a>
can be used to automatically generate a web-based <em>graphical user interface</em>
(GUI) for our simulation program. Although the programming technique
dramatically simplifies the efforts to create a GUI, the forthcoming
material on equipping our <code>decay</code> module with a GUI is quite technical
and of significantly less importance than knowing how to make
a command-line interface.

<h3 id="___sec21">Making a compute function </h3>

<p>
The first step is to identify a function
that performs the computations and that takes the necessary input
variables as arguments. This is called the <em>compute function</em> in
Parampool terminology. The purpose of this function is to take
values of \( I \), \( a \), \( T \) together with a sequence of \( \Delta t \) values
and a sequence of \( \theta \) and plot the numerical against the
exact solution for each pair of \( (\theta, \Delta t) \).
The plots can be arranged as a table with the columns being scheme type
(\( \theta \) value) and the rows reflecting the discretization parameter
(\( \Delta t \) value). Figure <a href="#softeng1:fig:GUI">3</a> displays what the
graphical web interface may look like after results are computed
(there are \( 3\times 3 \) plots in the GUI, but only \( 2\times 2 \) are
visible in the figure).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Automatically generated graphical web interface. <div id="softeng1:fig:GUI"></div> </p></center>
<p><img src="fig-softeng/web_GUI.png" align="bottom" width=800></p>
</center>

<p>
To tell Parampool what type of input data we have,
we assign default values of the right type to all arguments in the
compute function, here called <code>main_GUI</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">main_GUI</span>(I=<span style="color: #B452CD">1.0</span>, a=.<span style="color: #B452CD">2</span>, T=<span style="color: #B452CD">4.0</span>,
             dt_values=[<span style="color: #B452CD">1.25</span>, <span style="color: #B452CD">0.75</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">0.1</span>],
             theta_values=[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1</span>]):
</pre></div>
<p>
The compute function must return the HTML code we want for displaying
the result in a web page. Here we want to show a
table of plots.
Assume for now that the HTML code for one plot and the value of the
norm of the error can be computed by some other function <code>compute4web</code>.
The <code>main_GUI</code> function can then loop over \( \Delta t \) and \( \theta \)
values and put each plot in an HTML table. Appropriate code goes like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">main_GUI</span>(I=<span style="color: #B452CD">1.0</span>, a=.<span style="color: #B452CD">2</span>, T=<span style="color: #B452CD">4.0</span>,
             dt_values=[<span style="color: #B452CD">1.25</span>, <span style="color: #B452CD">0.75</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">0.1</span>],
             theta_values=[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1</span>]):
    <span style="color: #228B22"># Build HTML code for web page. Arrange plots in columns</span>
    <span style="color: #228B22"># corresponding to the theta values, with dt down the rows</span>
    theta2name = {<span style="color: #B452CD">0</span>: <span style="color: #CD5555">&#39;FE&#39;</span>, <span style="color: #B452CD">1</span>: <span style="color: #CD5555">&#39;BE&#39;</span>, <span style="color: #B452CD">0.5</span>: <span style="color: #CD5555">&#39;CN&#39;</span>}
    html_text = <span style="color: #CD5555">&#39;&lt;table&gt;\n&#39;</span>
    <span style="color: #8B008B; font-weight: bold">for</span> dt <span style="color: #8B008B">in</span> dt_values:
        html_text += <span style="color: #CD5555">&#39;&lt;tr&gt;\n&#39;</span>
        <span style="color: #8B008B; font-weight: bold">for</span> theta <span style="color: #8B008B">in</span> theta_values:
            E, html = compute4web(I, a, T, dt, theta)
            html_text += <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">&lt;td&gt;</span>
<span style="color: #CD5555">&lt;center&gt;&lt;b&gt;%s, dt=%g, error: %.3E&lt;/b&gt;&lt;/center&gt;&lt;br&gt;</span>
<span style="color: #CD5555">%s</span>
<span style="color: #CD5555">&lt;/td&gt;</span>
<span style="color: #CD5555">&quot;&quot;&quot;</span> % (theta2name[theta], dt, E, html)
        html_text += <span style="color: #CD5555">&#39;&lt;/tr&gt;\n&#39;</span>
    html_text += <span style="color: #CD5555">&#39;&lt;/table&gt;\n&#39;</span>
    <span style="color: #8B008B; font-weight: bold">return</span> html_text
</pre></div>
<p>
Making one plot is done in <code>compute4web</code>. The statements should be
straightforward from earlier examples, but there is one new feature:
we use a tool in Parampool to embed the PNG code for a plot file
directly in an HTML image tag. The details are hidden from the
programmer, who can just rely on
relevant HTML code in the string <code>html_text</code>. The function looks like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">compute4web</span>(I, a, T, dt, theta=<span style="color: #B452CD">0.5</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Run a case with the solver, compute error measure,</span>
<span style="color: #CD5555">    and plot the numerical and exact solutions in a PNG</span>
<span style="color: #CD5555">    plot whose data are embedded in an HTML image tag.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    u, t = solver(I, a, T, dt, theta)
    u_e = u_exact(t, I, a)
    e = u_e - u
    E = np.sqrt(dt*np.sum(e**<span style="color: #B452CD">2</span>))

    plt.figure()
    t_e = np.linspace(<span style="color: #B452CD">0</span>, T, <span style="color: #B452CD">1001</span>)    <span style="color: #228B22"># fine mesh for u_e</span>
    u_e = u_exact(t_e, I, a)
    plt.plot(t,   u,   <span style="color: #CD5555">&#39;r--o&#39;</span>)
    plt.plot(t_e, u_e, <span style="color: #CD5555">&#39;b-&#39;</span>)
    plt.legend([<span style="color: #CD5555">&#39;numerical&#39;</span>, <span style="color: #CD5555">&#39;exact&#39;</span>])
    plt.xlabel(<span style="color: #CD5555">&#39;t&#39;</span>)
    plt.ylabel(<span style="color: #CD5555">&#39;u&#39;</span>)
    plt.title(<span style="color: #CD5555">&#39;theta=%g, dt=%g&#39;</span> % (theta, dt))
    <span style="color: #228B22"># Save plot to HTML img tag with PNG code as embedded data</span>
    <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">parampool.utils</span> <span style="color: #8B008B; font-weight: bold">import</span> save_png_to_str
    html_text = save_png_to_str(plt, plotwidth=<span style="color: #B452CD">400</span>)

    <span style="color: #8B008B; font-weight: bold">return</span> E, html_text
</pre></div>

<h3 id="___sec22">Generating the user interface </h3>

<p>
The web GUI is automatically generated by
the following code, placed in the file <a href="http://tinyurl.com/ofkw6kc/softeng/decay_GUI_generate.py" target="_self"><tt>decay_GUI_generate.py</tt></a>.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">parampool.generator.flask</span> <span style="color: #8B008B; font-weight: bold">import</span> generate
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">decay</span> <span style="color: #8B008B; font-weight: bold">import</span> main_GUI
generate(main_GUI,
         filename_controller=<span style="color: #CD5555">&#39;decay_GUI_controller.py&#39;</span>,
         filename_template=<span style="color: #CD5555">&#39;decay_GUI_view.py&#39;</span>,
         filename_model=<span style="color: #CD5555">&#39;decay_GUI_model.py&#39;</span>)
</pre></div>
<p>
Running the <code>decay_GUI_generate.py</code> program results in three new
files whose names are specified in the call to <code>generate</code>:

<ol>
 <li> <code>decay_GUI_model.py</code> defines HTML widgets to be used to set
    input data in the web interface,</li>
 <li> <code>templates/decay_GUI_views.py</code> defines the layout of the web page,</li>
 <li> <code>decay_GUI_controller.py</code> runs the web application.</li>
</ol>

We only need to run the last program, and there is no need to look into
these files.

<h3 id="___sec23">Running the web application </h3>

<p>
The web GUI is started by

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay_GUI_controller.py
</pre></div>
<p>
Open a web browser at the location <code>127.0.0.1:5000</code>. Input fields for
<code>I</code>, <code>a</code>, <code>T</code>, <code>dt_values</code>, and <code>theta_values</code> are presented.  Figure
<a href="#softeng1:fig:GUI">3</a> shows a part of the resulting page if we run
with the default values for the input parameters.
With the techniques demonstrated here, one can
easily create a tailored web GUI for a particular type of application
and use it to interactively explore physical and numerical effects.

<h1 id="___sec24">Tests for verifying implementations </h1>

<p>
Any module with functions should have a set of tests that can
check the
correctness of the implementations.
There exists
well-established procedures and corresponding tools for automating
the execution of such tests. These tools allow large test sets to be
run with a one-line command, making it easy to check of the
still software works (as far as the
tests tell!). Here we shall illustrate two important
software testing techniques: <em>doctest</em> and <em>unit testing</em>.
The first one is Python specific, while unit testing is the dominating
test technique in the software industry today.

<h2 id="___sec25">Doctests </h2>

<p>
A doc string, the first string after the function header, is used to
document the purpose of functions and their arguments
(see the section <a href="#softeng1:basic:func">Implementing the numerical algorithm in a function</a>). Very often it
is instructive to include an example in the doc string
on how to use the function.
Interactive examples in the Python shell are most illustrative as
we can see the output resulting from the statements and expressions.
For example,
in the <code>solver</code> function, we can include an example on calling
this function and printing the computed <code>u</code> and <code>t</code> arrays:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, a, T, dt, theta):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.</span>


<span style="color: #CD5555">    &gt;&gt;&gt; u, t = solver(I=0.8, a=1.2, T=1.5, dt=0.5, theta=0.5)</span>
<span style="color: #CD5555">    &gt;&gt;&gt; for n in range(len(t)):</span>
<span style="color: #CD5555">    ...     print &#39;t=%.1f, u=%.14f&#39; % (t[n], u[n])</span>
<span style="color: #CD5555">    t=0.0, u=0.80000000000000</span>
<span style="color: #CD5555">    t=0.5, u=0.43076923076923</span>
<span style="color: #CD5555">    t=1.0, u=0.23195266272189</span>
<span style="color: #CD5555">    t=1.5, u=0.12489758761948</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    ...
</pre></div>
<p>
When such interactive demonstrations are inserted in doc strings,
Python's <a href="http://docs.python.org/library/doctest.html" target="_self"><tt>doctest</tt></a>
module can be used to automate running all commands
in interactive sessions and compare new output with the output
appearing in the doc string.  All we have to do in the current example
is to run the module file <code>decay.py</code> with

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python -m doctest decay.py
</pre></div>
<p>
This command imports the <code>doctest</code> module, which runs all
doctests found in the file and reports discrepancies between
expected and computed output.
Alternatively, the test block in a module may run all doctests
by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">if</span> __name__ == <span style="color: #CD5555">&#39;__main__&#39;</span>:
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">doctest</span>
    doctest.testmod()
</pre></div>
<p>
Doctests can also be embedded in nose/pytest unit tests
as explained in the next section.

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Doctests prevent command-line arguments!</b>
<p>
No additional command-line argument is allowed when running doctests.
If your program relies on command-line input, make sure the doctests
can be run <em>without</em> such input on the command line.

<p>
However, you can simulate command-line input by filling <code>sys.argv</code>
with values, e.g.,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eee8d5"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sys</span>; sys.argv = <span style="color: #CD5555">&#39;--I 1.0 --a 5&#39;</span>.split()
</pre></div>

</div>


<p>
The execution command above will report any problem if a test fails.
As an illustration, let us alter the <code>u</code> value at <code>t=1.5</code> in
the output of the doctest by replacing the last digit <code>8</code> by <code>7</code>.
This edit triggers a report:

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python -m doctest decay.py
********************************************************
File &quot;decay.py&quot;, line ...
Failed example:
    for n in range(len(t)):
        print &#39;t=%.1f, u=%.14f&#39; % (t[n], u[n])
Expected:
    t=0.0, u=0.80000000000000
    t=0.5, u=0.43076923076923
    t=1.0, u=0.23195266272189
    t=1.5, u=0.12489758761948
Got:
    t=0.0, u=0.80000000000000
    t=0.5, u=0.43076923076923
    t=1.0, u=0.23195266272189
    t=1.5, u=0.12489758761947
</pre></div>
<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Pay attention to the number of digits in doctest results!</b>
<p>
Note that in the output of <code>t</code> and <code>u</code> we write <code>u</code> with 14 digits.
Writing all 16 digits is not a good idea: if the tests are run on
different hardware, round-off errors might be different, and
the <code>doctest</code> module detects that the numbers are not precisely the same
and reports failures. In the present application, where \( 0 < u(t) \leq 0.8 \),
we expect round-off errors to be of size \( 10^{-16} \), so comparing 15
digits would probably be reliable, but we compare 14 to be on the
safe side. On the other hand, comparing a small number of digits may
hide software errors.
</div>


<p>
Doctests are highly encouraged as they do two things: 1) demonstrate
how a function is used and 2) test that the function works.

<h2 id="___sec26">Unit tests and test functions </h2>

<p>
The unit testing technique consists of identifying smaller units
of code and writing one or more tests for
each unit. One unit can typically be a function.
Each test should, ideally, not depend on the outcome of
other tests. The recommended practice is actually to
design and write the unit tests first and <em>then</em> implement the functions!

<p>
In scientific computing it is not always obvious how to best perform
unit testing. The units are naturally larger than in non-scientific
software. Very often the solution procedure of a mathematical problem
identifies a unit, such as our <code>solver</code> function.

<h3 id="___sec27">Two Python test frameworks: nose and pytest </h3>

<p>
Python offers two very easy-to-use software frameworks for implementing
unit tests: nose and pytest. These work (almost) in the same way,
but our recommendation is to go for pytest.

<h3 id="___sec28">Test function requirements </h3>

<p>
For a test to qualify as a <em>test function</em> in nose or pytest, three
rules must be followed:

<ol>
 <li> The function name must start with <code>test_</code>.</li>
 <li> Function arguments are not allowed.</li>
 <li> An <code>AssertionError</code> exception must be raised if the test fails.</li>
</ol>

A specific example might be illustrative before proceeding.
We have the following function that we want to test:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">double</span>(n):
    <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">2</span>*n
</pre></div>
<p>
The corresponding test function could, in principle, have been written
as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_double</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;Test that double(n) works for one specific n.&quot;&quot;&quot;</span>
    n = <span style="color: #B452CD">4</span>
    expected = <span style="color: #B452CD">2</span>*<span style="color: #B452CD">4</span>
    computed = double(<span style="color: #B452CD">4</span>)
    <span style="color: #8B008B; font-weight: bold">if</span> expected != computed:
        <span style="color: #8B008B; font-weight: bold">raise</span> <span style="color: #008b45; font-weight: bold">AssertionError</span>
</pre></div>
<p>
The last two lines, however, are never written like this in test functions.
Instead, Python's <code>assert</code> statement is used: <code>assert success, msg</code>, where
<code>success</code> is a boolean variable, which is <code>False</code> if the test fails, and
<code>msg</code> is <em>an optional</em> message string that is printed when the test fails.
A better version of the test function is therefore

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_double</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;Test that double(n) works for one specific n.&quot;&quot;&quot;</span>
    n = <span style="color: #B452CD">4</span>
    expected = <span style="color: #B452CD">2</span>*<span style="color: #B452CD">4</span>
    computed = double(<span style="color: #B452CD">4</span>)
    msg = <span style="color: #CD5555">&#39;expected %g, computed %g&#39;</span> % (expected, computed)
    success = expected == computed
    <span style="color: #8B008B; font-weight: bold">assert</span> success, msg
</pre></div>

<h3 id="___sec29">Comparison of real numbers </h3>

<p>
Because of the finite precision arithmetics on a computer, which gives
rise to round-off errors, the <code>==</code> operator is not suitable for
checking whether two real numbers are equal. Obviously, this principle
also applies to tests in test functions.
We must therefore replace <code>a == b</code> by a comparison
based on a tolerance <code>tol</code>: <code>abs(a-b) &lt; tol</code>. The next example illustrates
the problem and its solution.

<p>
Here is a slightly different function that
we want to test:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">third</span>(x):
    <span style="color: #8B008B; font-weight: bold">return</span> x/<span style="color: #B452CD">3.</span>
</pre></div>
<p>
We write a test function where the expected result is computed as
\( \frac{1}{3}x \) rather than \( x/3 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_third</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;Check that third(x) works for many x values.&quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">for</span> x <span style="color: #8B008B">in</span> np.linspace(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">21</span>):
        expected = (<span style="color: #B452CD">1</span>/<span style="color: #B452CD">3.0</span>)*x
        computed = third(x)
        success = expected == computed
        <span style="color: #8B008B; font-weight: bold">assert</span> success
</pre></div>
<p>
This <code>test_third</code> function executes silently, i.e., no failure,
until <code>x</code> becomes 0.15. Then round-off errors make the <code>==</code> comparison
<code>False</code>. In fact, seven of the <code>x</code> values above face this problem.
The solution is to compare <code>expected</code> and <code>computed</code>
with a small tolerance:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_third</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;Check that third(x) works for many x values.&quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">for</span> x <span style="color: #8B008B">in</span> np.linspace(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">21</span>):
        expected = (<span style="color: #B452CD">1</span>/<span style="color: #B452CD">3.</span>)*x
        computed = third(x)
        tol = <span style="color: #B452CD">1E-15</span>
        success = <span style="color: #658b00">abs</span>(expected - computed) &lt; tol
        <span style="color: #8B008B; font-weight: bold">assert</span> success
</pre></div>
<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Always compare real numbers with a tolerance!</b>
<p>
Real numbers should never be compared with the <code>==</code> operator, but always
with the absolute value of the difference and a tolerance.
So, replace <code>a == b</code>, if <code>a</code> and/or <code>b</code> is <code>float</code>, by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eee8d5"><pre style="line-height: 125%">tol = <span style="color: #B452CD">1E-14</span>
<span style="color: #658b00">abs</span>(a - b) &lt; tol
</pre></div>
<p>
The suitable size of <code>tol</code> depends on the size of <code>a</code> and <code>b</code>
(see <a href="#softeng1:exer:tol">Problem 5: Experiment with tolerances in comparisons</a>).
</div>


<h3 id="___sec30">Special assert functions from nose </h3>

<p>
Test frameworks often contain more tailored
<em>assert functions</em> that can be called instead of using the <code>assert</code>
statement. For example, comparing two objects within
a tolerance, as in the present
case, can be done by the <code>assert_almost_equal</code> from the nose
framework:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">nose.tools</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">nt</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_third</span>():
    x = <span style="color: #B452CD">0.15</span>
    expected = (<span style="color: #B452CD">1</span>/<span style="color: #B452CD">3.</span>)*x
    computed = third(x)
    nt.assert_almost_equal(
        expected, computed, delta=<span style="color: #B452CD">1E-15</span>,
        msg=<span style="color: #CD5555">&#39;diff=%.17E&#39;</span> % (expected - computed))
</pre></div>
<p>
Whether to use the plain <code>assert</code> statement with a comparison based on
a tolerance or to use the ready-made function <code>assert_almost_equal</code>
depends on the programmer's preference. The examples used in the
documentation of the pytest framework stick to the plain <code>assert</code>
statement.

<h3 id="___sec31">Locating test functions </h3>

<p>
Test functions can reside in a module together with the functions they
are supposed to verify, or the test functions can be collected in
separate files having names starting with <code>test</code>. Actually,
nose and pytest can recursively run all test functions
in all <code>test*.py</code>
files in the current directory, as well as in all subdirectories!

<p>
The <a href="http://tinyurl.com/ofkw6kc/softeng/decay.py" target="_self"><tt>decay.py</tt></a> module file features
test functions in the module, but we could equally well have made
a subdirectory <code>tests</code> and put the test functions in
<a href="http://tinyurl.com/ofkw6kc/softeng/tests/test_decay.py" target="_self"><tt>tests/test_decay.py</tt></a>.

<h3 id="___sec32">Running tests </h3>

<p>
To run all test functions in the file <code>decay.py</code> do

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; nosetests -s -v decay.py
Terminal&gt; py.test -s -v decay.py
</pre></div>
<p>
The <code>-s</code> option ensures that output from the test functions is printed
in the terminal window, while <code>-v</code> prints the outcome of each individual
test function.

<p>
Alternatively, if the test functions are located in some separate
<code>test*.py</code> files,
we can just write

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; py.test -s -v
</pre></div>
<p>
to <em>recursively</em> run <em>all</em> test functions in the current
directory tree. The corresponding

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; nosetests -s -v
</pre></div>
<p>
command does the same, but requires subdirectory names to start
with <code>test</code> or end with <code>_test</code> or <code>_tests</code> (which is a good habit anyway).
An example of a <code>tests</code> directory with a <code>test*.py</code>
file is found in <a href="http://tinyurl.com/ofkw6kc/softeng/tests" target="_self"><tt>src/softeng/tests</tt></a>.

<h3 id="___sec33">Embedding doctests in a test function </h3>

<p>
Doctests can also be executed from nose/pytest unit tests. Here is an
example of a file <a href="http://tinyurl.com/ofkw6kc/softeng/tests/test_decay_doctest.py" target="_self"><tt>test_decay_doctest.py</tt></a> where we in the test
block run all the doctests in the imported module <code>decay</code>, but we also
include a local test function that does the same:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sys</span>, <span style="color: #008b45; text-decoration: underline">os</span>
sys.path.insert(<span style="color: #B452CD">0</span>, os.pardir)
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">decay</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">doctest</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_decay_module_with_doctest</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;Doctest embedded in a nose/pytest unit test.&quot;&quot;&quot;</span>
    <span style="color: #228B22"># Test all functions with doctest in module decay</span>
    failure_count, test_count = doctest.testmod(m=decay)
    <span style="color: #8B008B; font-weight: bold">assert</span> failure_count == <span style="color: #B452CD">0</span>

<span style="color: #8B008B; font-weight: bold">if</span> __name__ == <span style="color: #CD5555">&#39;__main__&#39;</span>:
    <span style="color: #228B22"># Run all functions with doctests in this module</span>
    failure_count, test_count = doctest.testmod(m=decay)
</pre></div>
<p>
Running this file as a program from the command line
triggers the <code>doctest.testmod</code> call
in the test block, while applying <code>py.test</code> or <code>nosetests</code> to the file triggers
an import of the file and execution of the test function
<code>test_decay_modue_with_doctest</code>.

<h3 id="___sec34">Installing nose and pytest </h3>

<p>
With <code>pip</code> available, it is trivial to install nose and/or pytest:
<code>sudo pip install nose</code> and <code>sudo pip install pytest</code>.

<h2 id="___sec35">Test function for the solver </h2>

<p>
Finding good test problems for verifying the implementation of numerical
methods is a topic on its own. The challenge is that we very seldom know
what the numerical errors are. For the present model problem
<a href="#mjx-eqn-1">(1)</a>-<a href="#mjx-eqn-2">(2)</a> solved by
<a href="#mjx-eqn-3">(3)</a> one can, fortunately, derive a formula for
the numerical approximation:

$$ u^n = I\left(
\frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t}
\right)^n\tp$$

Then we know that the implementation should
produce numbers that agree with this formula to machine precision.
The formula for \( u^n \) is known as an <em>exact discrete solution</em> of the
problem and can be coded as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">u_discrete_exact</span>(n, I, a, theta, dt):
    <span style="color: #CD5555">&quot;&quot;&quot;Return exact discrete solution of the numerical schemes.&quot;&quot;&quot;</span>
    dt = <span style="color: #658b00">float</span>(dt)  <span style="color: #228B22"># avoid integer division</span>
    A = (<span style="color: #B452CD">1</span> - (<span style="color: #B452CD">1</span>-theta)*a*dt)/(<span style="color: #B452CD">1</span> + theta*dt*a)
    <span style="color: #8B008B; font-weight: bold">return</span> I*A**n
</pre></div>
<p>
A test function can evaluate this solution on a time mesh
and check that the <code>u</code> values produced by the <code>solver</code> function
do not deviate with more than a small tolerance:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_u_discrete_exact</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;Check that solver reproduces the exact discr. sol.&quot;&quot;&quot;</span>
    theta = <span style="color: #B452CD">0.8</span>; a = <span style="color: #B452CD">2</span>; I = <span style="color: #B452CD">0.1</span>; dt = <span style="color: #B452CD">0.8</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #B452CD">8</span>/dt)  <span style="color: #228B22"># no of steps</span>
    u, t = solver(I=I, a=a, T=Nt*dt, dt=dt, theta=theta)

    <span style="color: #228B22"># Evaluate exact discrete solution on the mesh</span>
    u_de = np.array([u_discrete_exact(n, I, a, theta, dt)
                     <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Nt+<span style="color: #B452CD">1</span>)])

    <span style="color: #228B22"># Find largest deviation</span>
    diff = np.abs(u_de - u).max()
    tol = <span style="color: #B452CD">1E-14</span>
    success = diff &lt; tol
    <span style="color: #8B008B; font-weight: bold">assert</span> success
</pre></div>
<p>
Among important things to consider when constructing test functions
is testing the effect of wrong input to the function being tested.
In our <code>solver</code> function, for example, integer values of \( a \), \( \Delta t \), and
\( \theta \) may cause unintended integer
division. We should therefore add a test to make sure our <code>solver</code>
function does not fall into this potential trap:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_potential_integer_division</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;Choose variables that can trigger integer division.&quot;&quot;&quot;</span>
    theta = <span style="color: #B452CD">1</span>; a = <span style="color: #B452CD">1</span>; I = <span style="color: #B452CD">1</span>; dt = <span style="color: #B452CD">2</span>
    Nt = <span style="color: #B452CD">4</span>
    u, t = solver(I=I, a=a, T=Nt*dt, dt=dt, theta=theta)
    u_de = np.array([u_discrete_exact(n, I, a, theta, dt)
                     <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Nt+<span style="color: #B452CD">1</span>)])
    diff = np.abs(u_de - u).max()
    <span style="color: #8B008B; font-weight: bold">assert</span> diff &lt; <span style="color: #B452CD">1E-14</span>
</pre></div>
<p>
In more complicated problems where there is no exact solution of the
numerical problem solved by the software, one must use the method
of manufactured solutions, compute convergence rates for a series
of \( \Delta t \) values, and check that the rates converges to the
expected ones (from theory).

<h2 id="___sec36">Test function for reading positional command-line arguments </h2>

<p>
The function <code>read_command_line_positional</code> extracts numbers from the
command line. To test it, we must decide on a set of values for
the input data, fill <code>sys.argv</code>
accordingly, and check that we get the expected values:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_read_command_line_positional</span>():
    <span style="color: #228B22"># Decide on a data set of input parameters</span>
    I = <span style="color: #B452CD">1.6</span>;  a = <span style="color: #B452CD">1.8</span>;  T = <span style="color: #B452CD">2.2</span>;  theta = <span style="color: #B452CD">0.5</span>
    dt_values = [<span style="color: #B452CD">0.1</span>, <span style="color: #B452CD">0.2</span>, <span style="color: #B452CD">0.05</span>]
    <span style="color: #228B22"># Expected return from read_command_line_positional</span>
    expected = [I, a, T, theta, dt_values]
    <span style="color: #228B22"># Construct corresponding sys.argv array</span>
    sys.argv = [sys.argv[<span style="color: #B452CD">0</span>], <span style="color: #658b00">str</span>(I), <span style="color: #658b00">str</span>(a), <span style="color: #658b00">str</span>(T), <span style="color: #CD5555">&#39;CN&#39;</span>] + \ 
               [<span style="color: #658b00">str</span>(dt) <span style="color: #8B008B; font-weight: bold">for</span> dt <span style="color: #8B008B">in</span> dt_values]
    computed = read_command_line_positional()
    <span style="color: #8B008B; font-weight: bold">for</span> expected_arg, computed_arg <span style="color: #8B008B">in</span> <span style="color: #658b00">zip</span>(expected, computed):
        <span style="color: #8B008B; font-weight: bold">assert</span> expected_arg == computed_arg
</pre></div>
<p>
Note that <code>sys.argv[0]</code> is always the program name and that we have to
copy that string from the original <code>sys.argv</code> array to the new one we
construct in the test function. (Actually, this test function destroys
the original <code>sys.argv</code> that Python fetched from the command line.)

<p>
Any numerical code writer should always be skeptical to the use of the exact
equality operator <code>==</code> in test functions, since round-off errors often
come into play. Here, however, we set some real values, convert them
to strings and convert back again to real numbers (of the same precision).
This string-number conversion does not involve any finite precision
arithmetics effects so we
can safely use <code>==</code> in tests. Note also that the last element in
<code>expected</code> and <code>computed</code> is the list <code>dt_values</code>, and <code>==</code> works
for comparing two lists as well.

<h2 id="___sec37">Test function for reading option-value pairs </h2>

<p>
The function <code>read_command_line_argparse</code> can be verified with a
test function that has the same setup as <code>test_read_command_line_positional</code>
above.
However, the construction of the command line is a bit more complicated.
We find it convenient to construct the line as a string and then
split the line into words to get the desired list <code>sys.argv</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_read_command_line_argparse</span>():
    I = <span style="color: #B452CD">1.6</span>;  a = <span style="color: #B452CD">1.8</span>;  T = <span style="color: #B452CD">2.2</span>;  theta = <span style="color: #B452CD">0.5</span>
    dt_values = [<span style="color: #B452CD">0.1</span>, <span style="color: #B452CD">0.2</span>, <span style="color: #B452CD">0.05</span>]
    <span style="color: #228B22"># Expected return from read_command_line_argparse</span>
    expected = [I, a, T, theta, dt_values]
    <span style="color: #228B22"># Construct corresponding sys.argv array</span>
    command_line = <span style="color: #CD5555">&#39;%s --a %s --I %s --T %s --scheme CN --dt &#39;</span> % \ 
                   (sys.argv[<span style="color: #B452CD">0</span>], a, I, T)
    command_line += <span style="color: #CD5555">&#39; &#39;</span>.join([<span style="color: #658b00">str</span>(dt) <span style="color: #8B008B; font-weight: bold">for</span> dt <span style="color: #8B008B">in</span> dt_values])
    sys.argv = command_line.split()
    computed = read_command_line_argparse()
    <span style="color: #8B008B; font-weight: bold">for</span> expected_arg, computed_arg <span style="color: #8B008B">in</span> <span style="color: #658b00">zip</span>(expected, computed):
        <span style="color: #8B008B; font-weight: bold">assert</span> expected_arg == computed_arg
</pre></div>
<p>
Recall that the Python function <code>zip</code> enables iteration over
several lists, tuples, or arrays at the same time.

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Let silent test functions speak up during development!</b>
<p>
When you develop test functions in a module, it is common to use IPython
for interactive experimentation:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eee8d5"><pre style="line-height: 125%">In[<span style="color: #B452CD">1</span>]: <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">decay</span>

In[<span style="color: #B452CD">2</span>]: decay.test_read_command_line_argparse()
</pre></div>
<p>
Note that a working test function is completely silent! Many
find it psychologically annoying to convince themselves that a
completely silent function is doing the right things. It can therefore,
during development of a test function, be convenient to insert
print statements in the function to monitor that the function body
is indeed executed. For example, one can print the expected and
computed values in the terminal window:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eee8d5"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_read_command_line_argparse</span>():
    ...
    <span style="color: #8B008B; font-weight: bold">for</span> expected_arg, computed_arg <span style="color: #8B008B">in</span> <span style="color: #658b00">zip</span>(expected, computed):
        <span style="color: #8B008B; font-weight: bold">print</span> expected_arg, computed_arg
        <span style="color: #8B008B; font-weight: bold">assert</span> expected_arg == computed_arg
</pre></div>
<p>
After performing this edit, we want to run the test again, but
in IPython the module must first be reloaded (reimported):

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eee8d5"><pre style="line-height: 125%">In[<span style="color: #B452CD">3</span>]: <span style="color: #658b00">reload</span>(decay)  <span style="color: #228B22"># force new import</span>

In[<span style="color: #B452CD">2</span>]: decay.test_read_command_line_argparse()
<span style="color: #B452CD">1.6</span> <span style="color: #B452CD">1.6</span>
<span style="color: #B452CD">1.8</span> <span style="color: #B452CD">1.8</span>
<span style="color: #B452CD">2.2</span> <span style="color: #B452CD">2.2</span>
<span style="color: #B452CD">0.5</span> <span style="color: #B452CD">0.5</span>
[<span style="color: #B452CD">0.1</span>, <span style="color: #B452CD">0.2</span>, <span style="color: #B452CD">0.05</span>] [<span style="color: #B452CD">0.1</span>, <span style="color: #B452CD">0.2</span>, <span style="color: #B452CD">0.05</span>]
</pre></div>
<p>
Now we clearly see the objects that are compared.
</div>


<h2 id="softeng1:basic:unittest">Classical class-based unit testing</h2>

<p>
The test functions written for the nose and pytest frameworks are
very straightforward and to the point, with no framework-required boilerplate
code. We just write the statements we need to get the computations and
comparisons done, before applying the required <code>assert</code>.

<p>
The classical way of implementing unit tests (which derives from the
JUnit object-oriented tool in Java) leads to much more comprehensive
implementations with a lot of boilerplate code.  Python comes with a
built-in module <code>unittest</code> for doing this type of classical unit
tests. Although nose or pytest are much more convenient to use than
<code>unittest</code>, class-based unit testing in the style of <code>unittest</code> has a
very strong position in computer science and is so widespread in
the software industry that
even computational scientists should have an idea how such unit test
code is written. A short demo of <code>unittest</code> is therefore included
next. (Readers who are not familiar with object-oriented programming
in Python may find the text hard to understand, but one can safely
jump to the next section.)

<p>
Suppose we have a function <code>double(x)</code> in a module file <code>mymod.py</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">double</span>(x):
    <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">2</span>*x
</pre></div>
<p>
Unit testing with the aid of the <code>unittest</code> module
consists of writing a file <code>test_mymod.py</code> for testing the functions
in <code>mymod.py</code>. The individual tests must be methods with names
starting with <code>test_</code> in a class derived from class <code>TestCase</code> in
<code>unittest</code>. With one test method for the function <code>double</code>, the
<code>test_mymod.py</code> file becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">unittest</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">mymod</span>

<span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">TestMyCode</span>(unittest.TestCase):
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_double</span>(<span style="color: #658b00">self</span>):
        x = <span style="color: #B452CD">4</span>
        expected = <span style="color: #B452CD">2</span>*x
        computed = mymod.double(x)
        <span style="color: #658b00">self</span>.assertEqual(expected, computed)

<span style="color: #8B008B; font-weight: bold">if</span> __name__ == <span style="color: #CD5555">&#39;__main__&#39;</span>:
    unittest.main()
</pre></div>
<p>
The test is run by executing the test file <code>test_mymod.py</code> as a standard
Python program. There is no support in <code>unittest</code> for automatically
locating and running all tests in all test files in a directory tree.

<p>
We could use the basic <code>assert</code> statement as we did with nose and pytest
functions, but those who write code based on <code>unittest</code> almost
exclusively use the wide range of built-in assert functions such
as <code>assertEqual</code>, <code>assertNotEqual</code>, <code>assertAlmostEqual</code>, to mention
some of them.

<p>
Translation of the test functions from the previous sections
to <code>unittest</code> means making a new file <code>test_decay.py</code> file with a
test class <code>TestDecay</code> where the stand-alone functions for
nose/pytest now become methods in this class.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">unittest</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">decay</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">u_discrete_exact</span>(n, I, a, theta, dt):
    ...

<span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">TestDecay</span>(unittest.TestCase):

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_exact_discrete_solution</span>(<span style="color: #658b00">self</span>):
        theta = <span style="color: #B452CD">0.8</span>; a = <span style="color: #B452CD">2</span>; I = <span style="color: #B452CD">0.1</span>; dt = <span style="color: #B452CD">0.8</span>
        Nt = <span style="color: #658b00">int</span>(<span style="color: #B452CD">8</span>/dt)  <span style="color: #228B22"># no of steps</span>
        u, t = decay.solver(I=I, a=a, T=Nt*dt, dt=dt, theta=theta)
        <span style="color: #228B22"># Evaluate exact discrete solution on the mesh</span>
        u_de = np.array([u_discrete_exact(n, I, a, theta, dt)
                         <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Nt+<span style="color: #B452CD">1</span>)])
        diff = np.abs(u_de - u).max()  <span style="color: #228B22"># largest deviation</span>
        <span style="color: #658b00">self</span>.assertAlmostEqual(diff, <span style="color: #B452CD">0</span>, delta=<span style="color: #B452CD">1E-14</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_potential_integer_division</span>(<span style="color: #658b00">self</span>):
        ...
        <span style="color: #658b00">self</span>.assertAlmostEqual(diff, <span style="color: #B452CD">0</span>, delta=<span style="color: #B452CD">1E-14</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_read_command_line_positional</span>(<span style="color: #658b00">self</span>):
        ...
        <span style="color: #8B008B; font-weight: bold">for</span> expected_arg, computed_arg <span style="color: #8B008B">in</span> <span style="color: #658b00">zip</span>(expected, computed):
            <span style="color: #658b00">self</span>.assertEqual(expected_arg, computed_arg)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_read_command_line_argparse</span>(<span style="color: #658b00">self</span>):
        ...

<span style="color: #8B008B; font-weight: bold">if</span> __name__ == <span style="color: #CD5555">&#39;__main__&#39;</span>:
    unittest.main()
</pre></div>

<h1 id="softeng1:prog:se:git">Sharing the software with other users</h1>

<p>
As soon as you have some working software that you intend to share
with others, you should package your software in a standard way such
that users can easily download your software, install it, improve it,
and ask you to approve their improvements in new versions of the software.
During recent years, the software development community has established
quite firm tools and rules for how all this is done. The following
subsections cover three steps in sharing software:

<ol>
<li> Organizing the software for public distribution.</li>
<li> Uploading the software to a cloud service (here GitHub).</li>
<li> Downloading and installing the software.</li>
</ol>

<h2 id="___sec40">Organizing the software directory tree </h2>

<p>
We start with organizing our software as a directory tree. Our
software consists of one module file, <code>decay.py</code>, and possibly some
unit tests in a separate file located in a directory <code>tests</code>.

<p>
The <code>decay.py</code> can be used as a module or as a program. For distribution
to other users who install the program <code>decay.py</code> in system directories,
we need to insert the following line at the top of the file:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #228B22">#!/usr/bin/env python</span>
</pre></div>
<p>
This line makes it possible to write just the filename and get the
file executed by the <code>python</code> program (or more precisely, the first
<code>python</code> program found in the directories in the <code>PATH</code> environment
variable).

<h3 id="___sec41">Distributing just a module file </h3>

<p>
Let us start out with the minimum solution alternative: distributing
just the <code>decay.py</code> file. Then the software is just one file and all
we need is a directory with this file.  Users will also this directory
to contain an installation script <code>setup.py</code> and a <code>README</code> file
telling what the software is about, the author's email address, a URL
for downloading the software, and other useful information.

<p>
The <code>setup.py</code> file can be as short as

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">distutils.core</span> <span style="color: #8B008B; font-weight: bold">import</span> setup
setup(name=<span style="color: #CD5555">&#39;decay&#39;</span>,
      version=<span style="color: #CD5555">&#39;0.1&#39;</span>,
      py_modules=[<span style="color: #CD5555">&#39;decay&#39;</span>],
      scripts=[<span style="color: #CD5555">&#39;decay.py&#39;</span>],
      )
</pre></div>
<p>
The <code>py_modules</code> argument specifies a list of modules to be installed, while
<code>scripts</code> specifies stand-alone programs. Our <code>decay.py</code> can be used
either as a module or as an executable program, so we want users to
have both possibilities.

<h3 id="___sec42">Distributing a package </h3>

<p>
If the software consists of more files than one or two modules, one
should make a Python <em>package</em> out of it. In our case we make a
package <code>decay</code> containing one module, also called <code>decay</code>.

<p>
To make a package <code>decay</code>, create a directory <code>decay</code> and an empty
file in it with name <code>__init__.py</code>.
A <code>setup.py</code> script must now specify the directory name of the package
and also an executable program (<code>scripts=</code>)
in case we want to run <code>decay.py</code> as a stand-alone application:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">distutils.core</span> <span style="color: #8B008B; font-weight: bold">import</span> setup
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>

setup(name=<span style="color: #CD5555">&#39;decay&#39;</span>,
      version=<span style="color: #CD5555">&#39;0.1&#39;</span>,
      author=<span style="color: #CD5555">&#39;Hans Petter Langtangen&#39;</span>,
      author_email=<span style="color: #CD5555">&#39;hpl@simula.no&#39;</span>,
      url=<span style="color: #CD5555">&#39;https://github.com/hplgit/decay-package/&#39;</span>,
      packages=[<span style="color: #CD5555">&#39;decay&#39;</span>],
      scripts=[os.path.join(<span style="color: #CD5555">&#39;decay&#39;</span>, <span style="color: #CD5555">&#39;decay.py&#39;</span>)]
     )
</pre></div>
<p>
We have also added some author and download information.
The reader is referred to the <a href="https://docs.python.org/2/distutils/setupscript.html" target="_self">Distutils documentation</a> for more information on how to
write <code>setup.py</code> scripts.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Remark about the executable file.</b>
<p>
The executable program, <code>decay.py</code>, is above taken to be the complete
module file <code>decay.py</code>. It would normally be preferred to instead
write a very short script essentially importing <code>decay</code> and running
the test block in <code>decay.py</code>.  In this way, we distribute a module and
a very short file, say <code>decay-main.py</code>, as an executable program:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eee8d5"><pre style="line-height: 125%"><span style="color: #228B22">#!/usr/bin/env python</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">decay</span>
decay.decay.experiment_compare_dt(<span style="color: #658b00">True</span>)
decay.decay.plt.show()
</pre></div>

</div>


<p>
In this package example, we move the unit tests out of the <code>decay.py</code>
module to a separate file, <code>test_decay.py</code>, and place this file in a
directory <code>tests</code>. Then the <code>nosetests</code> and <code>py.test</code> programs will
automatically find and execute the tests.

<p>
The complete directory structure reads

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; /bin/ls -R
.:
decay  README  setup.py

./decay:
decay.py  __init__.py  tests

./decay/tests:
test_decay.py
</pre></div>

<h2 id="___sec43">Publishing the software at GitHub </h2>

<p>
The leading site today for publishing open source software projects is
GitHub at <a href="http://github.com" target="_self"><tt>http://github.com</tt></a>, provided you want your software to
be open to the world. With a paid GitHub account, you can have private
projects too.

<p>
Sign up for a GitHub account if you do not already have one.
Go to your account settings and provide an SSH key (typically
the file <code>~/.ssh/id_rsa.pub</code>) such that
you can communicate with GitHub without being prompted for your password.
All communication between your computer and GitHub goes via the version
control system Git. This may at first sight look tedious, but
this is the way professionals work with software today. With Git you
have full control of the history of your files, i.e., &quot;who did what when&quot;.
The technology makes Git superior to simpler alternatives
like Dropbox and Google Drive,
especially when you collaborate with others.
There is a reason why Git has gained the position it has,
and there is no reason why you should not adopt this tool.

<p>
To create a new project, click on <em>New repository</em> on the main page and
fill out a project name. Click on the check button <em>Initialize this
repository with a README</em>, and click on <em>Create repository</em>. The next
step is to clone (copy) the GitHub repo (short for repository) to
your own computer(s) and fill it with files. The typical clone command is

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; git clone git://github.com:username/projname.git
</pre></div>
<p>
where <code>username</code> is your GitHub username and <code>projname</code> is the
name of the repo (project). The result of <code>git clone</code> is a
directory <code>projname</code>. Go to this directory and add files.
As soon as the repo directory is populated with files, run

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; git add .
Terminal&gt; git commit -am &#39;First registration of project files&#39;
Terminal&gt; git push origin master
</pre></div>
<p>
The above <code>git</code> commands look cryptic, but these commands plus
2-3 more are the essence of what you need in your daily work with
files in small or big
software projects. I strongly encourage you to
learn more about <a href="http://hplgit.github.io/teamods/bitgit/html/" target="_self">version control systems and project hosting
sites</a>
<a href="._softeng-solarized002.html#Langtangen_bitgit">[1]</a>.

<p>
Your project files are now stored in the cloud at
<a href="https://github.com/username/projname" target="_self"><tt>https://github.com/username/projname</tt></a>. Anyone can
get the software by the listed <code>git clone</code> command you used above,
or by clicking on the links for zip and tar files.

<p>
Every time you update the project files, you need to register
the update at GitHub by

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; git commit -am &#39;Description of the changes you made...&#39;
Terminal&gt; git push origin master
</pre></div>
<p>
The files at GitHub are now synchronized with your local ones.
Similarly, every time you start working on files in this project,
make sure you have the latest version:
<code>git pull origin master</code>.

<p>
You are recommended to read <a href="http://hplgit.github.io/teamods/bitgit/html/" target="_self">a quick intro</a> that makes you
up and going with this style of
professional work. And you should put all your writings and programming
projects in repositories in the cloud!

<h2 id="___sec44">Downloading and installing the software </h2>

<p>
Users of your software go to the Git repo at <code>github.com</code> and
clone the repository. One can use either SSH or HTTP for communication.
Most users will use the latter, typically

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; git clone https://github.com/username/projname.git
</pre></div>
<p>
The result is a directory <code>projname</code> with the files in the repo.

<h3 id="___sec45">Installing just a module file </h3>

<p>
The software package is in the case above a directory <code>decay</code> with three files

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; ls decay
README   decay.py   setup.py
</pre></div>
<p>
To install the <code>decay.py</code> file, a user
just runs <code>setup.py</code>:

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; sudo python setup.py install
</pre></div>
<p>
This command will install the software in system directories, so the user
needs to run the command as <code>root</code> on Unix systems (therefore the command
starts with <code>sudo</code>).
The user can now import the module by <code>import decay</code> and run
the program by

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; decay.py
</pre></div>
<p>
A user can easily install the software on her personal account if
a system-wide installation is not desirable. We refer to the
<a href="https://docs.python.org/2/install/index.html#alternate-installation" target="_self">installation documentation</a> for the many arguments that can be given to <code>setup.py</code>.
Note that if the software is installed on a personal account, the
<code>PATH</code> and <code>PYTHONPATH</code> environment variables must contain the
relevant directories.

<p>
Our <code>setup.py</code> file specifies a module <code>decay</code> to be installed as well
as a program <code>decay.py</code>.  Modules are typically installed in some <code>lib</code>
directory on the computer system, e.g.,
<code>/usr/local/lib/python2.7/dist-packages</code>, while executable programs go
to <code>/usr/local/bin</code>.

<h3 id="___sec46">Installing a package </h3>

<p>
When the software is organized as a Python package, the installation is
done by running <code>setup.py</code> exactly as explained above, but the use of a module
<code>decay</code> in a package <code>decay</code> requires the following syntax:

<p>

<!-- code=text typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">import decay
u, t = decay.decay.solver(...)
</pre></div>
<p>
That is, the call goes like <code>packagename.modulename.functionname</code>.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Package import in <code>__init__.py</code>.</b>
<p>
One can ease the use of packages by providing a somewhat simpler
import like

<p>

<!-- code=text typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eee8d5"><pre style="line-height: 125%">import decay
u, t = decay.solver(...)

# or
from decay import solver
u, t = solver(...)
</pre></div>
<p>
This is accomplished by putting an import statement in the <code>__init__.py</code>
file, which is always run when doing the package import <code>import decay</code>
or <code>from decay import</code>. The <code>__init__.py</code> file must now contain

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eee8d5"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">decay</span> <span style="color: #8B008B; font-weight: bold">import</span> *
</pre></div>
<p>
Obviously, it is the package developer who decides on such an
<code>__init__.py</code> file or if it should just be empty.
</div>


<h1 id="softeng1:prog:se:class">Classes for problem and solution method</h1>

<p>
The numerical solution procedure was compactly and conveniently implemented in
a Python function <code>solver</code> in the section <a href="#softeng1:basic:math">Mathematical problem and solution technique</a>.
In more complicated problems it might
be beneficial to use classes instead of functions only. Here we shall
describe a class-based software design well suited for scientific problems
where there is a mathematical model of some physical phenomenon and
some numerical methods to solve the equations involved in the model.

<p>
We introduce a class <code>Problem</code> to hold the definition of the physical
problem, and a class <code>Solver</code> to hold the data and methods needed to
numerically solve the problem.  The forthcoming text will explain the
inner workings of these classes and how they represent an alternative
to the <code>solver</code> and <code>experiment_*</code> functions in the <code>decay</code>
module.

<p>
Explaining the details of class programming in Python is considered
far beyond the scope of this text.  Readers who are unfamiliar with Python
class programming should first consult one of the many electronic
Python tutorials or textbooks to come up to speed with concepts and
syntax of Python classes before reading on. The author has a gentle
introduction to class programming for scientific applications
in <a href="._softeng-solarized002.html#Langtangen_2012">[2]</a>, see <a href="http://hplgit.github.io/primer.html/doc/web/index.html" target="_self">Chapter 7 and 9 and Appendix E</a>.
Other useful resources are

<ul>
 <li> The Python Tutorial: <a href="http://docs.python.org/2/tutorial/classes.html" target="_self"><tt>http://docs.python.org/2/tutorial/classes.html</tt></a></li>
 <li> Wiki book on Python Programming: <a href="http://en.wikibooks.org/wiki/Python_Programming/Classes" target="_self"><tt>http://en.wikibooks.org/wiki/Python_Programming/Classes</tt></a></li>
 <li> <code>tutorialspoint.com</code>: <a href="http://www.tutorialspoint.com/python/python_classes_objects.htm" target="_self"><tt>http://www.tutorialspoint.com/python/python_classes_objects.htm</tt></a></li>
</ul>

<h2 id="___sec48">The problem class </h2>

<p>
The purpose of the problem class is to store all information about
the mathematical model. This usually means the physical parameters
and formulas
in the problem. Looking at our model problem
<a href="#mjx-eqn-1">(1)</a>-<a href="#mjx-eqn-2">(2)</a>, the physical data cover
\( I \), \( a \), and \( T \). Since we have an analytical solution of
the ODE problem, we may add this solution in terms of a Python
function (or method) to the problem class as well.
A possible problem class is therefore

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> exp

<span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">Problem</span>(<span style="color: #658b00">object</span>):
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__init__</span>(<span style="color: #658b00">self</span>, I=<span style="color: #B452CD">1</span>, a=<span style="color: #B452CD">1</span>, T=<span style="color: #B452CD">10</span>):
        <span style="color: #658b00">self</span>.T, <span style="color: #658b00">self</span>.I, <span style="color: #658b00">self</span>.a = I, <span style="color: #658b00">float</span>(a), T

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">u_exact</span>(<span style="color: #658b00">self</span>, t):
        I, a = <span style="color: #658b00">self</span>.I, <span style="color: #658b00">self</span>.a
        <span style="color: #8B008B; font-weight: bold">return</span> I*exp(-a*t)
</pre></div>
<p>
We could in the <code>u_exact</code> method have written
<code>self.I*exp(-self.a*t)</code>, but using local variables <code>I</code> and <code>a</code> allows
the nicer formula <code>I*exp(-a*t)</code>, which looks much closer to the mathematical
expression \( Ie^{-at} \).  This is not an important issue with the
current compact formula, but is beneficial in more complicated
problems with longer formulas to obtain the closest possible
relationship between code and mathematics. The coding style in
this standalone is to strip
off the <code>self</code> prefix when the code expresses mathematical formulas.

<p>
The class data can be set either as arguments in the constructor or
at any time later, e.g.,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">problem = Problem(T=<span style="color: #B452CD">5</span>)
problem.T = <span style="color: #B452CD">8</span>
problem.dt = <span style="color: #B452CD">1.5</span>
</pre></div>
<p>
(Some programmers prefer <code>set</code> and <code>get</code> functions for setting and getting
data in classes, often implemented via <em>properties</em> in Python, but
this author considers that overkill when there are just a few data items
in a class.)

<p>
It would be convenient if class <code>Problem</code> could also initialize
the data from the command line. To this end, we add a method for
defining a set of command-line options and a method that sets the
local attributes equal to what was found on the command line.
The default values associated with the command-line options are taken
as the values provided to the constructor. Class <code>Problem</code> now becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">Problem</span>(<span style="color: #658b00">object</span>):
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__init__</span>(<span style="color: #658b00">self</span>, I=<span style="color: #B452CD">1</span>, a=<span style="color: #B452CD">1</span>, T=<span style="color: #B452CD">10</span>):
        <span style="color: #658b00">self</span>.T, <span style="color: #658b00">self</span>.I, <span style="color: #658b00">self</span>.a = I, <span style="color: #658b00">float</span>(a), T

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">define_command_line_options</span>(<span style="color: #658b00">self</span>, parser=<span style="color: #658b00">None</span>):
        <span style="color: #CD5555">&quot;&quot;&quot;Return updated (parser) or new ArgumentParser object.&quot;&quot;&quot;</span>
        <span style="color: #8B008B; font-weight: bold">if</span> parser <span style="color: #8B008B">is</span> <span style="color: #658b00">None</span>:
            <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">argparse</span>
            parser = argparse.ArgumentParser()

        parser.add_argument(
            <span style="color: #CD5555">&#39;--I&#39;</span>, <span style="color: #CD5555">&#39;--initial_condition&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>,
            default=<span style="color: #B452CD">1.0</span>, help=<span style="color: #CD5555">&#39;initial condition, u(0)&#39;</span>,
            metavar=<span style="color: #CD5555">&#39;I&#39;</span>)
        parser.add_argument(
            <span style="color: #CD5555">&#39;--a&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">1.0</span>,
            help=<span style="color: #CD5555">&#39;coefficient in ODE&#39;</span>, metavar=<span style="color: #CD5555">&#39;a&#39;</span>)
        parser.add_argument(
            <span style="color: #CD5555">&#39;--T&#39;</span>, <span style="color: #CD5555">&#39;--stop_time&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>,
            default=<span style="color: #B452CD">1.0</span>, help=<span style="color: #CD5555">&#39;end time of simulation&#39;</span>,
            metavar=<span style="color: #CD5555">&#39;T&#39;</span>)
        <span style="color: #8B008B; font-weight: bold">return</span> parser

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">init_from_command_line</span>(<span style="color: #658b00">self</span>, args):
        <span style="color: #CD5555">&quot;&quot;&quot;Load attributes from ArgumentParser into instance.&quot;&quot;&quot;</span>
        <span style="color: #658b00">self</span>.I, <span style="color: #658b00">self</span>.a, <span style="color: #658b00">self</span>.T = args.I, args.a, args.T

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">u_exact</span>(<span style="color: #658b00">self</span>, t):
        <span style="color: #CD5555">&quot;&quot;&quot;Return the exact solution u(t)=I*exp(-a*t).&quot;&quot;&quot;</span>
        I, a = <span style="color: #658b00">self</span>.I, <span style="color: #658b00">self</span>.a
        <span style="color: #8B008B; font-weight: bold">return</span> I*exp(-a*t)
</pre></div>
<p>
Observe that if the user already has an <code>ArgumentParser</code> object it can be
supplied, but if she does not have any, class <code>Problem</code> makes one.
Python's <code>None</code> object is used to indicate that a variable is not
initialized with a proper value.

<h2 id="___sec49">The solver class </h2>

<p>
The solver class stores parameters related to the numerical solution method
and provides a function <code>solve</code> for solving the problem.
For convenience, a problem object is given to the constructor
in a solver object such that the object gets access to the
physical data. In the present example,
the numerical solution method involves the parameters \( \Delta t \)
and \( \theta \), which then constitute the data part of the solver class.
We include, as in the problem class, functionality for
reading \( \Delta t \) and \( \theta \) from the command line:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">Solver</span>(<span style="color: #658b00">object</span>):
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__init__</span>(<span style="color: #658b00">self</span>, problem, dt=<span style="color: #B452CD">0.1</span>, theta=<span style="color: #B452CD">0.5</span>):
        <span style="color: #658b00">self</span>.problem = problem
        <span style="color: #658b00">self</span>.dt, <span style="color: #658b00">self</span>.theta = <span style="color: #658b00">float</span>(dt), theta

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">define_command_line_options</span>(<span style="color: #658b00">self</span>, parser):
        <span style="color: #CD5555">&quot;&quot;&quot;Return updated (parser) or new ArgumentParser object.&quot;&quot;&quot;</span>
        parser.add_argument(
            <span style="color: #CD5555">&#39;--scheme&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">str</span>, default=<span style="color: #CD5555">&#39;CN&#39;</span>,
            help=<span style="color: #CD5555">&#39;FE, BE, or CN&#39;</span>)
        parser.add_argument(
            <span style="color: #CD5555">&#39;--dt&#39;</span>, <span style="color: #CD5555">&#39;--time_step_values&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>,
            default=[<span style="color: #B452CD">1.0</span>], help=<span style="color: #CD5555">&#39;time step values&#39;</span>,
            metavar=<span style="color: #CD5555">&#39;dt&#39;</span>, nargs=<span style="color: #CD5555">&#39;+&#39;</span>, dest=<span style="color: #CD5555">&#39;dt_values&#39;</span>)
        <span style="color: #8B008B; font-weight: bold">return</span> parser

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">init_from_command_line</span>(<span style="color: #658b00">self</span>, args):
        <span style="color: #CD5555">&quot;&quot;&quot;Load attributes from ArgumentParser into instance.&quot;&quot;&quot;</span>
        <span style="color: #658b00">self</span>.dt, <span style="color: #658b00">self</span>.theta = args.dt, args.theta

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solve</span>(<span style="color: #658b00">self</span>):
        <span style="color: #658b00">self</span>.u, <span style="color: #658b00">self</span>.t = solver(
            <span style="color: #658b00">self</span>.problem.I, <span style="color: #658b00">self</span>.problem.a, <span style="color: #658b00">self</span>.problem.T,
            <span style="color: #658b00">self</span>.dt, <span style="color: #658b00">self</span>.theta)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">error</span>(<span style="color: #658b00">self</span>):
        <span style="color: #CD5555">&quot;&quot;&quot;Return norm of error at the mesh points.&quot;&quot;&quot;</span>
        u_e = <span style="color: #658b00">self</span>.problem.u_exact(<span style="color: #658b00">self</span>.t)
        e = u_e - <span style="color: #658b00">self</span>.u
        E = np.sqrt(<span style="color: #658b00">self</span>.dt*np.sum(e**<span style="color: #B452CD">2</span>))
        <span style="color: #8B008B; font-weight: bold">return</span> E
</pre></div>
<p>
Note that we see no need to repeat the body of the previously
developed and tested <code>solver</code> function. We just call that function from
the <code>solve</code> method.  In this way, class <code>Solver</code> is merely a class wrapper
of the stand-alone <code>solver</code> function. With a single object of class <code>Solver</code>
we have all the physical and numerical data bundled together with the numerical
solution method.

<h3 id="___sec50">Combining the objects </h3>

<p>
Eventually we need to show how the classes <code>Problem</code> and <code>Solver</code>
play together. We read parameters from the command line and make a
plot with the numerical and exact solution:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">experiment_classes</span>():
    problem = Problem()
    solver = Solver(problem)

    <span style="color: #228B22"># Read input from the command line</span>
    parser = problem.define_command_line_options()
    parser = solver. define_command_line_options(parser)
    args = parser.parse_args()
    problem.init_from_command_line(args)
    solver. init_from_command_line(args)

    <span style="color: #228B22"># Solve and plot</span>
    solver.solve()
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
    t_e = np.linspace(<span style="color: #B452CD">0</span>, T, <span style="color: #B452CD">1001</span>)    <span style="color: #228B22"># very fine mesh for u_e</span>
    u_e = problem.u_exact(t_e)
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Error:&#39;</span>, solver.error()

    plt.plot(t,   u,   <span style="color: #CD5555">&#39;r--o&#39;</span>)
    plt.plot(t_e, u_e, <span style="color: #CD5555">&#39;b-&#39;</span>)
    plt.legend([<span style="color: #CD5555">&#39;numerical, theta=%g&#39;</span> % theta, <span style="color: #CD5555">&#39;exact&#39;</span>])
    plt.xlabel(<span style="color: #CD5555">&#39;t&#39;</span>)
    plt.ylabel(<span style="color: #CD5555">&#39;u&#39;</span>)
    plotfile = <span style="color: #CD5555">&#39;tmp&#39;</span>
    plt.savefig(plotfile + <span style="color: #CD5555">&#39;.png&#39;</span>);  plt.savefig(plotfile + <span style="color: #CD5555">&#39;.pdf&#39;</span>)
    plt.show()
</pre></div>

<h2 id="softeng1:prog:se:class2">Improving the problem and solver classes</h2>

<p>
The previous <code>Problem</code> and <code>Solver</code> classes containing parameters
soon get much repetitive code when the number of parameters increases.
Much of this code can be parameterized and be made more compact.
For this purpose, we decide to collect all parameters in a dictionary,
<code>self.prm</code>, with two associated dictionaries <code>self.type</code> and
<code>self.help</code> for holding associated object types and help strings.
The reason is that processing dictionaries is easier than processing
a set of individual attributes.
For the specific ODE example we deal with, the three dictionaries in
the problem class are typically

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #658b00">self</span>.prm  = <span style="color: #658b00">dict</span>(I=<span style="color: #B452CD">1</span>, a=<span style="color: #B452CD">1</span>, T=<span style="color: #B452CD">10</span>)
<span style="color: #658b00">self</span>.type = <span style="color: #658b00">dict</span>(I=<span style="color: #658b00">float</span>, a=<span style="color: #658b00">float</span>, T=<span style="color: #658b00">float</span>)
<span style="color: #658b00">self</span>.help = <span style="color: #658b00">dict</span>(I=<span style="color: #CD5555">&#39;initial condition, u(0)&#39;</span>,
                 a=<span style="color: #CD5555">&#39;coefficient in ODE&#39;</span>,
                 T=<span style="color: #CD5555">&#39;end time of simulation&#39;</span>)
</pre></div>
<p>
Provided a problem or solver class defines these three
dictionaries in the constructor,
we can create a super class <code>Parameters</code> with general code
for defining command-line options and reading them as well as
methods for setting and getting each parameter. A <code>Problem</code> or <code>Solver</code> for
a particular mathematical problem can then
inherit most of the needed functionality and code
from the <code>Parameters</code> class. For example,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">Problem</span>(Parameters):
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__init__</span>(<span style="color: #658b00">self</span>):
        <span style="color: #658b00">self</span>.prm  = <span style="color: #658b00">dict</span>(I=<span style="color: #B452CD">1</span>, a=<span style="color: #B452CD">1</span>, T=<span style="color: #B452CD">10</span>)
        <span style="color: #658b00">self</span>.type = <span style="color: #658b00">dict</span>(I=<span style="color: #658b00">float</span>, a=<span style="color: #658b00">float</span>, T=<span style="color: #658b00">float</span>)
        <span style="color: #658b00">self</span>.help = <span style="color: #658b00">dict</span>(I=<span style="color: #CD5555">&#39;initial condition, u(0)&#39;</span>,
                         a=<span style="color: #CD5555">&#39;coefficient in ODE&#39;</span>,
                         T=<span style="color: #CD5555">&#39;end time of simulation&#39;</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">u_exact</span>(<span style="color: #658b00">self</span>, t):
        I, a = <span style="color: #658b00">self</span>[<span style="color: #CD5555">&#39;I a&#39;</span>.split()]
        <span style="color: #8B008B; font-weight: bold">return</span> I*np.exp(-a*t)

<span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">Solver</span>(Parameters):
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__init__</span>(<span style="color: #658b00">self</span>, problem):
        <span style="color: #658b00">self</span>.problem = problem   <span style="color: #228B22"># class Problem object</span>
        <span style="color: #658b00">self</span>.prm  = <span style="color: #658b00">dict</span>(dt=<span style="color: #B452CD">0.5</span>, theta=<span style="color: #B452CD">0.5</span>)
        <span style="color: #658b00">self</span>.type = <span style="color: #658b00">dict</span>(dt=<span style="color: #658b00">float</span>, theta=<span style="color: #658b00">float</span>)
        <span style="color: #658b00">self</span>.help = <span style="color: #658b00">dict</span>(dt=<span style="color: #CD5555">&#39;time step value&#39;</span>,
                         theta=<span style="color: #CD5555">&#39;time discretization parameter&#39;</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solve</span>(<span style="color: #658b00">self</span>):
        <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">decay</span> <span style="color: #8B008B; font-weight: bold">import</span> solver
        I, a, T = <span style="color: #658b00">self</span>.problem[<span style="color: #CD5555">&#39;I a T&#39;</span>.split()]
        dt, theta = <span style="color: #658b00">self</span>[<span style="color: #CD5555">&#39;dt theta&#39;</span>.split()]
        <span style="color: #658b00">self</span>.u, <span style="color: #658b00">self</span>.t = solver(I, a, T, dt, theta)
</pre></div>
<p>
By inheritance, these classes can automatically do a lot more when it comes to
reading and assigning parameter values:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">problem = Problem()
solver = Solver(problem)

<span style="color: #228B22"># Read input from the command line</span>
parser = problem.define_command_line_options()
parser = solver. define_command_line_options(parser)
args = parser.parse_args()
problem.init_from_command_line(args)
solver. init_from_command_line(args)

<span style="color: #228B22"># Other syntax for setting/getting parameter values</span>
problem[<span style="color: #CD5555">&#39;T&#39;</span>] = <span style="color: #B452CD">6</span>
<span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Time step:&#39;</span>, solver[<span style="color: #CD5555">&#39;dt&#39;</span>]

solver.solve()
u, t = solver.u, solver.t
</pre></div>

<h3 id="___sec52">A generic class for parameters </h3>

<p>
A simplified version of the parameter class looks as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">Parameters</span>(<span style="color: #658b00">object</span>):
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__getitem__</span>(<span style="color: #658b00">self</span>, name):
        <span style="color: #CD5555">&quot;&quot;&quot;obj[name] syntax for getting parameters.&quot;&quot;&quot;</span>
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">isinstance</span>(name, (<span style="color: #658b00">list</span>,<span style="color: #658b00">tuple</span>)):         <span style="color: #228B22"># get many?</span>
            <span style="color: #8B008B; font-weight: bold">return</span> [<span style="color: #658b00">self</span>.prm[n] <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> name]
        <span style="color: #8B008B; font-weight: bold">else</span>:
            <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #658b00">self</span>.prm[name]

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__setitem__</span>(<span style="color: #658b00">self</span>, name, value):
        <span style="color: #CD5555">&quot;&quot;&quot;obj[name] = value syntax for setting a parameter.&quot;&quot;&quot;</span>
        <span style="color: #658b00">self</span>.prm[name] = value

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">define_command_line_options</span>(<span style="color: #658b00">self</span>, parser=<span style="color: #658b00">None</span>):
        <span style="color: #CD5555">&quot;&quot;&quot;Automatic registering of options.&quot;&quot;&quot;</span>
        <span style="color: #8B008B; font-weight: bold">if</span> parser <span style="color: #8B008B">is</span> <span style="color: #658b00">None</span>:
            <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">argparse</span>
            parser = argparse.ArgumentParser()

        <span style="color: #8B008B; font-weight: bold">for</span> name <span style="color: #8B008B">in</span> <span style="color: #658b00">self</span>.prm:
            tp = <span style="color: #658b00">self</span>.type[name] <span style="color: #8B008B; font-weight: bold">if</span> name <span style="color: #8B008B">in</span> <span style="color: #658b00">self</span>.type <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #658b00">str</span>
            help = <span style="color: #658b00">self</span>.help[name] <span style="color: #8B008B; font-weight: bold">if</span> name <span style="color: #8B008B">in</span> <span style="color: #658b00">self</span>.help <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #658b00">None</span>
            parser.add_argument(
                <span style="color: #CD5555">&#39;--&#39;</span> + name, default=<span style="color: #658b00">self</span>.get(name), metavar=name,
                <span style="color: #658b00">type</span>=tp, help=help)

        <span style="color: #8B008B; font-weight: bold">return</span> parser

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">init_from_command_line</span>(<span style="color: #658b00">self</span>, args):
        <span style="color: #8B008B; font-weight: bold">for</span> name <span style="color: #8B008B">in</span> <span style="color: #658b00">self</span>.prm:
            <span style="color: #658b00">self</span>.prm[name] = <span style="color: #658b00">getattr</span>(args, name)
</pre></div>
<p>
The file <a href="http://tinyurl.com/ofkw6kc/softeng/decay_oo.py" target="_self"><tt>decay_oo.py</tt></a> contains
a slightly more advanced version of class <code>Parameters</code> where we
in the functions for getting and setting parameters
test for valid parameter names and
raise exceptions with informative messages if any name is not registered.

<p>
We have already sketched the <code>Problem</code> and <code>Solver</code> classes that build
on inheritance from <code>Parameters</code>. We have also shown how they are
used. The only remaining code is to make the plot, but this code is
identical to previous versions when the numerical solution is
available in an object <code>t</code> and the exact one in <code>u_e</code>.

<p>
The advantage with the <code>Parameters</code> class is that it scales to problems
with a large number of physical and numerical parameters:
as long as the parameters are defined once via a dictionary,
the compact code in class <code>Parameters</code> can handle any collection of
parameters of any size.

<h1 id="softeng1:experiments">Automating scientific experiments</h1>

<p>
Empirical scientific investigations based on running computer programs
require careful design of the experiments and accurate reporting of results.
Although there is a strong tradition to do such investigations manually,
the extreme requirements to scientific accuracy make a program much
better suited to conduct the experiments. We shall in this section outline
how we can write such programs, often called <em>scripts</em>, for running other
programs and archiving the results.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Scientific investigation.</b>
<p>
The purpose of the investigations is to explore the quality of numerical
solutions to an ordinary differential equation. More specifically, we
solve the initial-value problem

$$
\begin{equation}
u^\prime(t) = -au(t),\quad u(0)=I,\quad t\in (0,T],
\tag{4}
\end{equation}
$$

by the \( \theta \)-rule:

$$
\begin{equation}
u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,
\quad u^0=I\tp
\tag{5}
\end{equation}
$$

This scheme corresponds to well-known methods: \( \theta=0 \) gives the
Forward Euler (FE) scheme, \( \theta=1 \) gives the Backward Euler (BE) scheme,
and \( \theta=\frac{1}{2} \) gives the Crank-Nicolson
(CN) or midpoint/centered scheme.

<p>
For chosen constants \( I \), \( a \), and \( T \), we run the three schemes for various
values of \( \Delta t \), and present the following results in a report:

<ol>
<li> visual comparison of the numerical and exact solution in a plot for
   each \( \Delta t \) and \( \theta=0,1,\frac{1}{2} \),</li>
<li> a table and a plot of the norm of the numerical error versus \( \Delta t \)
   for \( \theta=0,1,\frac{1}{2} \).</li>
</ol>

The report will also document the mathematical details of the problem under
investigation.
</div>


<h2 id="___sec54">Available software </h2>

<p>
Appropriate software for implementing <a href="#mjx-eqn-5">(5)</a>
is available in a program <a href="http://tinyurl.com/nc4upel/doconce_src/model.py" target="_self"><tt>model.py</tt></a>, which is run as

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python model.py --I 1.5 --a 0.25 --T 6 --dt 1.25 0.75 0.5
</pre></div>
<p>
The command-line input corresponds to setting \( I=1.5 \), \( a=0.25 \), \( T=6 \),
and run three values of \( \Delta t \): 1.25, 0.75, ad 0.5.

<p>
The results of running this <code>model.py</code> command are text in the
terminal window and a set of plot files.
The plot files have names <code>M_D.E</code>, where <code>M</code> denotes the method
(<code>FE</code>, <code>BE</code>, <code>CN</code> for \( \theta=0,1,\frac{1}{2} \), respectively), <code>D</code>
the time step length (here <code>1.25</code>, <code>0.75</code>, or <code>0.5</code>), and <code>E</code>
is the plot file extension <code>png</code> or <code>pdf</code>.
The text output in the terminal window looks like

<p>

<!-- code=text typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">0.0   1.25:    5.998E-01
0.0   0.75:    1.926E-01
0.0   0.50:    1.123E-01
0.0   0.10:    1.558E-02
0.5   1.25:    6.231E-02
0.5   0.75:    1.543E-02
0.5   0.50:    7.237E-03
0.5   0.10:    2.469E-04
1.0   1.25:    1.766E-01
1.0   0.75:    8.579E-02
1.0   0.50:    6.884E-02
1.0   0.10:    1.411E-02
</pre></div>
<p>
The first column is the \( \theta \) value, the next the \( \Delta t \) value,
and the final column represents the numerical error \( E \) (the
norm of discrete error function on the mesh).

<h2 id="___sec55">The results we want to produce </h2>

<p>
The results we need for our investigations are slightly different than
what is directly produced by <code>model.py</code>:

<ol>
<li> We need to collect all the plots for one
   numerical method (FE, BE, CN) in a single plot.
   For example, if 4 \( \Delta t \) values are run, the summarizing plot
   for the BE method has \( 2\times 2 \) subplots, with the subplot corresponding
   to the largest \( \Delta t \) in the upper left corner and the smallest
   in the bottom right corner.</li>
<li> We need to create a table containing
   \( \Delta t \) values in the first column and the numerical error
   \( E \) for \( \theta=0,0.5,1 \)
   in the next three columns. This table should be available as a
   standard CSV file.</li>
<li> We need to plot the numerical error \( E \) versus \( \Delta t \)
   in a log-log plot.</li>
</ol>

Consequently, we must write a script that can run <code>model.py</code> as described and
produce the results 1-3 above. This requires combining multiple plot files into
one file and interpreting the output from <code>model.py</code> as data for plotting and
file storage.

<p>
If the script's name is <code>exper1.py</code>, we run it with the desired \( \Delta t \)
values as positional command-line arguments:

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python exper1.py 0.5 0.25 0.1 0.05
</pre></div>
<p>
This run will then generate eight plot files: <code>FE.png</code> and <code>FE.pdf</code> summarizing
the plots with the FE method, <code>BE.png</code> and <code>BE.pdf</code> with
the BE method, <code>CN.png</code> and <code>CN.pdf</code> with the CN method, and <code>error.png</code>
and <code>error.pdf</code> with the log-log plot of the numerical error versus \( \Delta t \).
In addition, the table with numerical errors is written to a
file <code>error.csv</code>.

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Reproducible and replicable science.</b>
<p>
A script that automates running our computer experiments
will ensure
that the experiments can easily be rerun by anyone in
the future, either to confirm the same results or redo the experiments with
other input data.
Also, whatever we did to produce the results is
documented in every detail in the script.

<p>
A project where anyone can easily repeat the experiments with the same data
is referred to as being <em>replicable</em>, and replicability
should be a fundamental requirement in scientific computing work.
Of more scientific interest is <em>reproducibilty</em>, which means that we can
also run alternative experiments to arrive at the same conclusions.
This requires more than an automating script.
</div>


<h2 id="___sec56">Combining plot files </h2>

<p>
The script for running experiments needs to combine multiple image
files into one. The
<a href="http://www.imagemagick.org/script/montage.php" target="_self"><tt>montage</tt></a>
and
<a href="http://www.imagemagick.org/script/convert.php" target="_self"><tt>convert</tt></a> programs in
the ImageMagick software suite
can be used to combine image files.
However, these programs are best suited for
PNG files. For vector plots in PDF format one needs other tools
to preserve the quality: <code>pdftk</code>, <code>pdfnup</code>, and <code>pdfcrop</code>.

<p>
Suppose you have four files <code>f1.png</code>, <code>f2.png</code>, <code>f3.png</code>, and <code>f4.png</code>
and want to combine them into a \( 2\times 2 \) table of subplots in a new
file <code>f.png</code>, see
Figure <a href="#softeng1:experiments:fig:BE4a">4</a> for an example.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Illustration of the Backward Euler method for four time step values. <div id="softeng1:experiments:fig:BE4a"></div> </p></center>
<p><img src="fig-softeng/BE4a.png" align="bottom" width=600></p>
</center>

<p>
The appropriate ImageMagick commands are

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; montage -background white -geometry 100% -tile 2x \ 
          f1.png f2.png f3.png f4.png f.png
Terminal&gt; convert -trim f.png f.png
Terminal&gt; convert f.png -transparent white f.png
</pre></div>
<p>
The first command mounts the four files in one, the next <code>convert</code> command
removes unnecessary surrounding white space, and the final <code>convert</code> command
makes the white background transparent.

<p>
High-quality montage of PDF files <code>f1.pdf</code>,
<code>f2.pdf</code>, <code>f3.pdf</code>, and <code>f4.pdf</code> into <code>f.pdf</code> goes like

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; pdftk f1.pdf f2.pdf f3.pdf f4.pdf output tmp.pdf
Terminal&gt; pdfnup --nup 2x2 --outfile tmp.pdf tmp.pdf
Terminal&gt; pdfcrop tmp.pdf f.pdf
Terminal&gt; rm -f tmp.pdf
</pre></div>

<h2 id="___sec57">Running a program from Python </h2>

<p>
The script for automating experiments needs to run the <code>model.py</code> program
with appropriate command-line options. Python has several tools for
executing an arbitrary command in the operating systems.
Let <code>cmd</code> be a string containing the desired command.
In the present case study, <code>cmd</code> could be <code>'python model.py --I 1 --dt 0.5 0.2'</code>.
The following code
executes <code>cmd</code> and loads the text output into a string <code>output</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">subprocess</span> <span style="color: #8B008B; font-weight: bold">import</span> Popen, PIPE, STDOUT
p = Popen(cmd, shell=<span style="color: #658b00">True</span>, stdout=PIPE, stderr=STDOUT)
output, _ = p.communicate()

<span style="color: #228B22"># Check if the execution was successful</span>
failure = p.returncode
<span style="color: #8B008B; font-weight: bold">if</span> failure:
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Command failed:&#39;</span>, cmd; sys.exit(<span style="color: #B452CD">1</span>)
</pre></div>
<p>
Unsuccessful execution usually makes it meaningless to continue
the program, and therefore we abort the program with <code>sys.exit(1)</code>.
Any argument different from 0 signifies to the computer's operating system
that our program stopped with a failure.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Programming tip: use <code>_</code> for dummy variable.</b>
<p>
Sometimes we need to unpack tuples or lists in separate variables,
but we are not interested in all the variables. One example is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eee8d5"><pre style="line-height: 125%">output, error = p.communicate()
</pre></div>
<p>
but <code>error</code> is of no interest.
One can then use underscore <code>_</code> as variable name for the dummy
(uninteresting) variable(s):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eee8d5"><pre style="line-height: 125%">output, _ = p.communicate()
</pre></div>
<p>
Here is another example where we iterate over a list of three-tuples,
but the interest is limited to the second element in each three-tuple:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eee8d5"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">for</span> _, value, _ <span style="color: #8B008B">in</span> list_of_three_tuples:
    <span style="color: #228B22"># work with value</span>
</pre></div>

</div>


<p>
We need to interpret the contents of the string
<code>output</code> and store
the data in an appropriate data structure for further processing.
Since the content is basically a table and will be transformed to
a spread sheet format, we let the columns in the table be represented
by lists in the program,
and we collect these columns in a dictionary whose keys are natural
column names: <code>dt</code> and the three values of \( \theta \).
The following code translates the output of <code>cmd</code> (<code>output</code>)
to such a dictionary of lists (<code>errors</code>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">errors = {<span style="color: #CD5555">&#39;dt&#39;</span>: dt_values, <span style="color: #B452CD">1</span>: [], <span style="color: #B452CD">0</span>: [], <span style="color: #B452CD">0.5</span>: []}
<span style="color: #8B008B; font-weight: bold">for</span> line <span style="color: #8B008B">in</span> output.splitlines():
    words = line.split()
    <span style="color: #8B008B; font-weight: bold">if</span> words[<span style="color: #B452CD">0</span>] <span style="color: #8B008B">in</span> (<span style="color: #CD5555">&#39;0.0&#39;</span>, <span style="color: #CD5555">&#39;0.5&#39;</span>, <span style="color: #CD5555">&#39;1.0&#39;</span>):  <span style="color: #228B22"># line with E?</span>
        <span style="color: #228B22"># typical line: 0.0   1.25:    7.463E+00</span>
        theta = <span style="color: #658b00">float</span>(words[<span style="color: #B452CD">0</span>])
        E = <span style="color: #658b00">float</span>(words[<span style="color: #B452CD">2</span>])
        errors[theta].append(E)
</pre></div>

<h2 id="___sec58">The automating script </h2>

<p>
We have now all the core elements in place to write the complete
script where we run
<code>model.py</code> for a set of \( \Delta t \) values (given as positional
command-line arguments), make the error plot,
write the CSV file, and combine plot files as described above.
The complete code is listed below, followed by some explaining comments.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>, <span style="color: #008b45; text-decoration: underline">sys</span>, <span style="color: #008b45; text-decoration: underline">glob</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">run_experiments</span>(I=<span style="color: #B452CD">1</span>, a=<span style="color: #B452CD">2</span>, T=<span style="color: #B452CD">5</span>):
    <span style="color: #228B22"># The command line must contain dt values</span>
    <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">len</span>(sys.argv) &gt; <span style="color: #B452CD">1</span>:
        dt_values = [<span style="color: #658b00">float</span>(arg) <span style="color: #8B008B; font-weight: bold">for</span> arg <span style="color: #8B008B">in</span> sys.argv[<span style="color: #B452CD">1</span>:]]
    <span style="color: #8B008B; font-weight: bold">else</span>:
        <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Usage: %s dt1 dt2 dt3 ...&#39;</span> %  sys.argv[<span style="color: #B452CD">0</span>]
        sys.exit(<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># abort</span>

    <span style="color: #228B22"># Run module file and grab output</span>
    cmd = <span style="color: #CD5555">&#39;python model.py --I %g --a %g --T %g&#39;</span> % (I, a, T)
    dt_values_str = <span style="color: #CD5555">&#39; &#39;</span>.join([<span style="color: #658b00">str</span>(v) <span style="color: #8B008B; font-weight: bold">for</span> v <span style="color: #8B008B">in</span> dt_values])
    cmd += <span style="color: #CD5555">&#39; --dt %s&#39;</span> % dt_values_str
    <span style="color: #8B008B; font-weight: bold">print</span> cmd
    <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">subprocess</span> <span style="color: #8B008B; font-weight: bold">import</span> Popen, PIPE, STDOUT
    p = Popen(cmd, shell=<span style="color: #658b00">True</span>, stdout=PIPE, stderr=STDOUT)
    output, _ = p.communicate()
    failure = p.returncode
    <span style="color: #8B008B; font-weight: bold">if</span> failure:
        <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Command failed:&#39;</span>, cmd; sys.exit(<span style="color: #B452CD">1</span>)

    errors = {<span style="color: #CD5555">&#39;dt&#39;</span>: dt_values, <span style="color: #B452CD">1</span>: [], <span style="color: #B452CD">0</span>: [], <span style="color: #B452CD">0.5</span>: []}
    <span style="color: #8B008B; font-weight: bold">for</span> line <span style="color: #8B008B">in</span> output.splitlines():
        words = line.split()
        <span style="color: #8B008B; font-weight: bold">if</span> words[<span style="color: #B452CD">0</span>] <span style="color: #8B008B">in</span> (<span style="color: #CD5555">&#39;0.0&#39;</span>, <span style="color: #CD5555">&#39;0.5&#39;</span>, <span style="color: #CD5555">&#39;1.0&#39;</span>):  <span style="color: #228B22"># line with E?</span>
            <span style="color: #228B22"># typical line: 0.0   1.25:    7.463E+00</span>
            theta = <span style="color: #658b00">float</span>(words[<span style="color: #B452CD">0</span>])
            E = <span style="color: #658b00">float</span>(words[<span style="color: #B452CD">2</span>])
            errors[theta].append(E)

    <span style="color: #228B22"># Find min/max for the axis</span>
    E_min = <span style="color: #B452CD">1E+20</span>; E_max = -E_min
    <span style="color: #8B008B; font-weight: bold">for</span> theta <span style="color: #8B008B">in</span> <span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1</span>:
        E_min = <span style="color: #658b00">min</span>(E_min, <span style="color: #658b00">min</span>(errors[theta]))
        E_max = <span style="color: #658b00">max</span>(E_max, <span style="color: #658b00">max</span>(errors[theta]))

    plt.loglog(errors[<span style="color: #CD5555">&#39;dt&#39;</span>], errors[<span style="color: #B452CD">0</span>], <span style="color: #CD5555">&#39;ro-&#39;</span>)
    plt.loglog(errors[<span style="color: #CD5555">&#39;dt&#39;</span>], errors[<span style="color: #B452CD">0.5</span>], <span style="color: #CD5555">&#39;b+-&#39;</span>)
    plt.loglog(errors[<span style="color: #CD5555">&#39;dt&#39;</span>], errors[<span style="color: #B452CD">1</span>], <span style="color: #CD5555">&#39;gx-&#39;</span>)
    plt.legend([<span style="color: #CD5555">&#39;FE&#39;</span>, <span style="color: #CD5555">&#39;CN&#39;</span>, <span style="color: #CD5555">&#39;BE&#39;</span>], loc=<span style="color: #CD5555">&#39;upper left&#39;</span>)
    plt.xlabel(<span style="color: #CD5555">&#39;log(time step)&#39;</span>)
    plt.ylabel(<span style="color: #CD5555">&#39;log(error)&#39;</span>)
    plt.axis([<span style="color: #658b00">min</span>(dt_values), <span style="color: #658b00">max</span>(dt_values), E_min, E_max])
    plt.title(<span style="color: #CD5555">&#39;Error vs time step&#39;</span>)
    plt.savefig(<span style="color: #CD5555">&#39;error.png&#39;</span>);  plt.savefig(<span style="color: #CD5555">&#39;error.pdf&#39;</span>)

    <span style="color: #228B22"># Write out a table in CSV format</span>
    f = <span style="color: #658b00">open</span>(<span style="color: #CD5555">&#39;error.csv&#39;</span>, <span style="color: #CD5555">&#39;w&#39;</span>)
    f.write(<span style="color: #CD5555">r&#39;$\Delta t$,$\theta=0$,$\theta=0.5$,$\theta=1$&#39;</span> + <span style="color: #CD5555">&#39;\n&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">for</span> _dt, _fe, _cn, _be <span style="color: #8B008B">in</span> <span style="color: #658b00">zip</span>(
        errors[<span style="color: #CD5555">&#39;dt&#39;</span>], errors[<span style="color: #B452CD">0</span>], errors[<span style="color: #B452CD">0.5</span>], errors[<span style="color: #B452CD">1</span>]):
        f.write(<span style="color: #CD5555">&#39;%.2f,%.4f,%.4f,%.4f\n&#39;</span> % (_dt, _fe, _cn, _be))
    f.close()

    <span style="color: #228B22"># Combine images into rows with 2 plots in each row</span>
    image_commands = []
    <span style="color: #8B008B; font-weight: bold">for</span> method <span style="color: #8B008B">in</span> <span style="color: #CD5555">&#39;BE&#39;</span>, <span style="color: #CD5555">&#39;CN&#39;</span>, <span style="color: #CD5555">&#39;FE&#39;</span>:
        pdf_files = <span style="color: #CD5555">&#39; &#39;</span>.join([<span style="color: #CD5555">&#39;%s_%g.pdf&#39;</span> % (method, dt)
                              <span style="color: #8B008B; font-weight: bold">for</span> dt <span style="color: #8B008B">in</span> dt_values])
        png_files = <span style="color: #CD5555">&#39; &#39;</span>.join([<span style="color: #CD5555">&#39;%s_%g.png&#39;</span> % (method, dt)
                              <span style="color: #8B008B; font-weight: bold">for</span> dt <span style="color: #8B008B">in</span> dt_values])
        image_commands.append(
            <span style="color: #CD5555">&#39;montage -background white -geometry 100%&#39;</span> +
            <span style="color: #CD5555">&#39; -tile 2x %s %s.png&#39;</span> % (png_files, method))
        image_commands.append(
            <span style="color: #CD5555">&#39;convert -trim %s.png %s.png&#39;</span> % (method, method))
        image_commands.append(
            <span style="color: #CD5555">&#39;convert %s.png -transparent white %s.png&#39;</span> %
            (method, method))
        image_commands.append(
            <span style="color: #CD5555">&#39;pdftk %s output tmp.pdf&#39;</span> % pdf_files)
        num_rows = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(<span style="color: #658b00">len</span>(dt_values)/<span style="color: #B452CD">2.0</span>))
        image_commands.append(
            <span style="color: #CD5555">&#39;pdfnup --nup 2x%d --outfile tmp.pdf tmp.pdf&#39;</span> % num_rows)
        image_commands.append(
            <span style="color: #CD5555">&#39;pdfcrop tmp.pdf %s.pdf&#39;</span> % method)

    <span style="color: #8B008B; font-weight: bold">for</span> cmd <span style="color: #8B008B">in</span> image_commands:
        <span style="color: #8B008B; font-weight: bold">print</span> cmd
        failure = os.system(cmd)
        <span style="color: #8B008B; font-weight: bold">if</span> failure:
            <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Command failed:&#39;</span>, cmd; sys.exit(<span style="color: #B452CD">1</span>)

    <span style="color: #228B22"># Remove the files generated above and by model.py</span>
    <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">glob</span> <span style="color: #8B008B; font-weight: bold">import</span> glob
    filenames = glob(<span style="color: #CD5555">&#39;*_*.png&#39;</span>) + glob(<span style="color: #CD5555">&#39;*_*.pdf&#39;</span>) + glob(<span style="color: #CD5555">&#39;tmp*.pdf&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">for</span> filename <span style="color: #8B008B">in</span> filenames:
        os.remove(filename)

<span style="color: #8B008B; font-weight: bold">if</span> __name__ == <span style="color: #CD5555">&#39;__main__&#39;</span>:
    run_experiments(I=<span style="color: #B452CD">1</span>, a=<span style="color: #B452CD">2</span>, T=<span style="color: #B452CD">5</span>)
    plt.show()
</pre></div>
<p>
We may comment upon many useful constructs in this script:

<ul>
 <li> <code>[float(arg) for arg in sys.argv[1:]]</code> builds a list of real numbers
   from all the command-line arguments.</li>
 <li> <code>['%s_%s.png' % (method, dt) for dt in dt_values]</code> builds a list of
   filenames from a list of numbers (<code>dt_values</code>).</li>
 <li> All <code>montage</code>, <code>convert</code>, <code>pdftk</code>, <code>pdfnup</code>, and <code>pdfcrop</code>
   commands for creating
   composite figures are stored in a
   list and later executed in a loop.</li>
 <li> <code>glob('*_*.png')</code> returns a list of the names of all files in the
   current directory where the filename matches the <a href="http://en.wikipedia.org/wiki/Glob_(programming)" target="_self">Unix wildcard notation</a>
   <code>*_*.png</code> (meaning any text, underscore, any text, and then <code>.png</code>).</li>
 <li> <code>os.remove(filename)</code> removes the file with name <code>filename</code>.</li>
 <li> <code>failure = os.system(cmd)</code> runs an operating system command with
   simpler syntax than what is required by <code>subprocess</code> (but the output
   of <code>cmd</code> cannot be captured).</li>
</ul>

<h2 id="softeng1:exper:report">Making a report</h2>

<p>
The results of running computer experiments are best documented in a
little report containing the problem to be solved, key code segments,
and the plots from a series of experiments. At least the part of the
report containing the plots should be automatically generated by the
script that performs the set of experiments, because in the script we
know exactly which input data that were used to generate a specific
plot, thereby ensuring that each figure is connected to the
right data. Take a look at <a href="http://tinyurl.com/nc4upel/_static/sphinx-cloud/" target="_self">a sample report</a>  to see what we have in
mind.

<h3 id="___sec60">Word, OpenOffice, GoogleDocs </h3>

<p>
Microsoft Word, its open source counterparts OpenOffice and
LibreOffice, along with GoogleDocs and similar online services are the
dominating tools for writing reports today. Nevertheless, scientific
reports often need mathematical equations and nicely typeset computer
code in monospace font. The support for mathematics and computer code
in the mentioned tools is in this author's view not on par with the
technologies based on <em>markup languages</em> and which are addressed
below. Also, with markup languages one has a readable, pure text file
as source for the report, and changes in this text can easily be
tracked by version control systems like Git. The result is a very
strong tool for monitoring &quot;who did what when&quot; with the files,
resulting in increased reliability of the writing process. For
collaborative writing, the merge functionality in Git leads to safer
simultaneously editing that what is offered even by collaborative
tools like GoogleDocs.

<h3 id="___sec61">HTML with MathJax </h3>

<p>
HTML is the markup language used for web pages.  Nicely typeset computer
code is straightforward in HTML, and high-quality mathematical
typesetting is available using an extension to HTML called <a href="http://www.mathjax.org/" target="_self">MathJax</a>, which allows formulas and equations to be
typeset with LaTeX syntax and nicely rendered in web browsers, see
Figure <a href="#softeng1:exper:report:fig:mathjax">5</a>.  A relatively small
subset of LaTeX environments for mathematics is supported, but the
syntax for formulas is quite rich. Inline formulas look like <code>\(
u'=-au \)</code> while equations are surrounded by <code>$$</code> signs.  Inside such
signs, one can use <code>\[ u'=-au \]</code> for unnumbered equations, or
<code>\begin{equation}</code> and <code>\end{equation}</code> for
numbered equations, or <code>\begin{align}</code> and <code>\end{align}</code> for multiple
numbered aligned equations.  You need to be familiar with <a href="http://en.wikibooks.org/wiki/LaTeX/Mathematics" target="_self">mathematical
typesetting in LaTeX</a> to write MathJax
code.

<p>
The file <a href="http://tinyurl.com/p96acy2/report_generation/exper1_html.py" target="_self"><tt>exper1_mathjax.py</tt></a>
calls a script
<a href="http://tinyurl.com/p96acy2/exper1.py" target="_self"><tt>exper1.py</tt></a>
to perform the numerical experiments and then runs Python
statements for creating an <a href="http://tinyurl.com/nc4upel/_static/report_mathjax.html.html" target="_self">HTML file</a> with the source code for <a href="http://tinyurl.com/nc4upel/_static/report_mathjax.html" target="_self">the scientific report</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  Report in HTML format with MathJax. <div id="softeng1:exper:report:fig:mathjax"></div> </p></center>
<p><img src="fig-softeng/report_mathjax.png" align="bottom" width=600></p>
</center>

<h3 id="___sec62">LaTeX </h3>

<p>
<!-- "http://en.wikibooks.org/wiki/LaTeX" -->

<p>
The <em>de facto</em> language for mathematical typesetting and scientific
report writing is <a href="http://en.wikipedia.org/wiki/LaTeX" target="_self">LaTeX</a>. A
number of very sophisticated packages have been added to the language
over a period of three decades, allowing very fine-tuned layout and
typesetting. For output in the <a href="http://tinyurl.com/nc4upel/_static/report.pdf" target="_self">PDF format</a>, see Figure
<a href="#softeng1:exper:report:fig:latex">6</a> for an example, LaTeX is the
definite choice when it comes to <em>typesetting quality</em>.
The LaTeX language used to
write the reports has typically a lot of commands involving
<a href="http://tinyurl.com/nc4upel/_static/report.tex.html" target="_self">backslashes and braces</a>, and many claim that
LaTeX syntax is not particularly readable.  For output on the web via
HTML code (i.e., not only showing the PDF in the browser window), LaTeX
struggles with delivering high quality typesetting. Other tools,
especially Sphinx, give better results and can also produce
nice-looking PDFs.  The file <a href="http://tinyurl.com/p96acy2/report_generation/exper1_latex.py" target="_self"><tt>exper1_latex.py</tt></a> shows how to
generate the LaTeX source from a program.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 6:  Report in PDF format generated from LaTeX source. <div id="softeng1:exper:report:fig:latex"></div> </p></center>
<p><img src="fig-softeng/report_latexpdf.png" align="bottom" width=600></p>
</center>

<h3 id="___sec63">Sphinx </h3>

<p>
<!-- give pointers to source pages -->

<p>
<a href="http://sphinx.pocoo.org/" target="_self">Sphinx</a> is a typesetting language with
similarities to HTML and LaTeX, but with much less tagging. It has
recently become very popular for software documentation and
mathematical reports. Sphinx can utilize LaTeX for mathematical
formulas and equations. Unfortunately, the
subset of LaTeX mathematics supported is less than in full MathJax (in
particular, numbering of multiple equations in an <code>align</code> type
environment is not supported).  The <a href="http://tinyurl.com/nc4upel/_static/report_sphinx.rst.html" target="_self">Sphinx syntax</a> is an extension of
the reStructuredText language. An attractive feature of Sphinx is its
rich support for <a href="http://tinyurl.com/nc4upel/_static/sphinx-cloud/index.html" target="_self">fancy layout of web pages</a>. In particular,
Sphinx can easily be combined with various layout <em>themes</em> that give a
certain look and feel to the web site and that offers table of
contents, navigation, and search facilities, see Figure
<a href="#softeng1:exper:report:fig:sphinx">7</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 7:  Report in HTML format generated from Sphinx source. <div id="softeng1:exper:report:fig:sphinx"></div> </p></center>
<p><img src="fig-softeng/report_sphinx.png" align="bottom" width=600></p>
</center>

<h3 id="___sec64">Markdown </h3>

<p>
A recent, very popular format for easy writing of web pages is
<a href="http://daringfireball.net/projects/markdown/" target="_self">Markdown</a>.
Text is written very much like one would do in email, using
spacing and special characters to naturally format the code
instead of heavily tagging the text as in LaTeX and HTML.
With the tool <a href="http://johnmacfarlane.net/pandoc/" target="_self">Pandoc</a> one
can go from Markdown to a variety of formats.
HTML is a common output format, but LaTeX, epub, XML,
OpenOffice/LibreOffice, MediaWiki, and Microsoft Word are some other
possibilities. A Markdown version of our scientific
report demo is available as an IPython/Jupyter notebook (described next).

<h3 id="___sec65">IPython/Jupyter notebooks </h3>

<p>
The <a href="http://ipython.org/notebook.html" target="_self">IPython Notebook</a> is
a web-based tool where one can write scientific reports with live computer
code and graphics. Or the other way around: software can be equipped
with documentation in the style of scientific reports.
A slightly extended version of Markdown is used for writing text and
mathematics, and the <a href="http://tinyurl.com/nc4upel/_static/report.ipynb.html" target="_self">source code of a notebook</a> is in json format.
The interest in the notebook has grown amazingly fast
over just a few years, and further development now takes place
in the <a href="https://jupyter.org/" target="_self">Jupyter project</a>, which
supports a lot of programming languages for interactive notebook computing.
Jupyter notebooks are primarily live electronic documents, but they can be
printed out as PDF reports too.
A notebook version of our scientific report can be <a href="http://tinyurl.com/p96acy2/_static/report.ipynb" target="_self">downloaded</a> and experimented with
or <a href="http://nbviewer.ipython.org/url/hplgit.github.com/teamods/writing_reports/_static/report.ipynb" target="_self">just statically viewed</a> in a browser.

<h3 id="___sec66">Wiki formats </h3>

<p>
A range of wiki formats are popular for creating notes on the web,
especially documents which allow groups of people to edit and add
content. Apart from <a href="http://www.mediawiki.org/wiki/MediaWiki" target="_self">MediaWiki</a> (the wiki format used for
Wikipedia), wiki formats have no support for mathematical typesetting
and also limited tools for displaying computer code in nice ways.
Wiki formats are therefore less suitable for scientific reports compared
to the other formats mentioned here.

<h3 id="___sec67">DocOnce </h3>

<p>
Since it is difficult to choose the right tool or format for writing a
scientific report, it is advantageous to write the content in a format
that easily translates to LaTeX, HTML, Sphinx, Markdown,
IPython/Jupyter notebooks, and various wikis. <a href="https://github.com/hplgit/doconce" target="_self">DocOnce</a> is such a tool. It is similar to
Pandoc, but offers some special convenient features for writing about
mathematics and programming.  The <a href="http://tinyurl.com/nc4upel/_static/report.do.txt.html" target="_self">tagging is modest</a>, somewhere between
LaTeX and Markdown.  The program <a href="http://tinyurl.com/p96acy2/exper1_do.py" target="_self"><tt>exper1_do.py</tt></a> demonstrates how
to generate DocOnce code for a scientific report.
There is also a corresponding rich demo of the <a href="http://tinyurl.com/nc4upel/index.html" target="_self">resulting reports</a> that can be made from
this DocOnce code.

<p>
<!-- project with exploring instability (help with matplotlib contour plots, and maybe show such a plot) -->

<h2 id="softeng1:exper:github">Publishing a complete project</h2>

<p>
To assist the important principle of <em>replicable</em> science,
a report documenting scientific investigations should be accompanied by
all the software and data used for the investigations so that others
have a possibility to redo the work and assess the qualify of the results.

<p>
One way of documenting a complete project is to make a directory tree
with all relevant files. Preferably, the tree is published at
some project hosting site like <a href="http://hplgit.github.com/teamods/bitgit/html/" target="_self">Bitbucket or GitHub</a> so that others can download it
as a tarfile, zipfile, or clone the files directly using the Git version control
system.
For the investigations outlined in the section <a href="#softeng1:exper:report">Making a report</a>,
we can create a directory tree with files
<p>

<!-- code=text typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">setup.py
./src:
   model.py
./doc:
   ./src:
      exper1_mathjax.py
      make_report.sh
      run.sh
   ./pub:
      report.html
</pre></div>
<p>
The <code>src</code> directory holds source code (modules) to be reused in other projects,
the <code>setup.py</code> script builds and installs such software,
the <code>doc</code> directory contains the documentation, with <code>src</code> for the
source of the documentation (usually written in a markup language)
and <code>pub</code> for published (compiled) documentation.
The <code>run.sh</code> file is a simple Bash script listing the <code>python</code> commands
we used to run <code>exper1_mathjax.py</code> to generate the experiments and
the <code>report.html</code> file.

<p>
<!-- Point to DocOnce version -->

<h1 id="___sec69">Exercises </h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="softeng1:exer:derivative">Problem 1: Make a tool for differentiating curves</h2>

<p>
Suppose we have a curve specified through a set
of discrete coordinates \( (x_i,y_i) \), \( i=0,\ldots,n \), where the \( x_i \)
values are uniformly distributed with spacing \( \Delta x \): \( x_i=\Delta x \).
The derivative of this curve, defined as a new curve with points
\( (x_i, d_i) \), can be computed via finite differences:

$$
\begin{align}
d_0 &= \frac{y_1-y_0}{\Delta x},
\tag{6}\\ 
d_i &= \frac{y_{i+1}-y_{i-1}}{2\Delta x},\quad i=1,\ldots,n-1,
\tag{7}\\ 
d_n &= \frac{y_n-y_{n-1}}{\Delta x}\tp
\tag{8}
\end{align}
$$

<p>
<b>a)</b>
Write a function
<code>differentiate(x, y)</code> for differentiating a curve
with coordinates in the arrays <code>x</code> and <code>y</code>, using the
formulas above. The function should return the coordinate arrays
of the resulting differentiated curve.

<p>
<b>b)</b>
Since the formulas for differentiation used here are only approximate,
with unknown approximation errors, it is challenging to construct
test cases. Here are three approaches, which should be implemented
in three separate test functions.

<ol>
<li> Consider a curve with three points and compute \( d_i \), \( i=0,1,2 \),
   by hand. Make a test that compares the hand-calculated results with those
   from the function in a).</li>
<li> The formulas for \( d_i \) are exact for points on
   a straight line, as all the \( d_i \) values are then the same, equal to
   the slope of the line. A test can check this property.</li>
<li> For point lying on a parabola, the values for \( d_i \), \( i=1,\ldots,n-1 \),
   should equal the exact derivative of the parabola. Make a test based on
   this property.</li>
</ol>

<b>c)</b>
Start with a curve corresponding to \( y=\sin(\pi x) \) and \( n+1 \)
points in \( [0,1] \). Apply <code>differentiate</code> four times and plot the
resulting curve and the exact \( y=\sin\pi x \) for \( n=6, 11, 21, 41 \).

<p>
<!-- Using a 2nd-order backward formula at x=1 does not improve the -->
<!-- results much, one gets large errors at the end points. -->

<p>
Filename: <code>curvediff</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="softeng1:exer:integral:flat">Problem 2: Make solid software for the Trapezoidal rule</h2>

<p>
An integral

$$ \int_a^b f(x)dx $$

can be numerically approximated by the Trapezoidal rule,

$$ \int_a^b f(x)dx \approx \frac{h}{2}(f(a) + f(b)) + h\sum_{i=1}^{n-1} f(x_i),
$$

where \( x_i \) is a set of uniformly spaced points in \( [a,b] \):

$$ h = \frac{b-a}{n},\quad x_i=a + ih,\ i=1,\ldots,n-1\tp $$

<p>
Somebody has used this rule to compute the integral \( \int_0^\pi \sin^2x\, dx \):

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> pi, sin
np = <span style="color: #B452CD">20</span>
h = pi/np
I = <span style="color: #B452CD">0</span>
<span style="color: #8B008B; font-weight: bold">for</span> k <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, np):
    I += sin(k*h)**<span style="color: #B452CD">2</span>
<span style="color: #8B008B; font-weight: bold">print</span> I
</pre></div>
<p>
<b>a)</b>
The &quot;flat&quot; implementation above suffers from serious flaws:

<ol>
<li> A general numerical algorithm (the Trapezoidal rule) is implemented
   in a specialized form where the formula for \( f \) is inserted directly
   into the code for the general integration formula.</li>
<li> A general numerical algorithm is not encapsulated as a general
   function, with appropriate parameters, which can be reused
   across a wide range of applications.</li>
<li> The lazy programmer dropped the first terms in the general formula
   since \( \sin(0)=\sin(\pi)=0 \).</li>
<li> The sloppy programmer used <code>np</code> (number of points?) as variable for
   <code>n</code> in the formula and a counter <code>k</code> instead of <code>i</code>. Such small
   deviations from the mathematical notation are completely unnecessary.
   The closer the code and the mathematics can get, the easier it is
   to spot errors in formulas.</li>
</ol>

Write a function <code>trapezoidal</code> that fixes these flaws.
Place the function in a module <code>trapezoidal</code>.

<p>
<b>b)</b>
Write a test function <code>test_trapezoidal</code>. Call the test function
explicitly to check that it works. Remove the call and run pytest
on the module:

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; py.test -s -v trapezoidal
</pre></div>
<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Note that even if you know the value of the integral, you do not know
the error in the approximation produced by the Trapezoidal rule.
However, the Trapezoidal rule will integrate linear functions
exactly (i.e., to machine precision). Base a test function
on a linear \( f(x) \).

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>c)</b>
Add functionality such that we can compute \( \int_a^b f(x)dx \) by providing
\( f \), \( a \), \( b \), and \( n \) as positional command-line arguments to the
module file:

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python trapezoidal.py &#39;sin(x)**2&#39; 0 pi 20
</pre></div>
<p>
Here, \( a=0 \), \( b=\pi \), and \( n=20 \).

<p>
Note that the <code>trapezoidal.py</code> file must still be a valid module file, so the
interpretation of command-line data and computation of the integral
must be performed from calls in a test block.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
To translate a string formula on the command line, like <code>sin(x)**2</code>,
into a Python function, you can wrap a function declaration around
the formula and run <code>exec</code> on the string to turn it into live Python code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">math</span>, <span style="color: #008b45; text-decoration: underline">sys</span>
formula = sys.argv[<span style="color: #B452CD">1</span>]
f_code = <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">def f(x):</span>
<span style="color: #CD5555">    return %s</span>
<span style="color: #CD5555">&quot;&quot;&quot;</span> % formula
<span style="color: #8B008B; font-weight: bold">exec</span>(code, math.__dict__)
</pre></div>
<p>
The result is the same as if we had hardcoded

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> *

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">f</span>(x):
    <span style="color: #8B008B; font-weight: bold">return</span> sin(x)**<span style="color: #B452CD">2</span>
</pre></div>
<p>
in the program. Note that <code>exec</code> needs the namespace
<code>math.__dict__</code>, i.e., all names in the <code>math</code> module, such that
it understands <code>sin</code> and other mathematical functions.
Similarly, to allow \( a \) and \( b \) to be <code>math</code> expressions like <code>pi/4</code>
and <code>exp(4)</code>, do

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">a = eval(sys.argv[2], math.__dict__)
b = eval(sys.argv[2], math.__dict__)
</pre></div>
<p>
<!-- --- end hint in exercise --- -->

<p>
<b>d)</b>
Write a test function for verifying the implementation of
data reading from the command line.

<p>
Filename: <code>trapezoidal</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="softeng1:exer:integral:flat2">Problem 3: Implement classes for the Trapezoidal rule</h2>

<p>
We consider the same problem setting as in <a href="#softeng1:exer:integral:flat">Problem 2: Make solid software for the Trapezoidal rule</a>. Make a module with a class <code>Problem</code>
representing the mathematical problem to be solved and a class
<code>Solver</code> representing the solution method.  The rest of the
functionality of the module, including test functions and reading data
from the command line, should be as in <a href="#softeng1:exer:integral:flat">Problem 2: Make solid software for the Trapezoidal rule</a>.
Filename: <code>trapezoidal_class</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="softeng1:exer:doctest1">Problem 4: Write a doctest and a test function</h2>

<p>
Type in the following program:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sys</span>
<span style="color: #228B22"># This sqrt(x) returns real if x&gt;0 and complex if x&lt;0</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy.lib.scimath</span> <span style="color: #8B008B; font-weight: bold">import</span> sqrt

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">roots</span>(a, b, c):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Return the roots of the quadratic polynomial</span>
<span style="color: #CD5555">    p(x) = a*x**2 + b*x + c.</span>

<span style="color: #CD5555">    The roots are real or complex objects.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    q = b**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">4</span>*a*c
    r1 = (-b + sqrt(q))/(<span style="color: #B452CD">2</span>*a)
    r2 = (-b - sqrt(q))/(<span style="color: #B452CD">2</span>*a)
    <span style="color: #8B008B; font-weight: bold">return</span> r1, r2

a, b, c = [<span style="color: #658b00">float</span>(arg) <span style="color: #8B008B; font-weight: bold">for</span> arg <span style="color: #8B008B">in</span> sys.argv[<span style="color: #B452CD">1</span>:]]
<span style="color: #8B008B; font-weight: bold">print</span> roots(a, b, c)
</pre></div>
<p>
<b>a)</b>
Equip the <code>roots</code> function with a doctest.
Make sure to test both real and complex roots.
Write out numbers in the doctest with 14 digits or less.

<p>
<b>b)</b>
Make a test function for the <code>roots</code> function. Perform the
same mathematical tests as in a), but with different
programming technology.

<p>
Filename: <code>test_roots</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="softeng1:exer:tol">Problem 5: Experiment with tolerances in comparisons</h2>

<p>
When we replace a comparison <code>a == b</code>, where <code>a</code> and/or <code>b</code> are
<code>float</code> objects, by a comparison with tolerance, <code>abs(a-b) &lt; tol</code>,
the appropriate size of <code>tol</code> depends on the size <code>a</code> and <code>b</code>.
Investigate how the size of <code>abs(a-b)</code> varies when <code>b</code> takes on
values \( 10^k \), \( k=-5,-9,\ldots,20 \) and <code>a=1.0/49*b*49</code>.
Filename: <code>tolerance</code>.

<p>
<!-- Closing remarks for this Problem -->

<h3 id="___sec75">Remarks </h3>

<p>
You will experience that if <code>a</code> and <code>b</code> are large, as they can be
in geophysical applications where lengths measured in meters can be of size
\( 10^6 \) m, <code>tol</code> must be about \( 10^{-9} \), while <code>a</code> and <code>b</code> around unity can
have <code>tol</code> of size \( 10^{-15} \).

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="softeng1:exer:class:dts">Exercise 6: Make use of a class implementation</h2>

<p>
Implement the <code>experiment_compare_dt</code> function from <code>decay.py</code>
using class <code>Problem</code> and class <code>Solver</code> from
the section <a href="#softeng1:prog:se:class">Classes for problem and solution method</a>.
The parameters <code>I</code>, <code>a</code>, <code>T</code>, the scheme name, and a series of
<code>dt</code> values should be read from the command line.
Filename: <code>experiment_compare_dt_class</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="softeng1:exer:logistic">Problem 7: Make solid software for a difference equation</h2>

<p>
We have the following evolutionary difference equation for the number
of individuals \( u^n \) of a certain specie at time \( n\Delta t \):

$$
\begin{equation}
u^{n+1} = u^n + \Delta t r u^n\left(1 - \frac{u^n}{M^n}\right),
\quad u^0=U_0\tp
\tag{9}
\end{equation}
$$

Here, \( n \) is a counter in time, \( \Delta t \) is time between time levels
\( n \) and \( n+1 \) (assumed constant), \( r \) is a net reproduction rate
for the specie,
and \( M^n \) is the upper limit of the population that the environment can
sustain at time level \( n \).
Filename: <code>logistic</code>.

<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._softeng-solarized000.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._softeng-solarized002.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

