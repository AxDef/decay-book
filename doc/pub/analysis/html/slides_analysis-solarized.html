<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study guide: Analysis of exponential decay models">
<meta name="keywords" content="stability,consistency,stability,convergence">

<title>Study guide: Analysis of exponential decay models</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Analysis of finite difference equations',
               1,
               'decay:analysis',
               'decay:analysis'),
              ('Encouraging numerical solutions', 2, None, '___sec1'),
              ('Discouraging numerical solutions; Crank-Nicolson',
               2,
               None,
               '___sec2'),
              ('Discouraging numerical solutions; Forward Euler',
               2,
               None,
               '___sec3'),
              ('Summary of observations', 2, None, '___sec4'),
              ('Problem setting', 2, None, '___sec5'),
              ('Experimental investigation of oscillatory solutions',
               2,
               None,
               '___sec6'),
              ('Exact numerical solution', 2, None, '___sec7'),
              ('Stability', 2, None, '___sec8'),
              ('Computation of stability in this problem',
               2,
               None,
               '___sec9'),
              ('Computation of stability in this problem',
               2,
               None,
               '___sec10'),
              ('Explanation of problems with Forward Euler',
               2,
               None,
               '___sec11'),
              ('Explanation of problems with Crank-Nicolson',
               2,
               None,
               '___sec12'),
              ('Summary of stability', 2, None, '___sec13'),
              ('Comparing amplification factors', 2, None, '___sec14'),
              ('Plot of amplification factors', 2, None, '___sec15'),
              ('$p=a\\Delta t$ is the important parameter for numerical performance',
               2,
               None,
               '___sec16'),
              ('Series expansion of amplification factors',
               2,
               None,
               '___sec17'),
              ('Error in amplification factors', 2, None, '___sec18'),
              ('The fraction of numerical and exact amplification factors',
               2,
               None,
               '___sec19'),
              ('The true/global error at a point',
               2,
               'decay:analysis:gobal:error',
               'decay:analysis:gobal:error'),
              ('Computing the global error at a point', 2, None, '___sec21'),
              ('Convergence', 2, None, '___sec22'),
              ('Integrated errors', 2, None, '___sec23'),
              ('Truncation error', 2, None, '___sec24'),
              ('Computation of the truncation error', 2, None, '___sec25'),
              ('The truncation error for other schemes', 2, None, '___sec26'),
              ('Consistency, stability, and convergence',
               2,
               None,
               '___sec27')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
$$




    
<!-- ------------------- main content ---------------------- -->



<center><h1>Study guide: Analysis of exponential decay models</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>

<p>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>
<br>
<p>
<center><h4>Sep 13, 2016</h4></center> <!-- date -->
<br>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Table of contents</h2>

<p>
<a href="#decay:analysis"> Analysis of finite difference equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec1"> Encouraging numerical solutions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec2"> Discouraging numerical solutions; Crank-Nicolson </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec3"> Discouraging numerical solutions; Forward Euler </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec4"> Summary of observations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec5"> Problem setting </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec6"> Experimental investigation of oscillatory solutions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec7"> Exact numerical solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec8"> Stability </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec9"> Computation of stability in this problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec10"> Computation of stability in this problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec11"> Explanation of problems with Forward Euler </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec12"> Explanation of problems with Crank-Nicolson </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec13"> Summary of stability </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec14"> Comparing amplification factors </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec15"> Plot of amplification factors </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec16"> \( p=a\Delta t \) is the important parameter for numerical performance </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec17"> Series expansion of amplification factors </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec18"> Error in amplification factors </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec19"> The fraction of numerical and exact amplification factors </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:analysis:gobal:error"> The true/global error at a point </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec21"> Computing the global error at a point </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec22"> Convergence </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec23"> Integrated errors </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec24"> Truncation error </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec25"> Computation of the truncation error </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec26"> The truncation error for other schemes </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec27"> Consistency, stability, and convergence </a><br>
</p>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="decay:analysis">Analysis of finite difference equations</h1>

<p>
Model:
$$
\begin{equation}
u'(t) = -au(t),\quad u(0)=I
\label{_auto1}
\end{equation}
$$

<p>
Method:
$$
\begin{equation}
u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n
\label{decay:analysis:scheme}
\end{equation}
$$

<p>
<div class="alert alert-block alert-question alert-text-normal">
<b>Problem setting.</b>
<p>
How good is this method? Is it safe to use it?
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec1">Encouraging numerical solutions </h2>

<p>
\( I=1 \), \( a=2 \), \( \theta =1,0.5, 0 \), \( \Delta t=1.25, 0.75, 0.5, 0.1 \).

<p>
<center><p><img src="fig-analysis/BE4c.png" align="bottom" width=600></p></center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec2">Discouraging numerical solutions; Crank-Nicolson </h2>

<p>
<center><p><img src="fig-analysis/CN4c.png" align="bottom" width=600></p></center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec3">Discouraging numerical solutions; Forward Euler </h2>

<p>
<center><p><img src="fig-analysis/FE4c.png" align="bottom" width=600></p></center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec4">Summary of observations </h2>

<p>
The characteristics of the displayed curves can be summarized as follows:

<ul>
  <p><li> The Backward Euler scheme <em>always</em> gives a monotone solution, lying above
    the exact solution.</li>
  <p><li> The Crank-Nicolson scheme gives the most accurate results, but for
    \( \Delta t=1.25 \) the solution oscillates.</li>
  <p><li> The Forward Euler scheme gives a growing, oscillating solution for
    \( \Delta t=1.25 \); a decaying, oscillating solution for \( \Delta t=0.75 \);
    a strange solution \( u^n=0 \) for \( n\geq 1 \) when \( \Delta t=0.5 \); and
    a solution seemingly as accurate as the one by the Backward Euler
    scheme for \( \Delta t = 0.1 \), but the curve lies <em>below</em> the exact
    solution.</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec5">Problem setting </h2>

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Goal.</b>
<p>
We ask the question

<ul>
  <p><li> Under what circumstances, i.e., values of
    the input data \( I \), \( a \), and \( \Delta t \) will the Forward Euler and
    Crank-Nicolson schemes result in undesired oscillatory solutions?</li>
</ul>

Techniques of investigation:

<ul>
 <p><li> Numerical experiments</li>
 <p><li> Mathematical analysis</li>
</ul>

Another question to be raised is

<ul>
 <p><li> How does \( \Delta t \) impact the error in the numerical solution?</li>
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec6">Experimental investigation of oscillatory solutions </h2>

<p>
The solution is oscillatory if
$$ u^{n} > u^{n-1}$$

("Safe choices" of \( \Delta t \) lie
under the following curve as a function of \( a \).)

<p>
<center><p><img src="fig-analysis/osc_region_FE.png" align="bottom" width=400></p></center>

<p>
Seems that \( a\Delta t < 1 \) for FE and 2 for CN.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec7">Exact numerical solution </h2>

<p>
Starting with \( u^0=I \), the simple recursion \eqref{decay:analysis:scheme}
can be applied repeatedly \( n \) times, with the result that

$$
\begin{equation}
u^{n} = IA^n,\quad A = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}
\label{decay:analysis:unex}
\end{equation}
$$

<p>
Such a formula for the exact discrete solution is unusual to obtain in
practice, but very handy for our analysis here.

<p>
Note: An exact dicrete
solution fulfills a discrete equation (without round-off
errors), whereas an exact solution fulfills the original mathematical equation.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec8">Stability </h2>

<p>
Since \( u^n=I A^n \),

<ul>
 <p><li> \( A < 0 \) gives a factor \( (-1)^n \) and oscillatory solutions</li>
 <p><li> \( |A|>1 \) gives growing solutions</li>
 <p><li> Recall: the exact solution is <em>monotone</em> and <em>decaying</em></li>
 <p><li> If these qualitative properties are not met, we say that the
   numerical solution is <em>unstable</em></li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec9">Computation of stability in this problem </h2>

<p>
\( A < 0 \) if

$$
\frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t} < 0
$$

To avoid oscillatory solutions we must have \( A> 0 \) and

$$
\begin{equation}
\Delta t < \frac{1}{(1-\theta)a}\ 
\label{_auto2}
\end{equation}
$$


<ul>
 <p><li> Always fulfilled for Backward Euler</li>
 <p><li> \( \Delta t \leq 1/a \) for Forward Euler</li>
 <p><li> \( \Delta t \leq 2/a \) for Crank-Nicolson</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec10">Computation of stability in this problem </h2>

<p>
\( |A|\leq 1 \) means \( -1\leq A\leq 1 \)

$$
\begin{equation}
-1\leq\frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t} \leq 1
\label{decay:th:stability}
\end{equation}
$$

\( -1 \) is the critical limit (because \( A\le 1 \) is always satisfied):

$$
\begin{align*}
\Delta t &\leq \frac{2}{(1-2\theta)a},\quad \mbox{when }\theta < \half
\end{align*}
$$


<ul>
 <p><li> Always fulfilled for Backward Euler and Crank-Nicolson</li>
 <p><li> \( \Delta t \leq 2/a \) for Forward Euler</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec11">Explanation of problems with Forward Euler </h2>

<p>
<center><p><img src="fig-analysis/FE4c.png" align="bottom" width=500></p></center>

<ul>
 <p><li> \( a\Delta t= 2\cdot 1.25=2.5 \) and \( A=-1.5 \): oscillations and growth</li>
 <p><li> \( a\Delta t = 2\cdot 0.75=1.5 \) and \( A=-0.5 \): oscillations and decay</li>
 <p><li> \( \Delta t=0.5 \) and \( A=0 \): \( u^n=0 \) for \( n>0 \)</li>
 <p><li> Smaller \( \Delta t \): qualitatively correct solution</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec12">Explanation of problems with Crank-Nicolson </h2>

<p>
<center><p><img src="fig-analysis/CN4c.png" align="bottom" width=500></p></center>

<ul>
 <p><li> \( \Delta t=1.25 \) and \( A=-0.25 \): oscillatory solution</li>
 <p><li> Never any growing solution</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec13">Summary of stability </h2>

<ol>
<p><li> Forward Euler is <em>conditionally stable</em></li>

<ul>
   <p><li> \( \Delta t < 2/a \) for avoiding growth</li>
   <p><li> \( \Delta t\leq 1/a \) for avoiding oscillations</li>
</ul>

<p><li> The Crank-Nicolson is <em>unconditionally stable</em> wrt growth
   and conditionally stable wrt oscillations</li>

<ul>
   <p><li> \( \Delta t < 2/a \) for avoiding oscillations</li>
</ul>

<p><li> Backward Euler is unconditionally stable</li>
</ol>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec14">Comparing amplification factors </h2>

<p>
\( u^{n+1} \) is an amplification \( A \) of \( u^n \):

$$ u^{n+1} = Au^n,\quad A = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t} $$

<p>
The exact solution is also an amplification:

$$ u(t_{n+1}) = \Aex u(t_n), \quad \Aex = e^{-a\Delta t}$$

<p>
A possible measure of accuracy: \( \Aex - A \)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec15">Plot of amplification factors </h2>

<p>
<center><p><img src="fig-analysis/A_factors.png" align="bottom" width=600></p></center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec16">\( p=a\Delta t \) is the important parameter for numerical performance </h2>

<ul>
 <p><li> \( p=a\Delta t \) is a dimensionless parameter</li>
 <p><li> all expressions for stability and accuracy involve \( p \)</li>
 <p><li> Note that \( \Delta t \) alone is not so important, it is the
   combination with \( a \) through \( p=a\Delta t \) that matters</li>
</ul>

<div class="alert alert-block alert-notice alert-text-normal">
<b>Another &quot;proof&quot; why \( p=a\Delta t \) is key.</b>
<p>
If we scale the model
by \( \bar t=at \), \( \bar u=u/I \), we get
\( d\bar u/d\bar t = -\bar u \), \( \bar u(0)=1 \) (no physical parameters!).
The analysis show that \( \Delta \bar t \) is key, corresponding to
\( a\Delta t \) in the unscaled model.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec17">Series expansion of amplification factors </h2>

<p>
To investigate \( \Aex - A \) mathematically, we
can Taylor expand the expression, using \( p=a\Delta t \) as variable.

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">import</span> *
&gt;&gt;&gt; <span style="color: #228B22"># Create p as a mathematical symbol with name &#39;p&#39;</span>
&gt;&gt;&gt; p = Symbol(<span style="color: #CD5555">&#39;p&#39;</span>)
&gt;&gt;&gt; <span style="color: #228B22"># Create a mathematical expression with p</span>
&gt;&gt;&gt; A_e = exp(-p)
&gt;&gt;&gt;
&gt;&gt;&gt; <span style="color: #228B22"># Find the first 6 terms of the Taylor series of A_e</span>
&gt;&gt;&gt; A_e.series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">6</span>)
<span style="color: #B452CD">1</span> + (<span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>)*p**<span style="color: #B452CD">2</span> - p - <span style="color: #B452CD">1</span>/<span style="color: #B452CD">6</span>*p**<span style="color: #B452CD">3</span> - <span style="color: #B452CD">1</span>/<span style="color: #B452CD">120</span>*p**<span style="color: #B452CD">5</span> + (<span style="color: #B452CD">1</span>/<span style="color: #B452CD">24</span>)*p**<span style="color: #B452CD">4</span> + O(p**<span style="color: #B452CD">6</span>)

&gt;&gt;&gt; theta = Symbol(<span style="color: #CD5555">&#39;theta&#39;</span>)
&gt;&gt;&gt; A = (<span style="color: #B452CD">1</span>-(<span style="color: #B452CD">1</span>-theta)*p)/(<span style="color: #B452CD">1</span>+theta*p)
&gt;&gt;&gt; FE = A_e.series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>) - A.subs(theta, <span style="color: #B452CD">0</span>).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>)
&gt;&gt;&gt; BE = A_e.series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>) - A.subs(theta, <span style="color: #B452CD">1</span>).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>)
&gt;&gt;&gt; half = Rational(<span style="color: #B452CD">1</span>,<span style="color: #B452CD">2</span>)  <span style="color: #228B22"># exact fraction 1/2</span>
&gt;&gt;&gt; CN = A_e.series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>) - A.subs(theta, half).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>)
&gt;&gt;&gt; FE
(<span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>)*p**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">1</span>/<span style="color: #B452CD">6</span>*p**<span style="color: #B452CD">3</span> + O(p**<span style="color: #B452CD">4</span>)
&gt;&gt;&gt; BE
-<span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>*p**<span style="color: #B452CD">2</span> + (<span style="color: #B452CD">5</span>/<span style="color: #B452CD">6</span>)*p**<span style="color: #B452CD">3</span> + O(p**<span style="color: #B452CD">4</span>)
&gt;&gt;&gt; CN
(<span style="color: #B452CD">1</span>/<span style="color: #B452CD">12</span>)*p**<span style="color: #B452CD">3</span> + O(p**<span style="color: #B452CD">4</span>)
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec18">Error in amplification factors </h2>

<p>
Focus: the error measure \( A-\Aex \) as function of \( \Delta t \) (recall that \( p=a\Delta t \)):

$$
\begin{equation}
A-\Aex = \left\lbrace\begin{array}{ll}
\Oof{\Delta t^2}, & \hbox{Forward and Backward Euler},\\ 
\Oof{\Delta t^3}, & \hbox{Crank-Nicolson}
\end{array}\right.
\label{_auto3}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec19">The fraction of numerical and exact amplification factors </h2>

<p>
Focus: the error measure \( 1-A/\Aex \) as function of \( p=a\Delta t \):

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; FE = <span style="color: #B452CD">1</span> - (A.subs(theta, <span style="color: #B452CD">0</span>)/A_e).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>)
&gt;&gt;&gt; BE = <span style="color: #B452CD">1</span> - (A.subs(theta, <span style="color: #B452CD">1</span>)/A_e).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>)
&gt;&gt;&gt; CN = <span style="color: #B452CD">1</span> - (A.subs(theta, half)/A_e).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>)
&gt;&gt;&gt; FE
(<span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>)*p**<span style="color: #B452CD">2</span> + (<span style="color: #B452CD">1</span>/<span style="color: #B452CD">3</span>)*p**<span style="color: #B452CD">3</span> + O(p**<span style="color: #B452CD">4</span>)
&gt;&gt;&gt; BE
-<span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>*p**<span style="color: #B452CD">2</span> + (<span style="color: #B452CD">1</span>/<span style="color: #B452CD">3</span>)*p**<span style="color: #B452CD">3</span> + O(p**<span style="color: #B452CD">4</span>)
&gt;&gt;&gt; CN
(<span style="color: #B452CD">1</span>/<span style="color: #B452CD">12</span>)*p**<span style="color: #B452CD">3</span> + O(p**<span style="color: #B452CD">4</span>)
</pre></div>
</td></tr></table><p>
Same leading-order terms as for the error measure \( A-\Aex \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="decay:analysis:gobal:error">The true/global error at a point</h2>

<ul>
 <p><li> The error in \( A \) reflects the <em>local (amplification) error</em> when going from one
   time step to the next</li>
 <p><li> What is the <em>global (true) error</em> at \( t_n \)?
   \( e^n = \uex(t_n) - u^n = Ie^{-at_n} - IA^n \)</li>
 <p><li> Taylor series expansions of \( e^n \) simplify the expression</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec21">Computing the global error at a point </h2>

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; n = Symbol(<span style="color: #CD5555">&#39;n&#39;</span>)
&gt;&gt;&gt; u_e = exp(-p*n)   <span style="color: #228B22"># I=1</span>
&gt;&gt;&gt; u_n = A**n        <span style="color: #228B22"># I=1</span>
&gt;&gt;&gt; FE = u_e.series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>) - u_n.subs(theta, <span style="color: #B452CD">0</span>).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>)
&gt;&gt;&gt; BE = u_e.series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>) - u_n.subs(theta, <span style="color: #B452CD">1</span>).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>)
&gt;&gt;&gt; CN = u_e.series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>) - u_n.subs(theta, half).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>)
&gt;&gt;&gt; FE
(<span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>)*n*p**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>*n**<span style="color: #B452CD">2</span>*p**<span style="color: #B452CD">3</span> + (<span style="color: #B452CD">1</span>/<span style="color: #B452CD">3</span>)*n*p**<span style="color: #B452CD">3</span> + O(p**<span style="color: #B452CD">4</span>)
&gt;&gt;&gt; BE
(<span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>)*n**<span style="color: #B452CD">2</span>*p**<span style="color: #B452CD">3</span> - <span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>*n*p**<span style="color: #B452CD">2</span> + (<span style="color: #B452CD">1</span>/<span style="color: #B452CD">3</span>)*n*p**<span style="color: #B452CD">3</span> + O(p**<span style="color: #B452CD">4</span>)
&gt;&gt;&gt; CN
(<span style="color: #B452CD">1</span>/<span style="color: #B452CD">12</span>)*n*p**<span style="color: #B452CD">3</span> + O(p**<span style="color: #B452CD">4</span>)
</pre></div>
</td></tr></table><p>
Substitute \( n \) by \( t/\Delta t \):

<ul>
 <p><li> Forward and Backward Euler: leading order term \( \half ta^2\Delta t \)</li>
 <p><li> Crank-Nicolson: leading order term \( \frac{1}{12}ta^3\Delta t^2 \)</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec22">Convergence </h2>

<p>
The numerical scheme is convergent if the global error
\( e^n\rightarrow 0 \) as \( \Delta t\rightarrow 0 \).
If the error has a leading order term \( \Delta t^r \), the
convergence rate is of order \( r \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec23">Integrated errors </h2>

<p>
Focus: norm of the numerical error

$$ ||e^n||_{\ell^2} = \sqrt{\Delta t\sum_{n=0}^{N_t} ({\uex}(t_n) - u^n)^2}$$

<p>
Forward and Backward Euler:

$$ ||e^n||_{\ell^2} = \frac{1}{4}\sqrt{\frac{T^3}{3}} a^2\Delta t$$

<p>
Crank-Nicolson:

$$ ||e^n||_{\ell^2} = \frac{1}{12}\sqrt{\frac{T^3}{3}}a^3\Delta t^2$$

<p>
<div class="alert alert-block alert-summary alert-text-normal">
<b>Summary of errors.</b>
<p>
Analysis of both the pointwise and the time-integrated true errors:

<ul>
  <p><li> 1st order for Forward and Backward Euler</li>
  <p><li> 2nd order for Crank-Nicolson</li>
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec24">Truncation error </h2>

<ul>
 <p><li> How good is the discrete equation?</li>
 <p><li> Possible answer: see how well \( \uex \) fits the discrete equation</li>
</ul>

$$ \lbrack D^{+}_t u = -au\rbrack^n$$

i.e.,

$$ \frac{u^{n+1}-u^n}{\Delta t} = -au^n$$

Insert \( \uex \) (which does not in general fulfill this discrete equation):

$$
\begin{equation}
\frac{\uex(t_{n+1})-\uex(t_n)}{\Delta t} + a\uex(t_n) = R^n \neq 0
\label{decay:analysis:trunc:Req}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec25">Computation of the truncation error </h2>

<ul>
 <p><li> The residual \( R^n \) is the <em>truncation error</em>.</li>
 <p><li> How does \( R^n \) vary with \( \Delta t \)?</li>
</ul>

Tool: Taylor expand \( \uex \) around the point where the ODE is sampled
(here \( t_n \))

$$ \uex(t_{n+1}) = \uex(t_n) + \uex'(t_n)\Delta t + \half\uex''(t_n)
\Delta t^2 + \cdots $$

Inserting this Taylor series in \eqref{decay:analysis:trunc:Req} gives

$$ R^n = \uex'(t_n) + \half\uex''(t_n)\Delta t + \ldots + a\uex(t_n)$$

Now, \( \uex \) solves the ODE \( \uex'=-a\uex \), and then

$$ R^n \approx \half\uex''(t_n)\Delta t$$

This is a mathematical expression for the truncation error.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec26">The truncation error for other schemes </h2>

<p>
Backward Euler:

$$ R^n \approx -\half\uex''(t_n)\Delta t $$

<p>
Crank-Nicolson:

$$ R^{n+\half} \approx \frac{1}{24}\uex'''(t_{n+\half})\Delta t^2$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec27">Consistency, stability, and convergence </h2>

<ul>
  <p><li> Truncation error measures the residual in the difference equations.
    The scheme is <em>consistent</em> if the truncation error goes to 0
    as \( \Delta t\rightarrow 0 \). Importance: the difference equations
    approaches the differential equation as \( \Delta t\rightarrow 0 \).</li>
  <p><li> <em>Stability</em> means that the numerical solution exhibits the same
    qualitative properties as the exact solution. Here: monotone,
    decaying function.</li>
  <p><li> <em>Convergence</em> implies that the true (global) error
    \( e^n =\uex(t_n)-u^n\rightarrow 0 \) as \( \Delta t\rightarrow 0 \).
    This is really what we want!</li>
</ul>

The Lax equivalence theorem for <em>linear</em> differential equations:
consistency + stability is equivalent with convergence.

<p>
(Consistency and stability is in most problems
much easier to establish than
convergence.)

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

